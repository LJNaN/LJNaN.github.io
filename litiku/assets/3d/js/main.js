(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
			(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Bol3D = {}))
})(this, (function (exports) {
	'use strict'

	/**
	 * @license
	 * Copyright 2010-2021 Three.js Authors
	 * SPDX-License-Identifier: MIT
	 */
	const REVISION = '131'
	const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }
	const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }
	const CullFaceNone = 0
	const CullFaceBack = 1
	const CullFaceFront = 2
	const CullFaceFrontBack = 3
	const BasicShadowMap = 0
	const PCFShadowMap = 1
	const PCFSoftShadowMap = 2
	const VSMShadowMap = 3
	const FrontSide = 0
	const BackSide = 1
	const DoubleSide = 2
	const FlatShading = 1
	const SmoothShading = 2
	const NoBlending = 0
	const NormalBlending = 1
	const AdditiveBlending = 2
	const SubtractiveBlending = 3
	const MultiplyBlending = 4
	const CustomBlending = 5
	const AddEquation = 100
	const SubtractEquation = 101
	const ReverseSubtractEquation = 102
	const MinEquation = 103
	const MaxEquation = 104
	const ZeroFactor = 200
	const OneFactor = 201
	const SrcColorFactor = 202
	const OneMinusSrcColorFactor = 203
	const SrcAlphaFactor = 204
	const OneMinusSrcAlphaFactor = 205
	const DstAlphaFactor = 206
	const OneMinusDstAlphaFactor = 207
	const DstColorFactor = 208
	const OneMinusDstColorFactor = 209
	const SrcAlphaSaturateFactor = 210
	const NeverDepth = 0
	const AlwaysDepth = 1
	const LessDepth = 2
	const LessEqualDepth = 3
	const EqualDepth = 4
	const GreaterEqualDepth = 5
	const GreaterDepth = 6
	const NotEqualDepth = 7
	const MultiplyOperation = 0
	const MixOperation = 1
	const AddOperation = 2
	const NoToneMapping = 0
	const LinearToneMapping = 1
	const ReinhardToneMapping = 2
	const CineonToneMapping = 3
	const ACESFilmicToneMapping = 4
	const CustomToneMapping = 5

	const UVMapping = 300
	const CubeReflectionMapping = 301
	const CubeRefractionMapping = 302
	const EquirectangularReflectionMapping = 303
	const EquirectangularRefractionMapping = 304
	const CubeUVReflectionMapping = 306
	const CubeUVRefractionMapping = 307
	const RepeatWrapping = 1000
	const ClampToEdgeWrapping = 1001
	const MirroredRepeatWrapping = 1002
	const NearestFilter = 1003
	const NearestMipmapNearestFilter = 1004
	const NearestMipMapNearestFilter = 1004
	const NearestMipmapLinearFilter = 1005
	const NearestMipMapLinearFilter = 1005
	const LinearFilter = 1006
	const LinearMipmapNearestFilter = 1007
	const LinearMipMapNearestFilter = 1007
	const LinearMipmapLinearFilter = 1008
	const LinearMipMapLinearFilter = 1008
	const UnsignedByteType = 1009
	const ByteType = 1010
	const ShortType = 1011
	const UnsignedShortType = 1012
	const IntType = 1013
	const UnsignedIntType = 1014
	const FloatType = 1015
	const HalfFloatType = 1016
	const UnsignedShort4444Type = 1017
	const UnsignedShort5551Type = 1018
	const UnsignedShort565Type = 1019
	const UnsignedInt248Type = 1020
	const AlphaFormat = 1021
	const RGBFormat = 1022
	const RGBAFormat = 1023
	const LuminanceFormat = 1024
	const LuminanceAlphaFormat = 1025
	const RGBEFormat = RGBAFormat
	const DepthFormat = 1026
	const DepthStencilFormat = 1027
	const RedFormat = 1028
	const RedIntegerFormat = 1029
	const RGFormat = 1030
	const RGIntegerFormat = 1031
	const RGBIntegerFormat = 1032
	const RGBAIntegerFormat = 1033

	const RGB_S3TC_DXT1_Format = 33776
	const RGBA_S3TC_DXT1_Format = 33777
	const RGBA_S3TC_DXT3_Format = 33778
	const RGBA_S3TC_DXT5_Format = 33779
	const RGB_PVRTC_4BPPV1_Format = 35840
	const RGB_PVRTC_2BPPV1_Format = 35841
	const RGBA_PVRTC_4BPPV1_Format = 35842
	const RGBA_PVRTC_2BPPV1_Format = 35843
	const RGB_ETC1_Format = 36196
	const RGB_ETC2_Format = 37492
	const RGBA_ETC2_EAC_Format = 37496
	const RGBA_ASTC_4x4_Format = 37808
	const RGBA_ASTC_5x4_Format = 37809
	const RGBA_ASTC_5x5_Format = 37810
	const RGBA_ASTC_6x5_Format = 37811
	const RGBA_ASTC_6x6_Format = 37812
	const RGBA_ASTC_8x5_Format = 37813
	const RGBA_ASTC_8x6_Format = 37814
	const RGBA_ASTC_8x8_Format = 37815
	const RGBA_ASTC_10x5_Format = 37816
	const RGBA_ASTC_10x6_Format = 37817
	const RGBA_ASTC_10x8_Format = 37818
	const RGBA_ASTC_10x10_Format = 37819
	const RGBA_ASTC_12x10_Format = 37820
	const RGBA_ASTC_12x12_Format = 37821
	const RGBA_BPTC_Format = 36492
	const SRGB8_ALPHA8_ASTC_4x4_Format = 37840
	const SRGB8_ALPHA8_ASTC_5x4_Format = 37841
	const SRGB8_ALPHA8_ASTC_5x5_Format = 37842
	const SRGB8_ALPHA8_ASTC_6x5_Format = 37843
	const SRGB8_ALPHA8_ASTC_6x6_Format = 37844
	const SRGB8_ALPHA8_ASTC_8x5_Format = 37845
	const SRGB8_ALPHA8_ASTC_8x6_Format = 37846
	const SRGB8_ALPHA8_ASTC_8x8_Format = 37847
	const SRGB8_ALPHA8_ASTC_10x5_Format = 37848
	const SRGB8_ALPHA8_ASTC_10x6_Format = 37849
	const SRGB8_ALPHA8_ASTC_10x8_Format = 37850
	const SRGB8_ALPHA8_ASTC_10x10_Format = 37851
	const SRGB8_ALPHA8_ASTC_12x10_Format = 37852
	const SRGB8_ALPHA8_ASTC_12x12_Format = 37853
	const LoopOnce = 2200
	const LoopRepeat = 2201
	const LoopPingPong = 2202
	const InterpolateDiscrete = 2300
	const InterpolateLinear = 2301
	const InterpolateSmooth = 2302
	const ZeroCurvatureEnding = 2400
	const ZeroSlopeEnding = 2401
	const WrapAroundEnding = 2402
	const NormalAnimationBlendMode = 2500
	const AdditiveAnimationBlendMode = 2501
	const TrianglesDrawMode = 0
	const TriangleStripDrawMode = 1
	const TriangleFanDrawMode = 2
	const LinearEncoding = 3000
	const sRGBEncoding = 3001
	const GammaEncoding = 3007
	const RGBEEncoding = 3002
	const LogLuvEncoding = 3003
	const RGBM7Encoding = 3004
	const RGBM16Encoding = 3005
	const RGBDEncoding = 3006
	const BasicDepthPacking = 3200
	const RGBADepthPacking = 3201
	const TangentSpaceNormalMap = 0
	const ObjectSpaceNormalMap = 1

	const ZeroStencilOp = 0
	const KeepStencilOp = 7680
	const ReplaceStencilOp = 7681
	const IncrementStencilOp = 7682
	const DecrementStencilOp = 7683
	const IncrementWrapStencilOp = 34055
	const DecrementWrapStencilOp = 34056
	const InvertStencilOp = 5386

	const NeverStencilFunc = 512
	const LessStencilFunc = 513
	const EqualStencilFunc = 514
	const LessEqualStencilFunc = 515
	const GreaterStencilFunc = 516
	const NotEqualStencilFunc = 517
	const GreaterEqualStencilFunc = 518
	const AlwaysStencilFunc = 519

	const StaticDrawUsage = 35044
	const DynamicDrawUsage = 35048
	const StreamDrawUsage = 35040
	const StaticReadUsage = 35045
	const DynamicReadUsage = 35049
	const StreamReadUsage = 35041
	const StaticCopyUsage = 35046
	const DynamicCopyUsage = 35050
	const StreamCopyUsage = 35042

	const GLSL1 = '100'
	const GLSL3 = '300 es'

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	class EventDispatcher {

		addEventListener (type, listener) {

			if (this._listeners === undefined) this._listeners = {}

			const listeners = this._listeners

			if (listeners[type] === undefined) {

				listeners[type] = []

			}

			if (listeners[type].indexOf(listener) === - 1) {

				listeners[type].push(listener)

			}

		}

		hasEventListener (type, listener) {

			if (this._listeners === undefined) return false

			const listeners = this._listeners

			return listeners[type] !== undefined && listeners[type].indexOf(listener) !== - 1

		}

		removeEventListener (type, listener) {

			if (this._listeners === undefined) return

			const listeners = this._listeners
			const listenerArray = listeners[type]

			if (listenerArray !== undefined) {

				const index = listenerArray.indexOf(listener)

				if (index !== - 1) {

					listenerArray.splice(index, 1)

				}

			}

		}

		dispatchEvent (event) {

			if (this._listeners === undefined) return

			const listeners = this._listeners
			const listenerArray = listeners[event.type]

			if (listenerArray !== undefined) {

				event.target = this

				// Make a copy, in case listeners are removed while iterating.
				const array = listenerArray.slice(0)

				for (let i = 0, l = array.length; i < l; i++) {

					array[i].call(this, event)

				}

				event.target = null

			}

		}

	}

	const _lut = []

	for (let i = 0; i < 256; i++) {

		_lut[i] = (i < 16 ? '0' : '') + (i).toString(16)

	}

	let _seed = 1234567


	const DEG2RAD = Math.PI / 180
	const RAD2DEG = 180 / Math.PI

	// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
	function generateUUID () {

		const d0 = Math.random() * 0xffffffff | 0
		const d1 = Math.random() * 0xffffffff | 0
		const d2 = Math.random() * 0xffffffff | 0
		const d3 = Math.random() * 0xffffffff | 0
		const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' +
			_lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' +
			_lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] +
			_lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]

		// .toUpperCase() here flattens concatenated strings to save heap memory space.
		return uuid.toUpperCase()

	}

	function clamp (value, min, max) {

		return Math.max(min, Math.min(max, value))

	}

	// compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation
	function euclideanModulo (n, m) {

		return ((n % m) + m) % m

	}

	// Linear mapping from range <a1, a2> to range <b1, b2>
	function mapLinear (x, a1, a2, b1, b2) {

		return b1 + (x - a1) * (b2 - b1) / (a2 - a1)

	}

	// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
	function inverseLerp (x, y, value) {

		if (x !== y) {

			return (value - x) / (y - x)

		} else {

			return 0

		}

	}

	// https://en.wikipedia.org/wiki/Linear_interpolation
	function lerp (x, y, t) {

		return (1 - t) * x + t * y

	}

	// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
	function damp (x, y, lambda, dt) {

		return lerp(x, y, 1 - Math.exp(- lambda * dt))

	}

	// https://www.desmos.com/calculator/vcsjnyz7x4
	function pingpong (x, length = 1) {

		return length - Math.abs(euclideanModulo(x, length * 2) - length)

	}

	// http://en.wikipedia.org/wiki/Smoothstep
	function smoothstep (x, min, max) {

		if (x <= min) return 0
		if (x >= max) return 1

		x = (x - min) / (max - min)

		return x * x * (3 - 2 * x)

	}

	function smootherstep (x, min, max) {

		if (x <= min) return 0
		if (x >= max) return 1

		x = (x - min) / (max - min)

		return x * x * x * (x * (x * 6 - 15) + 10)

	}

	// Random integer from <low, high> interval
	function randInt (low, high) {

		return low + Math.floor(Math.random() * (high - low + 1))

	}

	// Random float from <low, high> interval
	function randFloat (low, high) {

		return low + Math.random() * (high - low)

	}

	// Random float from <-range/2, range/2> interval
	function randFloatSpread (range) {

		return range * (0.5 - Math.random())

	}

	// Deterministic pseudo-random float in the interval [ 0, 1 ]
	function seededRandom (s) {

		if (s !== undefined) _seed = s % 2147483647

		// Park-Miller algorithm

		_seed = _seed * 16807 % 2147483647

		return (_seed - 1) / 2147483646

	}

	function degToRad$1 (degrees) {

		return degrees * DEG2RAD

	}

	function radToDeg (radians) {

		return radians * RAD2DEG

	}

	function isPowerOfTwo$1 (value) {

		return (value & (value - 1)) === 0 && value !== 0

	}

	function ceilPowerOfTwo (value) {

		return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2))

	}

	function floorPowerOfTwo$1 (value) {

		return Math.pow(2, Math.floor(Math.log(value) / Math.LN2))

	}

	function setQuaternionFromProperEuler (q, a, b, c, order) {

		// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

		// rotations are applied to the axes in the order specified by 'order'
		// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
		// angles are in radians

		const cos = Math.cos
		const sin = Math.sin

		const c2 = cos(b / 2)
		const s2 = sin(b / 2)

		const c13 = cos((a + c) / 2)
		const s13 = sin((a + c) / 2)

		const c1_3 = cos((a - c) / 2)
		const s1_3 = sin((a - c) / 2)

		const c3_1 = cos((c - a) / 2)
		const s3_1 = sin((c - a) / 2)

		switch (order) {

			case 'XYX':
				q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13)
				break

			case 'YZY':
				q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13)
				break

			case 'ZXZ':
				q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13)
				break

			case 'XZX':
				q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13)
				break

			case 'YXY':
				q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13)
				break

			case 'ZYZ':
				q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13)
				break

			default:
				console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order)

		}

	}

	var MathUtils = /*#__PURE__*/Object.freeze({
		__proto__: null,
		DEG2RAD: DEG2RAD,
		RAD2DEG: RAD2DEG,
		generateUUID: generateUUID,
		clamp: clamp,
		euclideanModulo: euclideanModulo,
		mapLinear: mapLinear,
		inverseLerp: inverseLerp,
		lerp: lerp,
		damp: damp,
		pingpong: pingpong,
		smoothstep: smoothstep,
		smootherstep: smootherstep,
		randInt: randInt,
		randFloat: randFloat,
		randFloatSpread: randFloatSpread,
		seededRandom: seededRandom,
		degToRad: degToRad$1,
		radToDeg: radToDeg,
		isPowerOfTwo: isPowerOfTwo$1,
		ceilPowerOfTwo: ceilPowerOfTwo,
		floorPowerOfTwo: floorPowerOfTwo$1,
		setQuaternionFromProperEuler: setQuaternionFromProperEuler
	})

	class Vector2 {

		constructor(x = 0, y = 0) {

			this.x = x
			this.y = y

		}

		get width () {

			return this.x

		}

		set width (value) {

			this.x = value

		}

		get height () {

			return this.y

		}

		set height (value) {

			this.y = value

		}

		set (x, y) {

			this.x = x
			this.y = y

			return this

		}

		setScalar (scalar) {

			this.x = scalar
			this.y = scalar

			return this

		}

		setX (x) {

			this.x = x

			return this

		}

		setY (y) {

			this.y = y

			return this

		}

		setComponent (index, value) {

			switch (index) {

				case 0: this.x = value; break
				case 1: this.y = value; break
				default: throw new Error('index is out of range: ' + index)

			}

			return this

		}

		getComponent (index) {

			switch (index) {

				case 0: return this.x
				case 1: return this.y
				default: throw new Error('index is out of range: ' + index)

			}

		}

		clone () {

			return new this.constructor(this.x, this.y)

		}

		copy (v) {

			this.x = v.x
			this.y = v.y

			return this

		}

		add (v, w) {

			if (w !== undefined) {

				console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.')
				return this.addVectors(v, w)

			}

			this.x += v.x
			this.y += v.y

			return this

		}

		addScalar (s) {

			this.x += s
			this.y += s

			return this

		}

		addVectors (a, b) {

			this.x = a.x + b.x
			this.y = a.y + b.y

			return this

		}

		addScaledVector (v, s) {

			this.x += v.x * s
			this.y += v.y * s

			return this

		}

		sub (v, w) {

			if (w !== undefined) {

				console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.')
				return this.subVectors(v, w)

			}

			this.x -= v.x
			this.y -= v.y

			return this

		}

		subScalar (s) {

			this.x -= s
			this.y -= s

			return this

		}

		subVectors (a, b) {

			this.x = a.x - b.x
			this.y = a.y - b.y

			return this

		}

		multiply (v) {

			this.x *= v.x
			this.y *= v.y

			return this

		}

		multiplyScalar (scalar) {

			this.x *= scalar
			this.y *= scalar

			return this

		}

		divide (v) {

			this.x /= v.x
			this.y /= v.y

			return this

		}

		divideScalar (scalar) {

			return this.multiplyScalar(1 / scalar)

		}

		applyMatrix3 (m) {

			const x = this.x, y = this.y
			const e = m.elements

			this.x = e[0] * x + e[3] * y + e[6]
			this.y = e[1] * x + e[4] * y + e[7]

			return this

		}

		min (v) {

			this.x = Math.min(this.x, v.x)
			this.y = Math.min(this.y, v.y)

			return this

		}

		max (v) {

			this.x = Math.max(this.x, v.x)
			this.y = Math.max(this.y, v.y)

			return this

		}

		clamp (min, max) {

			// assumes min < max, componentwise

			this.x = Math.max(min.x, Math.min(max.x, this.x))
			this.y = Math.max(min.y, Math.min(max.y, this.y))

			return this

		}

		clampScalar (minVal, maxVal) {

			this.x = Math.max(minVal, Math.min(maxVal, this.x))
			this.y = Math.max(minVal, Math.min(maxVal, this.y))

			return this

		}

		clampLength (min, max) {

			const length = this.length()

			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)))

		}

		floor () {

			this.x = Math.floor(this.x)
			this.y = Math.floor(this.y)

			return this

		}

		ceil () {

			this.x = Math.ceil(this.x)
			this.y = Math.ceil(this.y)

			return this

		}

		round () {

			this.x = Math.round(this.x)
			this.y = Math.round(this.y)

			return this

		}

		roundToZero () {

			this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x)
			this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y)

			return this

		}

		negate () {

			this.x = - this.x
			this.y = - this.y

			return this

		}

		dot (v) {

			return this.x * v.x + this.y * v.y

		}

		cross (v) {

			return this.x * v.y - this.y * v.x

		}

		lengthSq () {

			return this.x * this.x + this.y * this.y

		}

		length () {

			return Math.sqrt(this.x * this.x + this.y * this.y)

		}

		manhattanLength () {

			return Math.abs(this.x) + Math.abs(this.y)

		}

		normalize () {

			return this.divideScalar(this.length() || 1)

		}

		angle () {

			// computes the angle in radians with respect to the positive x-axis

			const angle = Math.atan2(- this.y, - this.x) + Math.PI

			return angle

		}

		distanceTo (v) {

			return Math.sqrt(this.distanceToSquared(v))

		}

		distanceToSquared (v) {

			const dx = this.x - v.x, dy = this.y - v.y
			return dx * dx + dy * dy

		}

		manhattanDistanceTo (v) {

			return Math.abs(this.x - v.x) + Math.abs(this.y - v.y)

		}

		setLength (length) {

			return this.normalize().multiplyScalar(length)

		}

		lerp (v, alpha) {

			this.x += (v.x - this.x) * alpha
			this.y += (v.y - this.y) * alpha

			return this

		}

		lerpVectors (v1, v2, alpha) {

			this.x = v1.x + (v2.x - v1.x) * alpha
			this.y = v1.y + (v2.y - v1.y) * alpha

			return this

		}

		equals (v) {

			return ((v.x === this.x) && (v.y === this.y))

		}

		fromArray (array, offset = 0) {

			this.x = array[offset]
			this.y = array[offset + 1]

			return this

		}

		toArray (array = [], offset = 0) {

			array[offset] = this.x
			array[offset + 1] = this.y

			return array

		}

		fromBufferAttribute (attribute, index, offset) {

			if (offset !== undefined) {

				console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().')

			}

			this.x = attribute.getX(index)
			this.y = attribute.getY(index)

			return this

		}

		rotateAround (center, angle) {

			const c = Math.cos(angle), s = Math.sin(angle)

			const x = this.x - center.x
			const y = this.y - center.y

			this.x = x * c - y * s + center.x
			this.y = x * s + y * c + center.y

			return this

		}

		random () {

			this.x = Math.random()
			this.y = Math.random()

			return this

		}

	}

	Vector2.prototype.isVector2 = true

	class Matrix3 {

		constructor() {

			this.elements = [

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			]

			if (arguments.length > 0) {

				console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.')

			}

		}

		set (n11, n12, n13, n21, n22, n23, n31, n32, n33) {

			const te = this.elements

			te[0] = n11; te[1] = n21; te[2] = n31
			te[3] = n12; te[4] = n22; te[5] = n32
			te[6] = n13; te[7] = n23; te[8] = n33

			return this

		}

		identity () {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			)

			return this

		}

		copy (m) {

			const te = this.elements
			const me = m.elements

			te[0] = me[0]; te[1] = me[1]; te[2] = me[2]
			te[3] = me[3]; te[4] = me[4]; te[5] = me[5]
			te[6] = me[6]; te[7] = me[7]; te[8] = me[8]

			return this

		}

		extractBasis (xAxis, yAxis, zAxis) {

			xAxis.setFromMatrix3Column(this, 0)
			yAxis.setFromMatrix3Column(this, 1)
			zAxis.setFromMatrix3Column(this, 2)

			return this

		}

		setFromMatrix4 (m) {

			const me = m.elements

			this.set(

				me[0], me[4], me[8],
				me[1], me[5], me[9],
				me[2], me[6], me[10]

			)

			return this

		}

		multiply (m) {

			return this.multiplyMatrices(this, m)

		}

		premultiply (m) {

			return this.multiplyMatrices(m, this)

		}

		multiplyMatrices (a, b) {

			const ae = a.elements
			const be = b.elements
			const te = this.elements

			const a11 = ae[0], a12 = ae[3], a13 = ae[6]
			const a21 = ae[1], a22 = ae[4], a23 = ae[7]
			const a31 = ae[2], a32 = ae[5], a33 = ae[8]

			const b11 = be[0], b12 = be[3], b13 = be[6]
			const b21 = be[1], b22 = be[4], b23 = be[7]
			const b31 = be[2], b32 = be[5], b33 = be[8]

			te[0] = a11 * b11 + a12 * b21 + a13 * b31
			te[3] = a11 * b12 + a12 * b22 + a13 * b32
			te[6] = a11 * b13 + a12 * b23 + a13 * b33

			te[1] = a21 * b11 + a22 * b21 + a23 * b31
			te[4] = a21 * b12 + a22 * b22 + a23 * b32
			te[7] = a21 * b13 + a22 * b23 + a23 * b33

			te[2] = a31 * b11 + a32 * b21 + a33 * b31
			te[5] = a31 * b12 + a32 * b22 + a33 * b32
			te[8] = a31 * b13 + a32 * b23 + a33 * b33

			return this

		}

		multiplyScalar (s) {

			const te = this.elements

			te[0] *= s; te[3] *= s; te[6] *= s
			te[1] *= s; te[4] *= s; te[7] *= s
			te[2] *= s; te[5] *= s; te[8] *= s

			return this

		}

		determinant () {

			const te = this.elements

			const a = te[0], b = te[1], c = te[2],
				d = te[3], e = te[4], f = te[5],
				g = te[6], h = te[7], i = te[8]

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g

		}

		invert () {

			const te = this.elements,

				n11 = te[0], n21 = te[1], n31 = te[2],
				n12 = te[3], n22 = te[4], n32 = te[5],
				n13 = te[6], n23 = te[7], n33 = te[8],

				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,

				det = n11 * t11 + n21 * t12 + n31 * t13

			if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0)

			const detInv = 1 / det

			te[0] = t11 * detInv
			te[1] = (n31 * n23 - n33 * n21) * detInv
			te[2] = (n32 * n21 - n31 * n22) * detInv

			te[3] = t12 * detInv
			te[4] = (n33 * n11 - n31 * n13) * detInv
			te[5] = (n31 * n12 - n32 * n11) * detInv

			te[6] = t13 * detInv
			te[7] = (n21 * n13 - n23 * n11) * detInv
			te[8] = (n22 * n11 - n21 * n12) * detInv

			return this

		}

		transpose () {

			let tmp
			const m = this.elements

			tmp = m[1]; m[1] = m[3]; m[3] = tmp
			tmp = m[2]; m[2] = m[6]; m[6] = tmp
			tmp = m[5]; m[5] = m[7]; m[7] = tmp

			return this

		}

		getNormalMatrix (matrix4) {

			return this.setFromMatrix4(matrix4).invert().transpose()

		}

		transposeIntoArray (r) {

			const m = this.elements

			r[0] = m[0]
			r[1] = m[3]
			r[2] = m[6]
			r[3] = m[1]
			r[4] = m[4]
			r[5] = m[7]
			r[6] = m[2]
			r[7] = m[5]
			r[8] = m[8]

			return this

		}

		setUvTransform (tx, ty, sx, sy, rotation, cx, cy) {

			const c = Math.cos(rotation)
			const s = Math.sin(rotation)

			this.set(
				sx * c, sx * s, - sx * (c * cx + s * cy) + cx + tx,
				- sy * s, sy * c, - sy * (- s * cx + c * cy) + cy + ty,
				0, 0, 1
			)

			return this

		}

		scale (sx, sy) {

			const te = this.elements

			te[0] *= sx; te[3] *= sx; te[6] *= sx
			te[1] *= sy; te[4] *= sy; te[7] *= sy

			return this

		}

		rotate (theta) {

			const c = Math.cos(theta)
			const s = Math.sin(theta)

			const te = this.elements

			const a11 = te[0], a12 = te[3], a13 = te[6]
			const a21 = te[1], a22 = te[4], a23 = te[7]

			te[0] = c * a11 + s * a21
			te[3] = c * a12 + s * a22
			te[6] = c * a13 + s * a23

			te[1] = - s * a11 + c * a21
			te[4] = - s * a12 + c * a22
			te[7] = - s * a13 + c * a23

			return this

		}

		translate (tx, ty) {

			const te = this.elements

			te[0] += tx * te[2]; te[3] += tx * te[5]; te[6] += tx * te[8]
			te[1] += ty * te[2]; te[4] += ty * te[5]; te[7] += ty * te[8]

			return this

		}

		equals (matrix) {

			const te = this.elements
			const me = matrix.elements

			for (let i = 0; i < 9; i++) {

				if (te[i] !== me[i]) return false

			}

			return true

		}

		fromArray (array, offset = 0) {

			for (let i = 0; i < 9; i++) {

				this.elements[i] = array[i + offset]

			}

			return this

		}

		toArray (array = [], offset = 0) {

			const te = this.elements

			array[offset] = te[0]
			array[offset + 1] = te[1]
			array[offset + 2] = te[2]

			array[offset + 3] = te[3]
			array[offset + 4] = te[4]
			array[offset + 5] = te[5]

			array[offset + 6] = te[6]
			array[offset + 7] = te[7]
			array[offset + 8] = te[8]

			return array

		}

		clone () {

			return new this.constructor().fromArray(this.elements)

		}

	}

	Matrix3.prototype.isMatrix3 = true

	let _canvas

	class ImageUtils {

		static getDataURL (image) {

			if (/^data:/i.test(image.src)) {

				return image.src

			}

			if (typeof HTMLCanvasElement == 'undefined') {

				return image.src

			}

			let canvas

			if (image instanceof HTMLCanvasElement) {

				canvas = image

			} else {

				if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas')

				_canvas.width = image.width
				_canvas.height = image.height

				const context = _canvas.getContext('2d')

				if (image instanceof ImageData) {

					context.putImageData(image, 0, 0)

				} else {

					context.drawImage(image, 0, 0, image.width, image.height)

				}

				canvas = _canvas

			}

			if (canvas.width > 2048 || canvas.height > 2048) {

				console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image)

				return canvas.toDataURL('image/jpeg', 0.6)

			} else {

				return canvas.toDataURL('image/png')

			}

		}

	}

	let textureId = 0

	class Texture extends EventDispatcher {

		constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {

			super()

			Object.defineProperty(this, 'id', { value: textureId++ })

			this.uuid = generateUUID()

			this.name = ''

			this.image = image
			this.mipmaps = []

			this.mapping = mapping

			this.wrapS = wrapS
			this.wrapT = wrapT

			this.magFilter = magFilter
			this.minFilter = minFilter

			this.anisotropy = anisotropy

			this.format = format
			this.internalFormat = null
			this.type = type

			this.offset = new Vector2(0, 0)
			this.repeat = new Vector2(1, 1)
			this.center = new Vector2(0, 0)
			this.rotation = 0

			this.matrixAutoUpdate = true
			this.matrix = new Matrix3()

			this.generateMipmaps = true
			this.premultiplyAlpha = false
			this.flipY = true
			this.unpackAlignment = 4	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

			// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
			//
			// Also changing the encoding after already used by a Material will not automatically make the Material
			// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
			this.encoding = encoding

			this.version = 0
			this.onUpdate = null

			this.isRenderTargetTexture = false

		}

		updateMatrix () {

			this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)

		}

		clone () {

			return new this.constructor().copy(this)

		}

		copy (source) {

			this.name = source.name

			this.image = source.image
			this.mipmaps = source.mipmaps.slice(0)

			this.mapping = source.mapping

			this.wrapS = source.wrapS
			this.wrapT = source.wrapT

			this.magFilter = source.magFilter
			this.minFilter = source.minFilter

			this.anisotropy = source.anisotropy

			this.format = source.format
			this.internalFormat = source.internalFormat
			this.type = source.type

			this.offset.copy(source.offset)
			this.repeat.copy(source.repeat)
			this.center.copy(source.center)
			this.rotation = source.rotation

			this.matrixAutoUpdate = source.matrixAutoUpdate
			this.matrix.copy(source.matrix)

			this.generateMipmaps = source.generateMipmaps
			this.premultiplyAlpha = source.premultiplyAlpha
			this.flipY = source.flipY
			this.unpackAlignment = source.unpackAlignment
			this.encoding = source.encoding

			return this

		}

		toJSON (meta) {

			const isRootObject = (meta === undefined || typeof meta === 'string')

			if (!isRootObject && meta.textures[this.uuid] !== undefined) {

				return meta.textures[this.uuid]

			}

			const output = {

				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},

				uuid: this.uuid,
				name: this.name,

				mapping: this.mapping,

				repeat: [this.repeat.x, this.repeat.y],
				offset: [this.offset.x, this.offset.y],
				center: [this.center.x, this.center.y],
				rotation: this.rotation,

				wrap: [this.wrapS, this.wrapT],

				format: this.format,
				type: this.type,
				encoding: this.encoding,

				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,

				flipY: this.flipY,

				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment

			}

			if (this.image !== undefined) {

				// TODO: Move to THREE.Image

				const image = this.image

				if (image.uuid === undefined) {

					image.uuid = generateUUID() // UGH

				}

				if (!isRootObject && meta.images[image.uuid] === undefined) {

					let url

					if (Array.isArray(image)) {

						// process array of images e.g. CubeTexture

						url = []

						for (let i = 0, l = image.length; i < l; i++) {

							// check cube texture with data textures

							if (image[i].isDataTexture) {

								url.push(serializeImage(image[i].image))

							} else {

								url.push(serializeImage(image[i]))

							}

						}

					} else {

						// process single image

						url = serializeImage(image)

					}

					meta.images[image.uuid] = {
						uuid: image.uuid,
						url: url
					}

				}

				output.image = image.uuid

			}

			if (!isRootObject) {

				meta.textures[this.uuid] = output

			}

			return output

		}

		dispose () {

			this.dispatchEvent({ type: 'dispose' })

		}

		transformUv (uv) {

			if (this.mapping !== UVMapping) return uv

			uv.applyMatrix3(this.matrix)

			if (uv.x < 0 || uv.x > 1) {

				switch (this.wrapS) {

					case RepeatWrapping:

						uv.x = uv.x - Math.floor(uv.x)
						break

					case ClampToEdgeWrapping:

						uv.x = uv.x < 0 ? 0 : 1
						break

					case MirroredRepeatWrapping:

						if (Math.abs(Math.floor(uv.x) % 2) === 1) {

							uv.x = Math.ceil(uv.x) - uv.x

						} else {

							uv.x = uv.x - Math.floor(uv.x)

						}

						break

				}

			}

			if (uv.y < 0 || uv.y > 1) {

				switch (this.wrapT) {

					case RepeatWrapping:

						uv.y = uv.y - Math.floor(uv.y)
						break

					case ClampToEdgeWrapping:

						uv.y = uv.y < 0 ? 0 : 1
						break

					case MirroredRepeatWrapping:

						if (Math.abs(Math.floor(uv.y) % 2) === 1) {

							uv.y = Math.ceil(uv.y) - uv.y

						} else {

							uv.y = uv.y - Math.floor(uv.y)

						}

						break

				}

			}

			if (this.flipY) {

				uv.y = 1 - uv.y

			}

			return uv

		}

		set needsUpdate (value) {

			if (value === true) this.version++

		}

	}

	Texture.DEFAULT_IMAGE = undefined
	Texture.DEFAULT_MAPPING = UVMapping

	Texture.prototype.isTexture = true

	function serializeImage (image) {

		if ((typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) ||
			(typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement) ||
			(typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)) {

			// default images

			return ImageUtils.getDataURL(image)

		} else {

			if (image.data) {

				// images of DataTexture

				return {
					data: Array.prototype.slice.call(image.data),
					width: image.width,
					height: image.height,
					type: image.data.constructor.name
				}

			} else {

				console.warn('THREE.Texture: Unable to serialize Texture.')
				return {}

			}

		}

	}

	class Vector4 {

		constructor(x = 0, y = 0, z = 0, w = 1) {

			this.x = x
			this.y = y
			this.z = z
			this.w = w

		}

		get width () {

			return this.z

		}

		set width (value) {

			this.z = value

		}

		get height () {

			return this.w

		}

		set height (value) {

			this.w = value

		}

		set (x, y, z, w) {

			this.x = x
			this.y = y
			this.z = z
			this.w = w

			return this

		}

		setScalar (scalar) {

			this.x = scalar
			this.y = scalar
			this.z = scalar
			this.w = scalar

			return this

		}

		setX (x) {

			this.x = x

			return this

		}

		setY (y) {

			this.y = y

			return this

		}

		setZ (z) {

			this.z = z

			return this

		}

		setW (w) {

			this.w = w

			return this

		}

		setComponent (index, value) {

			switch (index) {

				case 0: this.x = value; break
				case 1: this.y = value; break
				case 2: this.z = value; break
				case 3: this.w = value; break
				default: throw new Error('index is out of range: ' + index)

			}

			return this

		}

		getComponent (index) {

			switch (index) {

				case 0: return this.x
				case 1: return this.y
				case 2: return this.z
				case 3: return this.w
				default: throw new Error('index is out of range: ' + index)

			}

		}

		clone () {

			return new this.constructor(this.x, this.y, this.z, this.w)

		}

		copy (v) {

			this.x = v.x
			this.y = v.y
			this.z = v.z
			this.w = (v.w !== undefined) ? v.w : 1

			return this

		}

		add (v, w) {

			if (w !== undefined) {

				console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.')
				return this.addVectors(v, w)

			}

			this.x += v.x
			this.y += v.y
			this.z += v.z
			this.w += v.w

			return this

		}

		addScalar (s) {

			this.x += s
			this.y += s
			this.z += s
			this.w += s

			return this

		}

		addVectors (a, b) {

			this.x = a.x + b.x
			this.y = a.y + b.y
			this.z = a.z + b.z
			this.w = a.w + b.w

			return this

		}

		addScaledVector (v, s) {

			this.x += v.x * s
			this.y += v.y * s
			this.z += v.z * s
			this.w += v.w * s

			return this

		}

		sub (v, w) {

			if (w !== undefined) {

				console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.')
				return this.subVectors(v, w)

			}

			this.x -= v.x
			this.y -= v.y
			this.z -= v.z
			this.w -= v.w

			return this

		}

		subScalar (s) {

			this.x -= s
			this.y -= s
			this.z -= s
			this.w -= s

			return this

		}

		subVectors (a, b) {

			this.x = a.x - b.x
			this.y = a.y - b.y
			this.z = a.z - b.z
			this.w = a.w - b.w

			return this

		}

		multiply (v) {

			this.x *= v.x
			this.y *= v.y
			this.z *= v.z
			this.w *= v.w

			return this

		}

		multiplyScalar (scalar) {

			this.x *= scalar
			this.y *= scalar
			this.z *= scalar
			this.w *= scalar

			return this

		}

		applyMatrix4 (m) {

			const x = this.x, y = this.y, z = this.z, w = this.w
			const e = m.elements

			this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w
			this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w
			this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w
			this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w

			return this

		}

		divideScalar (scalar) {

			return this.multiplyScalar(1 / scalar)

		}

		setAxisAngleFromQuaternion (q) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos(q.w)

			const s = Math.sqrt(1 - q.w * q.w)

			if (s < 0.0001) {

				this.x = 1
				this.y = 0
				this.z = 0

			} else {

				this.x = q.x / s
				this.y = q.y / s
				this.z = q.z / s

			}

			return this

		}

		setAxisAngleFromRotationMatrix (m) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			let angle, x, y, z // variables for result
			const epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[0], m12 = te[4], m13 = te[8],
				m21 = te[1], m22 = te[5], m23 = te[9],
				m31 = te[2], m32 = te[6], m33 = te[10]

			if ((Math.abs(m12 - m21) < epsilon) &&
				(Math.abs(m13 - m31) < epsilon) &&
				(Math.abs(m23 - m32) < epsilon)) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ((Math.abs(m12 + m21) < epsilon2) &&
					(Math.abs(m13 + m31) < epsilon2) &&
					(Math.abs(m23 + m32) < epsilon2) &&
					(Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {

					// this singularity is identity matrix so angle = 0

					this.set(1, 0, 0, 0)

					return this // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI

				const xx = (m11 + 1) / 2
				const yy = (m22 + 1) / 2
				const zz = (m33 + 1) / 2
				const xy = (m12 + m21) / 4
				const xz = (m13 + m31) / 4
				const yz = (m23 + m32) / 4

				if ((xx > yy) && (xx > zz)) {

					// m11 is the largest diagonal term

					if (xx < epsilon) {

						x = 0
						y = 0.707106781
						z = 0.707106781

					} else {

						x = Math.sqrt(xx)
						y = xy / x
						z = xz / x

					}

				} else if (yy > zz) {

					// m22 is the largest diagonal term

					if (yy < epsilon) {

						x = 0.707106781
						y = 0
						z = 0.707106781

					} else {

						y = Math.sqrt(yy)
						x = xy / y
						z = yz / y

					}

				} else {

					// m33 is the largest diagonal term so base result on this

					if (zz < epsilon) {

						x = 0.707106781
						y = 0.707106781
						z = 0

					} else {

						z = Math.sqrt(zz)
						x = xz / z
						y = yz / z

					}

				}

				this.set(x, y, z, angle)

				return this // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			let s = Math.sqrt((m32 - m23) * (m32 - m23) +
				(m13 - m31) * (m13 - m31) +
				(m21 - m12) * (m21 - m12)) // used to normalize

			if (Math.abs(s) < 0.001) s = 1

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = (m32 - m23) / s
			this.y = (m13 - m31) / s
			this.z = (m21 - m12) / s
			this.w = Math.acos((m11 + m22 + m33 - 1) / 2)

			return this

		}

		min (v) {

			this.x = Math.min(this.x, v.x)
			this.y = Math.min(this.y, v.y)
			this.z = Math.min(this.z, v.z)
			this.w = Math.min(this.w, v.w)

			return this

		}

		max (v) {

			this.x = Math.max(this.x, v.x)
			this.y = Math.max(this.y, v.y)
			this.z = Math.max(this.z, v.z)
			this.w = Math.max(this.w, v.w)

			return this

		}

		clamp (min, max) {

			// assumes min < max, componentwise

			this.x = Math.max(min.x, Math.min(max.x, this.x))
			this.y = Math.max(min.y, Math.min(max.y, this.y))
			this.z = Math.max(min.z, Math.min(max.z, this.z))
			this.w = Math.max(min.w, Math.min(max.w, this.w))

			return this

		}

		clampScalar (minVal, maxVal) {

			this.x = Math.max(minVal, Math.min(maxVal, this.x))
			this.y = Math.max(minVal, Math.min(maxVal, this.y))
			this.z = Math.max(minVal, Math.min(maxVal, this.z))
			this.w = Math.max(minVal, Math.min(maxVal, this.w))

			return this

		}

		clampLength (min, max) {

			const length = this.length()

			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)))

		}

		floor () {

			this.x = Math.floor(this.x)
			this.y = Math.floor(this.y)
			this.z = Math.floor(this.z)
			this.w = Math.floor(this.w)

			return this

		}

		ceil () {

			this.x = Math.ceil(this.x)
			this.y = Math.ceil(this.y)
			this.z = Math.ceil(this.z)
			this.w = Math.ceil(this.w)

			return this

		}

		round () {

			this.x = Math.round(this.x)
			this.y = Math.round(this.y)
			this.z = Math.round(this.z)
			this.w = Math.round(this.w)

			return this

		}

		roundToZero () {

			this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x)
			this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y)
			this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z)
			this.w = (this.w < 0) ? Math.ceil(this.w) : Math.floor(this.w)

			return this

		}

		negate () {

			this.x = - this.x
			this.y = - this.y
			this.z = - this.z
			this.w = - this.w

			return this

		}

		dot (v) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w

		}

		lengthSq () {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w

		}

		length () {

			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)

		}

		manhattanLength () {

			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)

		}

		normalize () {

			return this.divideScalar(this.length() || 1)

		}

		setLength (length) {

			return this.normalize().multiplyScalar(length)

		}

		lerp (v, alpha) {

			this.x += (v.x - this.x) * alpha
			this.y += (v.y - this.y) * alpha
			this.z += (v.z - this.z) * alpha
			this.w += (v.w - this.w) * alpha

			return this

		}

		lerpVectors (v1, v2, alpha) {

			this.x = v1.x + (v2.x - v1.x) * alpha
			this.y = v1.y + (v2.y - v1.y) * alpha
			this.z = v1.z + (v2.z - v1.z) * alpha
			this.w = v1.w + (v2.w - v1.w) * alpha

			return this

		}

		equals (v) {

			return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w))

		}

		fromArray (array, offset = 0) {

			this.x = array[offset]
			this.y = array[offset + 1]
			this.z = array[offset + 2]
			this.w = array[offset + 3]

			return this

		}

		toArray (array = [], offset = 0) {

			array[offset] = this.x
			array[offset + 1] = this.y
			array[offset + 2] = this.z
			array[offset + 3] = this.w

			return array

		}

		fromBufferAttribute (attribute, index, offset) {

			if (offset !== undefined) {

				console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().')

			}

			this.x = attribute.getX(index)
			this.y = attribute.getY(index)
			this.z = attribute.getZ(index)
			this.w = attribute.getW(index)

			return this

		}

		random () {

			this.x = Math.random()
			this.y = Math.random()
			this.z = Math.random()
			this.w = Math.random()

			return this

		}

	}

	Vector4.prototype.isVector4 = true

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	class WebGLRenderTarget extends EventDispatcher {

		constructor(width, height, options = {}) {

			super()

			this.width = width
			this.height = height
			this.depth = 1

			this.scissor = new Vector4(0, 0, width, height)
			this.scissorTest = false

			this.viewport = new Vector4(0, 0, width, height)

			this.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding)
			this.texture.isRenderTargetTexture = true

			this.texture.image = { width: width, height: height, depth: 1 }

			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter

			this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true
			this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false
			this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null

		}

		setTexture (texture) {

			texture.image = {
				width: this.width,
				height: this.height,
				depth: this.depth
			}

			this.texture = texture

		}

		setSize (width, height, depth = 1) {

			if (this.width !== width || this.height !== height || this.depth !== depth) {

				this.width = width
				this.height = height
				this.depth = depth

				this.texture.image.width = width
				this.texture.image.height = height
				this.texture.image.depth = depth

				this.dispose()

			}

			this.viewport.set(0, 0, width, height)
			this.scissor.set(0, 0, width, height)

		}

		clone () {

			return new this.constructor().copy(this)

		}

		copy (source) {

			this.width = source.width
			this.height = source.height
			this.depth = source.depth

			this.viewport.copy(source.viewport)

			this.texture = source.texture.clone()
			this.texture.image = { ...this.texture.image } // See #20328.

			this.depthBuffer = source.depthBuffer
			this.stencilBuffer = source.stencilBuffer
			this.depthTexture = source.depthTexture

			return this

		}

		dispose () {

			this.dispatchEvent({ type: 'dispose' })

		}

	}

	WebGLRenderTarget.prototype.isWebGLRenderTarget = true

	class WebGLMultipleRenderTargets extends WebGLRenderTarget {

		constructor(width, height, count) {

			super(width, height)

			const texture = this.texture

			this.texture = []

			for (let i = 0; i < count; i++) {

				this.texture[i] = texture.clone()

			}

		}

		setSize (width, height, depth = 1) {

			if (this.width !== width || this.height !== height || this.depth !== depth) {

				this.width = width
				this.height = height
				this.depth = depth

				for (let i = 0, il = this.texture.length; i < il; i++) {

					this.texture[i].image.width = width
					this.texture[i].image.height = height
					this.texture[i].image.depth = depth

				}

				this.dispose()

			}

			this.viewport.set(0, 0, width, height)
			this.scissor.set(0, 0, width, height)

			return this

		}

		copy (source) {

			this.dispose()

			this.width = source.width
			this.height = source.height
			this.depth = source.depth

			this.viewport.set(0, 0, this.width, this.height)
			this.scissor.set(0, 0, this.width, this.height)

			this.depthBuffer = source.depthBuffer
			this.stencilBuffer = source.stencilBuffer
			this.depthTexture = source.depthTexture

			this.texture.length = 0

			for (let i = 0, il = source.texture.length; i < il; i++) {

				this.texture[i] = source.texture[i].clone()

			}

			return this

		}

	}

	WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true

	class WebGLMultisampleRenderTarget extends WebGLRenderTarget {

		constructor(width, height, options) {

			super(width, height, options)

			this.samples = 4

		}

		copy (source) {

			super.copy.call(this, source)

			this.samples = source.samples

			return this

		}

	}

	WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true

	class Quaternion {

		constructor(x = 0, y = 0, z = 0, w = 1) {

			this._x = x
			this._y = y
			this._z = z
			this._w = w

		}

		static slerp (qa, qb, qm, t) {

			console.warn('THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.')
			return qm.slerpQuaternions(qa, qb, t)

		}

		static slerpFlat (dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {

			// fuzz-free, array-based Quaternion SLERP operation

			let x0 = src0[srcOffset0 + 0],
				y0 = src0[srcOffset0 + 1],
				z0 = src0[srcOffset0 + 2],
				w0 = src0[srcOffset0 + 3]

			const x1 = src1[srcOffset1 + 0],
				y1 = src1[srcOffset1 + 1],
				z1 = src1[srcOffset1 + 2],
				w1 = src1[srcOffset1 + 3]

			if (t === 0) {

				dst[dstOffset + 0] = x0
				dst[dstOffset + 1] = y0
				dst[dstOffset + 2] = z0
				dst[dstOffset + 3] = w0
				return

			}

			if (t === 1) {

				dst[dstOffset + 0] = x1
				dst[dstOffset + 1] = y1
				dst[dstOffset + 2] = z1
				dst[dstOffset + 3] = w1
				return

			}

			if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {

				let s = 1 - t
				const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
					dir = (cos >= 0 ? 1 : - 1),
					sqrSin = 1 - cos * cos

				// Skip the Slerp for tiny steps to avoid numeric problems:
				if (sqrSin > Number.EPSILON) {

					const sin = Math.sqrt(sqrSin),
						len = Math.atan2(sin, cos * dir)

					s = Math.sin(s * len) / sin
					t = Math.sin(t * len) / sin

				}

				const tDir = t * dir

				x0 = x0 * s + x1 * tDir
				y0 = y0 * s + y1 * tDir
				z0 = z0 * s + z1 * tDir
				w0 = w0 * s + w1 * tDir

				// Normalize in case we just did a lerp:
				if (s === 1 - t) {

					const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0)

					x0 *= f
					y0 *= f
					z0 *= f
					w0 *= f

				}

			}

			dst[dstOffset] = x0
			dst[dstOffset + 1] = y0
			dst[dstOffset + 2] = z0
			dst[dstOffset + 3] = w0

		}

		static multiplyQuaternionsFlat (dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {

			const x0 = src0[srcOffset0]
			const y0 = src0[srcOffset0 + 1]
			const z0 = src0[srcOffset0 + 2]
			const w0 = src0[srcOffset0 + 3]

			const x1 = src1[srcOffset1]
			const y1 = src1[srcOffset1 + 1]
			const z1 = src1[srcOffset1 + 2]
			const w1 = src1[srcOffset1 + 3]

			dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1
			dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1
			dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1
			dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1

			return dst

		}

		get x () {

			return this._x

		}

		set x (value) {

			this._x = value
			this._onChangeCallback()

		}

		get y () {

			return this._y

		}

		set y (value) {

			this._y = value
			this._onChangeCallback()

		}

		get z () {

			return this._z

		}

		set z (value) {

			this._z = value
			this._onChangeCallback()

		}

		get w () {

			return this._w

		}

		set w (value) {

			this._w = value
			this._onChangeCallback()

		}

		set (x, y, z, w) {

			this._x = x
			this._y = y
			this._z = z
			this._w = w

			this._onChangeCallback()

			return this

		}

		clone () {

			return new this.constructor(this._x, this._y, this._z, this._w)

		}

		copy (quaternion) {

			this._x = quaternion.x
			this._y = quaternion.y
			this._z = quaternion.z
			this._w = quaternion.w

			this._onChangeCallback()

			return this

		}

		setFromEuler (euler, update) {

			if (!(euler && euler.isEuler)) {

				throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.')

			}

			const x = euler._x, y = euler._y, z = euler._z, order = euler._order

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			const cos = Math.cos
			const sin = Math.sin

			const c1 = cos(x / 2)
			const c2 = cos(y / 2)
			const c3 = cos(z / 2)

			const s1 = sin(x / 2)
			const s2 = sin(y / 2)
			const s3 = sin(z / 2)

			switch (order) {

				case 'XYZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3
					this._y = c1 * s2 * c3 - s1 * c2 * s3
					this._z = c1 * c2 * s3 + s1 * s2 * c3
					this._w = c1 * c2 * c3 - s1 * s2 * s3
					break

				case 'YXZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3
					this._y = c1 * s2 * c3 - s1 * c2 * s3
					this._z = c1 * c2 * s3 - s1 * s2 * c3
					this._w = c1 * c2 * c3 + s1 * s2 * s3
					break

				case 'ZXY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3
					this._y = c1 * s2 * c3 + s1 * c2 * s3
					this._z = c1 * c2 * s3 + s1 * s2 * c3
					this._w = c1 * c2 * c3 - s1 * s2 * s3
					break

				case 'ZYX':
					this._x = s1 * c2 * c3 - c1 * s2 * s3
					this._y = c1 * s2 * c3 + s1 * c2 * s3
					this._z = c1 * c2 * s3 - s1 * s2 * c3
					this._w = c1 * c2 * c3 + s1 * s2 * s3
					break

				case 'YZX':
					this._x = s1 * c2 * c3 + c1 * s2 * s3
					this._y = c1 * s2 * c3 + s1 * c2 * s3
					this._z = c1 * c2 * s3 - s1 * s2 * c3
					this._w = c1 * c2 * c3 - s1 * s2 * s3
					break

				case 'XZY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3
					this._y = c1 * s2 * c3 - s1 * c2 * s3
					this._z = c1 * c2 * s3 + s1 * s2 * c3
					this._w = c1 * c2 * c3 + s1 * s2 * s3
					break

				default:
					console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order)

			}

			if (update !== false) this._onChangeCallback()

			return this

		}

		setFromAxisAngle (axis, angle) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			const halfAngle = angle / 2, s = Math.sin(halfAngle)

			this._x = axis.x * s
			this._y = axis.y * s
			this._z = axis.z * s
			this._w = Math.cos(halfAngle)

			this._onChangeCallback()

			return this

		}

		setFromRotationMatrix (m) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			const te = m.elements,

				m11 = te[0], m12 = te[4], m13 = te[8],
				m21 = te[1], m22 = te[5], m23 = te[9],
				m31 = te[2], m32 = te[6], m33 = te[10],

				trace = m11 + m22 + m33

			if (trace > 0) {

				const s = 0.5 / Math.sqrt(trace + 1.0)

				this._w = 0.25 / s
				this._x = (m32 - m23) * s
				this._y = (m13 - m31) * s
				this._z = (m21 - m12) * s

			} else if (m11 > m22 && m11 > m33) {

				const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33)

				this._w = (m32 - m23) / s
				this._x = 0.25 * s
				this._y = (m12 + m21) / s
				this._z = (m13 + m31) / s

			} else if (m22 > m33) {

				const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33)

				this._w = (m13 - m31) / s
				this._x = (m12 + m21) / s
				this._y = 0.25 * s
				this._z = (m23 + m32) / s

			} else {

				const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22)

				this._w = (m21 - m12) / s
				this._x = (m13 + m31) / s
				this._y = (m23 + m32) / s
				this._z = 0.25 * s

			}

			this._onChangeCallback()

			return this

		}

		setFromUnitVectors (vFrom, vTo) {

			// assumes direction vectors vFrom and vTo are normalized

			let r = vFrom.dot(vTo) + 1

			if (r < Number.EPSILON) {

				// vFrom and vTo point in opposite directions

				r = 0

				if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {

					this._x = - vFrom.y
					this._y = vFrom.x
					this._z = 0
					this._w = r

				} else {

					this._x = 0
					this._y = - vFrom.z
					this._z = vFrom.y
					this._w = r

				}

			} else {

				// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

				this._x = vFrom.y * vTo.z - vFrom.z * vTo.y
				this._y = vFrom.z * vTo.x - vFrom.x * vTo.z
				this._z = vFrom.x * vTo.y - vFrom.y * vTo.x
				this._w = r

			}

			return this.normalize()

		}

		angleTo (q) {

			return 2 * Math.acos(Math.abs(clamp(this.dot(q), - 1, 1)))

		}

		rotateTowards (q, step) {

			const angle = this.angleTo(q)

			if (angle === 0) return this

			const t = Math.min(1, step / angle)

			this.slerp(q, t)

			return this

		}

		identity () {

			return this.set(0, 0, 0, 1)

		}

		invert () {

			// quaternion is assumed to have unit length

			return this.conjugate()

		}

		conjugate () {

			this._x *= - 1
			this._y *= - 1
			this._z *= - 1

			this._onChangeCallback()

			return this

		}

		dot (v) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w

		}

		lengthSq () {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w

		}

		length () {

			return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)

		}

		normalize () {

			let l = this.length()

			if (l === 0) {

				this._x = 0
				this._y = 0
				this._z = 0
				this._w = 1

			} else {

				l = 1 / l

				this._x = this._x * l
				this._y = this._y * l
				this._z = this._z * l
				this._w = this._w * l

			}

			this._onChangeCallback()

			return this

		}

		multiply (q, p) {

			if (p !== undefined) {

				console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.')
				return this.multiplyQuaternions(q, p)

			}

			return this.multiplyQuaternions(this, q)

		}

		premultiply (q) {

			return this.multiplyQuaternions(q, this)

		}

		multiplyQuaternions (a, b) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w
			const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz

			this._onChangeCallback()

			return this

		}

		slerp (qb, t) {

			if (t === 0) return this
			if (t === 1) return this.copy(qb)

			const x = this._x, y = this._y, z = this._z, w = this._w

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z

			if (cosHalfTheta < 0) {

				this._w = - qb._w
				this._x = - qb._x
				this._y = - qb._y
				this._z = - qb._z

				cosHalfTheta = - cosHalfTheta

			} else {

				this.copy(qb)

			}

			if (cosHalfTheta >= 1.0) {

				this._w = w
				this._x = x
				this._y = y
				this._z = z

				return this

			}

			const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta

			if (sqrSinHalfTheta <= Number.EPSILON) {

				const s = 1 - t
				this._w = s * w + t * this._w
				this._x = s * x + t * this._x
				this._y = s * y + t * this._y
				this._z = s * z + t * this._z

				this.normalize()
				this._onChangeCallback()

				return this

			}

			const sinHalfTheta = Math.sqrt(sqrSinHalfTheta)
			const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta)
			const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
				ratioB = Math.sin(t * halfTheta) / sinHalfTheta

			this._w = (w * ratioA + this._w * ratioB)
			this._x = (x * ratioA + this._x * ratioB)
			this._y = (y * ratioA + this._y * ratioB)
			this._z = (z * ratioA + this._z * ratioB)

			this._onChangeCallback()

			return this

		}

		slerpQuaternions (qa, qb, t) {

			this.copy(qa).slerp(qb, t)

		}

		equals (quaternion) {

			return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w)

		}

		fromArray (array, offset = 0) {

			this._x = array[offset]
			this._y = array[offset + 1]
			this._z = array[offset + 2]
			this._w = array[offset + 3]

			this._onChangeCallback()

			return this

		}

		toArray (array = [], offset = 0) {

			array[offset] = this._x
			array[offset + 1] = this._y
			array[offset + 2] = this._z
			array[offset + 3] = this._w

			return array

		}

		fromBufferAttribute (attribute, index) {

			this._x = attribute.getX(index)
			this._y = attribute.getY(index)
			this._z = attribute.getZ(index)
			this._w = attribute.getW(index)

			return this

		}

		_onChange (callback) {

			this._onChangeCallback = callback

			return this

		}

		_onChangeCallback () { }

	}

	Quaternion.prototype.isQuaternion = true

	class Vector3 {

		constructor(x = 0, y = 0, z = 0) {

			this.x = x
			this.y = y
			this.z = z

		}

		set (x, y, z) {

			if (z === undefined) z = this.z // sprite.scale.set(x,y)

			this.x = x
			this.y = y
			this.z = z

			return this

		}

		setScalar (scalar) {

			this.x = scalar
			this.y = scalar
			this.z = scalar

			return this

		}

		setX (x) {

			this.x = x

			return this

		}

		setY (y) {

			this.y = y

			return this

		}

		setZ (z) {

			this.z = z

			return this

		}

		setComponent (index, value) {

			switch (index) {

				case 0: this.x = value; break
				case 1: this.y = value; break
				case 2: this.z = value; break
				default: throw new Error('index is out of range: ' + index)

			}

			return this

		}

		getComponent (index) {

			switch (index) {

				case 0: return this.x
				case 1: return this.y
				case 2: return this.z
				default: throw new Error('index is out of range: ' + index)

			}

		}

		clone () {

			return new this.constructor(this.x, this.y, this.z)

		}

		copy (v) {

			this.x = v.x
			this.y = v.y
			this.z = v.z

			return this

		}

		add (v, w) {

			if (w !== undefined) {

				console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.')
				return this.addVectors(v, w)

			}

			this.x += v.x
			this.y += v.y
			this.z += v.z

			return this

		}

		addScalar (s) {

			this.x += s
			this.y += s
			this.z += s

			return this

		}

		addVectors (a, b) {

			this.x = a.x + b.x
			this.y = a.y + b.y
			this.z = a.z + b.z

			return this

		}

		addScaledVector (v, s) {

			this.x += v.x * s
			this.y += v.y * s
			this.z += v.z * s

			return this

		}

		sub (v, w) {

			if (w !== undefined) {

				console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.')
				return this.subVectors(v, w)

			}

			this.x -= v.x
			this.y -= v.y
			this.z -= v.z

			return this

		}

		subScalar (s) {

			this.x -= s
			this.y -= s
			this.z -= s

			return this

		}

		subVectors (a, b) {

			this.x = a.x - b.x
			this.y = a.y - b.y
			this.z = a.z - b.z

			return this

		}

		multiply (v, w) {

			if (w !== undefined) {

				console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.')
				return this.multiplyVectors(v, w)

			}

			this.x *= v.x
			this.y *= v.y
			this.z *= v.z

			return this

		}

		multiplyScalar (scalar) {

			this.x *= scalar
			this.y *= scalar
			this.z *= scalar

			return this

		}

		multiplyVectors (a, b) {

			this.x = a.x * b.x
			this.y = a.y * b.y
			this.z = a.z * b.z

			return this

		}

		applyEuler (euler) {

			if (!(euler && euler.isEuler)) {

				console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.')

			}

			return this.applyQuaternion(_quaternion$4.setFromEuler(euler))

		}

		applyAxisAngle (axis, angle) {

			return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle))

		}

		applyMatrix3 (m) {

			const x = this.x, y = this.y, z = this.z
			const e = m.elements

			this.x = e[0] * x + e[3] * y + e[6] * z
			this.y = e[1] * x + e[4] * y + e[7] * z
			this.z = e[2] * x + e[5] * y + e[8] * z

			return this

		}

		applyNormalMatrix (m) {

			return this.applyMatrix3(m).normalize()

		}

		applyMatrix4 (m) {

			const x = this.x, y = this.y, z = this.z
			const e = m.elements

			const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15])

			this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w
			this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w
			this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w

			return this

		}

		applyQuaternion (q) {

			const x = this.x, y = this.y, z = this.z
			const qx = q.x, qy = q.y, qz = q.z, qw = q.w

			// calculate quat * vector

			const ix = qw * x + qy * z - qz * y
			const iy = qw * y + qz * x - qx * z
			const iz = qw * z + qx * y - qy * x
			const iw = - qx * x - qy * y - qz * z

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx

			return this

		}

		project (camera) {

			return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix)

		}

		unproject (camera) {

			return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld)

		}

		transformDirection (m) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			const x = this.x, y = this.y, z = this.z
			const e = m.elements

			this.x = e[0] * x + e[4] * y + e[8] * z
			this.y = e[1] * x + e[5] * y + e[9] * z
			this.z = e[2] * x + e[6] * y + e[10] * z

			return this.normalize()

		}

		divide (v) {

			this.x /= v.x
			this.y /= v.y
			this.z /= v.z

			return this

		}

		divideScalar (scalar) {

			return this.multiplyScalar(1 / scalar)

		}

		min (v) {

			this.x = Math.min(this.x, v.x)
			this.y = Math.min(this.y, v.y)
			this.z = Math.min(this.z, v.z)

			return this

		}

		max (v) {

			this.x = Math.max(this.x, v.x)
			this.y = Math.max(this.y, v.y)
			this.z = Math.max(this.z, v.z)

			return this

		}

		clamp (min, max) {

			// assumes min < max, componentwise

			this.x = Math.max(min.x, Math.min(max.x, this.x))
			this.y = Math.max(min.y, Math.min(max.y, this.y))
			this.z = Math.max(min.z, Math.min(max.z, this.z))

			return this

		}

		clampScalar (minVal, maxVal) {

			this.x = Math.max(minVal, Math.min(maxVal, this.x))
			this.y = Math.max(minVal, Math.min(maxVal, this.y))
			this.z = Math.max(minVal, Math.min(maxVal, this.z))

			return this

		}

		clampLength (min, max) {

			const length = this.length()

			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)))

		}

		floor () {

			this.x = Math.floor(this.x)
			this.y = Math.floor(this.y)
			this.z = Math.floor(this.z)

			return this

		}

		ceil () {

			this.x = Math.ceil(this.x)
			this.y = Math.ceil(this.y)
			this.z = Math.ceil(this.z)

			return this

		}

		round () {

			this.x = Math.round(this.x)
			this.y = Math.round(this.y)
			this.z = Math.round(this.z)

			return this

		}

		roundToZero () {

			this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x)
			this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y)
			this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z)

			return this

		}

		negate () {

			this.x = - this.x
			this.y = - this.y
			this.z = - this.z

			return this

		}

		dot (v) {

			return this.x * v.x + this.y * v.y + this.z * v.z

		}

		// TODO lengthSquared?

		lengthSq () {

			return this.x * this.x + this.y * this.y + this.z * this.z

		}

		length () {

			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)

		}

		manhattanLength () {

			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)

		}

		normalize () {

			return this.divideScalar(this.length() || 1)

		}

		setLength (length) {

			return this.normalize().multiplyScalar(length)

		}

		lerp (v, alpha) {

			this.x += (v.x - this.x) * alpha
			this.y += (v.y - this.y) * alpha
			this.z += (v.z - this.z) * alpha

			return this

		}

		lerpVectors (v1, v2, alpha) {

			this.x = v1.x + (v2.x - v1.x) * alpha
			this.y = v1.y + (v2.y - v1.y) * alpha
			this.z = v1.z + (v2.z - v1.z) * alpha

			return this

		}

		cross (v, w) {

			if (w !== undefined) {

				console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.')
				return this.crossVectors(v, w)

			}

			return this.crossVectors(this, v)

		}

		crossVectors (a, b) {

			const ax = a.x, ay = a.y, az = a.z
			const bx = b.x, by = b.y, bz = b.z

			this.x = ay * bz - az * by
			this.y = az * bx - ax * bz
			this.z = ax * by - ay * bx

			return this

		}

		projectOnVector (v) {

			const denominator = v.lengthSq()

			if (denominator === 0) return this.set(0, 0, 0)

			const scalar = v.dot(this) / denominator

			return this.copy(v).multiplyScalar(scalar)

		}

		projectOnPlane (planeNormal) {

			_vector$c.copy(this).projectOnVector(planeNormal)

			return this.sub(_vector$c)

		}

		reflect (normal) {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)))

		}

		angleTo (v) {

			const denominator = Math.sqrt(this.lengthSq() * v.lengthSq())

			if (denominator === 0) return Math.PI / 2

			const theta = this.dot(v) / denominator

			// clamp, to handle numerical problems

			return Math.acos(clamp(theta, - 1, 1))

		}

		distanceTo (v) {

			return Math.sqrt(this.distanceToSquared(v))

		}

		distanceToSquared (v) {

			const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z

			return dx * dx + dy * dy + dz * dz

		}

		manhattanDistanceTo (v) {

			return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z)

		}

		setFromSpherical (s) {

			return this.setFromSphericalCoords(s.radius, s.phi, s.theta)

		}

		setFromSphericalCoords (radius, phi, theta) {

			const sinPhiRadius = Math.sin(phi) * radius

			this.x = sinPhiRadius * Math.sin(theta)
			this.y = Math.cos(phi) * radius
			this.z = sinPhiRadius * Math.cos(theta)

			return this

		}

		setFromCylindrical (c) {

			return this.setFromCylindricalCoords(c.radius, c.theta, c.y)

		}

		setFromCylindricalCoords (radius, theta, y) {

			this.x = radius * Math.sin(theta)
			this.y = y
			this.z = radius * Math.cos(theta)

			return this

		}

		setFromMatrixPosition (m) {

			const e = m.elements

			this.x = e[12]
			this.y = e[13]
			this.z = e[14]

			return this

		}

		setFromMatrixScale (m) {

			const sx = this.setFromMatrixColumn(m, 0).length()
			const sy = this.setFromMatrixColumn(m, 1).length()
			const sz = this.setFromMatrixColumn(m, 2).length()

			this.x = sx
			this.y = sy
			this.z = sz

			return this

		}

		setFromMatrixColumn (m, index) {

			return this.fromArray(m.elements, index * 4)

		}

		setFromMatrix3Column (m, index) {

			return this.fromArray(m.elements, index * 3)

		}

		equals (v) {

			return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z))

		}

		fromArray (array, offset = 0) {

			this.x = array[offset]
			this.y = array[offset + 1]
			this.z = array[offset + 2]

			return this

		}

		toArray (array = [], offset = 0) {

			array[offset] = this.x
			array[offset + 1] = this.y
			array[offset + 2] = this.z

			return array

		}

		fromBufferAttribute (attribute, index, offset) {

			if (offset !== undefined) {

				console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().')

			}

			this.x = attribute.getX(index)
			this.y = attribute.getY(index)
			this.z = attribute.getZ(index)

			return this

		}

		random () {

			this.x = Math.random()
			this.y = Math.random()
			this.z = Math.random()

			return this

		}

	}

	Vector3.prototype.isVector3 = true

	const _vector$c = /*@__PURE__*/ new Vector3()
	const _quaternion$4 = /*@__PURE__*/ new Quaternion()

	class Box3 {

		constructor(min = new Vector3(+ Infinity, + Infinity, + Infinity), max = new Vector3(- Infinity, - Infinity, - Infinity)) {

			this.min = min
			this.max = max

		}

		set (min, max) {

			this.min.copy(min)
			this.max.copy(max)

			return this

		}

		setFromArray (array) {

			let minX = + Infinity
			let minY = + Infinity
			let minZ = + Infinity

			let maxX = - Infinity
			let maxY = - Infinity
			let maxZ = - Infinity

			for (let i = 0, l = array.length; i < l; i += 3) {

				const x = array[i]
				const y = array[i + 1]
				const z = array[i + 2]

				if (x < minX) minX = x
				if (y < minY) minY = y
				if (z < minZ) minZ = z

				if (x > maxX) maxX = x
				if (y > maxY) maxY = y
				if (z > maxZ) maxZ = z

			}

			this.min.set(minX, minY, minZ)
			this.max.set(maxX, maxY, maxZ)

			return this

		}

		setFromBufferAttribute (attribute) {

			let minX = + Infinity
			let minY = + Infinity
			let minZ = + Infinity

			let maxX = - Infinity
			let maxY = - Infinity
			let maxZ = - Infinity

			for (let i = 0, l = attribute.count; i < l; i++) {

				const x = attribute.getX(i)
				const y = attribute.getY(i)
				const z = attribute.getZ(i)

				if (x < minX) minX = x
				if (y < minY) minY = y
				if (z < minZ) minZ = z

				if (x > maxX) maxX = x
				if (y > maxY) maxY = y
				if (z > maxZ) maxZ = z

			}

			this.min.set(minX, minY, minZ)
			this.max.set(maxX, maxY, maxZ)

			return this

		}

		setFromPoints (points) {

			this.makeEmpty()

			for (let i = 0, il = points.length; i < il; i++) {

				this.expandByPoint(points[i])

			}

			return this

		}

		setFromCenterAndSize (center, size) {

			const halfSize = _vector$b.copy(size).multiplyScalar(0.5)

			this.min.copy(center).sub(halfSize)
			this.max.copy(center).add(halfSize)

			return this

		}

		setFromObject (object) {

			this.makeEmpty()

			return this.expandByObject(object)

		}

		clone () {

			return new this.constructor().copy(this)

		}

		copy (box) {

			this.min.copy(box.min)
			this.max.copy(box.max)

			return this

		}

		makeEmpty () {

			this.min.x = this.min.y = this.min.z = + Infinity
			this.max.x = this.max.y = this.max.z = - Infinity

			return this

		}

		isEmpty () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z)

		}

		getCenter (target) {

			return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5)

		}

		getSize (target) {

			return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min)

		}

		expandByPoint (point) {

			this.min.min(point)
			this.max.max(point)

			return this

		}

		expandByVector (vector) {

			this.min.sub(vector)
			this.max.add(vector)

			return this

		}

		expandByScalar (scalar) {

			this.min.addScalar(- scalar)
			this.max.addScalar(scalar)

			return this

		}

		expandByObject (object) {

			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms

			object.updateWorldMatrix(false, false)

			const geometry = object.geometry

			if (geometry !== undefined) {

				if (geometry.boundingBox === null) {

					geometry.computeBoundingBox()

				}

				_box$3.copy(geometry.boundingBox)
				_box$3.applyMatrix4(object.matrixWorld)

				this.union(_box$3)

			}

			const children = object.children

			for (let i = 0, l = children.length; i < l; i++) {

				this.expandByObject(children[i])

			}

			return this

		}

		containsPoint (point) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ||
				point.z < this.min.z || point.z > this.max.z ? false : true

		}

		containsBox (box) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y &&
				this.min.z <= box.min.z && box.max.z <= this.max.z

		}

		getParameter (point, target) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			return target.set(
				(point.x - this.min.x) / (this.max.x - this.min.x),
				(point.y - this.min.y) / (this.max.y - this.min.y),
				(point.z - this.min.z) / (this.max.z - this.min.z)
			)

		}

		intersectsBox (box) {

			// using 6 splitting planes to rule out intersections.
			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ||
				box.max.z < this.min.z || box.min.z > this.max.z ? false : true

		}

		intersectsSphere (sphere) {

			// Find the point on the AABB closest to the sphere center.
			this.clampPoint(sphere.center, _vector$b)

			// If that point is inside the sphere, the AABB and sphere intersect.
			return _vector$b.distanceToSquared(sphere.center) <= (sphere.radius * sphere.radius)

		}

		intersectsPlane (plane) {

			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.

			let min, max

			if (plane.normal.x > 0) {

				min = plane.normal.x * this.min.x
				max = plane.normal.x * this.max.x

			} else {

				min = plane.normal.x * this.max.x
				max = plane.normal.x * this.min.x

			}

			if (plane.normal.y > 0) {

				min += plane.normal.y * this.min.y
				max += plane.normal.y * this.max.y

			} else {

				min += plane.normal.y * this.max.y
				max += plane.normal.y * this.min.y

			}

			if (plane.normal.z > 0) {

				min += plane.normal.z * this.min.z
				max += plane.normal.z * this.max.z

			} else {

				min += plane.normal.z * this.max.z
				max += plane.normal.z * this.min.z

			}

			return (min <= - plane.constant && max >= - plane.constant)

		}

		intersectsTriangle (triangle) {

			if (this.isEmpty()) {

				return false

			}

			// compute box center and extents
			this.getCenter(_center)
			_extents.subVectors(this.max, _center)

			// translate triangle to aabb origin
			_v0$2.subVectors(triangle.a, _center)
			_v1$7.subVectors(triangle.b, _center)
			_v2$3.subVectors(triangle.c, _center)

			// compute edge vectors for triangle
			_f0.subVectors(_v1$7, _v0$2)
			_f1.subVectors(_v2$3, _v1$7)
			_f2.subVectors(_v0$2, _v2$3)

			// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
			// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
			// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
			let axes = [
				0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
				_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
				- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
			]
			if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {

				return false

			}

			// test 3 face normals from the aabb
			axes = [1, 0, 0, 0, 1, 0, 0, 0, 1]
			if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {

				return false

			}

			// finally testing the face normal of the triangle
			// use already existing triangle edge vectors here
			_triangleNormal.crossVectors(_f0, _f1)
			axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z]

			return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)

		}

		clampPoint (point, target) {

			return target.copy(point).clamp(this.min, this.max)

		}

		distanceToPoint (point) {

			const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max)

			return clampedPoint.sub(point).length()

		}

		getBoundingSphere (target) {

			this.getCenter(target.center)

			target.radius = this.getSize(_vector$b).length() * 0.5

			return target

		}

		intersect (box) {

			this.min.max(box.min)
			this.max.min(box.max)

			// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
			if (this.isEmpty()) this.makeEmpty()

			return this

		}

		union (box) {

			this.min.min(box.min)
			this.max.max(box.max)

			return this

		}

		applyMatrix4 (matrix) {

			// transform of empty box is an empty box.
			if (this.isEmpty()) return this

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix) // 000
			_points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix) // 001
			_points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix) // 010
			_points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix) // 011
			_points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix) // 100
			_points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix) // 101
			_points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix) // 110
			_points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix) // 111

			this.setFromPoints(_points)

			return this

		}

		translate (offset) {

			this.min.add(offset)
			this.max.add(offset)

			return this

		}

		equals (box) {

			return box.min.equals(this.min) && box.max.equals(this.max)

		}

	}

	Box3.prototype.isBox3 = true

	const _points = [
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3()
	]

	const _vector$b = /*@__PURE__*/ new Vector3()

	const _box$3 = /*@__PURE__*/ new Box3()

	// triangle centered vertices

	const _v0$2 = /*@__PURE__*/ new Vector3()
	const _v1$7 = /*@__PURE__*/ new Vector3()
	const _v2$3 = /*@__PURE__*/ new Vector3()

	// triangle edge vectors

	const _f0 = /*@__PURE__*/ new Vector3()
	const _f1 = /*@__PURE__*/ new Vector3()
	const _f2 = /*@__PURE__*/ new Vector3()

	const _center = /*@__PURE__*/ new Vector3()
	const _extents = /*@__PURE__*/ new Vector3()
	const _triangleNormal = /*@__PURE__*/ new Vector3()
	const _testAxis = /*@__PURE__*/ new Vector3()

	function satForAxes (axes, v0, v1, v2, extents) {

		for (let i = 0, j = axes.length - 3; i <= j; i += 3) {

			_testAxis.fromArray(axes, i)
			// project the aabb onto the seperating axis
			const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z)
			// project all 3 vertices of the triangle onto the seperating axis
			const p0 = v0.dot(_testAxis)
			const p1 = v1.dot(_testAxis)
			const p2 = v2.dot(_testAxis)
			// actual test, basically see if either of the most extreme of the triangle points intersects r
			if (Math.max(- Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {

				// points of the projected triangle are outside the projected half-length of the aabb
				// the axis is seperating and we can exit
				return false

			}

		}

		return true

	}

	const _box$2 = /*@__PURE__*/ new Box3()
	const _v1$6 = /*@__PURE__*/ new Vector3()
	const _toFarthestPoint = /*@__PURE__*/ new Vector3()
	const _toPoint = /*@__PURE__*/ new Vector3()

	class Sphere {

		constructor(center = new Vector3(), radius = - 1) {

			this.center = center
			this.radius = radius

		}

		set (center, radius) {

			this.center.copy(center)
			this.radius = radius

			return this

		}

		setFromPoints (points, optionalCenter) {

			const center = this.center

			if (optionalCenter !== undefined) {

				center.copy(optionalCenter)

			} else {

				_box$2.setFromPoints(points).getCenter(center)

			}

			let maxRadiusSq = 0

			for (let i = 0, il = points.length; i < il; i++) {

				maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]))

			}

			this.radius = Math.sqrt(maxRadiusSq)

			return this

		}

		copy (sphere) {

			this.center.copy(sphere.center)
			this.radius = sphere.radius

			return this

		}

		isEmpty () {

			return (this.radius < 0)

		}

		makeEmpty () {

			this.center.set(0, 0, 0)
			this.radius = - 1

			return this

		}

		containsPoint (point) {

			return (point.distanceToSquared(this.center) <= (this.radius * this.radius))

		}

		distanceToPoint (point) {

			return (point.distanceTo(this.center) - this.radius)

		}

		intersectsSphere (sphere) {

			const radiusSum = this.radius + sphere.radius

			return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum)

		}

		intersectsBox (box) {

			return box.intersectsSphere(this)

		}

		intersectsPlane (plane) {

			return Math.abs(plane.distanceToPoint(this.center)) <= this.radius

		}

		clampPoint (point, target) {

			const deltaLengthSq = this.center.distanceToSquared(point)

			target.copy(point)

			if (deltaLengthSq > (this.radius * this.radius)) {

				target.sub(this.center).normalize()
				target.multiplyScalar(this.radius).add(this.center)

			}

			return target

		}

		getBoundingBox (target) {

			if (this.isEmpty()) {

				// Empty sphere produces empty bounding box
				target.makeEmpty()
				return target

			}

			target.set(this.center, this.center)
			target.expandByScalar(this.radius)

			return target

		}

		applyMatrix4 (matrix) {

			this.center.applyMatrix4(matrix)
			this.radius = this.radius * matrix.getMaxScaleOnAxis()

			return this

		}

		translate (offset) {

			this.center.add(offset)

			return this

		}

		expandByPoint (point) {

			// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671

			_toPoint.subVectors(point, this.center)

			const lengthSq = _toPoint.lengthSq()

			if (lengthSq > (this.radius * this.radius)) {

				const length = Math.sqrt(lengthSq)
				const missingRadiusHalf = (length - this.radius) * 0.5

				// Nudge this sphere towards the target point. Add half the missing distance to radius,
				// and the other half to position. This gives a tighter enclosure, instead of if
				// the whole missing distance were just added to radius.

				this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length))
				this.radius += missingRadiusHalf

			}

			return this

		}

		union (sphere) {

			// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769

			// To enclose another sphere into this sphere, we only need to enclose two points:
			// 1) Enclose the farthest point on the other sphere into this sphere.
			// 2) Enclose the opposite point of the farthest point into this sphere.

			_toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius)

			this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint))
			this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint))

			return this

		}

		equals (sphere) {

			return sphere.center.equals(this.center) && (sphere.radius === this.radius)

		}

		clone () {

			return new this.constructor().copy(this)

		}

	}

	const _vector$a = /*@__PURE__*/ new Vector3()
	const _segCenter = /*@__PURE__*/ new Vector3()
	const _segDir = /*@__PURE__*/ new Vector3()
	const _diff = /*@__PURE__*/ new Vector3()

	const _edge1 = /*@__PURE__*/ new Vector3()
	const _edge2 = /*@__PURE__*/ new Vector3()
	const _normal$1 = /*@__PURE__*/ new Vector3()

	class Ray {

		constructor(origin = new Vector3(), direction = new Vector3(0, 0, - 1)) {

			this.origin = origin
			this.direction = direction

		}

		set (origin, direction) {

			this.origin.copy(origin)
			this.direction.copy(direction)

			return this

		}

		copy (ray) {

			this.origin.copy(ray.origin)
			this.direction.copy(ray.direction)

			return this

		}

		at (t, target) {

			return target.copy(this.direction).multiplyScalar(t).add(this.origin)

		}

		lookAt (v) {

			this.direction.copy(v).sub(this.origin).normalize()

			return this

		}

		recast (t) {

			this.origin.copy(this.at(t, _vector$a))

			return this

		}

		closestPointToPoint (point, target) {

			target.subVectors(point, this.origin)

			const directionDistance = target.dot(this.direction)

			if (directionDistance < 0) {

				return target.copy(this.origin)

			}

			return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin)

		}

		distanceToPoint (point) {

			return Math.sqrt(this.distanceSqToPoint(point))

		}

		distanceSqToPoint (point) {

			const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction)

			// point behind the ray

			if (directionDistance < 0) {

				return this.origin.distanceToSquared(point)

			}

			_vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin)

			return _vector$a.distanceToSquared(point)

		}

		distanceSqToSegment (v0, v1, optionalPointOnRay, optionalPointOnSegment) {

			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment

			_segCenter.copy(v0).add(v1).multiplyScalar(0.5)
			_segDir.copy(v1).sub(v0).normalize()
			_diff.copy(this.origin).sub(_segCenter)

			const segExtent = v0.distanceTo(v1) * 0.5
			const a01 = - this.direction.dot(_segDir)
			const b0 = _diff.dot(this.direction)
			const b1 = - _diff.dot(_segDir)
			const c = _diff.lengthSq()
			const det = Math.abs(1 - a01 * a01)
			let s0, s1, sqrDist, extDet

			if (det > 0) {

				// The ray and segment are not parallel.

				s0 = a01 * b1 - b0
				s1 = a01 * b0 - b1
				extDet = segExtent * det

				if (s0 >= 0) {

					if (s1 >= - extDet) {

						if (s1 <= extDet) {

							// region 0
							// Minimum at interior points of ray and segment.

							const invDet = 1 / det
							s0 *= invDet
							s1 *= invDet
							sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c

						} else {

							// region 1

							s1 = segExtent
							s0 = Math.max(0, - (a01 * s1 + b0))
							sqrDist = - s0 * s0 + s1 * (s1 + 2 * b1) + c

						}

					} else {

						// region 5

						s1 = - segExtent
						s0 = Math.max(0, - (a01 * s1 + b0))
						sqrDist = - s0 * s0 + s1 * (s1 + 2 * b1) + c

					}

				} else {

					if (s1 <= - extDet) {

						// region 4

						s0 = Math.max(0, - (- a01 * segExtent + b0))
						s1 = (s0 > 0) ? - segExtent : Math.min(Math.max(- segExtent, - b1), segExtent)
						sqrDist = - s0 * s0 + s1 * (s1 + 2 * b1) + c

					} else if (s1 <= extDet) {

						// region 3

						s0 = 0
						s1 = Math.min(Math.max(- segExtent, - b1), segExtent)
						sqrDist = s1 * (s1 + 2 * b1) + c

					} else {

						// region 2

						s0 = Math.max(0, - (a01 * segExtent + b0))
						s1 = (s0 > 0) ? segExtent : Math.min(Math.max(- segExtent, - b1), segExtent)
						sqrDist = - s0 * s0 + s1 * (s1 + 2 * b1) + c

					}

				}

			} else {

				// Ray and segment are parallel.

				s1 = (a01 > 0) ? - segExtent : segExtent
				s0 = Math.max(0, - (a01 * s1 + b0))
				sqrDist = - s0 * s0 + s1 * (s1 + 2 * b1) + c

			}

			if (optionalPointOnRay) {

				optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin)

			}

			if (optionalPointOnSegment) {

				optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter)

			}

			return sqrDist

		}

		intersectSphere (sphere, target) {

			_vector$a.subVectors(sphere.center, this.origin)
			const tca = _vector$a.dot(this.direction)
			const d2 = _vector$a.dot(_vector$a) - tca * tca
			const radius2 = sphere.radius * sphere.radius

			if (d2 > radius2) return null

			const thc = Math.sqrt(radius2 - d2)

			// t0 = first intersect point - entrance on front of sphere
			const t0 = tca - thc

			// t1 = second intersect point - exit point on back of sphere
			const t1 = tca + thc

			// test to see if both t0 and t1 are behind the ray - if so, return null
			if (t0 < 0 && t1 < 0) return null

			// test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.
			if (t0 < 0) return this.at(t1, target)

			// else t0 is in front of the ray, so return the first collision point scaled by t0
			return this.at(t0, target)

		}

		intersectsSphere (sphere) {

			return this.distanceSqToPoint(sphere.center) <= (sphere.radius * sphere.radius)

		}

		distanceToPlane (plane) {

			const denominator = plane.normal.dot(this.direction)

			if (denominator === 0) {

				// line is coplanar, return origin
				if (plane.distanceToPoint(this.origin) === 0) {

					return 0

				}

				// Null is preferable to undefined since undefined means.... it is undefined

				return null

			}

			const t = - (this.origin.dot(plane.normal) + plane.constant) / denominator

			// Return if the ray never intersects the plane

			return t >= 0 ? t : null

		}

		intersectPlane (plane, target) {

			const t = this.distanceToPlane(plane)

			if (t === null) {

				return null

			}

			return this.at(t, target)

		}

		intersectsPlane (plane) {

			// check if the ray lies on the plane first

			const distToPoint = plane.distanceToPoint(this.origin)

			if (distToPoint === 0) {

				return true

			}

			const denominator = plane.normal.dot(this.direction)

			if (denominator * distToPoint < 0) {

				return true

			}

			// ray origin is behind the plane (and is pointing behind it)

			return false

		}

		intersectBox (box, target) {

			let tmin, tmax, tymin, tymax, tzmin, tzmax

			const invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z

			const origin = this.origin

			if (invdirx >= 0) {

				tmin = (box.min.x - origin.x) * invdirx
				tmax = (box.max.x - origin.x) * invdirx

			} else {

				tmin = (box.max.x - origin.x) * invdirx
				tmax = (box.min.x - origin.x) * invdirx

			}

			if (invdiry >= 0) {

				tymin = (box.min.y - origin.y) * invdiry
				tymax = (box.max.y - origin.y) * invdiry

			} else {

				tymin = (box.max.y - origin.y) * invdiry
				tymax = (box.min.y - origin.y) * invdiry

			}

			if ((tmin > tymax) || (tymin > tmax)) return null

			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if (tymin > tmin || tmin !== tmin) tmin = tymin

			if (tymax < tmax || tmax !== tmax) tmax = tymax

			if (invdirz >= 0) {

				tzmin = (box.min.z - origin.z) * invdirz
				tzmax = (box.max.z - origin.z) * invdirz

			} else {

				tzmin = (box.max.z - origin.z) * invdirz
				tzmax = (box.min.z - origin.z) * invdirz

			}

			if ((tmin > tzmax) || (tzmin > tmax)) return null

			if (tzmin > tmin || tmin !== tmin) tmin = tzmin

			if (tzmax < tmax || tmax !== tmax) tmax = tzmax

			//return point closest to the ray (positive side)

			if (tmax < 0) return null

			return this.at(tmin >= 0 ? tmin : tmax, target)

		}

		intersectsBox (box) {

			return this.intersectBox(box, _vector$a) !== null

		}

		intersectTriangle (a, b, c, backfaceCulling, target) {

			// Compute the offset origin, edges, and normal.

			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

			_edge1.subVectors(b, a)
			_edge2.subVectors(c, a)
			_normal$1.crossVectors(_edge1, _edge2)

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			let DdN = this.direction.dot(_normal$1)
			let sign

			if (DdN > 0) {

				if (backfaceCulling) return null
				sign = 1

			} else if (DdN < 0) {

				sign = - 1
				DdN = - DdN

			} else {

				return null

			}

			_diff.subVectors(this.origin, a)
			const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2))

			// b1 < 0, no intersection
			if (DdQxE2 < 0) {

				return null

			}

			const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff))

			// b2 < 0, no intersection
			if (DdE1xQ < 0) {

				return null

			}

			// b1+b2 > 1, no intersection
			if (DdQxE2 + DdE1xQ > DdN) {

				return null

			}

			// Line intersects triangle, check if ray does.
			const QdN = - sign * _diff.dot(_normal$1)

			// t < 0, no intersection
			if (QdN < 0) {

				return null

			}

			// Ray intersects triangle.
			return this.at(QdN / DdN, target)

		}

		applyMatrix4 (matrix4) {

			this.origin.applyMatrix4(matrix4)
			this.direction.transformDirection(matrix4)

			return this

		}

		equals (ray) {

			return ray.origin.equals(this.origin) && ray.direction.equals(this.direction)

		}

		clone () {

			return new this.constructor().copy(this)

		}

	}

	class Matrix4 {

		constructor() {

			this.elements = [

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			]

			if (arguments.length > 0) {

				console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.')

			}

		}

		set (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {

			const te = this.elements

			te[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14
			te[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24
			te[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34
			te[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44

			return this

		}

		identity () {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			)

			return this

		}

		clone () {

			return new Matrix4().fromArray(this.elements)

		}

		copy (m) {

			const te = this.elements
			const me = m.elements

			te[0] = me[0]; te[1] = me[1]; te[2] = me[2]; te[3] = me[3]
			te[4] = me[4]; te[5] = me[5]; te[6] = me[6]; te[7] = me[7]
			te[8] = me[8]; te[9] = me[9]; te[10] = me[10]; te[11] = me[11]
			te[12] = me[12]; te[13] = me[13]; te[14] = me[14]; te[15] = me[15]

			return this

		}

		copyPosition (m) {

			const te = this.elements, me = m.elements

			te[12] = me[12]
			te[13] = me[13]
			te[14] = me[14]

			return this

		}

		setFromMatrix3 (m) {

			const me = m.elements

			this.set(

				me[0], me[3], me[6], 0,
				me[1], me[4], me[7], 0,
				me[2], me[5], me[8], 0,
				0, 0, 0, 1

			)

			return this

		}

		extractBasis (xAxis, yAxis, zAxis) {

			xAxis.setFromMatrixColumn(this, 0)
			yAxis.setFromMatrixColumn(this, 1)
			zAxis.setFromMatrixColumn(this, 2)

			return this

		}

		makeBasis (xAxis, yAxis, zAxis) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1
			)

			return this

		}

		extractRotation (m) {

			// this method does not support reflection matrices

			const te = this.elements
			const me = m.elements

			const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length()
			const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length()
			const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length()

			te[0] = me[0] * scaleX
			te[1] = me[1] * scaleX
			te[2] = me[2] * scaleX
			te[3] = 0

			te[4] = me[4] * scaleY
			te[5] = me[5] * scaleY
			te[6] = me[6] * scaleY
			te[7] = 0

			te[8] = me[8] * scaleZ
			te[9] = me[9] * scaleZ
			te[10] = me[10] * scaleZ
			te[11] = 0

			te[12] = 0
			te[13] = 0
			te[14] = 0
			te[15] = 1

			return this

		}

		makeRotationFromEuler (euler) {

			if (!(euler && euler.isEuler)) {

				console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.')

			}

			const te = this.elements

			const x = euler.x, y = euler.y, z = euler.z
			const a = Math.cos(x), b = Math.sin(x)
			const c = Math.cos(y), d = Math.sin(y)
			const e = Math.cos(z), f = Math.sin(z)

			if (euler.order === 'XYZ') {

				const ae = a * e, af = a * f, be = b * e, bf = b * f

				te[0] = c * e
				te[4] = - c * f
				te[8] = d

				te[1] = af + be * d
				te[5] = ae - bf * d
				te[9] = - b * c

				te[2] = bf - ae * d
				te[6] = be + af * d
				te[10] = a * c

			} else if (euler.order === 'YXZ') {

				const ce = c * e, cf = c * f, de = d * e, df = d * f

				te[0] = ce + df * b
				te[4] = de * b - cf
				te[8] = a * d

				te[1] = a * f
				te[5] = a * e
				te[9] = - b

				te[2] = cf * b - de
				te[6] = df + ce * b
				te[10] = a * c

			} else if (euler.order === 'ZXY') {

				const ce = c * e, cf = c * f, de = d * e, df = d * f

				te[0] = ce - df * b
				te[4] = - a * f
				te[8] = de + cf * b

				te[1] = cf + de * b
				te[5] = a * e
				te[9] = df - ce * b

				te[2] = - a * d
				te[6] = b
				te[10] = a * c

			} else if (euler.order === 'ZYX') {

				const ae = a * e, af = a * f, be = b * e, bf = b * f

				te[0] = c * e
				te[4] = be * d - af
				te[8] = ae * d + bf

				te[1] = c * f
				te[5] = bf * d + ae
				te[9] = af * d - be

				te[2] = - d
				te[6] = b * c
				te[10] = a * c

			} else if (euler.order === 'YZX') {

				const ac = a * c, ad = a * d, bc = b * c, bd = b * d

				te[0] = c * e
				te[4] = bd - ac * f
				te[8] = bc * f + ad

				te[1] = f
				te[5] = a * e
				te[9] = - b * e

				te[2] = - d * e
				te[6] = ad * f + bc
				te[10] = ac - bd * f

			} else if (euler.order === 'XZY') {

				const ac = a * c, ad = a * d, bc = b * c, bd = b * d

				te[0] = c * e
				te[4] = - f
				te[8] = d * e

				te[1] = ac * f + bd
				te[5] = a * e
				te[9] = ad * f - bc

				te[2] = bc * f - ad
				te[6] = b * e
				te[10] = bd * f + ac

			}

			// bottom row
			te[3] = 0
			te[7] = 0
			te[11] = 0

			// last column
			te[12] = 0
			te[13] = 0
			te[14] = 0
			te[15] = 1

			return this

		}

		makeRotationFromQuaternion (q) {

			return this.compose(_zero, q, _one)

		}

		lookAt (eye, target, up) {

			const te = this.elements

			_z.subVectors(eye, target)

			if (_z.lengthSq() === 0) {

				// eye and target are in the same position

				_z.z = 1

			}

			_z.normalize()
			_x.crossVectors(up, _z)

			if (_x.lengthSq() === 0) {

				// up and z are parallel

				if (Math.abs(up.z) === 1) {

					_z.x += 0.0001

				} else {

					_z.z += 0.0001

				}

				_z.normalize()
				_x.crossVectors(up, _z)

			}

			_x.normalize()
			_y.crossVectors(_z, _x)

			te[0] = _x.x; te[4] = _y.x; te[8] = _z.x
			te[1] = _x.y; te[5] = _y.y; te[9] = _z.y
			te[2] = _x.z; te[6] = _y.z; te[10] = _z.z

			return this

		}

		multiply (m, n) {

			if (n !== undefined) {

				console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.')
				return this.multiplyMatrices(m, n)

			}

			return this.multiplyMatrices(this, m)

		}

		premultiply (m) {

			return this.multiplyMatrices(m, this)

		}

		multiplyMatrices (a, b) {

			const ae = a.elements
			const be = b.elements
			const te = this.elements

			const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12]
			const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13]
			const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14]
			const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15]

			const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12]
			const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13]
			const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14]
			const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15]

			te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41
			te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42
			te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43
			te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44

			te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41
			te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42
			te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43
			te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44

			te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41
			te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42
			te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43
			te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44

			te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41
			te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42
			te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43
			te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44

			return this

		}

		multiplyScalar (s) {

			const te = this.elements

			te[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s
			te[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s
			te[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s
			te[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s

			return this

		}

		determinant () {

			const te = this.elements

			const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12]
			const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13]
			const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14]
			const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15]

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					- n13 * n24 * n32
					- n14 * n22 * n33
					+ n12 * n24 * n33
					+ n13 * n22 * n34
					- n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					- n11 * n24 * n33
					+ n14 * n21 * n33
					- n13 * n21 * n34
					+ n13 * n24 * n31
					- n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					- n11 * n22 * n34
					- n14 * n21 * n32
					+ n12 * n21 * n34
					+ n14 * n22 * n31
					- n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					- n11 * n23 * n32
					+ n11 * n22 * n33
					+ n13 * n21 * n32
					- n12 * n21 * n33
					+ n12 * n23 * n31
				)

			)

		}

		transpose () {

			const te = this.elements
			let tmp

			tmp = te[1]; te[1] = te[4]; te[4] = tmp
			tmp = te[2]; te[2] = te[8]; te[8] = tmp
			tmp = te[6]; te[6] = te[9]; te[9] = tmp

			tmp = te[3]; te[3] = te[12]; te[12] = tmp
			tmp = te[7]; te[7] = te[13]; te[13] = tmp
			tmp = te[11]; te[11] = te[14]; te[14] = tmp

			return this

		}

		setPosition (x, y, z) {

			const te = this.elements

			if (x.isVector3) {

				te[12] = x.x
				te[13] = x.y
				te[14] = x.z

			} else {

				te[12] = x
				te[13] = y
				te[14] = z

			}

			return this

		}

		invert () {

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			const te = this.elements,

				n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3],
				n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7],
				n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11],
				n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15],

				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34

			const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14

			if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

			const detInv = 1 / det

			te[0] = t11 * detInv
			te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv
			te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv
			te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv

			te[4] = t12 * detInv
			te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv
			te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv
			te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv

			te[8] = t13 * detInv
			te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv
			te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv
			te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv

			te[12] = t14 * detInv
			te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv
			te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv
			te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv

			return this

		}

		scale (v) {

			const te = this.elements
			const x = v.x, y = v.y, z = v.z

			te[0] *= x; te[4] *= y; te[8] *= z
			te[1] *= x; te[5] *= y; te[9] *= z
			te[2] *= x; te[6] *= y; te[10] *= z
			te[3] *= x; te[7] *= y; te[11] *= z

			return this

		}

		getMaxScaleOnAxis () {

			const te = this.elements

			const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2]
			const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6]
			const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10]

			return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq))

		}

		makeTranslation (x, y, z) {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			)

			return this

		}

		makeRotationX (theta) {

			const c = Math.cos(theta), s = Math.sin(theta)

			this.set(

				1, 0, 0, 0,
				0, c, - s, 0,
				0, s, c, 0,
				0, 0, 0, 1

			)

			return this

		}

		makeRotationY (theta) {

			const c = Math.cos(theta), s = Math.sin(theta)

			this.set(

				c, 0, s, 0,
				0, 1, 0, 0,
				- s, 0, c, 0,
				0, 0, 0, 1

			)

			return this

		}

		makeRotationZ (theta) {

			const c = Math.cos(theta), s = Math.sin(theta)

			this.set(

				c, - s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			)

			return this

		}

		makeRotationAxis (axis, angle) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			const c = Math.cos(angle)
			const s = Math.sin(angle)
			const t = 1 - c
			const x = axis.x, y = axis.y, z = axis.z
			const tx = t * x, ty = t * y

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			)

			return this

		}

		makeScale (x, y, z) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			)

			return this

		}

		makeShear (xy, xz, yx, yz, zx, zy) {

			this.set(

				1, yx, zx, 0,
				xy, 1, zy, 0,
				xz, yz, 1, 0,
				0, 0, 0, 1

			)

			return this

		}

		compose (position, quaternion, scale) {

			const te = this.elements

			const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w
			const x2 = x + x, y2 = y + y, z2 = z + z
			const xx = x * x2, xy = x * y2, xz = x * z2
			const yy = y * y2, yz = y * z2, zz = z * z2
			const wx = w * x2, wy = w * y2, wz = w * z2

			const sx = scale.x, sy = scale.y, sz = scale.z

			te[0] = (1 - (yy + zz)) * sx
			te[1] = (xy + wz) * sx
			te[2] = (xz - wy) * sx
			te[3] = 0

			te[4] = (xy - wz) * sy
			te[5] = (1 - (xx + zz)) * sy
			te[6] = (yz + wx) * sy
			te[7] = 0

			te[8] = (xz + wy) * sz
			te[9] = (yz - wx) * sz
			te[10] = (1 - (xx + yy)) * sz
			te[11] = 0

			te[12] = position.x
			te[13] = position.y
			te[14] = position.z
			te[15] = 1

			return this

		}

		decompose (position, quaternion, scale) {

			const te = this.elements

			let sx = _v1$5.set(te[0], te[1], te[2]).length()
			const sy = _v1$5.set(te[4], te[5], te[6]).length()
			const sz = _v1$5.set(te[8], te[9], te[10]).length()

			// if determine is negative, we need to invert one scale
			const det = this.determinant()
			if (det < 0) sx = - sx

			position.x = te[12]
			position.y = te[13]
			position.z = te[14]

			// scale the rotation part
			_m1$2.copy(this)

			const invSX = 1 / sx
			const invSY = 1 / sy
			const invSZ = 1 / sz

			_m1$2.elements[0] *= invSX
			_m1$2.elements[1] *= invSX
			_m1$2.elements[2] *= invSX

			_m1$2.elements[4] *= invSY
			_m1$2.elements[5] *= invSY
			_m1$2.elements[6] *= invSY

			_m1$2.elements[8] *= invSZ
			_m1$2.elements[9] *= invSZ
			_m1$2.elements[10] *= invSZ

			quaternion.setFromRotationMatrix(_m1$2)

			scale.x = sx
			scale.y = sy
			scale.z = sz

			return this

		}

		makePerspective (left, right, top, bottom, near, far) {

			if (far === undefined) {

				console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.')

			}

			const te = this.elements
			const x = 2 * near / (right - left)
			const y = 2 * near / (top - bottom)

			const a = (right + left) / (right - left)
			const b = (top + bottom) / (top - bottom)
			const c = - (far + near) / (far - near)
			const d = - 2 * far * near / (far - near)

			te[0] = x; te[4] = 0; te[8] = a; te[12] = 0
			te[1] = 0; te[5] = y; te[9] = b; te[13] = 0
			te[2] = 0; te[6] = 0; te[10] = c; te[14] = d
			te[3] = 0; te[7] = 0; te[11] = - 1; te[15] = 0

			return this

		}

		makeOrthographic (left, right, top, bottom, near, far) {

			const te = this.elements
			const w = 1.0 / (right - left)
			const h = 1.0 / (top - bottom)
			const p = 1.0 / (far - near)

			const x = (right + left) * w
			const y = (top + bottom) * h
			const z = (far + near) * p

			te[0] = 2 * w; te[4] = 0; te[8] = 0; te[12] = - x
			te[1] = 0; te[5] = 2 * h; te[9] = 0; te[13] = - y
			te[2] = 0; te[6] = 0; te[10] = - 2 * p; te[14] = - z
			te[3] = 0; te[7] = 0; te[11] = 0; te[15] = 1

			return this

		}

		equals (matrix) {

			const te = this.elements
			const me = matrix.elements

			for (let i = 0; i < 16; i++) {

				if (te[i] !== me[i]) return false

			}

			return true

		}

		fromArray (array, offset = 0) {

			for (let i = 0; i < 16; i++) {

				this.elements[i] = array[i + offset]

			}

			return this

		}

		toArray (array = [], offset = 0) {

			const te = this.elements

			array[offset] = te[0]
			array[offset + 1] = te[1]
			array[offset + 2] = te[2]
			array[offset + 3] = te[3]

			array[offset + 4] = te[4]
			array[offset + 5] = te[5]
			array[offset + 6] = te[6]
			array[offset + 7] = te[7]

			array[offset + 8] = te[8]
			array[offset + 9] = te[9]
			array[offset + 10] = te[10]
			array[offset + 11] = te[11]

			array[offset + 12] = te[12]
			array[offset + 13] = te[13]
			array[offset + 14] = te[14]
			array[offset + 15] = te[15]

			return array

		}

	}

	Matrix4.prototype.isMatrix4 = true

	const _v1$5 = /*@__PURE__*/ new Vector3()
	const _m1$2 = /*@__PURE__*/ new Matrix4()
	const _zero = /*@__PURE__*/ new Vector3(0, 0, 0)
	const _one = /*@__PURE__*/ new Vector3(1, 1, 1)
	const _x = /*@__PURE__*/ new Vector3()
	const _y = /*@__PURE__*/ new Vector3()
	const _z = /*@__PURE__*/ new Vector3()

	const _matrix$1 = /*@__PURE__*/ new Matrix4()
	const _quaternion$3 = /*@__PURE__*/ new Quaternion()

	class Euler {

		constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {

			this._x = x
			this._y = y
			this._z = z
			this._order = order

		}

		get x () {

			return this._x

		}

		set x (value) {

			this._x = value
			this._onChangeCallback()

		}

		get y () {

			return this._y

		}

		set y (value) {

			this._y = value
			this._onChangeCallback()

		}

		get z () {

			return this._z

		}

		set z (value) {

			this._z = value
			this._onChangeCallback()

		}

		get order () {

			return this._order

		}

		set order (value) {

			this._order = value
			this._onChangeCallback()

		}

		set (x, y, z, order = this._order) {

			this._x = x
			this._y = y
			this._z = z
			this._order = order

			this._onChangeCallback()

			return this

		}

		clone () {

			return new this.constructor(this._x, this._y, this._z, this._order)

		}

		copy (euler) {

			this._x = euler._x
			this._y = euler._y
			this._z = euler._z
			this._order = euler._order

			this._onChangeCallback()

			return this

		}

		setFromRotationMatrix (m, order = this._order, update = true) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			const te = m.elements
			const m11 = te[0], m12 = te[4], m13 = te[8]
			const m21 = te[1], m22 = te[5], m23 = te[9]
			const m31 = te[2], m32 = te[6], m33 = te[10]

			switch (order) {

				case 'XYZ':

					this._y = Math.asin(clamp(m13, - 1, 1))

					if (Math.abs(m13) < 0.9999999) {

						this._x = Math.atan2(- m23, m33)
						this._z = Math.atan2(- m12, m11)

					} else {

						this._x = Math.atan2(m32, m22)
						this._z = 0

					}

					break

				case 'YXZ':

					this._x = Math.asin(- clamp(m23, - 1, 1))

					if (Math.abs(m23) < 0.9999999) {

						this._y = Math.atan2(m13, m33)
						this._z = Math.atan2(m21, m22)

					} else {

						this._y = Math.atan2(- m31, m11)
						this._z = 0

					}

					break

				case 'ZXY':

					this._x = Math.asin(clamp(m32, - 1, 1))

					if (Math.abs(m32) < 0.9999999) {

						this._y = Math.atan2(- m31, m33)
						this._z = Math.atan2(- m12, m22)

					} else {

						this._y = 0
						this._z = Math.atan2(m21, m11)

					}

					break

				case 'ZYX':

					this._y = Math.asin(- clamp(m31, - 1, 1))

					if (Math.abs(m31) < 0.9999999) {

						this._x = Math.atan2(m32, m33)
						this._z = Math.atan2(m21, m11)

					} else {

						this._x = 0
						this._z = Math.atan2(- m12, m22)

					}

					break

				case 'YZX':

					this._z = Math.asin(clamp(m21, - 1, 1))

					if (Math.abs(m21) < 0.9999999) {

						this._x = Math.atan2(- m23, m22)
						this._y = Math.atan2(- m31, m11)

					} else {

						this._x = 0
						this._y = Math.atan2(m13, m33)

					}

					break

				case 'XZY':

					this._z = Math.asin(- clamp(m12, - 1, 1))

					if (Math.abs(m12) < 0.9999999) {

						this._x = Math.atan2(m32, m22)
						this._y = Math.atan2(m13, m11)

					} else {

						this._x = Math.atan2(- m23, m33)
						this._y = 0

					}

					break

				default:

					console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order)

			}

			this._order = order

			if (update === true) this._onChangeCallback()

			return this

		}

		setFromQuaternion (q, order, update) {

			_matrix$1.makeRotationFromQuaternion(q)

			return this.setFromRotationMatrix(_matrix$1, order, update)

		}

		setFromVector3 (v, order = this._order) {

			return this.set(v.x, v.y, v.z, order)

		}

		reorder (newOrder) {

			// WARNING: this discards revolution information -bhouston

			_quaternion$3.setFromEuler(this)

			return this.setFromQuaternion(_quaternion$3, newOrder)

		}

		equals (euler) {

			return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order)

		}

		fromArray (array) {

			this._x = array[0]
			this._y = array[1]
			this._z = array[2]
			if (array[3] !== undefined) this._order = array[3]

			this._onChangeCallback()

			return this

		}

		toArray (array = [], offset = 0) {

			array[offset] = this._x
			array[offset + 1] = this._y
			array[offset + 2] = this._z
			array[offset + 3] = this._order

			return array

		}

		toVector3 (optionalResult) {

			if (optionalResult) {

				return optionalResult.set(this._x, this._y, this._z)

			} else {

				return new Vector3(this._x, this._y, this._z)

			}

		}

		_onChange (callback) {

			this._onChangeCallback = callback

			return this

		}

		_onChangeCallback () { }

	}

	Euler.prototype.isEuler = true

	Euler.DefaultOrder = 'XYZ'
	Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX']

	class Layers {

		constructor() {

			this.mask = 1 | 0

		}

		set (channel) {

			this.mask = 1 << channel | 0

		}

		enable (channel) {

			this.mask |= 1 << channel | 0

		}

		enableAll () {

			this.mask = 0xffffffff | 0

		}

		toggle (channel) {

			this.mask ^= 1 << channel | 0

		}

		disable (channel) {

			this.mask &= ~(1 << channel | 0)

		}

		disableAll () {

			this.mask = 0

		}

		test (layers) {

			return (this.mask & layers.mask) !== 0

		}

	}

	let _object3DId = 0

	const _v1$4 = /*@__PURE__*/ new Vector3()
	const _q1 = /*@__PURE__*/ new Quaternion()
	const _m1$1 = /*@__PURE__*/ new Matrix4()
	const _target = /*@__PURE__*/ new Vector3()

	const _position$3 = /*@__PURE__*/ new Vector3()
	const _scale$2 = /*@__PURE__*/ new Vector3()
	const _quaternion$2 = /*@__PURE__*/ new Quaternion()

	const _xAxis = /*@__PURE__*/ new Vector3(1, 0, 0)
	const _yAxis = /*@__PURE__*/ new Vector3(0, 1, 0)
	const _zAxis = /*@__PURE__*/ new Vector3(0, 0, 1)

	const _addedEvent = { type: 'added' }
	const _removedEvent = { type: 'removed' }

	class Object3D extends EventDispatcher {

		constructor() {

			super()

			Object.defineProperty(this, 'id', { value: _object3DId++ })

			this.uuid = generateUUID()

			this.name = ''
			this.type = 'Object3D'

			this.parent = null
			this.children = []

			this.up = Object3D.DefaultUp.clone()

			const position = new Vector3()
			const rotation = new Euler()
			const quaternion = new Quaternion()
			const scale = new Vector3(1, 1, 1)

			function onRotationChange () {

				quaternion.setFromEuler(rotation, false)

			}

			function onQuaternionChange () {

				rotation.setFromQuaternion(quaternion, undefined, false)

			}

			rotation._onChange(onRotationChange)
			quaternion._onChange(onQuaternionChange)

			Object.defineProperties(this, {
				position: {
					configurable: true,
					enumerable: true,
					value: position
				},
				rotation: {
					configurable: true,
					enumerable: true,
					value: rotation
				},
				quaternion: {
					configurable: true,
					enumerable: true,
					value: quaternion
				},
				scale: {
					configurable: true,
					enumerable: true,
					value: scale
				},
				modelViewMatrix: {
					value: new Matrix4()
				},
				normalMatrix: {
					value: new Matrix3()
				}
			})

			this.matrix = new Matrix4()
			this.matrixWorld = new Matrix4()

			this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate
			this.matrixWorldNeedsUpdate = false

			this.layers = new Layers()
			this.visible = true

			this.castShadow = false
			this.receiveShadow = false

			this.frustumCulled = true
			this.renderOrder = 0

			this.animations = []

			this.userData = {}

		}

		onBeforeRender () { }
		onAfterRender () { }

		applyMatrix4 (matrix) {

			if (this.matrixAutoUpdate) this.updateMatrix()

			this.matrix.premultiply(matrix)

			this.matrix.decompose(this.position, this.quaternion, this.scale)

		}

		applyQuaternion (q) {

			this.quaternion.premultiply(q)

			return this

		}

		setRotationFromAxisAngle (axis, angle) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle(axis, angle)

		}

		setRotationFromEuler (euler) {

			this.quaternion.setFromEuler(euler, true)

		}

		setRotationFromMatrix (m) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix(m)

		}

		setRotationFromQuaternion (q) {

			// assumes q is normalized

			this.quaternion.copy(q)

		}

		rotateOnAxis (axis, angle) {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			_q1.setFromAxisAngle(axis, angle)

			this.quaternion.multiply(_q1)

			return this

		}

		rotateOnWorldAxis (axis, angle) {

			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent

			_q1.setFromAxisAngle(axis, angle)

			this.quaternion.premultiply(_q1)

			return this

		}

		rotateX (angle) {

			return this.rotateOnAxis(_xAxis, angle)

		}

		rotateY (angle) {

			return this.rotateOnAxis(_yAxis, angle)

		}

		rotateZ (angle) {

			return this.rotateOnAxis(_zAxis, angle)

		}

		translateOnAxis (axis, distance) {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			_v1$4.copy(axis).applyQuaternion(this.quaternion)

			this.position.add(_v1$4.multiplyScalar(distance))

			return this

		}

		translateX (distance) {

			return this.translateOnAxis(_xAxis, distance)

		}

		translateY (distance) {

			return this.translateOnAxis(_yAxis, distance)

		}

		translateZ (distance) {

			return this.translateOnAxis(_zAxis, distance)

		}

		localToWorld (vector) {

			return vector.applyMatrix4(this.matrixWorld)

		}

		worldToLocal (vector) {

			return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert())

		}

		lookAt (x, y, z) {

			// This method does not support objects having non-uniformly-scaled parent(s)

			if (x.isVector3) {

				_target.copy(x)

			} else {

				_target.set(x, y, z)

			}

			const parent = this.parent

			this.updateWorldMatrix(true, false)

			_position$3.setFromMatrixPosition(this.matrixWorld)

			if (this.isCamera || this.isLight) {

				_m1$1.lookAt(_position$3, _target, this.up)

			} else {

				_m1$1.lookAt(_target, _position$3, this.up)

			}

			this.quaternion.setFromRotationMatrix(_m1$1)

			if (parent) {

				_m1$1.extractRotation(parent.matrixWorld)
				_q1.setFromRotationMatrix(_m1$1)
				this.quaternion.premultiply(_q1.invert())

			}

		}

		add (object) {

			if (arguments.length > 1) {

				for (let i = 0; i < arguments.length; i++) {

					this.add(arguments[i])

				}

				return this

			}

			if (object === this) {

				console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object)
				return this

			}

			if (object && object.isObject3D) {

				if (object.parent !== null) {

					object.parent.remove(object)

				}

				object.parent = this
				this.children.push(object)

				object.dispatchEvent(_addedEvent)

			} else {

				console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object)

			}

			return this

		}

		remove (object) {

			if (arguments.length > 1) {

				for (let i = 0; i < arguments.length; i++) {

					this.remove(arguments[i])

				}

				return this

			}

			const index = this.children.indexOf(object)

			if (index !== - 1) {

				object.parent = null
				this.children.splice(index, 1)

				object.dispatchEvent(_removedEvent)

			}

			return this

		}

		removeFromParent () {

			const parent = this.parent

			if (parent !== null) {

				parent.remove(this)

			}

			return this

		}

		clear () {

			for (let i = 0; i < this.children.length; i++) {

				const object = this.children[i]

				object.parent = null

				object.dispatchEvent(_removedEvent)

			}

			this.children.length = 0

			return this


		}

		attach (object) {

			// adds object as a child of this, while maintaining the object's world transform

			this.updateWorldMatrix(true, false)

			_m1$1.copy(this.matrixWorld).invert()

			if (object.parent !== null) {

				object.parent.updateWorldMatrix(true, false)

				_m1$1.multiply(object.parent.matrixWorld)

			}

			object.applyMatrix4(_m1$1)

			this.add(object)

			object.updateWorldMatrix(false, true)

			return this

		}

		getObjectById (id) {

			return this.getObjectByProperty('id', id)

		}

		getObjectByName (name) {

			return this.getObjectByProperty('name', name)

		}

		getObjectByProperty (name, value) {

			if (this[name] === value) return this

			for (let i = 0, l = this.children.length; i < l; i++) {

				const child = this.children[i]
				const object = child.getObjectByProperty(name, value)

				if (object !== undefined) {

					return object

				}

			}

			return undefined

		}

		getWorldPosition (target) {

			this.updateWorldMatrix(true, false)

			return target.setFromMatrixPosition(this.matrixWorld)

		}

		getWorldQuaternion (target) {

			this.updateWorldMatrix(true, false)

			this.matrixWorld.decompose(_position$3, target, _scale$2)

			return target

		}

		getWorldScale (target) {

			this.updateWorldMatrix(true, false)

			this.matrixWorld.decompose(_position$3, _quaternion$2, target)

			return target

		}

		getWorldDirection (target) {

			this.updateWorldMatrix(true, false)

			const e = this.matrixWorld.elements

			return target.set(e[8], e[9], e[10]).normalize()

		}

		raycast () { }

		traverse (callback) {

			callback(this)

			const children = this.children

			for (let i = 0, l = children.length; i < l; i++) {

				children[i].traverse(callback)

			}

		}

		traverseVisible (callback) {

			if (this.visible === false) return

			callback(this)

			const children = this.children

			for (let i = 0, l = children.length; i < l; i++) {

				children[i].traverseVisible(callback)

			}

		}

		traverseAncestors (callback) {

			const parent = this.parent

			if (parent !== null) {

				callback(parent)

				parent.traverseAncestors(callback)

			}

		}

		updateMatrix () {

			this.matrix.compose(this.position, this.quaternion, this.scale)

			this.matrixWorldNeedsUpdate = true

		}

		updateMatrixWorld (force) {

			if (this.matrixAutoUpdate) this.updateMatrix()

			if (this.matrixWorldNeedsUpdate || force) {

				if (this.parent === null) {

					this.matrixWorld.copy(this.matrix)

				} else {

					this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)

				}

				this.matrixWorldNeedsUpdate = false

				force = true

			}

			// update children

			const children = this.children

			for (let i = 0, l = children.length; i < l; i++) {

				children[i].updateMatrixWorld(force)

			}

		}

		updateWorldMatrix (updateParents, updateChildren) {

			const parent = this.parent

			if (updateParents === true && parent !== null) {

				parent.updateWorldMatrix(true, false)

			}

			if (this.matrixAutoUpdate) this.updateMatrix()

			if (this.parent === null) {

				this.matrixWorld.copy(this.matrix)

			} else {

				this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)

			}

			// update children

			if (updateChildren === true) {

				const children = this.children

				for (let i = 0, l = children.length; i < l; i++) {

					children[i].updateWorldMatrix(false, true)

				}

			}

		}

		toJSON (meta) {

			// meta is a string when called from JSON.stringify
			const isRootObject = (meta === undefined || typeof meta === 'string')

			const output = {}

			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if (isRootObject) {

				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {},
					skeletons: {},
					animations: {}
				}

				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON'
				}

			}

			// standard Object3D serialization

			const object = {}

			object.uuid = this.uuid
			object.type = this.type

			if (this.name !== '') object.name = this.name
			if (this.castShadow === true) object.castShadow = true
			if (this.receiveShadow === true) object.receiveShadow = true
			if (this.visible === false) object.visible = false
			if (this.frustumCulled === false) object.frustumCulled = false
			if (this.renderOrder !== 0) object.renderOrder = this.renderOrder
			if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData

			object.layers = this.layers.mask
			object.matrix = this.matrix.toArray()

			if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false

			// object specific properties

			if (this.isInstancedMesh) {

				object.type = 'InstancedMesh'
				object.count = this.count
				object.instanceMatrix = this.instanceMatrix.toJSON()
				if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON()

			}

			//

			function serialize (library, element) {

				if (library[element.uuid] === undefined) {

					library[element.uuid] = element.toJSON(meta)

				}

				return element.uuid

			}

			if (this.isScene) {

				if (this.background) {

					if (this.background.isColor) {

						object.background = this.background.toJSON()

					} else if (this.background.isTexture) {

						object.background = this.background.toJSON(meta).uuid

					}

				}

				if (this.environment && this.environment.isTexture) {

					object.environment = this.environment.toJSON(meta).uuid

				}

			} else if (this.isMesh || this.isLine || this.isPoints) {

				object.geometry = serialize(meta.geometries, this.geometry)

				const parameters = this.geometry.parameters

				if (parameters !== undefined && parameters.shapes !== undefined) {

					const shapes = parameters.shapes

					if (Array.isArray(shapes)) {

						for (let i = 0, l = shapes.length; i < l; i++) {

							const shape = shapes[i]

							serialize(meta.shapes, shape)

						}

					} else {

						serialize(meta.shapes, shapes)

					}

				}

			}

			if (this.isSkinnedMesh) {

				object.bindMode = this.bindMode
				object.bindMatrix = this.bindMatrix.toArray()

				if (this.skeleton !== undefined) {

					serialize(meta.skeletons, this.skeleton)

					object.skeleton = this.skeleton.uuid

				}

			}

			if (this.material !== undefined) {

				if (Array.isArray(this.material)) {

					const uuids = []

					for (let i = 0, l = this.material.length; i < l; i++) {

						uuids.push(serialize(meta.materials, this.material[i]))

					}

					object.material = uuids

				} else {

					object.material = serialize(meta.materials, this.material)

				}

			}

			//

			if (this.children.length > 0) {

				object.children = []

				for (let i = 0; i < this.children.length; i++) {

					object.children.push(this.children[i].toJSON(meta).object)

				}

			}

			//

			if (this.animations.length > 0) {

				object.animations = []

				for (let i = 0; i < this.animations.length; i++) {

					const animation = this.animations[i]

					object.animations.push(serialize(meta.animations, animation))

				}

			}

			if (isRootObject) {

				const geometries = extractFromCache(meta.geometries)
				const materials = extractFromCache(meta.materials)
				const textures = extractFromCache(meta.textures)
				const images = extractFromCache(meta.images)
				const shapes = extractFromCache(meta.shapes)
				const skeletons = extractFromCache(meta.skeletons)
				const animations = extractFromCache(meta.animations)

				if (geometries.length > 0) output.geometries = geometries
				if (materials.length > 0) output.materials = materials
				if (textures.length > 0) output.textures = textures
				if (images.length > 0) output.images = images
				if (shapes.length > 0) output.shapes = shapes
				if (skeletons.length > 0) output.skeletons = skeletons
				if (animations.length > 0) output.animations = animations

			}

			output.object = object

			return output

			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache (cache) {

				const values = []
				for (const key in cache) {

					const data = cache[key]
					delete data.metadata
					values.push(data)

				}

				return values

			}

		}

		clone (recursive) {

			return new this.constructor().copy(this, recursive)

		}

		copy (source, recursive = true) {

			this.name = source.name

			this.up.copy(source.up)

			this.position.copy(source.position)
			this.rotation.order = source.rotation.order
			this.quaternion.copy(source.quaternion)
			this.scale.copy(source.scale)

			this.matrix.copy(source.matrix)
			this.matrixWorld.copy(source.matrixWorld)

			this.matrixAutoUpdate = source.matrixAutoUpdate
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate

			this.layers.mask = source.layers.mask
			this.visible = source.visible

			this.castShadow = source.castShadow
			this.receiveShadow = source.receiveShadow

			this.frustumCulled = source.frustumCulled
			this.renderOrder = source.renderOrder

			this.userData = JSON.parse(JSON.stringify(source.userData))

			if (recursive === true) {

				for (let i = 0; i < source.children.length; i++) {

					const child = source.children[i]
					this.add(child.clone())

				}

			}

			return this

		}

	}

	Object3D.DefaultUp = new Vector3(0, 1, 0)
	Object3D.DefaultMatrixAutoUpdate = true

	Object3D.prototype.isObject3D = true

	const _v0$1 = /*@__PURE__*/ new Vector3()
	const _v1$3 = /*@__PURE__*/ new Vector3()
	const _v2$2 = /*@__PURE__*/ new Vector3()
	const _v3$1 = /*@__PURE__*/ new Vector3()

	const _vab = /*@__PURE__*/ new Vector3()
	const _vac = /*@__PURE__*/ new Vector3()
	const _vbc = /*@__PURE__*/ new Vector3()
	const _vap = /*@__PURE__*/ new Vector3()
	const _vbp = /*@__PURE__*/ new Vector3()
	const _vcp = /*@__PURE__*/ new Vector3()

	class Triangle {

		constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {

			this.a = a
			this.b = b
			this.c = c

		}

		static getNormal (a, b, c, target) {

			target.subVectors(c, b)
			_v0$1.subVectors(a, b)
			target.cross(_v0$1)

			const targetLengthSq = target.lengthSq()
			if (targetLengthSq > 0) {

				return target.multiplyScalar(1 / Math.sqrt(targetLengthSq))

			}

			return target.set(0, 0, 0)

		}

		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		static getBarycoord (point, a, b, c, target) {

			_v0$1.subVectors(c, a)
			_v1$3.subVectors(b, a)
			_v2$2.subVectors(point, a)

			const dot00 = _v0$1.dot(_v0$1)
			const dot01 = _v0$1.dot(_v1$3)
			const dot02 = _v0$1.dot(_v2$2)
			const dot11 = _v1$3.dot(_v1$3)
			const dot12 = _v1$3.dot(_v2$2)

			const denom = (dot00 * dot11 - dot01 * dot01)

			// collinear or singular triangle
			if (denom === 0) {

				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return target.set(- 2, - 1, - 1)

			}

			const invDenom = 1 / denom
			const u = (dot11 * dot02 - dot01 * dot12) * invDenom
			const v = (dot00 * dot12 - dot01 * dot02) * invDenom

			// barycentric coordinates must always sum to 1
			return target.set(1 - u - v, v, u)

		}

		static containsPoint (point, a, b, c) {

			this.getBarycoord(point, a, b, c, _v3$1)

			return (_v3$1.x >= 0) && (_v3$1.y >= 0) && ((_v3$1.x + _v3$1.y) <= 1)

		}

		static getUV (point, p1, p2, p3, uv1, uv2, uv3, target) {

			this.getBarycoord(point, p1, p2, p3, _v3$1)

			target.set(0, 0)
			target.addScaledVector(uv1, _v3$1.x)
			target.addScaledVector(uv2, _v3$1.y)
			target.addScaledVector(uv3, _v3$1.z)

			return target

		}

		static isFrontFacing (a, b, c, direction) {

			_v0$1.subVectors(c, b)
			_v1$3.subVectors(a, b)

			// strictly front facing
			return (_v0$1.cross(_v1$3).dot(direction) < 0) ? true : false

		}

		set (a, b, c) {

			this.a.copy(a)
			this.b.copy(b)
			this.c.copy(c)

			return this

		}

		setFromPointsAndIndices (points, i0, i1, i2) {

			this.a.copy(points[i0])
			this.b.copy(points[i1])
			this.c.copy(points[i2])

			return this

		}

		clone () {

			return new this.constructor().copy(this)

		}

		copy (triangle) {

			this.a.copy(triangle.a)
			this.b.copy(triangle.b)
			this.c.copy(triangle.c)

			return this

		}

		getArea () {

			_v0$1.subVectors(this.c, this.b)
			_v1$3.subVectors(this.a, this.b)

			return _v0$1.cross(_v1$3).length() * 0.5

		}

		getMidpoint (target) {

			return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)

		}

		getNormal (target) {

			return Triangle.getNormal(this.a, this.b, this.c, target)

		}

		getPlane (target) {

			return target.setFromCoplanarPoints(this.a, this.b, this.c)

		}

		getBarycoord (point, target) {

			return Triangle.getBarycoord(point, this.a, this.b, this.c, target)

		}

		getUV (point, uv1, uv2, uv3, target) {

			return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target)

		}

		containsPoint (point) {

			return Triangle.containsPoint(point, this.a, this.b, this.c)

		}

		isFrontFacing (direction) {

			return Triangle.isFrontFacing(this.a, this.b, this.c, direction)

		}

		intersectsBox (box) {

			return box.intersectsTriangle(this)

		}

		closestPointToPoint (p, target) {

			const a = this.a, b = this.b, c = this.c
			let v, w

			// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
			// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
			// under the accompanying license; see chapter 5.1.5 for detailed explanation.
			// basically, we're distinguishing which of the voronoi regions of the triangle
			// the point lies in with the minimum amount of redundant computation.

			_vab.subVectors(b, a)
			_vac.subVectors(c, a)
			_vap.subVectors(p, a)
			const d1 = _vab.dot(_vap)
			const d2 = _vac.dot(_vap)
			if (d1 <= 0 && d2 <= 0) {

				// vertex region of A; barycentric coords (1, 0, 0)
				return target.copy(a)

			}

			_vbp.subVectors(p, b)
			const d3 = _vab.dot(_vbp)
			const d4 = _vac.dot(_vbp)
			if (d3 >= 0 && d4 <= d3) {

				// vertex region of B; barycentric coords (0, 1, 0)
				return target.copy(b)

			}

			const vc = d1 * d4 - d3 * d2
			if (vc <= 0 && d1 >= 0 && d3 <= 0) {

				v = d1 / (d1 - d3)
				// edge region of AB; barycentric coords (1-v, v, 0)
				return target.copy(a).addScaledVector(_vab, v)

			}

			_vcp.subVectors(p, c)
			const d5 = _vab.dot(_vcp)
			const d6 = _vac.dot(_vcp)
			if (d6 >= 0 && d5 <= d6) {

				// vertex region of C; barycentric coords (0, 0, 1)
				return target.copy(c)

			}

			const vb = d5 * d2 - d1 * d6
			if (vb <= 0 && d2 >= 0 && d6 <= 0) {

				w = d2 / (d2 - d6)
				// edge region of AC; barycentric coords (1-w, 0, w)
				return target.copy(a).addScaledVector(_vac, w)

			}

			const va = d3 * d6 - d5 * d4
			if (va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0) {

				_vbc.subVectors(c, b)
				w = (d4 - d3) / ((d4 - d3) + (d5 - d6))
				// edge region of BC; barycentric coords (0, 1-w, w)
				return target.copy(b).addScaledVector(_vbc, w) // edge region of BC

			}

			// face region
			const denom = 1 / (va + vb + vc)
			// u = va * denom
			v = vb * denom
			w = vc * denom

			return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w)

		}

		equals (triangle) {

			return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c)

		}

	}

	let materialId = 0

	class Material extends EventDispatcher {

		constructor() {

			super()

			Object.defineProperty(this, 'id', { value: materialId++ })

			this.uuid = generateUUID()

			this.name = ''
			this.type = 'Material'

			this.fog = true

			this.blending = NormalBlending
			this.side = FrontSide
			this.vertexColors = false

			this.opacity = 1
			this.transparent = false

			this.blendSrc = SrcAlphaFactor
			this.blendDst = OneMinusSrcAlphaFactor
			this.blendEquation = AddEquation
			this.blendSrcAlpha = null
			this.blendDstAlpha = null
			this.blendEquationAlpha = null

			this.depthFunc = LessEqualDepth
			this.depthTest = true
			this.depthWrite = true

			this.stencilWriteMask = 0xff
			this.stencilFunc = AlwaysStencilFunc
			this.stencilRef = 0
			this.stencilFuncMask = 0xff
			this.stencilFail = KeepStencilOp
			this.stencilZFail = KeepStencilOp
			this.stencilZPass = KeepStencilOp
			this.stencilWrite = false

			this.clippingPlanes = null
			this.clipIntersection = false
			this.clipShadows = false

			this.shadowSide = null

			this.colorWrite = true

			this.precision = null // override the renderer's default precision for this material

			this.polygonOffset = false
			this.polygonOffsetFactor = 0
			this.polygonOffsetUnits = 0

			this.dithering = false

			this.alphaTest = 0
			this.alphaToCoverage = false
			this.premultipliedAlpha = false

			this.visible = true

			this.toneMapped = true

			this.userData = {}

			this.version = 0

		}

		onBuild ( /* shaderobject, renderer */) { }

		onBeforeCompile ( /* shaderobject, renderer */) { }

		customProgramCacheKey () {

			return this.onBeforeCompile.toString()

		}

		setValues (values) {

			if (values === undefined) return

			for (const key in values) {

				const newValue = values[key]

				if (newValue === undefined) {

					console.warn('THREE.Material: \'' + key + '\' parameter is undefined.')
					continue

				}

				// for backward compatability if shading is set in the constructor
				if (key === 'shading') {

					console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.')
					this.flatShading = (newValue === FlatShading) ? true : false
					continue

				}

				const currentValue = this[key]

				if (currentValue === undefined) {

					console.warn('THREE.' + this.type + ': \'' + key + '\' is not a property of this material.')
					continue

				}

				if (currentValue && currentValue.isColor) {

					currentValue.set(newValue)

				} else if ((currentValue && currentValue.isVector3) && (newValue && newValue.isVector3)) {

					currentValue.copy(newValue)

				} else {

					this[key] = newValue

				}

			}

		}

		toJSON (meta) {

			const isRoot = (meta === undefined || typeof meta === 'string')

			if (isRoot) {

				meta = {
					textures: {},
					images: {}
				}

			}

			const data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			}

			// standard Material serialization
			data.uuid = this.uuid
			data.type = this.type

			if (this.name !== '') data.name = this.name

			if (this.color && this.color.isColor) data.color = this.color.getHex()

			if (this.roughness !== undefined) data.roughness = this.roughness
			if (this.metalness !== undefined) data.metalness = this.metalness

			if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex()
			if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex()
			if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity

			if (this.specular && this.specular.isColor) data.specular = this.specular.getHex()
			if (this.specularIntensity !== undefined) data.specularIntensity = this.specularIntensity
			if (this.specularTint && this.specularTint.isColor) data.specularTint = this.specularTint.getHex()
			if (this.shininess !== undefined) data.shininess = this.shininess
			if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat
			if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness

			if (this.clearcoatMap && this.clearcoatMap.isTexture) {

				data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid

			}

			if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {

				data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid

			}

			if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {

				data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid
				data.clearcoatNormalScale = this.clearcoatNormalScale.toArray()

			}

			if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid
			if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid
			if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid

			if (this.lightMap && this.lightMap.isTexture) {

				data.lightMap = this.lightMap.toJSON(meta).uuid
				data.lightMapIntensity = this.lightMapIntensity

			}

			if (this.aoMap && this.aoMap.isTexture) {

				data.aoMap = this.aoMap.toJSON(meta).uuid
				data.aoMapIntensity = this.aoMapIntensity

			}

			if (this.bumpMap && this.bumpMap.isTexture) {

				data.bumpMap = this.bumpMap.toJSON(meta).uuid
				data.bumpScale = this.bumpScale

			}

			if (this.normalMap && this.normalMap.isTexture) {

				data.normalMap = this.normalMap.toJSON(meta).uuid
				data.normalMapType = this.normalMapType
				data.normalScale = this.normalScale.toArray()

			}

			if (this.displacementMap && this.displacementMap.isTexture) {

				data.displacementMap = this.displacementMap.toJSON(meta).uuid
				data.displacementScale = this.displacementScale
				data.displacementBias = this.displacementBias

			}

			if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid
			if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid

			if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid
			if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid
			if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid
			if (this.specularTintMap && this.specularTintMap.isTexture) data.specularTintMap = this.specularTintMap.toJSON(meta).uuid

			if (this.envMap && this.envMap.isTexture) {

				data.envMap = this.envMap.toJSON(meta).uuid

				if (this.combine !== undefined) data.combine = this.combine

			}

			if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity
			if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity
			if (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio

			if (this.gradientMap && this.gradientMap.isTexture) {

				data.gradientMap = this.gradientMap.toJSON(meta).uuid

			}

			if (this.transmission !== undefined) data.transmission = this.transmission
			if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid
			if (this.thickness !== undefined) data.thickness = this.thickness
			if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid
			if (this.attenuationDistance !== undefined) data.attenuationDistance = this.attenuationDistance
			if (this.attenuationTint !== undefined) data.attenuationTint = this.attenuationTint.getHex()

			if (this.size !== undefined) data.size = this.size
			if (this.shadowSide !== null) data.shadowSide = this.shadowSide
			if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation

			if (this.blending !== NormalBlending) data.blending = this.blending
			if (this.side !== FrontSide) data.side = this.side
			if (this.vertexColors) data.vertexColors = true

			if (this.opacity < 1) data.opacity = this.opacity
			if (this.transparent === true) data.transparent = this.transparent

			data.depthFunc = this.depthFunc
			data.depthTest = this.depthTest
			data.depthWrite = this.depthWrite
			data.colorWrite = this.colorWrite

			data.stencilWrite = this.stencilWrite
			data.stencilWriteMask = this.stencilWriteMask
			data.stencilFunc = this.stencilFunc
			data.stencilRef = this.stencilRef
			data.stencilFuncMask = this.stencilFuncMask
			data.stencilFail = this.stencilFail
			data.stencilZFail = this.stencilZFail
			data.stencilZPass = this.stencilZPass

			// rotation (SpriteMaterial)
			if (this.rotation && this.rotation !== 0) data.rotation = this.rotation

			if (this.polygonOffset === true) data.polygonOffset = true
			if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor
			if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits

			if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth
			if (this.dashSize !== undefined) data.dashSize = this.dashSize
			if (this.gapSize !== undefined) data.gapSize = this.gapSize
			if (this.scale !== undefined) data.scale = this.scale

			if (this.dithering === true) data.dithering = true

			if (this.alphaTest > 0) data.alphaTest = this.alphaTest
			if (this.alphaToCoverage === true) data.alphaToCoverage = this.alphaToCoverage
			if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha

			if (this.wireframe === true) data.wireframe = this.wireframe
			if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth
			if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap
			if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin

			if (this.flatShading === true) data.flatShading = this.flatShading

			if (this.visible === false) data.visible = false

			if (this.toneMapped === false) data.toneMapped = false

			if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData

			// TODO: Copied from Object3D.toJSON

			function extractFromCache (cache) {

				const values = []

				for (const key in cache) {

					const data = cache[key]
					delete data.metadata
					values.push(data)

				}

				return values

			}

			if (isRoot) {

				const textures = extractFromCache(meta.textures)
				const images = extractFromCache(meta.images)

				if (textures.length > 0) data.textures = textures
				if (images.length > 0) data.images = images

			}

			return data

		}

		clone () {

			return new this.constructor().copy(this)

		}

		copy (source) {

			this.name = source.name

			this.fog = source.fog

			this.blending = source.blending
			this.side = source.side
			this.vertexColors = source.vertexColors

			this.opacity = source.opacity
			this.transparent = source.transparent

			this.blendSrc = source.blendSrc
			this.blendDst = source.blendDst
			this.blendEquation = source.blendEquation
			this.blendSrcAlpha = source.blendSrcAlpha
			this.blendDstAlpha = source.blendDstAlpha
			this.blendEquationAlpha = source.blendEquationAlpha

			this.depthFunc = source.depthFunc
			this.depthTest = source.depthTest
			this.depthWrite = source.depthWrite

			this.stencilWriteMask = source.stencilWriteMask
			this.stencilFunc = source.stencilFunc
			this.stencilRef = source.stencilRef
			this.stencilFuncMask = source.stencilFuncMask
			this.stencilFail = source.stencilFail
			this.stencilZFail = source.stencilZFail
			this.stencilZPass = source.stencilZPass
			this.stencilWrite = source.stencilWrite

			const srcPlanes = source.clippingPlanes
			let dstPlanes = null

			if (srcPlanes !== null) {

				const n = srcPlanes.length
				dstPlanes = new Array(n)

				for (let i = 0; i !== n; ++i) {

					dstPlanes[i] = srcPlanes[i].clone()

				}

			}

			this.clippingPlanes = dstPlanes
			this.clipIntersection = source.clipIntersection
			this.clipShadows = source.clipShadows

			this.shadowSide = source.shadowSide

			this.colorWrite = source.colorWrite

			this.precision = source.precision

			this.polygonOffset = source.polygonOffset
			this.polygonOffsetFactor = source.polygonOffsetFactor
			this.polygonOffsetUnits = source.polygonOffsetUnits

			this.dithering = source.dithering

			this.alphaTest = source.alphaTest
			this.alphaToCoverage = source.alphaToCoverage
			this.premultipliedAlpha = source.premultipliedAlpha

			this.visible = source.visible

			this.toneMapped = source.toneMapped

			this.userData = JSON.parse(JSON.stringify(source.userData))

			return this

		}

		dispose () {

			this.dispatchEvent({ type: 'dispose' })

		}

		set needsUpdate (value) {

			if (value === true) this.version++

		}

	}

	Material.prototype.isMaterial = true

	const _colorKeywords = {
		'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32
	}

	const _hslA = { h: 0, s: 0, l: 0 }
	const _hslB = { h: 0, s: 0, l: 0 }

	function hue2rgb (p, q, t) {

		if (t < 0) t += 1
		if (t > 1) t -= 1
		if (t < 1 / 6) return p + (q - p) * 6 * t
		if (t < 1 / 2) return q
		if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t)
		return p

	}

	function SRGBToLinear (c) {

		return (c < 0.04045) ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4)

	}

	function LinearToSRGB (c) {

		return (c < 0.0031308) ? c * 12.92 : 1.055 * (Math.pow(c, 0.41666)) - 0.055

	}

	class Color {

		constructor(r, g, b) {

			if (g === undefined && b === undefined) {

				// r is THREE.Color, hex or string
				return this.set(r)

			}

			return this.setRGB(r, g, b)

		}

		set (value) {

			if (value && value.isColor) {

				this.copy(value)

			} else if (typeof value === 'number') {

				this.setHex(value)

			} else if (typeof value === 'string') {

				this.setStyle(value)

			}

			return this

		}

		setScalar (scalar) {

			this.r = scalar
			this.g = scalar
			this.b = scalar

			return this

		}

		setHex (hex) {

			hex = Math.floor(hex)

			this.r = (hex >> 16 & 255) / 255
			this.g = (hex >> 8 & 255) / 255
			this.b = (hex & 255) / 255

			return this

		}

		setRGB (r, g, b) {

			this.r = r
			this.g = g
			this.b = b

			return this

		}

		setHSL (h, s, l) {

			// h,s,l ranges are in 0.0 - 1.0
			h = euclideanModulo(h, 1)
			s = clamp(s, 0, 1)
			l = clamp(l, 0, 1)

			if (s === 0) {

				this.r = this.g = this.b = l

			} else {

				const p = l <= 0.5 ? l * (1 + s) : l + s - (l * s)
				const q = (2 * l) - p

				this.r = hue2rgb(q, p, h + 1 / 3)
				this.g = hue2rgb(q, p, h)
				this.b = hue2rgb(q, p, h - 1 / 3)

			}

			return this

		}

		setStyle (style) {

			function handleAlpha (string) {

				if (string === undefined) return

				if (parseFloat(string) < 1) {

					console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.')

				}

			}


			let m

			if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {

				// rgb / hsl

				let color
				const name = m[1]
				const components = m[2]

				switch (name) {

					case 'rgb':
					case 'rgba':

						if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {

							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min(255, parseInt(color[1], 10)) / 255
							this.g = Math.min(255, parseInt(color[2], 10)) / 255
							this.b = Math.min(255, parseInt(color[3], 10)) / 255

							handleAlpha(color[4])

							return this

						}

						if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {

							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min(100, parseInt(color[1], 10)) / 100
							this.g = Math.min(100, parseInt(color[2], 10)) / 100
							this.b = Math.min(100, parseInt(color[3], 10)) / 100

							handleAlpha(color[4])

							return this

						}

						break

					case 'hsl':
					case 'hsla':

						if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {

							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							const h = parseFloat(color[1]) / 360
							const s = parseInt(color[2], 10) / 100
							const l = parseInt(color[3], 10) / 100

							handleAlpha(color[4])

							return this.setHSL(h, s, l)

						}

						break

				}

			} else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {

				// hex color

				const hex = m[1]
				const size = hex.length

				if (size === 3) {

					// #ff0
					this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255
					this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255
					this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255

					return this

				} else if (size === 6) {

					// #ff0000
					this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255
					this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255
					this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255

					return this

				}

			}

			if (style && style.length > 0) {

				return this.setColorName(style)

			}

			return this

		}

		setColorName (style) {

			// color keywords
			const hex = _colorKeywords[style.toLowerCase()]

			if (hex !== undefined) {

				// red
				this.setHex(hex)

			} else {

				// unknown color
				console.warn('THREE.Color: Unknown color ' + style)

			}

			return this

		}

		clone () {

			return new this.constructor(this.r, this.g, this.b)

		}

		copy (color) {

			this.r = color.r
			this.g = color.g
			this.b = color.b

			return this

		}

		copyGammaToLinear (color, gammaFactor = 2.0) {

			this.r = Math.pow(color.r, gammaFactor)
			this.g = Math.pow(color.g, gammaFactor)
			this.b = Math.pow(color.b, gammaFactor)

			return this

		}

		copyLinearToGamma (color, gammaFactor = 2.0) {

			const safeInverse = (gammaFactor > 0) ? (1.0 / gammaFactor) : 1.0

			this.r = Math.pow(color.r, safeInverse)
			this.g = Math.pow(color.g, safeInverse)
			this.b = Math.pow(color.b, safeInverse)

			return this

		}

		convertGammaToLinear (gammaFactor) {

			this.copyGammaToLinear(this, gammaFactor)

			return this

		}

		convertLinearToGamma (gammaFactor) {

			this.copyLinearToGamma(this, gammaFactor)

			return this

		}

		copySRGBToLinear (color) {

			this.r = SRGBToLinear(color.r)
			this.g = SRGBToLinear(color.g)
			this.b = SRGBToLinear(color.b)

			return this

		}

		copyLinearToSRGB (color) {

			this.r = LinearToSRGB(color.r)
			this.g = LinearToSRGB(color.g)
			this.b = LinearToSRGB(color.b)

			return this

		}

		convertSRGBToLinear () {

			this.copySRGBToLinear(this)

			return this

		}

		convertLinearToSRGB () {

			this.copyLinearToSRGB(this)

			return this

		}

		getHex () {

			return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0

		}

		getHexString () {

			return ('000000' + this.getHex().toString(16)).slice(- 6)

		}

		getHSL (target) {

			// h,s,l ranges are in 0.0 - 1.0

			const r = this.r, g = this.g, b = this.b

			const max = Math.max(r, g, b)
			const min = Math.min(r, g, b)

			let hue, saturation
			const lightness = (min + max) / 2.0

			if (min === max) {

				hue = 0
				saturation = 0

			} else {

				const delta = max - min

				saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min)

				switch (max) {

					case r: hue = (g - b) / delta + (g < b ? 6 : 0); break
					case g: hue = (b - r) / delta + 2; break
					case b: hue = (r - g) / delta + 4; break

				}

				hue /= 6

			}

			target.h = hue
			target.s = saturation
			target.l = lightness

			return target

		}

		getStyle () {

			return 'rgb(' + ((this.r * 255) | 0) + ',' + ((this.g * 255) | 0) + ',' + ((this.b * 255) | 0) + ')'

		}

		offsetHSL (h, s, l) {

			this.getHSL(_hslA)

			_hslA.h += h; _hslA.s += s; _hslA.l += l

			this.setHSL(_hslA.h, _hslA.s, _hslA.l)

			return this

		}

		add (color) {

			this.r += color.r
			this.g += color.g
			this.b += color.b

			return this

		}

		addColors (color1, color2) {

			this.r = color1.r + color2.r
			this.g = color1.g + color2.g
			this.b = color1.b + color2.b

			return this

		}

		addScalar (s) {

			this.r += s
			this.g += s
			this.b += s

			return this

		}

		sub (color) {

			this.r = Math.max(0, this.r - color.r)
			this.g = Math.max(0, this.g - color.g)
			this.b = Math.max(0, this.b - color.b)

			return this

		}

		multiply (color) {

			this.r *= color.r
			this.g *= color.g
			this.b *= color.b

			return this

		}

		multiplyScalar (s) {

			this.r *= s
			this.g *= s
			this.b *= s

			return this

		}

		lerp (color, alpha) {

			this.r += (color.r - this.r) * alpha
			this.g += (color.g - this.g) * alpha
			this.b += (color.b - this.b) * alpha

			return this

		}

		lerpColors (color1, color2, alpha) {

			this.r = color1.r + (color2.r - color1.r) * alpha
			this.g = color1.g + (color2.g - color1.g) * alpha
			this.b = color1.b + (color2.b - color1.b) * alpha

			return this

		}

		lerpHSL (color, alpha) {

			this.getHSL(_hslA)
			color.getHSL(_hslB)

			const h = lerp(_hslA.h, _hslB.h, alpha)
			const s = lerp(_hslA.s, _hslB.s, alpha)
			const l = lerp(_hslA.l, _hslB.l, alpha)

			this.setHSL(h, s, l)

			return this

		}

		equals (c) {

			return (c.r === this.r) && (c.g === this.g) && (c.b === this.b)

		}

		fromArray (array, offset = 0) {

			this.r = array[offset]
			this.g = array[offset + 1]
			this.b = array[offset + 2]

			return this

		}

		toArray (array = [], offset = 0) {

			array[offset] = this.r
			array[offset + 1] = this.g
			array[offset + 2] = this.b

			return array

		}

		fromBufferAttribute (attribute, index) {

			this.r = attribute.getX(index)
			this.g = attribute.getY(index)
			this.b = attribute.getZ(index)

			if (attribute.normalized === true) {

				// assuming Uint8Array

				this.r /= 255
				this.g /= 255
				this.b /= 255

			}

			return this

		}

		toJSON () {

			return this.getHex()

		}

	}

	Color.NAMES = _colorKeywords

	Color.prototype.isColor = true
	Color.prototype.r = 1
	Color.prototype.g = 1
	Color.prototype.b = 1

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 * }
	 */

	class MeshBasicMaterial extends Material {

		constructor(parameters) {

			super()

			this.type = 'MeshBasicMaterial'

			this.color = new Color(0xffffff) // emissive

			this.map = null

			this.lightMap = null
			this.lightMapIntensity = 1.0

			this.aoMap = null
			this.aoMapIntensity = 1.0

			this.specularMap = null

			this.alphaMap = null

			this.envMap = null
			this.combine = MultiplyOperation
			this.reflectivity = 1
			this.refractionRatio = 0.98

			this.wireframe = false
			this.wireframeLinewidth = 1
			this.wireframeLinecap = 'round'
			this.wireframeLinejoin = 'round'

			this.setValues(parameters)

		}

		copy (source) {

			super.copy(source)

			this.color.copy(source.color)

			this.map = source.map

			this.lightMap = source.lightMap
			this.lightMapIntensity = source.lightMapIntensity

			this.aoMap = source.aoMap
			this.aoMapIntensity = source.aoMapIntensity

			this.specularMap = source.specularMap

			this.alphaMap = source.alphaMap

			this.envMap = source.envMap
			this.combine = source.combine
			this.reflectivity = source.reflectivity
			this.refractionRatio = source.refractionRatio

			this.wireframe = source.wireframe
			this.wireframeLinewidth = source.wireframeLinewidth
			this.wireframeLinecap = source.wireframeLinecap
			this.wireframeLinejoin = source.wireframeLinejoin

			return this

		}

	}

	MeshBasicMaterial.prototype.isMeshBasicMaterial = true

	const _vector$9 = /*@__PURE__*/ new Vector3()
	const _vector2$1 = /*@__PURE__*/ new Vector2()

	class BufferAttribute {

		constructor(array, itemSize, normalized) {

			if (Array.isArray(array)) {

				throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.')

			}

			this.name = ''

			this.array = array
			this.itemSize = itemSize
			this.count = array !== undefined ? array.length / itemSize : 0
			this.normalized = normalized === true

			this.usage = StaticDrawUsage
			this.updateRange = { offset: 0, count: - 1 }

			this.version = 0

		}

		onUploadCallback () { }

		set needsUpdate (value) {

			if (value === true) this.version++

		}

		setUsage (value) {

			this.usage = value

			return this

		}

		copy (source) {

			this.name = source.name
			this.array = new source.array.constructor(source.array)
			this.itemSize = source.itemSize
			this.count = source.count
			this.normalized = source.normalized

			this.usage = source.usage

			return this

		}

		copyAt (index1, attribute, index2) {

			index1 *= this.itemSize
			index2 *= attribute.itemSize

			for (let i = 0, l = this.itemSize; i < l; i++) {

				this.array[index1 + i] = attribute.array[index2 + i]

			}

			return this

		}

		copyArray (array) {

			this.array.set(array)

			return this

		}

		copyColorsArray (colors) {

			const array = this.array
			let offset = 0

			for (let i = 0, l = colors.length; i < l; i++) {

				let color = colors[i]

				if (color === undefined) {

					console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i)
					color = new Color()

				}

				array[offset++] = color.r
				array[offset++] = color.g
				array[offset++] = color.b

			}

			return this

		}

		copyVector2sArray (vectors) {

			const array = this.array
			let offset = 0

			for (let i = 0, l = vectors.length; i < l; i++) {

				let vector = vectors[i]

				if (vector === undefined) {

					console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i)
					vector = new Vector2()

				}

				array[offset++] = vector.x
				array[offset++] = vector.y

			}

			return this

		}

		copyVector3sArray (vectors) {

			const array = this.array
			let offset = 0

			for (let i = 0, l = vectors.length; i < l; i++) {

				let vector = vectors[i]

				if (vector === undefined) {

					console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i)
					vector = new Vector3()

				}

				array[offset++] = vector.x
				array[offset++] = vector.y
				array[offset++] = vector.z

			}

			return this

		}

		copyVector4sArray (vectors) {

			const array = this.array
			let offset = 0

			for (let i = 0, l = vectors.length; i < l; i++) {

				let vector = vectors[i]

				if (vector === undefined) {

					console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i)
					vector = new Vector4()

				}

				array[offset++] = vector.x
				array[offset++] = vector.y
				array[offset++] = vector.z
				array[offset++] = vector.w

			}

			return this

		}

		applyMatrix3 (m) {

			if (this.itemSize === 2) {

				for (let i = 0, l = this.count; i < l; i++) {

					_vector2$1.fromBufferAttribute(this, i)
					_vector2$1.applyMatrix3(m)

					this.setXY(i, _vector2$1.x, _vector2$1.y)

				}

			} else if (this.itemSize === 3) {

				for (let i = 0, l = this.count; i < l; i++) {

					_vector$9.fromBufferAttribute(this, i)
					_vector$9.applyMatrix3(m)

					this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z)

				}

			}

			return this

		}

		applyMatrix4 (m) {

			for (let i = 0, l = this.count; i < l; i++) {

				_vector$9.x = this.getX(i)
				_vector$9.y = this.getY(i)
				_vector$9.z = this.getZ(i)

				_vector$9.applyMatrix4(m)

				this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z)

			}

			return this

		}

		applyNormalMatrix (m) {

			for (let i = 0, l = this.count; i < l; i++) {

				_vector$9.x = this.getX(i)
				_vector$9.y = this.getY(i)
				_vector$9.z = this.getZ(i)

				_vector$9.applyNormalMatrix(m)

				this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z)

			}

			return this

		}

		transformDirection (m) {

			for (let i = 0, l = this.count; i < l; i++) {

				_vector$9.x = this.getX(i)
				_vector$9.y = this.getY(i)
				_vector$9.z = this.getZ(i)

				_vector$9.transformDirection(m)

				this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z)

			}

			return this

		}

		set (value, offset = 0) {

			this.array.set(value, offset)

			return this

		}

		getX (index) {

			return this.array[index * this.itemSize]

		}

		setX (index, x) {

			this.array[index * this.itemSize] = x

			return this

		}

		getY (index) {

			return this.array[index * this.itemSize + 1]

		}

		setY (index, y) {

			this.array[index * this.itemSize + 1] = y

			return this

		}

		getZ (index) {

			return this.array[index * this.itemSize + 2]

		}

		setZ (index, z) {

			this.array[index * this.itemSize + 2] = z

			return this

		}

		getW (index) {

			return this.array[index * this.itemSize + 3]

		}

		setW (index, w) {

			this.array[index * this.itemSize + 3] = w

			return this

		}

		setXY (index, x, y) {

			index *= this.itemSize

			this.array[index + 0] = x
			this.array[index + 1] = y

			return this

		}

		setXYZ (index, x, y, z) {

			index *= this.itemSize

			this.array[index + 0] = x
			this.array[index + 1] = y
			this.array[index + 2] = z

			return this

		}

		setXYZW (index, x, y, z, w) {

			index *= this.itemSize

			this.array[index + 0] = x
			this.array[index + 1] = y
			this.array[index + 2] = z
			this.array[index + 3] = w

			return this

		}

		onUpload (callback) {

			this.onUploadCallback = callback

			return this

		}

		clone () {

			return new this.constructor(this.array, this.itemSize).copy(this)

		}

		toJSON () {

			const data = {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: Array.prototype.slice.call(this.array),
				normalized: this.normalized
			}

			if (this.name !== '') data.name = this.name
			if (this.usage !== StaticDrawUsage) data.usage = this.usage
			if (this.updateRange.offset !== 0 || this.updateRange.count !== - 1) data.updateRange = this.updateRange

			return data

		}

	}

	BufferAttribute.prototype.isBufferAttribute = true

	//

	class Int8BufferAttribute extends BufferAttribute {

		constructor(array, itemSize, normalized) {

			super(new Int8Array(array), itemSize, normalized)

		}

	}

	class Uint8BufferAttribute extends BufferAttribute {

		constructor(array, itemSize, normalized) {

			super(new Uint8Array(array), itemSize, normalized)

		}

	}

	class Uint8ClampedBufferAttribute extends BufferAttribute {

		constructor(array, itemSize, normalized) {

			super(new Uint8ClampedArray(array), itemSize, normalized)

		}

	}

	class Int16BufferAttribute extends BufferAttribute {

		constructor(array, itemSize, normalized) {

			super(new Int16Array(array), itemSize, normalized)

		}

	}

	class Uint16BufferAttribute extends BufferAttribute {

		constructor(array, itemSize, normalized) {

			super(new Uint16Array(array), itemSize, normalized)

		}

	}

	class Int32BufferAttribute extends BufferAttribute {

		constructor(array, itemSize, normalized) {

			super(new Int32Array(array), itemSize, normalized)

		}

	}

	class Uint32BufferAttribute extends BufferAttribute {

		constructor(array, itemSize, normalized) {

			super(new Uint32Array(array), itemSize, normalized)

		}

	}

	class Float16BufferAttribute extends BufferAttribute {

		constructor(array, itemSize, normalized) {

			super(new Uint16Array(array), itemSize, normalized)

		}

	}

	Float16BufferAttribute.prototype.isFloat16BufferAttribute = true

	class Float32BufferAttribute extends BufferAttribute {

		constructor(array, itemSize, normalized) {

			super(new Float32Array(array), itemSize, normalized)

		}

	}

	class Float64BufferAttribute extends BufferAttribute {

		constructor(array, itemSize, normalized) {

			super(new Float64Array(array), itemSize, normalized)

		}

	}

	function arrayMax$1 (array) {

		if (array.length === 0) return - Infinity

		let max = array[0]

		for (let i = 1, l = array.length; i < l; ++i) {

			if (array[i] > max) max = array[i]

		}

		return max

	}

	const TYPED_ARRAYS = {
		Int8Array: Int8Array,
		Uint8Array: Uint8Array,
		Uint8ClampedArray: Uint8ClampedArray,
		Int16Array: Int16Array,
		Uint16Array: Uint16Array,
		Int32Array: Int32Array,
		Uint32Array: Uint32Array,
		Float32Array: Float32Array,
		Float64Array: Float64Array
	}

	function getTypedArray (type, buffer) {

		return new TYPED_ARRAYS[type](buffer)

	}

	let _id = 0

	const _m1 = /*@__PURE__*/ new Matrix4()
	const _obj = /*@__PURE__*/ new Object3D()
	const _offset = /*@__PURE__*/ new Vector3()
	const _box$1$1 = /*@__PURE__*/ new Box3()
	const _boxMorphTargets = /*@__PURE__*/ new Box3()
	const _vector$8 = /*@__PURE__*/ new Vector3()

	class BufferGeometry extends EventDispatcher {

		constructor() {

			super()

			Object.defineProperty(this, 'id', { value: _id++ })

			this.uuid = generateUUID()

			this.name = ''
			this.type = 'BufferGeometry'

			this.index = null
			this.attributes = {}

			this.morphAttributes = {}
			this.morphTargetsRelative = false

			this.groups = []

			this.boundingBox = null
			this.boundingSphere = null

			this.drawRange = { start: 0, count: Infinity }

			this.userData = {}

		}

		getIndex () {

			return this.index

		}

		setIndex (index) {

			if (Array.isArray(index)) {

				this.index = new (arrayMax$1(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1)

			} else {

				this.index = index

			}

			return this

		}

		getAttribute (name) {

			return this.attributes[name]

		}

		setAttribute (name, attribute) {

			this.attributes[name] = attribute

			return this

		}

		deleteAttribute (name) {

			delete this.attributes[name]

			return this

		}

		hasAttribute (name) {

			return this.attributes[name] !== undefined

		}

		addGroup (start, count, materialIndex = 0) {

			this.groups.push({

				start: start,
				count: count,
				materialIndex: materialIndex

			})

		}

		clearGroups () {

			this.groups = []

		}

		setDrawRange (start, count) {

			this.drawRange.start = start
			this.drawRange.count = count

		}

		applyMatrix4 (matrix) {

			const position = this.attributes.position

			if (position !== undefined) {

				position.applyMatrix4(matrix)

				position.needsUpdate = true

			}

			const normal = this.attributes.normal

			if (normal !== undefined) {

				const normalMatrix = new Matrix3().getNormalMatrix(matrix)

				normal.applyNormalMatrix(normalMatrix)

				normal.needsUpdate = true

			}

			const tangent = this.attributes.tangent

			if (tangent !== undefined) {

				tangent.transformDirection(matrix)

				tangent.needsUpdate = true

			}

			if (this.boundingBox !== null) {

				this.computeBoundingBox()

			}

			if (this.boundingSphere !== null) {

				this.computeBoundingSphere()

			}

			return this

		}

		applyQuaternion (q) {

			_m1.makeRotationFromQuaternion(q)

			this.applyMatrix4(_m1)

			return this

		}

		rotateX (angle) {

			// rotate geometry around world x-axis

			_m1.makeRotationX(angle)

			this.applyMatrix4(_m1)

			return this

		}

		rotateY (angle) {

			// rotate geometry around world y-axis

			_m1.makeRotationY(angle)

			this.applyMatrix4(_m1)

			return this

		}

		rotateZ (angle) {

			// rotate geometry around world z-axis

			_m1.makeRotationZ(angle)

			this.applyMatrix4(_m1)

			return this

		}

		translate (x, y, z) {

			// translate geometry

			_m1.makeTranslation(x, y, z)

			this.applyMatrix4(_m1)

			return this

		}

		scale (x, y, z) {

			// scale geometry

			_m1.makeScale(x, y, z)

			this.applyMatrix4(_m1)

			return this

		}

		lookAt (vector) {

			_obj.lookAt(vector)

			_obj.updateMatrix()

			this.applyMatrix4(_obj.matrix)

			return this

		}

		center () {

			this.computeBoundingBox()

			this.boundingBox.getCenter(_offset).negate()

			this.translate(_offset.x, _offset.y, _offset.z)

			return this

		}

		setFromPoints (points) {

			const position = []

			for (let i = 0, l = points.length; i < l; i++) {

				const point = points[i]
				position.push(point.x, point.y, point.z || 0)

			}

			this.setAttribute('position', new Float32BufferAttribute(position, 3))

			return this

		}

		computeBoundingBox () {

			if (this.boundingBox === null) {

				this.boundingBox = new Box3()

			}

			const position = this.attributes.position
			const morphAttributesPosition = this.morphAttributes.position

			if (position && position.isGLBufferAttribute) {

				console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this)

				this.boundingBox.set(
					new Vector3(- Infinity, - Infinity, - Infinity),
					new Vector3(+ Infinity, + Infinity, + Infinity)
				)

				return

			}

			if (position !== undefined) {

				this.boundingBox.setFromBufferAttribute(position)

				// process morph attributes if present

				if (morphAttributesPosition) {

					for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {

						const morphAttribute = morphAttributesPosition[i]
						_box$1$1.setFromBufferAttribute(morphAttribute)

						if (this.morphTargetsRelative) {

							_vector$8.addVectors(this.boundingBox.min, _box$1$1.min)
							this.boundingBox.expandByPoint(_vector$8)

							_vector$8.addVectors(this.boundingBox.max, _box$1$1.max)
							this.boundingBox.expandByPoint(_vector$8)

						} else {

							this.boundingBox.expandByPoint(_box$1$1.min)
							this.boundingBox.expandByPoint(_box$1$1.max)

						}

					}

				}

			} else {

				this.boundingBox.makeEmpty()

			}

			if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {

				console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)

			}

		}

		computeBoundingSphere () {

			if (this.boundingSphere === null) {

				this.boundingSphere = new Sphere()

			}

			const position = this.attributes.position
			const morphAttributesPosition = this.morphAttributes.position

			if (position && position.isGLBufferAttribute) {

				console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this)

				this.boundingSphere.set(new Vector3(), Infinity)

				return

			}

			if (position) {

				// first, find the center of the bounding sphere

				const center = this.boundingSphere.center

				_box$1$1.setFromBufferAttribute(position)

				// process morph attributes if present

				if (morphAttributesPosition) {

					for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {

						const morphAttribute = morphAttributesPosition[i]
						_boxMorphTargets.setFromBufferAttribute(morphAttribute)

						if (this.morphTargetsRelative) {

							_vector$8.addVectors(_box$1$1.min, _boxMorphTargets.min)
							_box$1$1.expandByPoint(_vector$8)

							_vector$8.addVectors(_box$1$1.max, _boxMorphTargets.max)
							_box$1$1.expandByPoint(_vector$8)

						} else {

							_box$1$1.expandByPoint(_boxMorphTargets.min)
							_box$1$1.expandByPoint(_boxMorphTargets.max)

						}

					}

				}

				_box$1$1.getCenter(center)

				// second, try to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

				let maxRadiusSq = 0

				for (let i = 0, il = position.count; i < il; i++) {

					_vector$8.fromBufferAttribute(position, i)

					maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8))

				}

				// process morph attributes if present

				if (morphAttributesPosition) {

					for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {

						const morphAttribute = morphAttributesPosition[i]
						const morphTargetsRelative = this.morphTargetsRelative

						for (let j = 0, jl = morphAttribute.count; j < jl; j++) {

							_vector$8.fromBufferAttribute(morphAttribute, j)

							if (morphTargetsRelative) {

								_offset.fromBufferAttribute(position, j)
								_vector$8.add(_offset)

							}

							maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8))

						}

					}

				}

				this.boundingSphere.radius = Math.sqrt(maxRadiusSq)

				if (isNaN(this.boundingSphere.radius)) {

					console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)

				}

			}

		}

		computeFaceNormals () {

			// backwards compatibility

		}

		computeTangents () {

			const index = this.index
			const attributes = this.attributes

			// based on http://www.terathon.com/code/tangent.html
			// (per vertex tangents)

			if (index === null ||
				attributes.position === undefined ||
				attributes.normal === undefined ||
				attributes.uv === undefined) {

				console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)')
				return

			}

			const indices = index.array
			const positions = attributes.position.array
			const normals = attributes.normal.array
			const uvs = attributes.uv.array

			const nVertices = positions.length / 3

			if (attributes.tangent === undefined) {

				this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4))

			}

			const tangents = attributes.tangent.array

			const tan1 = [], tan2 = []

			for (let i = 0; i < nVertices; i++) {

				tan1[i] = new Vector3()
				tan2[i] = new Vector3()

			}

			const vA = new Vector3(),
				vB = new Vector3(),
				vC = new Vector3(),

				uvA = new Vector2(),
				uvB = new Vector2(),
				uvC = new Vector2(),

				sdir = new Vector3(),
				tdir = new Vector3()

			function handleTriangle (a, b, c) {

				vA.fromArray(positions, a * 3)
				vB.fromArray(positions, b * 3)
				vC.fromArray(positions, c * 3)

				uvA.fromArray(uvs, a * 2)
				uvB.fromArray(uvs, b * 2)
				uvC.fromArray(uvs, c * 2)

				vB.sub(vA)
				vC.sub(vA)

				uvB.sub(uvA)
				uvC.sub(uvA)

				const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y)

				// silently ignore degenerate uv triangles having coincident or colinear vertices

				if (!isFinite(r)) return

				sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, - uvB.y).multiplyScalar(r)
				tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, - uvC.x).multiplyScalar(r)

				tan1[a].add(sdir)
				tan1[b].add(sdir)
				tan1[c].add(sdir)

				tan2[a].add(tdir)
				tan2[b].add(tdir)
				tan2[c].add(tdir)

			}

			let groups = this.groups

			if (groups.length === 0) {

				groups = [{
					start: 0,
					count: indices.length
				}]

			}

			for (let i = 0, il = groups.length; i < il; ++i) {

				const group = groups[i]

				const start = group.start
				const count = group.count

				for (let j = start, jl = start + count; j < jl; j += 3) {

					handleTriangle(
						indices[j + 0],
						indices[j + 1],
						indices[j + 2]
					)

				}

			}

			const tmp = new Vector3(), tmp2 = new Vector3()
			const n = new Vector3(), n2 = new Vector3()

			function handleVertex (v) {

				n.fromArray(normals, v * 3)
				n2.copy(n)

				const t = tan1[v]

				// Gram-Schmidt orthogonalize

				tmp.copy(t)
				tmp.sub(n.multiplyScalar(n.dot(t))).normalize()

				// Calculate handedness

				tmp2.crossVectors(n2, t)
				const test = tmp2.dot(tan2[v])
				const w = (test < 0.0) ? - 1.0 : 1.0

				tangents[v * 4] = tmp.x
				tangents[v * 4 + 1] = tmp.y
				tangents[v * 4 + 2] = tmp.z
				tangents[v * 4 + 3] = w

			}

			for (let i = 0, il = groups.length; i < il; ++i) {

				const group = groups[i]

				const start = group.start
				const count = group.count

				for (let j = start, jl = start + count; j < jl; j += 3) {

					handleVertex(indices[j + 0])
					handleVertex(indices[j + 1])
					handleVertex(indices[j + 2])

				}

			}

		}

		computeVertexNormals () {

			const index = this.index
			const positionAttribute = this.getAttribute('position')

			if (positionAttribute !== undefined) {

				let normalAttribute = this.getAttribute('normal')

				if (normalAttribute === undefined) {

					normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3)
					this.setAttribute('normal', normalAttribute)

				} else {

					// reset existing normals to zero

					for (let i = 0, il = normalAttribute.count; i < il; i++) {

						normalAttribute.setXYZ(i, 0, 0, 0)

					}

				}

				const pA = new Vector3(), pB = new Vector3(), pC = new Vector3()
				const nA = new Vector3(), nB = new Vector3(), nC = new Vector3()
				const cb = new Vector3(), ab = new Vector3()

				// indexed elements

				if (index) {

					for (let i = 0, il = index.count; i < il; i += 3) {

						const vA = index.getX(i + 0)
						const vB = index.getX(i + 1)
						const vC = index.getX(i + 2)

						pA.fromBufferAttribute(positionAttribute, vA)
						pB.fromBufferAttribute(positionAttribute, vB)
						pC.fromBufferAttribute(positionAttribute, vC)

						cb.subVectors(pC, pB)
						ab.subVectors(pA, pB)
						cb.cross(ab)

						nA.fromBufferAttribute(normalAttribute, vA)
						nB.fromBufferAttribute(normalAttribute, vB)
						nC.fromBufferAttribute(normalAttribute, vC)

						nA.add(cb)
						nB.add(cb)
						nC.add(cb)

						normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z)
						normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z)
						normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z)

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for (let i = 0, il = positionAttribute.count; i < il; i += 3) {

						pA.fromBufferAttribute(positionAttribute, i + 0)
						pB.fromBufferAttribute(positionAttribute, i + 1)
						pC.fromBufferAttribute(positionAttribute, i + 2)

						cb.subVectors(pC, pB)
						ab.subVectors(pA, pB)
						cb.cross(ab)

						normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z)
						normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z)
						normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z)

					}

				}

				this.normalizeNormals()

				normalAttribute.needsUpdate = true

			}

		}

		merge (geometry, offset) {

			if (!(geometry && geometry.isBufferGeometry)) {

				console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry)
				return

			}

			if (offset === undefined) {

				offset = 0

				console.warn(
					'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
					+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
				)

			}

			const attributes = this.attributes

			for (const key in attributes) {

				if (geometry.attributes[key] === undefined) continue

				const attribute1 = attributes[key]
				const attributeArray1 = attribute1.array

				const attribute2 = geometry.attributes[key]
				const attributeArray2 = attribute2.array

				const attributeOffset = attribute2.itemSize * offset
				const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset)

				for (let i = 0, j = attributeOffset; i < length; i++, j++) {

					attributeArray1[j] = attributeArray2[i]

				}

			}

			return this

		}

		normalizeNormals () {

			const normals = this.attributes.normal

			for (let i = 0, il = normals.count; i < il; i++) {

				_vector$8.fromBufferAttribute(normals, i)

				_vector$8.normalize()

				normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z)

			}

		}

		toNonIndexed () {

			function convertBufferAttribute (attribute, indices) {

				const array = attribute.array
				const itemSize = attribute.itemSize
				const normalized = attribute.normalized

				const array2 = new array.constructor(indices.length * itemSize)

				let index = 0, index2 = 0

				for (let i = 0, l = indices.length; i < l; i++) {

					if (attribute.isInterleavedBufferAttribute) {

						index = indices[i] * attribute.data.stride + attribute.offset

					} else {

						index = indices[i] * itemSize

					}

					for (let j = 0; j < itemSize; j++) {

						array2[index2++] = array[index++]

					}

				}

				return new BufferAttribute(array2, itemSize, normalized)

			}

			//

			if (this.index === null) {

				console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.')
				return this

			}

			const geometry2 = new BufferGeometry()

			const indices = this.index.array
			const attributes = this.attributes

			// attributes

			for (const name in attributes) {

				const attribute = attributes[name]

				const newAttribute = convertBufferAttribute(attribute, indices)

				geometry2.setAttribute(name, newAttribute)

			}

			// morph attributes

			const morphAttributes = this.morphAttributes

			for (const name in morphAttributes) {

				const morphArray = []
				const morphAttribute = morphAttributes[name] // morphAttribute: array of Float32BufferAttributes

				for (let i = 0, il = morphAttribute.length; i < il; i++) {

					const attribute = morphAttribute[i]

					const newAttribute = convertBufferAttribute(attribute, indices)

					morphArray.push(newAttribute)

				}

				geometry2.morphAttributes[name] = morphArray

			}

			geometry2.morphTargetsRelative = this.morphTargetsRelative

			// groups

			const groups = this.groups

			for (let i = 0, l = groups.length; i < l; i++) {

				const group = groups[i]
				geometry2.addGroup(group.start, group.count, group.materialIndex)

			}

			return geometry2

		}

		toJSON () {

			const data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			}

			// standard BufferGeometry serialization

			data.uuid = this.uuid
			data.type = this.type
			if (this.name !== '') data.name = this.name
			if (Object.keys(this.userData).length > 0) data.userData = this.userData

			if (this.parameters !== undefined) {

				const parameters = this.parameters

				for (const key in parameters) {

					if (parameters[key] !== undefined) data[key] = parameters[key]

				}

				return data

			}

			// for simplicity the code assumes attributes are not shared across geometries, see #15811

			data.data = { attributes: {} }

			const index = this.index

			if (index !== null) {

				data.data.index = {
					type: index.array.constructor.name,
					array: Array.prototype.slice.call(index.array)
				}

			}

			const attributes = this.attributes

			for (const key in attributes) {

				const attribute = attributes[key]

				data.data.attributes[key] = attribute.toJSON(data.data)

			}

			const morphAttributes = {}
			let hasMorphAttributes = false

			for (const key in this.morphAttributes) {

				const attributeArray = this.morphAttributes[key]

				const array = []

				for (let i = 0, il = attributeArray.length; i < il; i++) {

					const attribute = attributeArray[i]

					array.push(attribute.toJSON(data.data))

				}

				if (array.length > 0) {

					morphAttributes[key] = array

					hasMorphAttributes = true

				}

			}

			if (hasMorphAttributes) {

				data.data.morphAttributes = morphAttributes
				data.data.morphTargetsRelative = this.morphTargetsRelative

			}

			const groups = this.groups

			if (groups.length > 0) {

				data.data.groups = JSON.parse(JSON.stringify(groups))

			}

			const boundingSphere = this.boundingSphere

			if (boundingSphere !== null) {

				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				}

			}

			return data

		}

		clone () {

			/*
			 // Handle primitives

			 const parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 const values = [];

			 for ( const key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 const geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */

			return new BufferGeometry().copy(this)

		}

		copy (source) {

			// reset

			this.index = null
			this.attributes = {}
			this.morphAttributes = {}
			this.groups = []
			this.boundingBox = null
			this.boundingSphere = null

			// used for storing cloned, shared data

			const data = {}

			// name

			this.name = source.name

			// index

			const index = source.index

			if (index !== null) {

				this.setIndex(index.clone(data))

			}

			// attributes

			const attributes = source.attributes

			for (const name in attributes) {

				const attribute = attributes[name]
				this.setAttribute(name, attribute.clone(data))

			}

			// morph attributes

			const morphAttributes = source.morphAttributes

			for (const name in morphAttributes) {

				const array = []
				const morphAttribute = morphAttributes[name] // morphAttribute: array of Float32BufferAttributes

				for (let i = 0, l = morphAttribute.length; i < l; i++) {

					array.push(morphAttribute[i].clone(data))

				}

				this.morphAttributes[name] = array

			}

			this.morphTargetsRelative = source.morphTargetsRelative

			// groups

			const groups = source.groups

			for (let i = 0, l = groups.length; i < l; i++) {

				const group = groups[i]
				this.addGroup(group.start, group.count, group.materialIndex)

			}

			// bounding box

			const boundingBox = source.boundingBox

			if (boundingBox !== null) {

				this.boundingBox = boundingBox.clone()

			}

			// bounding sphere

			const boundingSphere = source.boundingSphere

			if (boundingSphere !== null) {

				this.boundingSphere = boundingSphere.clone()

			}

			// draw range

			this.drawRange.start = source.drawRange.start
			this.drawRange.count = source.drawRange.count

			// user data

			this.userData = source.userData

			return this

		}

		dispose () {

			this.dispatchEvent({ type: 'dispose' })

		}

	}

	BufferGeometry.prototype.isBufferGeometry = true

	const _inverseMatrix$2 = /*@__PURE__*/ new Matrix4()
	const _ray$2 = /*@__PURE__*/ new Ray()
	const _sphere$3 = /*@__PURE__*/ new Sphere()

	const _vA$1 = /*@__PURE__*/ new Vector3()
	const _vB$1 = /*@__PURE__*/ new Vector3()
	const _vC$1 = /*@__PURE__*/ new Vector3()

	const _tempA = /*@__PURE__*/ new Vector3()
	const _tempB = /*@__PURE__*/ new Vector3()
	const _tempC = /*@__PURE__*/ new Vector3()

	const _morphA = /*@__PURE__*/ new Vector3()
	const _morphB = /*@__PURE__*/ new Vector3()
	const _morphC = /*@__PURE__*/ new Vector3()

	const _uvA$1 = /*@__PURE__*/ new Vector2()
	const _uvB$1 = /*@__PURE__*/ new Vector2()
	const _uvC$1 = /*@__PURE__*/ new Vector2()

	const _intersectionPoint = /*@__PURE__*/ new Vector3()
	const _intersectionPointWorld = /*@__PURE__*/ new Vector3()

	class Mesh extends Object3D {

		constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {

			super()

			this.type = 'Mesh'

			this.geometry = geometry
			this.material = material

			this.updateMorphTargets()

		}

		copy (source) {

			super.copy(source)

			if (source.morphTargetInfluences !== undefined) {

				this.morphTargetInfluences = source.morphTargetInfluences.slice()

			}

			if (source.morphTargetDictionary !== undefined) {

				this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary)

			}

			this.material = source.material
			this.geometry = source.geometry

			return this

		}

		updateMorphTargets () {

			const geometry = this.geometry

			if (geometry.isBufferGeometry) {

				const morphAttributes = geometry.morphAttributes
				const keys = Object.keys(morphAttributes)

				if (keys.length > 0) {

					const morphAttribute = morphAttributes[keys[0]]

					if (morphAttribute !== undefined) {

						this.morphTargetInfluences = []
						this.morphTargetDictionary = {}

						for (let m = 0, ml = morphAttribute.length; m < ml; m++) {

							const name = morphAttribute[m].name || String(m)

							this.morphTargetInfluences.push(0)
							this.morphTargetDictionary[name] = m

						}

					}

				}

			} else {

				const morphTargets = geometry.morphTargets

				if (morphTargets !== undefined && morphTargets.length > 0) {

					console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.')

				}

			}

		}

		raycast (raycaster, intersects) {

			const geometry = this.geometry
			const material = this.material
			const matrixWorld = this.matrixWorld

			if (material === undefined) return

			// Checking boundingSphere distance to ray

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere()

			_sphere$3.copy(geometry.boundingSphere)
			_sphere$3.applyMatrix4(matrixWorld)

			if (raycaster.ray.intersectsSphere(_sphere$3) === false) return

			//

			_inverseMatrix$2.copy(matrixWorld).invert()
			_ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2)

			// Check boundingBox before continuing

			if (geometry.boundingBox !== null) {

				if (_ray$2.intersectsBox(geometry.boundingBox) === false) return

			}

			let intersection

			if (geometry.isBufferGeometry) {

				const index = geometry.index
				const position = geometry.attributes.position
				const morphPosition = geometry.morphAttributes.position
				const morphTargetsRelative = geometry.morphTargetsRelative
				const uv = geometry.attributes.uv
				const uv2 = geometry.attributes.uv2
				const groups = geometry.groups
				const drawRange = geometry.drawRange

				if (index !== null) {

					// indexed buffer geometry

					if (Array.isArray(material)) {

						for (let i = 0, il = groups.length; i < il; i++) {

							const group = groups[i]
							const groupMaterial = material[group.materialIndex]

							const start = Math.max(group.start, drawRange.start)
							const end = Math.min((group.start + group.count), (drawRange.start + drawRange.count))

							for (let j = start, jl = end; j < jl; j += 3) {

								const a = index.getX(j)
								const b = index.getX(j + 1)
								const c = index.getX(j + 2)

								intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c)

								if (intersection) {

									intersection.faceIndex = Math.floor(j / 3) // triangle number in indexed buffer semantics
									intersection.face.materialIndex = group.materialIndex
									intersects.push(intersection)

								}

							}

						}

					} else {

						const start = Math.max(0, drawRange.start)
						const end = Math.min(index.count, (drawRange.start + drawRange.count))

						for (let i = start, il = end; i < il; i += 3) {

							const a = index.getX(i)
							const b = index.getX(i + 1)
							const c = index.getX(i + 2)

							intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c)

							if (intersection) {

								intersection.faceIndex = Math.floor(i / 3) // triangle number in indexed buffer semantics
								intersects.push(intersection)

							}

						}

					}

				} else if (position !== undefined) {

					// non-indexed buffer geometry

					if (Array.isArray(material)) {

						for (let i = 0, il = groups.length; i < il; i++) {

							const group = groups[i]
							const groupMaterial = material[group.materialIndex]

							const start = Math.max(group.start, drawRange.start)
							const end = Math.min((group.start + group.count), (drawRange.start + drawRange.count))

							for (let j = start, jl = end; j < jl; j += 3) {

								const a = j
								const b = j + 1
								const c = j + 2

								intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c)

								if (intersection) {

									intersection.faceIndex = Math.floor(j / 3) // triangle number in non-indexed buffer semantics
									intersection.face.materialIndex = group.materialIndex
									intersects.push(intersection)

								}

							}

						}

					} else {

						const start = Math.max(0, drawRange.start)
						const end = Math.min(position.count, (drawRange.start + drawRange.count))

						for (let i = start, il = end; i < il; i += 3) {

							const a = i
							const b = i + 1
							const c = i + 2

							intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c)

							if (intersection) {

								intersection.faceIndex = Math.floor(i / 3) // triangle number in non-indexed buffer semantics
								intersects.push(intersection)

							}

						}

					}

				}

			} else if (geometry.isGeometry) {

				console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.')

			}

		}

	}

	Mesh.prototype.isMesh = true

	function checkIntersection (object, material, raycaster, ray, pA, pB, pC, point) {

		let intersect

		if (material.side === BackSide) {

			intersect = ray.intersectTriangle(pC, pB, pA, true, point)

		} else {

			intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point)

		}

		if (intersect === null) return null

		_intersectionPointWorld.copy(point)
		_intersectionPointWorld.applyMatrix4(object.matrixWorld)

		const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld)

		if (distance < raycaster.near || distance > raycaster.far) return null

		return {
			distance: distance,
			point: _intersectionPointWorld.clone(),
			object: object
		}

	}

	function checkBufferGeometryIntersection (object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {

		_vA$1.fromBufferAttribute(position, a)
		_vB$1.fromBufferAttribute(position, b)
		_vC$1.fromBufferAttribute(position, c)

		const morphInfluences = object.morphTargetInfluences

		if (morphPosition && morphInfluences) {

			_morphA.set(0, 0, 0)
			_morphB.set(0, 0, 0)
			_morphC.set(0, 0, 0)

			for (let i = 0, il = morphPosition.length; i < il; i++) {

				const influence = morphInfluences[i]
				const morphAttribute = morphPosition[i]

				if (influence === 0) continue

				_tempA.fromBufferAttribute(morphAttribute, a)
				_tempB.fromBufferAttribute(morphAttribute, b)
				_tempC.fromBufferAttribute(morphAttribute, c)

				if (morphTargetsRelative) {

					_morphA.addScaledVector(_tempA, influence)
					_morphB.addScaledVector(_tempB, influence)
					_morphC.addScaledVector(_tempC, influence)

				} else {

					_morphA.addScaledVector(_tempA.sub(_vA$1), influence)
					_morphB.addScaledVector(_tempB.sub(_vB$1), influence)
					_morphC.addScaledVector(_tempC.sub(_vC$1), influence)

				}

			}

			_vA$1.add(_morphA)
			_vB$1.add(_morphB)
			_vC$1.add(_morphC)

		}

		if (object.isSkinnedMesh) {

			object.boneTransform(a, _vA$1)
			object.boneTransform(b, _vB$1)
			object.boneTransform(c, _vC$1)

		}

		const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint)

		if (intersection) {

			if (uv) {

				_uvA$1.fromBufferAttribute(uv, a)
				_uvB$1.fromBufferAttribute(uv, b)
				_uvC$1.fromBufferAttribute(uv, c)

				intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2())

			}

			if (uv2) {

				_uvA$1.fromBufferAttribute(uv2, a)
				_uvB$1.fromBufferAttribute(uv2, b)
				_uvC$1.fromBufferAttribute(uv2, c)

				intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2())

			}

			const face = {
				a: a,
				b: b,
				c: c,
				normal: new Vector3(),
				materialIndex: 0
			}

			Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal)

			intersection.face = face

		}

		return intersection

	}

	class BoxGeometry extends BufferGeometry {

		constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {

			super()

			this.type = 'BoxGeometry'

			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			}

			const scope = this

			// segments

			widthSegments = Math.floor(widthSegments)
			heightSegments = Math.floor(heightSegments)
			depthSegments = Math.floor(depthSegments)

			// buffers

			const indices = []
			const vertices = []
			const normals = []
			const uvs = []

			// helper variables

			let numberOfVertices = 0
			let groupStart = 0

			// build each side of the box geometry

			buildPlane('z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0) // px
			buildPlane('z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1) // nx
			buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2) // py
			buildPlane('x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3) // ny
			buildPlane('x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4) // pz
			buildPlane('x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5) // nz

			// build geometry

			this.setIndex(indices)
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))

			function buildPlane (u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {

				const segmentWidth = width / gridX
				const segmentHeight = height / gridY

				const widthHalf = width / 2
				const heightHalf = height / 2
				const depthHalf = depth / 2

				const gridX1 = gridX + 1
				const gridY1 = gridY + 1

				let vertexCounter = 0
				let groupCount = 0

				const vector = new Vector3()

				// generate vertices, normals and uvs

				for (let iy = 0; iy < gridY1; iy++) {

					const y = iy * segmentHeight - heightHalf

					for (let ix = 0; ix < gridX1; ix++) {

						const x = ix * segmentWidth - widthHalf

						// set values to correct vector component

						vector[u] = x * udir
						vector[v] = y * vdir
						vector[w] = depthHalf

						// now apply vector to vertex buffer

						vertices.push(vector.x, vector.y, vector.z)

						// set values to correct vector component

						vector[u] = 0
						vector[v] = 0
						vector[w] = depth > 0 ? 1 : - 1

						// now apply vector to normal buffer

						normals.push(vector.x, vector.y, vector.z)

						// uvs

						uvs.push(ix / gridX)
						uvs.push(1 - (iy / gridY))

						// counters

						vertexCounter += 1

					}

				}

				// indices

				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment

				for (let iy = 0; iy < gridY; iy++) {

					for (let ix = 0; ix < gridX; ix++) {

						const a = numberOfVertices + ix + gridX1 * iy
						const b = numberOfVertices + ix + gridX1 * (iy + 1)
						const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1)
						const d = numberOfVertices + (ix + 1) + gridX1 * iy

						// faces

						indices.push(a, b, d)
						indices.push(b, c, d)

						// increase counter

						groupCount += 6

					}

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup(groupStart, groupCount, materialIndex)

				// calculate new start value for groups

				groupStart += groupCount

				// update total number of vertices

				numberOfVertices += vertexCounter

			}

		}

		static fromJSON (data) {

			return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments)

		}

	}

	/**
	 * Uniform Utilities
	 */

	function cloneUniforms$1 (src) {

		const dst = {}

		for (const u in src) {

			dst[u] = {}

			for (const p in src[u]) {

				const property = src[u][p]

				if (property && (property.isColor ||
					property.isMatrix3 || property.isMatrix4 ||
					property.isVector2 || property.isVector3 || property.isVector4 ||
					property.isTexture || property.isQuaternion)) {

					dst[u][p] = property.clone()

				} else if (Array.isArray(property)) {

					dst[u][p] = property.slice()

				} else {

					dst[u][p] = property

				}

			}

		}

		return dst

	}

	function mergeUniforms$1 (uniforms) {

		const merged = {}

		for (let u = 0; u < uniforms.length; u++) {

			const tmp = cloneUniforms$1(uniforms[u])

			for (const p in tmp) {

				merged[p] = tmp[p]

			}

		}

		return merged

	}

	// Legacy

	const UniformsUtils$1 = { clone: cloneUniforms$1, merge: mergeUniforms$1 }

	var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"

	var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"

	/**
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>
	 * }
	 */

	class ShaderMaterial extends Material {

		constructor(parameters) {

			super()

			this.type = 'ShaderMaterial'

			this.defines = {}
			this.uniforms = {}

			this.vertexShader = default_vertex
			this.fragmentShader = default_fragment

			this.linewidth = 1

			this.wireframe = false
			this.wireframeLinewidth = 1

			this.fog = false // set to use scene fog
			this.lights = false // set to use scene lights
			this.clipping = false // set to use user-defined clipping planes

			this.extensions = {
				derivatives: false, // set to use derivatives
				fragDepth: false, // set to use fragment depth values
				drawBuffers: false, // set to use draw buffers
				shaderTextureLOD: false // set to use shader texture LOD
			}

			// When rendered geometry doesn't include these attributes but the material does,
			// use these default values in WebGL. This avoids errors when buffer data is missing.
			this.defaultAttributeValues = {
				'color': [1, 1, 1],
				'uv': [0, 0],
				'uv2': [0, 0]
			}

			this.index0AttributeName = undefined
			this.uniformsNeedUpdate = false

			this.glslVersion = null

			if (parameters !== undefined) {

				if (parameters.attributes !== undefined) {

					console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.')

				}

				this.setValues(parameters)

			}

		}

		copy (source) {

			super.copy(source)

			this.fragmentShader = source.fragmentShader
			this.vertexShader = source.vertexShader

			this.uniforms = cloneUniforms$1(source.uniforms)

			this.defines = Object.assign({}, source.defines)

			this.wireframe = source.wireframe
			this.wireframeLinewidth = source.wireframeLinewidth

			this.lights = source.lights
			this.clipping = source.clipping

			this.extensions = Object.assign({}, source.extensions)

			this.glslVersion = source.glslVersion

			return this

		}

		toJSON (meta) {

			const data = super.toJSON(meta)

			data.glslVersion = this.glslVersion
			data.uniforms = {}

			for (const name in this.uniforms) {

				const uniform = this.uniforms[name]
				const value = uniform.value

				if (value && value.isTexture) {

					data.uniforms[name] = {
						type: 't',
						value: value.toJSON(meta).uuid
					}

				} else if (value && value.isColor) {

					data.uniforms[name] = {
						type: 'c',
						value: value.getHex()
					}

				} else if (value && value.isVector2) {

					data.uniforms[name] = {
						type: 'v2',
						value: value.toArray()
					}

				} else if (value && value.isVector3) {

					data.uniforms[name] = {
						type: 'v3',
						value: value.toArray()
					}

				} else if (value && value.isVector4) {

					data.uniforms[name] = {
						type: 'v4',
						value: value.toArray()
					}

				} else if (value && value.isMatrix3) {

					data.uniforms[name] = {
						type: 'm3',
						value: value.toArray()
					}

				} else if (value && value.isMatrix4) {

					data.uniforms[name] = {
						type: 'm4',
						value: value.toArray()
					}

				} else {

					data.uniforms[name] = {
						value: value
					}

					// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

				}

			}

			if (Object.keys(this.defines).length > 0) data.defines = this.defines

			data.vertexShader = this.vertexShader
			data.fragmentShader = this.fragmentShader

			const extensions = {}

			for (const key in this.extensions) {

				if (this.extensions[key] === true) extensions[key] = true

			}

			if (Object.keys(extensions).length > 0) data.extensions = extensions

			return data

		}

	}

	ShaderMaterial.prototype.isShaderMaterial = true

	class Camera extends Object3D {

		constructor() {

			super()

			this.type = 'Camera'

			this.matrixWorldInverse = new Matrix4()

			this.projectionMatrix = new Matrix4()
			this.projectionMatrixInverse = new Matrix4()

		}

		copy (source, recursive) {

			super.copy(source, recursive)

			this.matrixWorldInverse.copy(source.matrixWorldInverse)

			this.projectionMatrix.copy(source.projectionMatrix)
			this.projectionMatrixInverse.copy(source.projectionMatrixInverse)

			return this

		}

		getWorldDirection (target) {

			this.updateWorldMatrix(true, false)

			const e = this.matrixWorld.elements

			return target.set(- e[8], - e[9], - e[10]).normalize()

		}

		updateMatrixWorld (force) {

			super.updateMatrixWorld(force)

			this.matrixWorldInverse.copy(this.matrixWorld).invert()

		}

		updateWorldMatrix (updateParents, updateChildren) {

			super.updateWorldMatrix(updateParents, updateChildren)

			this.matrixWorldInverse.copy(this.matrixWorld).invert()

		}

		clone () {

			return new this.constructor().copy(this)

		}

	}

	Camera.prototype.isCamera = true

	class PerspectiveCamera extends Camera {

		constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {

			super()

			this.type = 'PerspectiveCamera'

			this.fov = fov
			this.zoom = 1

			this.near = near
			this.far = far
			this.focus = 10

			this.aspect = aspect
			this.view = null

			this.filmGauge = 35	// width of the film (default in millimeters)
			this.filmOffset = 0	// horizontal film offset (same unit as gauge)

			this.updateProjectionMatrix()

		}

		copy (source, recursive) {

			super.copy(source, recursive)

			this.fov = source.fov
			this.zoom = source.zoom

			this.near = source.near
			this.far = source.far
			this.focus = source.focus

			this.aspect = source.aspect
			this.view = source.view === null ? null : Object.assign({}, source.view)

			this.filmGauge = source.filmGauge
			this.filmOffset = source.filmOffset

			return this

		}

		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength (focalLength) {

			/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
			const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength

			this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope)
			this.updateProjectionMatrix()

		}

		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		getFocalLength () {

			const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov)

			return 0.5 * this.getFilmHeight() / vExtentSlope

		}

		getEffectiveFOV () {

			return RAD2DEG * 2 * Math.atan(
				Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom)

		}

		getFilmWidth () {

			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min(this.aspect, 1)

		}

		getFilmHeight () {

			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max(this.aspect, 1)

		}

		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   const w = 1920;
		 *   const h = 1080;
		 *   const fullWidth = w * 3;
		 *   const fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */
		setViewOffset (fullWidth, fullHeight, x, y, width, height) {

			this.aspect = fullWidth / fullHeight

			if (this.view === null) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				}

			}

			this.view.enabled = true
			this.view.fullWidth = fullWidth
			this.view.fullHeight = fullHeight
			this.view.offsetX = x
			this.view.offsetY = y
			this.view.width = width
			this.view.height = height

			this.updateProjectionMatrix()

		}

		clearViewOffset () {

			if (this.view !== null) {

				this.view.enabled = false

			}

			this.updateProjectionMatrix()

		}

		updateProjectionMatrix () {

			const near = this.near
			let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom
			let height = 2 * top
			let width = this.aspect * height
			let left = - 0.5 * width
			const view = this.view

			if (this.view !== null && this.view.enabled) {

				const fullWidth = view.fullWidth,
					fullHeight = view.fullHeight

				left += view.offsetX * width / fullWidth
				top -= view.offsetY * height / fullHeight
				width *= view.width / fullWidth
				height *= view.height / fullHeight

			}

			const skew = this.filmOffset
			if (skew !== 0) left += near * skew / this.getFilmWidth()

			this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far)

			this.projectionMatrixInverse.copy(this.projectionMatrix).invert()

		}

		toJSON (meta) {

			const data = super.toJSON(meta)

			data.object.fov = this.fov
			data.object.zoom = this.zoom

			data.object.near = this.near
			data.object.far = this.far
			data.object.focus = this.focus

			data.object.aspect = this.aspect

			if (this.view !== null) data.object.view = Object.assign({}, this.view)

			data.object.filmGauge = this.filmGauge
			data.object.filmOffset = this.filmOffset

			return data

		}

	}

	PerspectiveCamera.prototype.isPerspectiveCamera = true

	const fov = 90, aspect = 1

	class CubeCamera extends Object3D {

		constructor(near, far, renderTarget) {

			super()

			this.type = 'CubeCamera'

			if (renderTarget.isWebGLCubeRenderTarget !== true) {

				console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.')
				return

			}

			this.renderTarget = renderTarget

			const cameraPX = new PerspectiveCamera(fov, aspect, near, far)
			cameraPX.layers = this.layers
			cameraPX.up.set(0, - 1, 0)
			cameraPX.lookAt(new Vector3(1, 0, 0))
			this.add(cameraPX)

			const cameraNX = new PerspectiveCamera(fov, aspect, near, far)
			cameraNX.layers = this.layers
			cameraNX.up.set(0, - 1, 0)
			cameraNX.lookAt(new Vector3(- 1, 0, 0))
			this.add(cameraNX)

			const cameraPY = new PerspectiveCamera(fov, aspect, near, far)
			cameraPY.layers = this.layers
			cameraPY.up.set(0, 0, 1)
			cameraPY.lookAt(new Vector3(0, 1, 0))
			this.add(cameraPY)

			const cameraNY = new PerspectiveCamera(fov, aspect, near, far)
			cameraNY.layers = this.layers
			cameraNY.up.set(0, 0, - 1)
			cameraNY.lookAt(new Vector3(0, - 1, 0))
			this.add(cameraNY)

			const cameraPZ = new PerspectiveCamera(fov, aspect, near, far)
			cameraPZ.layers = this.layers
			cameraPZ.up.set(0, - 1, 0)
			cameraPZ.lookAt(new Vector3(0, 0, 1))
			this.add(cameraPZ)

			const cameraNZ = new PerspectiveCamera(fov, aspect, near, far)
			cameraNZ.layers = this.layers
			cameraNZ.up.set(0, - 1, 0)
			cameraNZ.lookAt(new Vector3(0, 0, - 1))
			this.add(cameraNZ)

		}

		update (renderer, scene) {

			if (this.parent === null) this.updateMatrixWorld()

			const renderTarget = this.renderTarget

			const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children

			const currentXrEnabled = renderer.xr.enabled
			const currentRenderTarget = renderer.getRenderTarget()

			renderer.xr.enabled = false

			const generateMipmaps = renderTarget.texture.generateMipmaps

			renderTarget.texture.generateMipmaps = false

			renderer.setRenderTarget(renderTarget, 0)
			renderer.render(scene, cameraPX)

			renderer.setRenderTarget(renderTarget, 1)
			renderer.render(scene, cameraNX)

			renderer.setRenderTarget(renderTarget, 2)
			renderer.render(scene, cameraPY)

			renderer.setRenderTarget(renderTarget, 3)
			renderer.render(scene, cameraNY)

			renderer.setRenderTarget(renderTarget, 4)
			renderer.render(scene, cameraPZ)

			renderTarget.texture.generateMipmaps = generateMipmaps

			renderer.setRenderTarget(renderTarget, 5)
			renderer.render(scene, cameraNZ)

			renderer.setRenderTarget(currentRenderTarget)

			renderer.xr.enabled = currentXrEnabled

		}

	}

	class CubeTexture extends Texture {

		constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {

			images = images !== undefined ? images : []
			mapping = mapping !== undefined ? mapping : CubeReflectionMapping
			format = format !== undefined ? format : RGBFormat

			super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding)

			this.flipY = false

		}

		get images () {

			return this.image

		}

		set images (value) {

			this.image = value

		}

	}

	CubeTexture.prototype.isCubeTexture = true

	class WebGLCubeRenderTarget extends WebGLRenderTarget {

		constructor(size, options, dummy) {

			if (Number.isInteger(options)) {

				console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )')

				options = dummy

			}

			super(size, size, options)

			options = options || {}

			// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
			// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
			// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

			// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
			// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
			// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

			this.texture = new CubeTexture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding)
			this.texture.isRenderTargetTexture = true

			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter

			this.texture._needsFlipEnvMap = false

		}

		fromEquirectangularTexture (renderer, texture) {

			this.texture.type = texture.type
			this.texture.format = RGBAFormat // see #18859
			this.texture.encoding = texture.encoding

			this.texture.generateMipmaps = texture.generateMipmaps
			this.texture.minFilter = texture.minFilter
			this.texture.magFilter = texture.magFilter

			const shader = {

				uniforms: {
					tEquirect: { value: null },
				},

				vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

				fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
			}

			const geometry = new BoxGeometry(5, 5, 5)

			const material = new ShaderMaterial({

				name: 'CubemapFromEquirect',

				uniforms: cloneUniforms$1(shader.uniforms),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader,
				side: BackSide,
				blending: NoBlending

			})

			material.uniforms.tEquirect.value = texture

			const mesh = new Mesh(geometry, material)

			const currentMinFilter = texture.minFilter

			// Avoid blurred poles
			if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter

			const camera = new CubeCamera(1, 10, this)
			camera.update(renderer, mesh)

			texture.minFilter = currentMinFilter

			mesh.geometry.dispose()
			mesh.material.dispose()

			return this

		}

		clear (renderer, color, depth, stencil) {

			const currentRenderTarget = renderer.getRenderTarget()

			for (let i = 0; i < 6; i++) {

				renderer.setRenderTarget(this, i)

				renderer.clear(color, depth, stencil)

			}

			renderer.setRenderTarget(currentRenderTarget)

		}

	}

	WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true

	const _vector1 = /*@__PURE__*/ new Vector3()
	const _vector2 = /*@__PURE__*/ new Vector3()
	const _normalMatrix = /*@__PURE__*/ new Matrix3()

	class Plane {

		constructor(normal = new Vector3(1, 0, 0), constant = 0) {

			// normal is assumed to be normalized

			this.normal = normal
			this.constant = constant

		}

		set (normal, constant) {

			this.normal.copy(normal)
			this.constant = constant

			return this

		}

		setComponents (x, y, z, w) {

			this.normal.set(x, y, z)
			this.constant = w

			return this

		}

		setFromNormalAndCoplanarPoint (normal, point) {

			this.normal.copy(normal)
			this.constant = - point.dot(this.normal)

			return this

		}

		setFromCoplanarPoints (a, b, c) {

			const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize()

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint(normal, a)

			return this

		}

		copy (plane) {

			this.normal.copy(plane.normal)
			this.constant = plane.constant

			return this

		}

		normalize () {

			// Note: will lead to a divide by zero if the plane is invalid.

			const inverseNormalLength = 1.0 / this.normal.length()
			this.normal.multiplyScalar(inverseNormalLength)
			this.constant *= inverseNormalLength

			return this

		}

		negate () {

			this.constant *= - 1
			this.normal.negate()

			return this

		}

		distanceToPoint (point) {

			return this.normal.dot(point) + this.constant

		}

		distanceToSphere (sphere) {

			return this.distanceToPoint(sphere.center) - sphere.radius

		}

		projectPoint (point, target) {

			return target.copy(this.normal).multiplyScalar(- this.distanceToPoint(point)).add(point)

		}

		intersectLine (line, target) {

			const direction = line.delta(_vector1)

			const denominator = this.normal.dot(direction)

			if (denominator === 0) {

				// line is coplanar, return origin
				if (this.distanceToPoint(line.start) === 0) {

					return target.copy(line.start)

				}

				// Unsure if this is the correct method to handle this case.
				return null

			}

			const t = - (line.start.dot(this.normal) + this.constant) / denominator

			if (t < 0 || t > 1) {

				return null

			}

			return target.copy(direction).multiplyScalar(t).add(line.start)

		}

		intersectsLine (line) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			const startSign = this.distanceToPoint(line.start)
			const endSign = this.distanceToPoint(line.end)

			return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0)

		}

		intersectsBox (box) {

			return box.intersectsPlane(this)

		}

		intersectsSphere (sphere) {

			return sphere.intersectsPlane(this)

		}

		coplanarPoint (target) {

			return target.copy(this.normal).multiplyScalar(- this.constant)

		}

		applyMatrix4 (matrix, optionalNormalMatrix) {

			const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix)

			const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix)

			const normal = this.normal.applyMatrix3(normalMatrix).normalize()

			this.constant = - referencePoint.dot(normal)

			return this

		}

		translate (offset) {

			this.constant -= offset.dot(this.normal)

			return this

		}

		equals (plane) {

			return plane.normal.equals(this.normal) && (plane.constant === this.constant)

		}

		clone () {

			return new this.constructor().copy(this)

		}

	}

	Plane.prototype.isPlane = true

	const _sphere$2 = /*@__PURE__*/ new Sphere()
	const _vector$7 = /*@__PURE__*/ new Vector3()

	class Frustum {

		constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {

			this.planes = [p0, p1, p2, p3, p4, p5]

		}

		set (p0, p1, p2, p3, p4, p5) {

			const planes = this.planes

			planes[0].copy(p0)
			planes[1].copy(p1)
			planes[2].copy(p2)
			planes[3].copy(p3)
			planes[4].copy(p4)
			planes[5].copy(p5)

			return this

		}

		copy (frustum) {

			const planes = this.planes

			for (let i = 0; i < 6; i++) {

				planes[i].copy(frustum.planes[i])

			}

			return this

		}

		setFromProjectionMatrix (m) {

			const planes = this.planes
			const me = m.elements
			const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3]
			const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7]
			const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11]
			const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15]

			planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize()
			planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize()
			planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize()
			planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize()
			planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize()
			planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize()

			return this

		}

		intersectsObject (object) {

			const geometry = object.geometry

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere()

			_sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld)

			return this.intersectsSphere(_sphere$2)

		}

		intersectsSprite (sprite) {

			_sphere$2.center.set(0, 0, 0)
			_sphere$2.radius = 0.7071067811865476
			_sphere$2.applyMatrix4(sprite.matrixWorld)

			return this.intersectsSphere(_sphere$2)

		}

		intersectsSphere (sphere) {

			const planes = this.planes
			const center = sphere.center
			const negRadius = - sphere.radius

			for (let i = 0; i < 6; i++) {

				const distance = planes[i].distanceToPoint(center)

				if (distance < negRadius) {

					return false

				}

			}

			return true

		}

		intersectsBox (box) {

			const planes = this.planes

			for (let i = 0; i < 6; i++) {

				const plane = planes[i]

				// corner at max distance

				_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x
				_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y
				_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z

				if (plane.distanceToPoint(_vector$7) < 0) {

					return false

				}

			}

			return true

		}

		containsPoint (point) {

			const planes = this.planes

			for (let i = 0; i < 6; i++) {

				if (planes[i].distanceToPoint(point) < 0) {

					return false

				}

			}

			return true

		}

		clone () {

			return new this.constructor().copy(this)

		}

	}

	function WebGLAnimation$1 () {

		let context = null
		let isAnimating = false
		let animationLoop = null
		let requestId = null

		function onAnimationFrame (time, frame) {

			animationLoop(time, frame)

			requestId = context.requestAnimationFrame(onAnimationFrame)

		}

		return {

			start: function () {

				if (isAnimating === true) return
				if (animationLoop === null) return

				requestId = context.requestAnimationFrame(onAnimationFrame)

				isAnimating = true

			},

			stop: function () {

				context.cancelAnimationFrame(requestId)

				isAnimating = false

			},

			setAnimationLoop: function (callback) {

				animationLoop = callback

			},

			setContext: function (value) {

				context = value

			}

		}

	}

	function WebGLAttributes$1 (gl, capabilities) {

		const isWebGL2 = capabilities.isWebGL2

		const buffers = new WeakMap()

		function createBuffer (attribute, bufferType) {

			const array = attribute.array
			const usage = attribute.usage

			const buffer = gl.createBuffer()

			gl.bindBuffer(bufferType, buffer)
			gl.bufferData(bufferType, array, usage)

			attribute.onUploadCallback()

			let type = 5126

			if (array instanceof Float32Array) {

				type = 5126

			} else if (array instanceof Float64Array) {

				console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.')

			} else if (array instanceof Uint16Array) {

				if (attribute.isFloat16BufferAttribute) {

					if (isWebGL2) {

						type = 5131

					} else {

						console.warn('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.')

					}

				} else {

					type = 5123

				}

			} else if (array instanceof Int16Array) {

				type = 5122

			} else if (array instanceof Uint32Array) {

				type = 5125

			} else if (array instanceof Int32Array) {

				type = 5124

			} else if (array instanceof Int8Array) {

				type = 5120

			} else if (array instanceof Uint8Array) {

				type = 5121

			} else if (array instanceof Uint8ClampedArray) {

				type = 5121

			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			}

		}

		function updateBuffer (buffer, attribute, bufferType) {

			const array = attribute.array
			const updateRange = attribute.updateRange

			gl.bindBuffer(bufferType, buffer)

			if (updateRange.count === - 1) {

				// Not using update ranges

				gl.bufferSubData(bufferType, 0, array)

			} else {

				if (isWebGL2) {

					gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array, updateRange.offset, updateRange.count)

				} else {

					gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array.subarray(updateRange.offset, updateRange.offset + updateRange.count))

				}

				updateRange.count = - 1 // reset range

			}

		}

		//

		function get (attribute) {

			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data

			return buffers.get(attribute)

		}

		function remove (attribute) {

			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data

			const data = buffers.get(attribute)

			if (data) {

				gl.deleteBuffer(data.buffer)

				buffers.delete(attribute)

			}

		}

		function update (attribute, bufferType) {

			if (attribute.isGLBufferAttribute) {

				const cached = buffers.get(attribute)

				if (!cached || cached.version < attribute.version) {

					buffers.set(attribute, {
						buffer: attribute.buffer,
						type: attribute.type,
						bytesPerElement: attribute.elementSize,
						version: attribute.version
					})

				}

				return

			}

			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data

			const data = buffers.get(attribute)

			if (data === undefined) {

				buffers.set(attribute, createBuffer(attribute, bufferType))

			} else if (data.version < attribute.version) {

				updateBuffer(data.buffer, attribute, bufferType)

				data.version = attribute.version

			}

		}

		return {

			get: get,
			remove: remove,
			update: update

		}

	}

	class PlaneGeometry extends BufferGeometry {

		constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {

			super()
			this.type = 'PlaneGeometry'

			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			}

			const width_half = width / 2
			const height_half = height / 2

			const gridX = Math.floor(widthSegments)
			const gridY = Math.floor(heightSegments)

			const gridX1 = gridX + 1
			const gridY1 = gridY + 1

			const segment_width = width / gridX
			const segment_height = height / gridY

			//

			const indices = []
			const vertices = []
			const normals = []
			const uvs = []

			for (let iy = 0; iy < gridY1; iy++) {

				const y = iy * segment_height - height_half

				for (let ix = 0; ix < gridX1; ix++) {

					const x = ix * segment_width - width_half

					vertices.push(x, - y, 0)

					normals.push(0, 0, 1)

					uvs.push(ix / gridX)
					uvs.push(1 - (iy / gridY))

				}

			}

			for (let iy = 0; iy < gridY; iy++) {

				for (let ix = 0; ix < gridX; ix++) {

					const a = ix + gridX1 * iy
					const b = ix + gridX1 * (iy + 1)
					const c = (ix + 1) + gridX1 * (iy + 1)
					const d = (ix + 1) + gridX1 * iy

					indices.push(a, b, d)
					indices.push(b, c, d)

				}

			}

			this.setIndex(indices)
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))

		}

		static fromJSON (data) {

			return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments)

		}

	}

	var alphamap_fragment$1 = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif"

	var alphamap_pars_fragment$1 = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif"

	var alphatest_fragment$1 = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif"

	var aomap_fragment$1 = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif"

	var aomap_pars_fragment$1 = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif"

	var begin_vertex$1 = "vec3 transformed = vec3( position );"

	var beginnormal_vertex$1 = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif"

	var bsdfs$1 = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in vec3 f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn ( f90 - f0 ) * fresnel + f0;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in vec3 f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, vec3( 1.0 ), dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif"

	var bumpmap_pars_fragment$1 = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif"

	var clipping_planes_fragment$1 = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif"

	var clipping_planes_pars_fragment$1 = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif"

	var clipping_planes_pars_vertex$1 = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif"

	var clipping_planes_vertex$1 = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif"

	var color_fragment$1 = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif"

	var color_pars_fragment$1 = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif"

	var color_pars_vertex$1 = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif"

	var color_vertex$1 = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif"

	var common$1 = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}"

	var cube_uv_reflection_fragment$1 = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif"

	var defaultnormal_vertex$1 = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif"

	var displacementmap_pars_vertex$1 = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif"

	var displacementmap_vertex$1 = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif"

	var emissivemap_fragment$1 = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif"

	var emissivemap_pars_fragment$1 = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif"

	var encodings_fragment$1 = "gl_FragColor = linearToOutputTexel( gl_FragColor );"

	var encodings_pars_fragment$1 = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}"

	var envmap_fragment$1 = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif"

	var envmap_common_pars_fragment$1 = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif"

	var envmap_pars_fragment$1 = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif"

	var envmap_pars_vertex$1 = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif"

	var envmap_vertex$1 = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif"

	var fog_vertex$1 = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif"

	var fog_pars_vertex$1 = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif"

	var fog_fragment$1 = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif"

	var fog_pars_fragment$1 = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif"

	var gradientmap_pars_fragment$1 = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}"

	var lightmap_fragment$1 = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif"

	var lightmap_pars_fragment$1 = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif"

	var lights_lambert_vertex$1 = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif"

	var lights_pars_begin$1 = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif"

	var envmap_physical_pars_fragment$1 = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif"

	var lights_toon_fragment$1 = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;"

	var lights_toon_pars_fragment$1 = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)"

	var lights_phong_fragment$1 = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;"

	var lights_phong_pars_fragment$1 = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)"

	var lights_physical_fragment$1 = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\t#ifdef SPECULAR\n\t\tvec3 specularIntensityFactor = vec3( specularIntensity );\n\t\tvec3 specularTintFactor = specularTint;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARTINTMAP\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularColorF90 = mix( specularIntensityFactor, vec3( 1.0 ), metalnessFactor );\n\t#else\n\t\tvec3 specularIntensityFactor = vec3( 1.0 );\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularColorF90 = vec3( 1.0 );\n\t#endif\n\tmaterial.specularColor = mix( min( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularColorF90 = vec3( 1.0 );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif"

	var lights_physical_pars_fragment$1 = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n\tvec3 specularColorF90;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), vec3( 1.0 ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularColorF90, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}"

	var lights_fragment_begin$1 = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif"

	var lights_fragment_maps$1 = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif"

	var lights_fragment_end$1 = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif"

	var logdepthbuf_fragment$1 = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif"

	var logdepthbuf_pars_fragment$1 = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif"

	var logdepthbuf_pars_vertex$1 = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif"

	var logdepthbuf_vertex$1 = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif"

	var map_fragment$1 = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif"

	var map_pars_fragment$1 = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif"

	var map_particle_fragment$1 = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif"

	var map_particle_pars_fragment$1 = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif"

	var metalnessmap_fragment$1 = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif"

	var metalnessmap_pars_fragment$1 = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif"

	var morphnormal_vertex$1 = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif"

	var morphtarget_pars_vertex$1 = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif"

	var morphtarget_vertex$1 = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif"

	var normal_fragment_begin$1 = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;"

	var normal_fragment_maps$1 = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif"

	var normalmap_pars_fragment$1 = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif"

	var clearcoat_normal_fragment_begin$1 = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif"

	var clearcoat_normal_fragment_maps$1 = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif"

	var clearcoat_pars_fragment$1 = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif"

	var packing$1 = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}"

	var premultiplied_alpha_fragment$1 = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif"

	var project_vertex$1 = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;"

	var dithering_fragment$1 = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif"

	var dithering_pars_fragment$1 = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif"

	var roughnessmap_fragment$1 = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif"

	var roughnessmap_pars_fragment$1 = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif"

	var shadowmap_pars_fragment$1 = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif"

	var shadowmap_pars_vertex$1 = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif"

	var shadowmap_vertex$1 = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif"

	var shadowmask_pars_fragment$1 = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}"

	var skinbase_vertex$1 = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif"

	var skinning_pars_vertex$1 = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif"

	var skinning_vertex$1 = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif"

	var skinnormal_vertex$1 = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif"

	var specularmap_fragment$1 = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif"

	var specularmap_pars_fragment$1 = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif"

	var tonemapping_fragment$1 = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif"

	var tonemapping_pars_fragment$1 = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }"

	var transmission_fragment$1 = "#ifdef USE_TRANSMISSION\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif"

	var transmission_pars_fragment$1 = "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif"

	var uv_pars_fragment$1 = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif"

	var uv_pars_vertex$1 = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif"

	var uv_vertex$1 = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif"

	var uv2_pars_fragment$1 = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif"

	var uv2_pars_vertex$1 = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif"

	var uv2_vertex$1 = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif"

	var worldpos_vertex$1 = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif"

	var background_frag$1 = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}"

	var background_vert$1 = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}"

	var cube_frag$1 = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}"

	var cube_vert$1 = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}"

	var depth_frag$1 = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}"

	var depth_vert$1 = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}"

	var distanceRGBA_frag$1 = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}"

	var distanceRGBA_vert$1 = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}"

	var equirect_frag$1 = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}"

	var equirect_vert$1 = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}"

	var linedashed_frag$1 = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}"

	var linedashed_vert$1 = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"

	var meshbasic_frag$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"

	var meshbasic_vert$1 = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}"

	var meshlambert_frag$1 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"

	var meshlambert_vert$1 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}"

	var meshmatcap_frag$1 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"

	var meshmatcap_vert$1 = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t\t#ifdef USE_TANGENT\n\t\t\tvTangent = normalize( transformedTangent );\n\t\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t\t#endif\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}"

	var meshtoon_frag$1 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"

	var meshtoon_vert$1 = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}"

	var meshphong_frag$1 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"

	var meshphong_vert$1 = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}"

	var meshphysical_frag$1 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"

	var meshphysical_vert$1 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}"

	var normal_frag$1 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}"

	var normal_vert$1 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}"

	var points_frag$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}"

	var points_vert$1 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}"

	var shadow_frag$1 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"

	var shadow_vert$1 = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}"

	var sprite_frag$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"

	var sprite_vert$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"

	const ShaderChunk$1 = {
		alphamap_fragment: alphamap_fragment$1,
		alphamap_pars_fragment: alphamap_pars_fragment$1,
		alphatest_fragment: alphatest_fragment$1,
		aomap_fragment: aomap_fragment$1,
		aomap_pars_fragment: aomap_pars_fragment$1,
		begin_vertex: begin_vertex$1,
		beginnormal_vertex: beginnormal_vertex$1,
		bsdfs: bsdfs$1,
		bumpmap_pars_fragment: bumpmap_pars_fragment$1,
		clipping_planes_fragment: clipping_planes_fragment$1,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment$1,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex$1,
		clipping_planes_vertex: clipping_planes_vertex$1,
		color_fragment: color_fragment$1,
		color_pars_fragment: color_pars_fragment$1,
		color_pars_vertex: color_pars_vertex$1,
		color_vertex: color_vertex$1,
		common: common$1,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment$1,
		defaultnormal_vertex: defaultnormal_vertex$1,
		displacementmap_pars_vertex: displacementmap_pars_vertex$1,
		displacementmap_vertex: displacementmap_vertex$1,
		emissivemap_fragment: emissivemap_fragment$1,
		emissivemap_pars_fragment: emissivemap_pars_fragment$1,
		encodings_fragment: encodings_fragment$1,
		encodings_pars_fragment: encodings_pars_fragment$1,
		envmap_fragment: envmap_fragment$1,
		envmap_common_pars_fragment: envmap_common_pars_fragment$1,
		envmap_pars_fragment: envmap_pars_fragment$1,
		envmap_pars_vertex: envmap_pars_vertex$1,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment$1,
		envmap_vertex: envmap_vertex$1,
		fog_vertex: fog_vertex$1,
		fog_pars_vertex: fog_pars_vertex$1,
		fog_fragment: fog_fragment$1,
		fog_pars_fragment: fog_pars_fragment$1,
		gradientmap_pars_fragment: gradientmap_pars_fragment$1,
		lightmap_fragment: lightmap_fragment$1,
		lightmap_pars_fragment: lightmap_pars_fragment$1,
		lights_lambert_vertex: lights_lambert_vertex$1,
		lights_pars_begin: lights_pars_begin$1,
		lights_toon_fragment: lights_toon_fragment$1,
		lights_toon_pars_fragment: lights_toon_pars_fragment$1,
		lights_phong_fragment: lights_phong_fragment$1,
		lights_phong_pars_fragment: lights_phong_pars_fragment$1,
		lights_physical_fragment: lights_physical_fragment$1,
		lights_physical_pars_fragment: lights_physical_pars_fragment$1,
		lights_fragment_begin: lights_fragment_begin$1,
		lights_fragment_maps: lights_fragment_maps$1,
		lights_fragment_end: lights_fragment_end$1,
		logdepthbuf_fragment: logdepthbuf_fragment$1,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment$1,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex$1,
		logdepthbuf_vertex: logdepthbuf_vertex$1,
		map_fragment: map_fragment$1,
		map_pars_fragment: map_pars_fragment$1,
		map_particle_fragment: map_particle_fragment$1,
		map_particle_pars_fragment: map_particle_pars_fragment$1,
		metalnessmap_fragment: metalnessmap_fragment$1,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment$1,
		morphnormal_vertex: morphnormal_vertex$1,
		morphtarget_pars_vertex: morphtarget_pars_vertex$1,
		morphtarget_vertex: morphtarget_vertex$1,
		normal_fragment_begin: normal_fragment_begin$1,
		normal_fragment_maps: normal_fragment_maps$1,
		normalmap_pars_fragment: normalmap_pars_fragment$1,
		clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin$1,
		clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps$1,
		clearcoat_pars_fragment: clearcoat_pars_fragment$1,
		packing: packing$1,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment$1,
		project_vertex: project_vertex$1,
		dithering_fragment: dithering_fragment$1,
		dithering_pars_fragment: dithering_pars_fragment$1,
		roughnessmap_fragment: roughnessmap_fragment$1,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment$1,
		shadowmap_pars_fragment: shadowmap_pars_fragment$1,
		shadowmap_pars_vertex: shadowmap_pars_vertex$1,
		shadowmap_vertex: shadowmap_vertex$1,
		shadowmask_pars_fragment: shadowmask_pars_fragment$1,
		skinbase_vertex: skinbase_vertex$1,
		skinning_pars_vertex: skinning_pars_vertex$1,
		skinning_vertex: skinning_vertex$1,
		skinnormal_vertex: skinnormal_vertex$1,
		specularmap_fragment: specularmap_fragment$1,
		specularmap_pars_fragment: specularmap_pars_fragment$1,
		tonemapping_fragment: tonemapping_fragment$1,
		tonemapping_pars_fragment: tonemapping_pars_fragment$1,
		transmission_fragment: transmission_fragment$1,
		transmission_pars_fragment: transmission_pars_fragment$1,
		uv_pars_fragment: uv_pars_fragment$1,
		uv_pars_vertex: uv_pars_vertex$1,
		uv_vertex: uv_vertex$1,
		uv2_pars_fragment: uv2_pars_fragment$1,
		uv2_pars_vertex: uv2_pars_vertex$1,
		uv2_vertex: uv2_vertex$1,
		worldpos_vertex: worldpos_vertex$1,

		background_frag: background_frag$1,
		background_vert: background_vert$1,
		cube_frag: cube_frag$1,
		cube_vert: cube_vert$1,
		depth_frag: depth_frag$1,
		depth_vert: depth_vert$1,
		distanceRGBA_frag: distanceRGBA_frag$1,
		distanceRGBA_vert: distanceRGBA_vert$1,
		equirect_frag: equirect_frag$1,
		equirect_vert: equirect_vert$1,
		linedashed_frag: linedashed_frag$1,
		linedashed_vert: linedashed_vert$1,
		meshbasic_frag: meshbasic_frag$1,
		meshbasic_vert: meshbasic_vert$1,
		meshlambert_frag: meshlambert_frag$1,
		meshlambert_vert: meshlambert_vert$1,
		meshmatcap_frag: meshmatcap_frag$1,
		meshmatcap_vert: meshmatcap_vert$1,
		meshtoon_frag: meshtoon_frag$1,
		meshtoon_vert: meshtoon_vert$1,
		meshphong_frag: meshphong_frag$1,
		meshphong_vert: meshphong_vert$1,
		meshphysical_frag: meshphysical_frag$1,
		meshphysical_vert: meshphysical_vert$1,
		normal_frag: normal_frag$1,
		normal_vert: normal_vert$1,
		points_frag: points_frag$1,
		points_vert: points_vert$1,
		shadow_frag: shadow_frag$1,
		shadow_vert: shadow_vert$1,
		sprite_frag: sprite_frag$1,
		sprite_vert: sprite_vert$1
	}

	/**
	 * Uniforms library for shared webgl shaders
	 */

	const UniformsLib$1 = {

		common: {

			diffuse: { value: new Color(0xffffff) },
			opacity: { value: 1.0 },

			map: { value: null },
			uvTransform: { value: new Matrix3() },
			uv2Transform: { value: new Matrix3() },

			alphaMap: { value: null },

		},

		specularmap: {

			specularMap: { value: null },

		},

		envmap: {

			envMap: { value: null },
			flipEnvMap: { value: - 1 },
			reflectivity: { value: 1.0 },
			refractionRatio: { value: 0.98 },
			maxMipLevel: { value: 0 }

		},

		aomap: {

			aoMap: { value: null },
			aoMapIntensity: { value: 1 }

		},

		lightmap: {

			lightMap: { value: null },
			lightMapIntensity: { value: 1 }

		},

		emissivemap: {

			emissiveMap: { value: null }

		},

		bumpmap: {

			bumpMap: { value: null },
			bumpScale: { value: 1 }

		},

		normalmap: {

			normalMap: { value: null },
			normalScale: { value: new Vector2(1, 1) }

		},

		displacementmap: {

			displacementMap: { value: null },
			displacementScale: { value: 1 },
			displacementBias: { value: 0 }

		},

		roughnessmap: {

			roughnessMap: { value: null }

		},

		metalnessmap: {

			metalnessMap: { value: null }

		},

		gradientmap: {

			gradientMap: { value: null }

		},

		fog: {

			fogDensity: { value: 0.00025 },
			fogNear: { value: 1 },
			fogFar: { value: 2000 },
			fogColor: { value: new Color(0xffffff) }

		},

		lights: {

			ambientLightColor: { value: [] },

			lightProbe: { value: [] },

			directionalLights: {
				value: [], properties: {
					direction: {},
					color: {}
				}
			},

			directionalLightShadows: {
				value: [], properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},

			directionalShadowMap: { value: [] },
			directionalShadowMatrix: { value: [] },

			spotLights: {
				value: [], properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {}
				}
			},

			spotLightShadows: {
				value: [], properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},

			spotShadowMap: { value: [] },
			spotShadowMatrix: { value: [] },

			pointLights: {
				value: [], properties: {
					color: {},
					position: {},
					decay: {},
					distance: {}
				}
			},

			pointLightShadows: {
				value: [], properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {},
					shadowCameraNear: {},
					shadowCameraFar: {}
				}
			},

			pointShadowMap: { value: [] },
			pointShadowMatrix: { value: [] },

			hemisphereLights: {
				value: [], properties: {
					direction: {},
					skyColor: {},
					groundColor: {}
				}
			},

			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: {
				value: [], properties: {
					color: {},
					position: {},
					width: {},
					height: {}
				}
			},

			ltc_1: { value: null },
			ltc_2: { value: null }

		},

		points: {

			diffuse: { value: new Color(0xffffff) },
			opacity: { value: 1.0 },
			size: { value: 1.0 },
			scale: { value: 1.0 },
			map: { value: null },
			alphaMap: { value: null },
			uvTransform: { value: new Matrix3() }

		},

		sprite: {

			diffuse: { value: new Color(0xffffff) },
			opacity: { value: 1.0 },
			center: { value: new Vector2(0.5, 0.5) },
			rotation: { value: 0.0 },
			map: { value: null },
			alphaMap: { value: null },
			uvTransform: { value: new Matrix3() }

		}

	}

	const ShaderLib$1 = {

		basic: {

			uniforms: mergeUniforms$1([
				UniformsLib$1.common,
				UniformsLib$1.specularmap,
				UniformsLib$1.envmap,
				UniformsLib$1.aomap,
				UniformsLib$1.lightmap,
				UniformsLib$1.fog
			]),

			vertexShader: ShaderChunk$1.meshbasic_vert,
			fragmentShader: ShaderChunk$1.meshbasic_frag

		},

		lambert: {

			uniforms: mergeUniforms$1([
				UniformsLib$1.common,
				UniformsLib$1.specularmap,
				UniformsLib$1.envmap,
				UniformsLib$1.aomap,
				UniformsLib$1.lightmap,
				UniformsLib$1.emissivemap,
				UniformsLib$1.fog,
				UniformsLib$1.lights,
				{
					emissive: { value: new Color(0x000000) }
				}
			]),

			vertexShader: ShaderChunk$1.meshlambert_vert,
			fragmentShader: ShaderChunk$1.meshlambert_frag

		},

		phong: {

			uniforms: mergeUniforms$1([
				UniformsLib$1.common,
				UniformsLib$1.specularmap,
				UniformsLib$1.envmap,
				UniformsLib$1.aomap,
				UniformsLib$1.lightmap,
				UniformsLib$1.emissivemap,
				UniformsLib$1.bumpmap,
				UniformsLib$1.normalmap,
				UniformsLib$1.displacementmap,
				UniformsLib$1.fog,
				UniformsLib$1.lights,
				{
					emissive: { value: new Color(0x000000) },
					specular: { value: new Color(0x111111) },
					shininess: { value: 30 }
				}
			]),

			vertexShader: ShaderChunk$1.meshphong_vert,
			fragmentShader: ShaderChunk$1.meshphong_frag

		},

		standard: {

			uniforms: mergeUniforms$1([
				UniformsLib$1.common,
				UniformsLib$1.envmap,
				UniformsLib$1.aomap,
				UniformsLib$1.lightmap,
				UniformsLib$1.emissivemap,
				UniformsLib$1.bumpmap,
				UniformsLib$1.normalmap,
				UniformsLib$1.displacementmap,
				UniformsLib$1.roughnessmap,
				UniformsLib$1.metalnessmap,
				UniformsLib$1.fog,
				UniformsLib$1.lights,
				{
					emissive: { value: new Color(0x000000) },
					roughness: { value: 1.0 },
					metalness: { value: 0.0 },
					envMapIntensity: { value: 1 } // temporary
				}
			]),

			vertexShader: ShaderChunk$1.meshphysical_vert,
			fragmentShader: ShaderChunk$1.meshphysical_frag

		},

		toon: {

			uniforms: mergeUniforms$1([
				UniformsLib$1.common,
				UniformsLib$1.aomap,
				UniformsLib$1.lightmap,
				UniformsLib$1.emissivemap,
				UniformsLib$1.bumpmap,
				UniformsLib$1.normalmap,
				UniformsLib$1.displacementmap,
				UniformsLib$1.gradientmap,
				UniformsLib$1.fog,
				UniformsLib$1.lights,
				{
					emissive: { value: new Color(0x000000) }
				}
			]),

			vertexShader: ShaderChunk$1.meshtoon_vert,
			fragmentShader: ShaderChunk$1.meshtoon_frag

		},

		matcap: {

			uniforms: mergeUniforms$1([
				UniformsLib$1.common,
				UniformsLib$1.bumpmap,
				UniformsLib$1.normalmap,
				UniformsLib$1.displacementmap,
				UniformsLib$1.fog,
				{
					matcap: { value: null }
				}
			]),

			vertexShader: ShaderChunk$1.meshmatcap_vert,
			fragmentShader: ShaderChunk$1.meshmatcap_frag

		},

		points: {

			uniforms: mergeUniforms$1([
				UniformsLib$1.points,
				UniformsLib$1.fog
			]),

			vertexShader: ShaderChunk$1.points_vert,
			fragmentShader: ShaderChunk$1.points_frag

		},

		dashed: {

			uniforms: mergeUniforms$1([
				UniformsLib$1.common,
				UniformsLib$1.fog,
				{
					scale: { value: 1 },
					dashSize: { value: 1 },
					totalSize: { value: 2 }
				}
			]),

			vertexShader: ShaderChunk$1.linedashed_vert,
			fragmentShader: ShaderChunk$1.linedashed_frag

		},

		depth: {

			uniforms: mergeUniforms$1([
				UniformsLib$1.common,
				UniformsLib$1.displacementmap
			]),

			vertexShader: ShaderChunk$1.depth_vert,
			fragmentShader: ShaderChunk$1.depth_frag

		},

		normal: {

			uniforms: mergeUniforms$1([
				UniformsLib$1.common,
				UniformsLib$1.bumpmap,
				UniformsLib$1.normalmap,
				UniformsLib$1.displacementmap,
				{
					opacity: { value: 1.0 }
				}
			]),

			vertexShader: ShaderChunk$1.normal_vert,
			fragmentShader: ShaderChunk$1.normal_frag

		},

		sprite: {

			uniforms: mergeUniforms$1([
				UniformsLib$1.sprite,
				UniformsLib$1.fog
			]),

			vertexShader: ShaderChunk$1.sprite_vert,
			fragmentShader: ShaderChunk$1.sprite_frag

		},

		background: {

			uniforms: {
				uvTransform: { value: new Matrix3() },
				t2D: { value: null },
			},

			vertexShader: ShaderChunk$1.background_vert,
			fragmentShader: ShaderChunk$1.background_frag

		},
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		cube: {

			uniforms: mergeUniforms$1([
				UniformsLib$1.envmap,
				{
					opacity: { value: 1.0 }
				}
			]),

			vertexShader: ShaderChunk$1.cube_vert,
			fragmentShader: ShaderChunk$1.cube_frag

		},

		equirect: {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: ShaderChunk$1.equirect_vert,
			fragmentShader: ShaderChunk$1.equirect_frag

		},

		distanceRGBA: {

			uniforms: mergeUniforms$1([
				UniformsLib$1.common,
				UniformsLib$1.displacementmap,
				{
					referencePosition: { value: new Vector3() },
					nearDistance: { value: 1 },
					farDistance: { value: 1000 }
				}
			]),

			vertexShader: ShaderChunk$1.distanceRGBA_vert,
			fragmentShader: ShaderChunk$1.distanceRGBA_frag

		},

		shadow: {

			uniforms: mergeUniforms$1([
				UniformsLib$1.lights,
				UniformsLib$1.fog,
				{
					color: { value: new Color(0x00000) },
					opacity: { value: 1.0 }
				},
			]),

			vertexShader: ShaderChunk$1.shadow_vert,
			fragmentShader: ShaderChunk$1.shadow_frag

		}

	}

	ShaderLib$1.physical = {

		uniforms: mergeUniforms$1([
			ShaderLib$1.standard.uniforms,
			{
				clearcoat: { value: 0 },
				clearcoatMap: { value: null },
				clearcoatRoughness: { value: 0 },
				clearcoatRoughnessMap: { value: null },
				clearcoatNormalScale: { value: new Vector2(1, 1) },
				clearcoatNormalMap: { value: null },
				sheen: { value: new Color(0x000000) },
				transmission: { value: 0 },
				transmissionMap: { value: null },
				transmissionSamplerSize: { value: new Vector2() },
				transmissionSamplerMap: { value: null },
				thickness: { value: 0 },
				thicknessMap: { value: null },
				attenuationDistance: { value: 0 },
				attenuationTint: { value: new Color(0x000000) },
				specularIntensity: { value: 0 },
				specularIntensityMap: { value: null },
				specularTint: { value: new Color(1, 1, 1) },
				specularTintMap: { value: null },
			}
		]),

		vertexShader: ShaderChunk$1.meshphysical_vert,
		fragmentShader: ShaderChunk$1.meshphysical_frag

	}

	function WebGLBackground$1 (renderer, cubemaps, state, objects, premultipliedAlpha) {

		const clearColor = new Color(0x000000)
		let clearAlpha = 0

		let planeMesh
		let boxMesh

		let currentBackground = null
		let currentBackgroundVersion = 0
		let currentTonemapping = null

		function render (renderList, scene) {

			let forceClear = false
			let background = scene.isScene === true ? scene.background : null

			if (background && background.isTexture) {

				background = cubemaps.get(background)

			}

			// Ignore background in AR
			// TODO: Reconsider this.

			const xr = renderer.xr
			const session = xr.getSession && xr.getSession()

			if (session && session.environmentBlendMode === 'additive') {

				background = null

			}

			if (background === null) {

				setClear(clearColor, clearAlpha)

			} else if (background && background.isColor) {

				setClear(background, 1)
				forceClear = true

			}

			if (renderer.autoClear || forceClear) {

				renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil)

			}

			if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {

				if (boxMesh === undefined) {

					boxMesh = new Mesh(
						new BoxGeometry(1, 1, 1),
						new ShaderMaterial({
							name: 'BackgroundCubeMaterial',
							uniforms: cloneUniforms$1(ShaderLib$1.cube.uniforms),
							vertexShader: ShaderLib$1.cube.vertexShader,
							fragmentShader: ShaderLib$1.cube.fragmentShader,
							side: BackSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						})
					)

					boxMesh.geometry.deleteAttribute('normal')
					boxMesh.geometry.deleteAttribute('uv')

					boxMesh.onBeforeRender = function (renderer, scene, camera) {

						this.matrixWorld.copyPosition(camera.matrixWorld)

					}

					// enable code injection for non-built-in material
					Object.defineProperty(boxMesh.material, 'envMap', {

						get: function () {

							return this.uniforms.envMap.value

						}

					})

					objects.update(boxMesh)

				}

				boxMesh.material.uniforms.envMap.value = background
				boxMesh.material.uniforms.flipEnvMap.value = (background.isCubeTexture && background.isRenderTargetTexture === false) ? - 1 : 1

				if (currentBackground !== background ||
					currentBackgroundVersion !== background.version ||
					currentTonemapping !== renderer.toneMapping) {

					boxMesh.material.needsUpdate = true

					currentBackground = background
					currentBackgroundVersion = background.version
					currentTonemapping = renderer.toneMapping

				}

				// push to the pre-sorted opaque render list
				renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null)

			} else if (background && background.isTexture) {

				if (planeMesh === undefined) {

					planeMesh = new Mesh(
						new PlaneGeometry(2, 2),
						new ShaderMaterial({
							name: 'BackgroundMaterial',
							uniforms: cloneUniforms$1(ShaderLib$1.background.uniforms),
							vertexShader: ShaderLib$1.background.vertexShader,
							fragmentShader: ShaderLib$1.background.fragmentShader,
							side: FrontSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						})
					)

					planeMesh.geometry.deleteAttribute('normal')

					// enable code injection for non-built-in material
					Object.defineProperty(planeMesh.material, 'map', {

						get: function () {

							return this.uniforms.t2D.value

						}

					})

					objects.update(planeMesh)

				}

				planeMesh.material.uniforms.t2D.value = background

				if (background.matrixAutoUpdate === true) {

					background.updateMatrix()

				}

				planeMesh.material.uniforms.uvTransform.value.copy(background.matrix)

				if (currentBackground !== background ||
					currentBackgroundVersion !== background.version ||
					currentTonemapping !== renderer.toneMapping) {

					planeMesh.material.needsUpdate = true

					currentBackground = background
					currentBackgroundVersion = background.version
					currentTonemapping = renderer.toneMapping

				}


				// push to the pre-sorted opaque render list
				renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null)

			}

		}

		function setClear (color, alpha) {

			state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha)

		}

		return {

			getClearColor: function () {

				return clearColor

			},
			setClearColor: function (color, alpha = 1) {

				clearColor.set(color)
				clearAlpha = alpha
				setClear(clearColor, clearAlpha)

			},
			getClearAlpha: function () {

				return clearAlpha

			},
			setClearAlpha: function (alpha) {

				clearAlpha = alpha
				setClear(clearColor, clearAlpha)

			},
			render: render

		}

	}

	function WebGLBindingStates$1 (gl, extensions, attributes, capabilities) {

		const maxVertexAttributes = gl.getParameter(34921)

		const extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object')
		const vaoAvailable = capabilities.isWebGL2 || extension !== null

		const bindingStates = {}

		const defaultState = createBindingState(null)
		let currentState = defaultState

		function setup (object, material, program, geometry, index) {

			let updateBuffers = false

			if (vaoAvailable) {

				const state = getBindingState(geometry, program, material)

				if (currentState !== state) {

					currentState = state
					bindVertexArrayObject(currentState.object)

				}

				updateBuffers = needsUpdate(geometry, index)

				if (updateBuffers) saveCache(geometry, index)

			} else {

				const wireframe = (material.wireframe === true)

				if (currentState.geometry !== geometry.id ||
					currentState.program !== program.id ||
					currentState.wireframe !== wireframe) {

					currentState.geometry = geometry.id
					currentState.program = program.id
					currentState.wireframe = wireframe

					updateBuffers = true

				}

			}

			if (object.isInstancedMesh === true) {

				updateBuffers = true

			}

			if (index !== null) {

				attributes.update(index, 34963)

			}

			if (updateBuffers) {

				setupVertexAttributes(object, material, program, geometry)

				if (index !== null) {

					gl.bindBuffer(34963, attributes.get(index).buffer)

				}

			}

		}

		function createVertexArrayObject () {

			if (capabilities.isWebGL2) return gl.createVertexArray()

			return extension.createVertexArrayOES()

		}

		function bindVertexArrayObject (vao) {

			if (capabilities.isWebGL2) return gl.bindVertexArray(vao)

			return extension.bindVertexArrayOES(vao)

		}

		function deleteVertexArrayObject (vao) {

			if (capabilities.isWebGL2) return gl.deleteVertexArray(vao)

			return extension.deleteVertexArrayOES(vao)

		}

		function getBindingState (geometry, program, material) {

			const wireframe = (material.wireframe === true)

			let programMap = bindingStates[geometry.id]

			if (programMap === undefined) {

				programMap = {}
				bindingStates[geometry.id] = programMap

			}

			let stateMap = programMap[program.id]

			if (stateMap === undefined) {

				stateMap = {}
				programMap[program.id] = stateMap

			}

			let state = stateMap[wireframe]

			if (state === undefined) {

				state = createBindingState(createVertexArrayObject())
				stateMap[wireframe] = state

			}

			return state

		}

		function createBindingState (vao) {

			const newAttributes = []
			const enabledAttributes = []
			const attributeDivisors = []

			for (let i = 0; i < maxVertexAttributes; i++) {

				newAttributes[i] = 0
				enabledAttributes[i] = 0
				attributeDivisors[i] = 0

			}

			return {

				// for backward compatibility on non-VAO support browser
				geometry: null,
				program: null,
				wireframe: false,

				newAttributes: newAttributes,
				enabledAttributes: enabledAttributes,
				attributeDivisors: attributeDivisors,
				object: vao,
				attributes: {},
				index: null

			}

		}

		function needsUpdate (geometry, index) {

			const cachedAttributes = currentState.attributes
			const geometryAttributes = geometry.attributes

			let attributesNum = 0

			for (const key in geometryAttributes) {

				const cachedAttribute = cachedAttributes[key]
				const geometryAttribute = geometryAttributes[key]

				if (cachedAttribute === undefined) return true

				if (cachedAttribute.attribute !== geometryAttribute) return true

				if (cachedAttribute.data !== geometryAttribute.data) return true

				attributesNum++

			}

			if (currentState.attributesNum !== attributesNum) return true

			if (currentState.index !== index) return true

			return false

		}

		function saveCache (geometry, index) {

			const cache = {}
			const attributes = geometry.attributes
			let attributesNum = 0

			for (const key in attributes) {

				const attribute = attributes[key]

				const data = {}
				data.attribute = attribute

				if (attribute.data) {

					data.data = attribute.data

				}

				cache[key] = data

				attributesNum++

			}

			currentState.attributes = cache
			currentState.attributesNum = attributesNum

			currentState.index = index

		}

		function initAttributes () {

			const newAttributes = currentState.newAttributes

			for (let i = 0, il = newAttributes.length; i < il; i++) {

				newAttributes[i] = 0

			}

		}

		function enableAttribute (attribute) {

			enableAttributeAndDivisor(attribute, 0)

		}

		function enableAttributeAndDivisor (attribute, meshPerAttribute) {

			const newAttributes = currentState.newAttributes
			const enabledAttributes = currentState.enabledAttributes
			const attributeDivisors = currentState.attributeDivisors

			newAttributes[attribute] = 1

			if (enabledAttributes[attribute] === 0) {

				gl.enableVertexAttribArray(attribute)
				enabledAttributes[attribute] = 1

			}

			if (attributeDivisors[attribute] !== meshPerAttribute) {

				const extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays')

				extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute)
				attributeDivisors[attribute] = meshPerAttribute

			}

		}

		function disableUnusedAttributes () {

			const newAttributes = currentState.newAttributes
			const enabledAttributes = currentState.enabledAttributes

			for (let i = 0, il = enabledAttributes.length; i < il; i++) {

				if (enabledAttributes[i] !== newAttributes[i]) {

					gl.disableVertexAttribArray(i)
					enabledAttributes[i] = 0

				}

			}

		}

		function vertexAttribPointer (index, size, type, normalized, stride, offset) {

			if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {

				gl.vertexAttribIPointer(index, size, type, stride, offset)

			} else {

				gl.vertexAttribPointer(index, size, type, normalized, stride, offset)

			}

		}

		function setupVertexAttributes (object, material, program, geometry) {

			if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {

				if (extensions.get('ANGLE_instanced_arrays') === null) return

			}

			initAttributes()

			const geometryAttributes = geometry.attributes

			const programAttributes = program.getAttributes()

			const materialDefaultAttributeValues = material.defaultAttributeValues

			for (const name in programAttributes) {

				const programAttribute = programAttributes[name]

				if (programAttribute >= 0) {

					const geometryAttribute = geometryAttributes[name]

					if (geometryAttribute !== undefined) {

						const normalized = geometryAttribute.normalized
						const size = geometryAttribute.itemSize

						const attribute = attributes.get(geometryAttribute)

						// TODO Attribute may not be available on context restore

						if (attribute === undefined) continue

						const buffer = attribute.buffer
						const type = attribute.type
						const bytesPerElement = attribute.bytesPerElement

						if (geometryAttribute.isInterleavedBufferAttribute) {

							const data = geometryAttribute.data
							const stride = data.stride
							const offset = geometryAttribute.offset

							if (data && data.isInstancedInterleavedBuffer) {

								enableAttributeAndDivisor(programAttribute, data.meshPerAttribute)

								if (geometry._maxInstanceCount === undefined) {

									geometry._maxInstanceCount = data.meshPerAttribute * data.count

								}

							} else {

								enableAttribute(programAttribute)

							}

							gl.bindBuffer(34962, buffer)
							vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement)

						} else {

							if (geometryAttribute.isInstancedBufferAttribute) {

								enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute)

								if (geometry._maxInstanceCount === undefined) {

									geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count

								}

							} else {

								enableAttribute(programAttribute)

							}

							gl.bindBuffer(34962, buffer)
							vertexAttribPointer(programAttribute, size, type, normalized, 0, 0)

						}

					} else if (name === 'instanceMatrix') {

						const attribute = attributes.get(object.instanceMatrix)

						// TODO Attribute may not be available on context restore

						if (attribute === undefined) continue

						const buffer = attribute.buffer
						const type = attribute.type

						enableAttributeAndDivisor(programAttribute + 0, 1)
						enableAttributeAndDivisor(programAttribute + 1, 1)
						enableAttributeAndDivisor(programAttribute + 2, 1)
						enableAttributeAndDivisor(programAttribute + 3, 1)

						gl.bindBuffer(34962, buffer)

						gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0)
						gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16)
						gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32)
						gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48)

					} else if (name === 'instanceColor') {

						const attribute = attributes.get(object.instanceColor)

						// TODO Attribute may not be available on context restore

						if (attribute === undefined) continue

						const buffer = attribute.buffer
						const type = attribute.type

						enableAttributeAndDivisor(programAttribute, 1)

						gl.bindBuffer(34962, buffer)

						gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0)

					} else if (materialDefaultAttributeValues !== undefined) {

						const value = materialDefaultAttributeValues[name]

						if (value !== undefined) {

							switch (value.length) {

								case 2:
									gl.vertexAttrib2fv(programAttribute, value)
									break

								case 3:
									gl.vertexAttrib3fv(programAttribute, value)
									break

								case 4:
									gl.vertexAttrib4fv(programAttribute, value)
									break

								default:
									gl.vertexAttrib1fv(programAttribute, value)

							}

						}

					}

				}

			}

			disableUnusedAttributes()

		}

		function dispose () {

			reset()

			for (const geometryId in bindingStates) {

				const programMap = bindingStates[geometryId]

				for (const programId in programMap) {

					const stateMap = programMap[programId]

					for (const wireframe in stateMap) {

						deleteVertexArrayObject(stateMap[wireframe].object)

						delete stateMap[wireframe]

					}

					delete programMap[programId]

				}

				delete bindingStates[geometryId]

			}

		}

		function releaseStatesOfGeometry (geometry) {

			if (bindingStates[geometry.id] === undefined) return

			const programMap = bindingStates[geometry.id]

			for (const programId in programMap) {

				const stateMap = programMap[programId]

				for (const wireframe in stateMap) {

					deleteVertexArrayObject(stateMap[wireframe].object)

					delete stateMap[wireframe]

				}

				delete programMap[programId]

			}

			delete bindingStates[geometry.id]

		}

		function releaseStatesOfProgram (program) {

			for (const geometryId in bindingStates) {

				const programMap = bindingStates[geometryId]

				if (programMap[program.id] === undefined) continue

				const stateMap = programMap[program.id]

				for (const wireframe in stateMap) {

					deleteVertexArrayObject(stateMap[wireframe].object)

					delete stateMap[wireframe]

				}

				delete programMap[program.id]

			}

		}

		function reset () {

			resetDefaultState()

			if (currentState === defaultState) return

			currentState = defaultState
			bindVertexArrayObject(currentState.object)

		}

		// for backward-compatilibity

		function resetDefaultState () {

			defaultState.geometry = null
			defaultState.program = null
			defaultState.wireframe = false

		}

		return {

			setup: setup,
			reset: reset,
			resetDefaultState: resetDefaultState,
			dispose: dispose,
			releaseStatesOfGeometry: releaseStatesOfGeometry,
			releaseStatesOfProgram: releaseStatesOfProgram,

			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			disableUnusedAttributes: disableUnusedAttributes

		}

	}

	function WebGLBufferRenderer$1 (gl, extensions, info, capabilities) {

		const isWebGL2 = capabilities.isWebGL2

		let mode

		function setMode (value) {

			mode = value

		}

		function render (start, count) {

			gl.drawArrays(mode, start, count)

			info.update(count, mode, 1)

		}

		function renderInstances (start, count, primcount) {

			if (primcount === 0) return

			let extension, methodName

			if (isWebGL2) {

				extension = gl
				methodName = 'drawArraysInstanced'

			} else {

				extension = extensions.get('ANGLE_instanced_arrays')
				methodName = 'drawArraysInstancedANGLE'

				if (extension === null) {

					console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.')
					return

				}

			}

			extension[methodName](mode, start, count, primcount)

			info.update(count, mode, primcount)

		}

		//

		this.setMode = setMode
		this.render = render
		this.renderInstances = renderInstances

	}

	function WebGLCapabilities$1 (gl, extensions, parameters) {

		let maxAnisotropy

		function getMaxAnisotropy () {

			if (maxAnisotropy !== undefined) return maxAnisotropy

			if (extensions.has('EXT_texture_filter_anisotropic') === true) {

				const extension = extensions.get('EXT_texture_filter_anisotropic')

				maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT)

			} else {

				maxAnisotropy = 0

			}

			return maxAnisotropy

		}

		function getMaxPrecision (precision) {

			if (precision === 'highp') {

				if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
					gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {

					return 'highp'

				}

				precision = 'mediump'

			}

			if (precision === 'mediump') {

				if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
					gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {

					return 'mediump'

				}

			}

			return 'lowp'

		}

		/* eslint-disable no-undef */
		const isWebGL2 = (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) ||
			(typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext)
		/* eslint-enable no-undef */

		let precision = parameters.precision !== undefined ? parameters.precision : 'highp'
		const maxPrecision = getMaxPrecision(precision)

		if (maxPrecision !== precision) {

			console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.')
			precision = maxPrecision

		}

		const drawBuffers = isWebGL2 || extensions.has('WEBGL_draw_buffers')

		const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true

		const maxTextures = gl.getParameter(34930)
		const maxVertexTextures = gl.getParameter(35660)
		const maxTextureSize = gl.getParameter(3379)
		const maxCubemapSize = gl.getParameter(34076)

		const maxAttributes = gl.getParameter(34921)
		const maxVertexUniforms = gl.getParameter(36347)
		const maxVaryings = gl.getParameter(36348)
		const maxFragmentUniforms = gl.getParameter(36349)

		const vertexTextures = maxVertexTextures > 0
		const floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float')
		const floatVertexTextures = vertexTextures && floatFragmentTextures

		const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0

		return {

			isWebGL2: isWebGL2,

			drawBuffers: drawBuffers,

			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,

			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,

			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,

			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures,

			maxSamples: maxSamples

		}

	}

	function WebGLClipping$1 (properties) {

		const scope = this

		let globalState = null,
			numGlobalPlanes = 0,
			localClippingEnabled = false,
			renderingShadows = false

		const plane = new Plane(),
			viewNormalMatrix = new Matrix3(),

			uniform = { value: null, needsUpdate: false }

		this.uniform = uniform
		this.numPlanes = 0
		this.numIntersection = 0

		this.init = function (planes, enableLocalClipping, camera) {

			const enabled =
				planes.length !== 0 ||
				enableLocalClipping ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				numGlobalPlanes !== 0 ||
				localClippingEnabled

			localClippingEnabled = enableLocalClipping

			globalState = projectPlanes(planes, camera, 0)
			numGlobalPlanes = planes.length

			return enabled

		}

		this.beginShadows = function () {

			renderingShadows = true
			projectPlanes(null)

		}

		this.endShadows = function () {

			renderingShadows = false
			resetGlobalState()

		}

		this.setState = function (material, camera, useCache) {

			const planes = material.clippingPlanes,
				clipIntersection = material.clipIntersection,
				clipShadows = material.clipShadows

			const materialProperties = properties.get(material)

			if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {

				// there's no local clipping

				if (renderingShadows) {

					// there's no global clipping

					projectPlanes(null)

				} else {

					resetGlobalState()

				}

			} else {

				const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
					lGlobal = nGlobal * 4

				let dstArray = materialProperties.clippingState || null

				uniform.value = dstArray // ensure unique state

				dstArray = projectPlanes(planes, camera, lGlobal, useCache)

				for (let i = 0; i !== lGlobal; ++i) {

					dstArray[i] = globalState[i]

				}

				materialProperties.clippingState = dstArray
				this.numIntersection = clipIntersection ? this.numPlanes : 0
				this.numPlanes += nGlobal

			}


		}

		function resetGlobalState () {

			if (uniform.value !== globalState) {

				uniform.value = globalState
				uniform.needsUpdate = numGlobalPlanes > 0

			}

			scope.numPlanes = numGlobalPlanes
			scope.numIntersection = 0

		}

		function projectPlanes (planes, camera, dstOffset, skipTransform) {

			const nPlanes = planes !== null ? planes.length : 0
			let dstArray = null

			if (nPlanes !== 0) {

				dstArray = uniform.value

				if (skipTransform !== true || dstArray === null) {

					const flatSize = dstOffset + nPlanes * 4,
						viewMatrix = camera.matrixWorldInverse

					viewNormalMatrix.getNormalMatrix(viewMatrix)

					if (dstArray === null || dstArray.length < flatSize) {

						dstArray = new Float32Array(flatSize)

					}

					for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {

						plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix)

						plane.normal.toArray(dstArray, i4)
						dstArray[i4 + 3] = plane.constant

					}

				}

				uniform.value = dstArray
				uniform.needsUpdate = true

			}

			scope.numPlanes = nPlanes
			scope.numIntersection = 0

			return dstArray

		}

	}

	function WebGLCubeMaps$1 (renderer) {

		let cubemaps = new WeakMap()

		function mapTextureMapping (texture, mapping) {

			if (mapping === EquirectangularReflectionMapping) {

				texture.mapping = CubeReflectionMapping

			} else if (mapping === EquirectangularRefractionMapping) {

				texture.mapping = CubeRefractionMapping

			}

			return texture

		}

		function get (texture) {

			if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {

				const mapping = texture.mapping

				if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {

					if (cubemaps.has(texture)) {

						const cubemap = cubemaps.get(texture).texture
						return mapTextureMapping(cubemap, texture.mapping)

					} else {

						const image = texture.image

						if (image && image.height > 0) {

							const currentRenderTarget = renderer.getRenderTarget()

							const renderTarget = new WebGLCubeRenderTarget(image.height / 2)
							renderTarget.fromEquirectangularTexture(renderer, texture)
							cubemaps.set(texture, renderTarget)

							renderer.setRenderTarget(currentRenderTarget)

							texture.addEventListener('dispose', onTextureDispose)

							return mapTextureMapping(renderTarget.texture, texture.mapping)

						} else {

							// image not yet ready. try the conversion next frame

							return null

						}

					}

				}

			}

			return texture

		}

		function onTextureDispose (event) {

			const texture = event.target

			texture.removeEventListener('dispose', onTextureDispose)

			const cubemap = cubemaps.get(texture)

			if (cubemap !== undefined) {

				cubemaps.delete(texture)
				cubemap.dispose()

			}

		}

		function dispose () {

			cubemaps = new WeakMap()

		}

		return {
			get: get,
			dispose: dispose
		}

	}

	class OrthographicCamera extends Camera {

		constructor(left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000) {

			super()

			this.type = 'OrthographicCamera'

			this.zoom = 1
			this.view = null

			this.left = left
			this.right = right
			this.top = top
			this.bottom = bottom

			this.near = near
			this.far = far

			this.updateProjectionMatrix()

		}

		copy (source, recursive) {

			super.copy(source, recursive)

			this.left = source.left
			this.right = source.right
			this.top = source.top
			this.bottom = source.bottom
			this.near = source.near
			this.far = source.far

			this.zoom = source.zoom
			this.view = source.view === null ? null : Object.assign({}, source.view)

			return this

		}

		setViewOffset (fullWidth, fullHeight, x, y, width, height) {

			if (this.view === null) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				}

			}

			this.view.enabled = true
			this.view.fullWidth = fullWidth
			this.view.fullHeight = fullHeight
			this.view.offsetX = x
			this.view.offsetY = y
			this.view.width = width
			this.view.height = height

			this.updateProjectionMatrix()

		}

		clearViewOffset () {

			if (this.view !== null) {

				this.view.enabled = false

			}

			this.updateProjectionMatrix()

		}

		updateProjectionMatrix () {

			const dx = (this.right - this.left) / (2 * this.zoom)
			const dy = (this.top - this.bottom) / (2 * this.zoom)
			const cx = (this.right + this.left) / 2
			const cy = (this.top + this.bottom) / 2

			let left = cx - dx
			let right = cx + dx
			let top = cy + dy
			let bottom = cy - dy

			if (this.view !== null && this.view.enabled) {

				const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom
				const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom

				left += scaleW * this.view.offsetX
				right = left + scaleW * this.view.width
				top -= scaleH * this.view.offsetY
				bottom = top - scaleH * this.view.height

			}

			this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far)

			this.projectionMatrixInverse.copy(this.projectionMatrix).invert()

		}

		toJSON (meta) {

			const data = super.toJSON(meta)

			data.object.zoom = this.zoom
			data.object.left = this.left
			data.object.right = this.right
			data.object.top = this.top
			data.object.bottom = this.bottom
			data.object.near = this.near
			data.object.far = this.far

			if (this.view !== null) data.object.view = Object.assign({}, this.view)

			return data

		}

	}

	OrthographicCamera.prototype.isOrthographicCamera = true

	class RawShaderMaterial extends ShaderMaterial {

		constructor(parameters) {

			super(parameters)

			this.type = 'RawShaderMaterial'

		}

	}

	RawShaderMaterial.prototype.isRawShaderMaterial = true

	const LOD_MIN = 4
	const LOD_MAX = 8
	const SIZE_MAX = Math.pow(2, LOD_MAX)

	// The standard deviations (radians) associated with the extra mips. These are
	// chosen to approximate a Trowbridge-Reitz distribution function times the
	// geometric shadowing function. These sigma values squared must match the
	// variance #defines in cube_uv_reflection_fragment.glsl.js.
	const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582]

	const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length

	// The maximum length of the blur for loop. Smaller sigmas will use fewer
	// samples and exit early, but not recompile the shader.
	const MAX_SAMPLES = 20

	const ENCODINGS = {
		[LinearEncoding]: 0,
		[sRGBEncoding]: 1,
		[RGBEEncoding]: 2,
		[RGBM7Encoding]: 3,
		[RGBM16Encoding]: 4,
		[RGBDEncoding]: 5,
		[GammaEncoding]: 6
	}

	const backgroundMaterial = new MeshBasicMaterial({
		side: BackSide,
		depthWrite: false,
		depthTest: false,
	})
	const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial)

	const _flatCamera = /*@__PURE__*/ new OrthographicCamera()
	const { _lodPlanes, _sizeLods, _sigmas } = /*@__PURE__*/ _createPlanes()
	const _clearColor = /*@__PURE__*/ new Color()
	let _oldTarget = null

	// Golden Ratio
	const PHI = (1 + Math.sqrt(5)) / 2
	const INV_PHI = 1 / PHI

	// Vertices of a dodecahedron (except the opposites, which represent the
	// same axis), used as axis directions evenly spread on a sphere.
	const _axisDirections = [
		/*@__PURE__*/ new Vector3(1, 1, 1),
		/*@__PURE__*/ new Vector3(- 1, 1, 1),
		/*@__PURE__*/ new Vector3(1, 1, - 1),
		/*@__PURE__*/ new Vector3(- 1, 1, - 1),
		/*@__PURE__*/ new Vector3(0, PHI, INV_PHI),
		/*@__PURE__*/ new Vector3(0, PHI, - INV_PHI),
		/*@__PURE__*/ new Vector3(INV_PHI, 0, PHI),
		/*@__PURE__*/ new Vector3(- INV_PHI, 0, PHI),
		/*@__PURE__*/ new Vector3(PHI, INV_PHI, 0),
		/*@__PURE__*/ new Vector3(- PHI, INV_PHI, 0)]

	/**
	 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
	 * (PMREM) from a cubeMap environment texture. This allows different levels of
	 * blur to be quickly accessed based on material roughness. It is packed into a
	 * special CubeUV format that allows us to perform custom interpolation so that
	 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
	 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
	 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
	 * higher roughness levels. In this way we maintain resolution to smoothly
	 * interpolate diffuse lighting while limiting sampling computation.
	 *
	 * Paper: Fast, Accurate Image-Based Lighting
	 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
	*/

	function convertLinearToRGBE (color) {

		const maxComponent = Math.max(color.r, color.g, color.b)
		const fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), - 128.0), 127.0)
		color.multiplyScalar(Math.pow(2.0, - fExp))

		const alpha = (fExp + 128.0) / 255.0
		return alpha

	}

	class PMREMGenerator {

		constructor(renderer) {

			this._renderer = renderer
			this._pingPongRenderTarget = null

			this._blurMaterial = _getBlurShader(MAX_SAMPLES)
			this._equirectShader = null
			this._cubemapShader = null

			this._compileMaterial(this._blurMaterial)

		}

		/**
		 * Generates a PMREM from a supplied Scene, which can be faster than using an
		 * image if networking bandwidth is low. Optional sigma specifies a blur radius
		 * in radians to be applied to the scene before PMREM generation. Optional near
		 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
		 * is placed at the origin).
		 */
		fromScene (scene, sigma = 0, near = 0.1, far = 100) {

			_oldTarget = this._renderer.getRenderTarget()
			const cubeUVRenderTarget = this._allocateTargets()

			this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget)
			if (sigma > 0) {

				this._blur(cubeUVRenderTarget, 0, 0, sigma)

			}

			this._applyPMREM(cubeUVRenderTarget)
			this._cleanup(cubeUVRenderTarget)

			return cubeUVRenderTarget

		}

		/**
		 * Generates a PMREM from an equirectangular texture, which can be either LDR
		 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
		 * as this matches best with the 256 x 256 cubemap output.
		 */
		fromEquirectangular (equirectangular) {

			return this._fromTexture(equirectangular)

		}

		/**
		 * Generates a PMREM from an cubemap texture, which can be either LDR
		 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
		 * as this matches best with the 256 x 256 cubemap output.
		 */
		fromCubemap (cubemap) {

			return this._fromTexture(cubemap)

		}

		/**
		 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */
		compileCubemapShader () {

			if (this._cubemapShader === null) {

				this._cubemapShader = _getCubemapShader()
				this._compileMaterial(this._cubemapShader)

			}

		}

		/**
		 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */
		compileEquirectangularShader () {

			if (this._equirectShader === null) {

				this._equirectShader = _getEquirectShader()
				this._compileMaterial(this._equirectShader)

			}

		}

		/**
		 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
		 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
		 * one of them will cause any others to also become unusable.
		 */
		dispose () {

			this._blurMaterial.dispose()

			if (this._cubemapShader !== null) this._cubemapShader.dispose()
			if (this._equirectShader !== null) this._equirectShader.dispose()

			for (let i = 0; i < _lodPlanes.length; i++) {

				_lodPlanes[i].dispose()

			}

		}

		// private interface

		_cleanup (outputTarget) {

			this._pingPongRenderTarget.dispose()
			this._renderer.setRenderTarget(_oldTarget)
			outputTarget.scissorTest = false
			_setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height)

		}

		_fromTexture (texture) {

			_oldTarget = this._renderer.getRenderTarget()
			const cubeUVRenderTarget = this._allocateTargets(texture)
			this._textureToCubeUV(texture, cubeUVRenderTarget)
			this._applyPMREM(cubeUVRenderTarget)
			this._cleanup(cubeUVRenderTarget)

			return cubeUVRenderTarget

		}

		_allocateTargets (texture) { // warning: null texture is valid

			const params = {
				magFilter: NearestFilter,
				minFilter: NearestFilter,
				generateMipmaps: false,
				type: UnsignedByteType,
				format: RGBEFormat,
				encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
				depthBuffer: false
			}

			const cubeUVRenderTarget = _createRenderTarget(params)
			cubeUVRenderTarget.depthBuffer = texture ? false : true
			this._pingPongRenderTarget = _createRenderTarget(params)
			return cubeUVRenderTarget

		}

		_compileMaterial (material) {

			const tmpMesh = new Mesh(_lodPlanes[0], material)
			this._renderer.compile(tmpMesh, _flatCamera)

		}

		_sceneToCubeUV (scene, near, far, cubeUVRenderTarget) {

			const fov = 90
			const aspect = 1
			const cubeCamera = new PerspectiveCamera(fov, aspect, near, far)
			const upSign = [1, - 1, 1, 1, 1, 1]
			const forwardSign = [1, 1, 1, - 1, - 1, - 1]
			const renderer = this._renderer

			const originalAutoClear = renderer.autoClear
			const outputEncoding = renderer.outputEncoding
			const toneMapping = renderer.toneMapping
			renderer.getClearColor(_clearColor)

			renderer.toneMapping = NoToneMapping
			renderer.outputEncoding = LinearEncoding
			renderer.autoClear = false

			let useSolidColor = false
			const background = scene.background
			if (background) {

				if (background.isColor) {

					backgroundMaterial.color.copy(background).convertSRGBToLinear()
					scene.background = null

					const alpha = convertLinearToRGBE(backgroundMaterial.color)
					backgroundMaterial.opacity = alpha
					useSolidColor = true

				}

			} else {

				backgroundMaterial.color.copy(_clearColor).convertSRGBToLinear()

				const alpha = convertLinearToRGBE(backgroundMaterial.color)
				backgroundMaterial.opacity = alpha
				useSolidColor = true

			}


			for (let i = 0; i < 6; i++) {

				const col = i % 3
				if (col == 0) {

					cubeCamera.up.set(0, upSign[i], 0)
					cubeCamera.lookAt(forwardSign[i], 0, 0)

				} else if (col == 1) {

					cubeCamera.up.set(0, 0, upSign[i])
					cubeCamera.lookAt(0, forwardSign[i], 0)

				} else {

					cubeCamera.up.set(0, upSign[i], 0)
					cubeCamera.lookAt(0, 0, forwardSign[i])

				}

				_setViewport(cubeUVRenderTarget,
					col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX)
				renderer.setRenderTarget(cubeUVRenderTarget)

				if (useSolidColor) {

					renderer.render(backgroundBox, cubeCamera)

				}

				renderer.render(scene, cubeCamera)

			}

			renderer.toneMapping = toneMapping
			renderer.outputEncoding = outputEncoding
			renderer.autoClear = originalAutoClear

		}

		_textureToCubeUV (texture, cubeUVRenderTarget) {

			const renderer = this._renderer

			if (texture.isCubeTexture) {

				if (this._cubemapShader == null) {

					this._cubemapShader = _getCubemapShader()

				}

			} else {

				if (this._equirectShader == null) {

					this._equirectShader = _getEquirectShader()

				}

			}

			const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader
			const mesh = new Mesh(_lodPlanes[0], material)

			const uniforms = material.uniforms

			uniforms['envMap'].value = texture

			if (!texture.isCubeTexture) {

				uniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height)

			}

			uniforms['inputEncoding'].value = ENCODINGS[texture.encoding]
			uniforms['outputEncoding'].value = ENCODINGS[cubeUVRenderTarget.texture.encoding]

			_setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX)

			renderer.setRenderTarget(cubeUVRenderTarget)
			renderer.render(mesh, _flatCamera)

		}

		_applyPMREM (cubeUVRenderTarget) {

			const renderer = this._renderer
			const autoClear = renderer.autoClear
			renderer.autoClear = false

			for (let i = 1; i < TOTAL_LODS; i++) {

				const sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1])

				const poleAxis = _axisDirections[(i - 1) % _axisDirections.length]

				this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis)

			}

			renderer.autoClear = autoClear

		}

		/**
		 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
		 * vertically and horizontally, but this breaks down on a cube. Here we apply
		 * the blur latitudinally (around the poles), and then longitudinally (towards
		 * the poles) to approximate the orthogonally-separable blur. It is least
		 * accurate at the poles, but still does a decent job.
		 */
		_blur (cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {

			const pingPongRenderTarget = this._pingPongRenderTarget

			this._halfBlur(
				cubeUVRenderTarget,
				pingPongRenderTarget,
				lodIn,
				lodOut,
				sigma,
				'latitudinal',
				poleAxis)

			this._halfBlur(
				pingPongRenderTarget,
				cubeUVRenderTarget,
				lodOut,
				lodOut,
				sigma,
				'longitudinal',
				poleAxis)

		}

		_halfBlur (targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {

			const renderer = this._renderer
			const blurMaterial = this._blurMaterial

			if (direction !== 'latitudinal' && direction !== 'longitudinal') {

				console.error(
					'blur direction must be either latitudinal or longitudinal!')

			}

			// Number of standard deviations at which to cut off the discrete approximation.
			const STANDARD_DEVIATIONS = 3

			const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial)
			const blurUniforms = blurMaterial.uniforms

			const pixels = _sizeLods[lodIn] - 1
			const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1)
			const sigmaPixels = sigmaRadians / radiansPerPixel
			const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES

			if (samples > MAX_SAMPLES) {

				console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`)

			}

			const weights = []
			let sum = 0

			for (let i = 0; i < MAX_SAMPLES; ++i) {

				const x = i / sigmaPixels
				const weight = Math.exp(- x * x / 2)
				weights.push(weight)

				if (i == 0) {

					sum += weight

				} else if (i < samples) {

					sum += 2 * weight

				}

			}

			for (let i = 0; i < weights.length; i++) {

				weights[i] = weights[i] / sum

			}

			blurUniforms['envMap'].value = targetIn.texture
			blurUniforms['samples'].value = samples
			blurUniforms['weights'].value = weights
			blurUniforms['latitudinal'].value = direction === 'latitudinal'

			if (poleAxis) {

				blurUniforms['poleAxis'].value = poleAxis

			}

			blurUniforms['dTheta'].value = radiansPerPixel
			blurUniforms['mipInt'].value = LOD_MAX - lodIn
			blurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding]
			blurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding]

			const outputSize = _sizeLods[lodOut]
			const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize)
			const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0)

			_setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize)
			renderer.setRenderTarget(targetOut)
			renderer.render(blurMesh, _flatCamera)

		}

	}

	function _isLDR (texture) {

		if (texture === undefined || texture.type !== UnsignedByteType) return false

		return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding

	}

	function _createPlanes () {

		const _lodPlanes = []
		const _sizeLods = []
		const _sigmas = []

		let lod = LOD_MAX

		for (let i = 0; i < TOTAL_LODS; i++) {

			const sizeLod = Math.pow(2, lod)
			_sizeLods.push(sizeLod)
			let sigma = 1.0 / sizeLod

			if (i > LOD_MAX - LOD_MIN) {

				sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1]

			} else if (i == 0) {

				sigma = 0

			}

			_sigmas.push(sigma)

			const texelSize = 1.0 / (sizeLod - 1)
			const min = - texelSize / 2
			const max = 1 + texelSize / 2
			const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max]

			const cubeFaces = 6
			const vertices = 6
			const positionSize = 3
			const uvSize = 2
			const faceIndexSize = 1

			const position = new Float32Array(positionSize * vertices * cubeFaces)
			const uv = new Float32Array(uvSize * vertices * cubeFaces)
			const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces)

			for (let face = 0; face < cubeFaces; face++) {

				const x = (face % 3) * 2 / 3 - 1
				const y = face > 2 ? 0 : - 1
				const coordinates = [
					x, y, 0,
					x + 2 / 3, y, 0,
					x + 2 / 3, y + 1, 0,
					x, y, 0,
					x + 2 / 3, y + 1, 0,
					x, y + 1, 0
				]
				position.set(coordinates, positionSize * vertices * face)
				uv.set(uv1, uvSize * vertices * face)
				const fill = [face, face, face, face, face, face]
				faceIndex.set(fill, faceIndexSize * vertices * face)

			}

			const planes = new BufferGeometry()
			planes.setAttribute('position', new BufferAttribute(position, positionSize))
			planes.setAttribute('uv', new BufferAttribute(uv, uvSize))
			planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize))
			_lodPlanes.push(planes)

			if (lod > LOD_MIN) {

				lod--

			}

		}

		return { _lodPlanes, _sizeLods, _sigmas }

	}

	function _createRenderTarget (params) {

		const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params)
		cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping
		cubeUVRenderTarget.texture.name = 'PMREM.cubeUv'
		cubeUVRenderTarget.scissorTest = true
		return cubeUVRenderTarget

	}

	function _setViewport (target, x, y, width, height) {

		target.viewport.set(x, y, width, height)
		target.scissor.set(x, y, width, height)

	}

	function _getBlurShader (maxSamples) {

		const weights = new Float32Array(maxSamples)
		const poleAxis = new Vector3(0, 1, 0)
		const shaderMaterial = new RawShaderMaterial({

			name: 'SphericalGaussianBlur',

			defines: { 'n': maxSamples },

			uniforms: {
				'envMap': { value: null },
				'samples': { value: 1 },
				'weights': { value: weights },
				'latitudinal': { value: false },
				'dTheta': { value: 0 },
				'mipInt': { value: 0 },
				'poleAxis': { value: poleAxis },
				'inputEncoding': { value: ENCODINGS[LinearEncoding] },
				'outputEncoding': { value: ENCODINGS[LinearEncoding] }
			},

			vertexShader: _getCommonVertexShader(),

			fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

			blending: NoBlending,
			depthTest: false,
			depthWrite: false

		})

		return shaderMaterial

	}

	function _getEquirectShader () {

		const texelSize = new Vector2(1, 1)
		const shaderMaterial = new RawShaderMaterial({

			name: 'EquirectangularToCubeUV',

			uniforms: {
				'envMap': { value: null },
				'texelSize': { value: texelSize },
				'inputEncoding': { value: ENCODINGS[LinearEncoding] },
				'outputEncoding': { value: ENCODINGS[LinearEncoding] }
			},

			vertexShader: _getCommonVertexShader(),

			fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

			blending: NoBlending,
			depthTest: false,
			depthWrite: false

		})

		return shaderMaterial

	}

	function _getCubemapShader () {

		const shaderMaterial = new RawShaderMaterial({

			name: 'CubemapToCubeUV',

			uniforms: {
				'envMap': { value: null },
				'inputEncoding': { value: ENCODINGS[LinearEncoding] },
				'outputEncoding': { value: ENCODINGS[LinearEncoding] }
			},

			vertexShader: _getCommonVertexShader(),

			fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

			blending: NoBlending,
			depthTest: false,
			depthWrite: false

		})

		return shaderMaterial

	}

	function _getCommonVertexShader () {

		return /* glsl */`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`

	}

	function _getEncodings () {

		return /* glsl */`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`

	}

	function WebGLCubeUVMaps$1 (renderer) {

		let cubeUVmaps = new WeakMap()

		let pmremGenerator = null

		function get (texture) {

			if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {

				const mapping = texture.mapping

				const isEquirectMap = (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping)
				const isCubeMap = (mapping === CubeReflectionMapping || mapping === CubeRefractionMapping)

				if (isEquirectMap || isCubeMap) {

					// equirect/cube map to cubeUV conversion

					if (cubeUVmaps.has(texture)) {

						return cubeUVmaps.get(texture).texture

					} else {

						const image = texture.image

						if ((isEquirectMap && image && image.height > 0) || (isCubeMap && image && isCubeTextureComplete(image))) {

							const currentRenderTarget = renderer.getRenderTarget()

							if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer)

							const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture)
							cubeUVmaps.set(texture, renderTarget)

							renderer.setRenderTarget(currentRenderTarget)

							texture.addEventListener('dispose', onTextureDispose)

							return renderTarget.texture

						} else {

							// image not yet ready. try the conversion next frame

							return null

						}

					}

				}

			}

			return texture

		}

		function isCubeTextureComplete (image) {

			let count = 0
			const length = 6

			for (let i = 0; i < length; i++) {

				if (image[i] !== undefined) count++

			}

			return count === length


		}

		function onTextureDispose (event) {

			const texture = event.target

			texture.removeEventListener('dispose', onTextureDispose)

			const cubemapUV = cubeUVmaps.get(texture)

			if (cubemapUV !== undefined) {

				cubemapUV.delete(texture)
				cubemapUV.dispose()

			}

		}

		function dispose () {

			cubeUVmaps = new WeakMap()

			if (pmremGenerator !== null) {

				pmremGenerator.dispose()
				pmremGenerator = null

			}

		}

		return {
			get: get,
			dispose: dispose
		}

	}

	function WebGLExtensions$1 (gl) {

		const extensions = {}

		function getExtension (name) {

			if (extensions[name] !== undefined) {

				return extensions[name]

			}

			let extension

			switch (name) {

				case 'WEBGL_depth_texture':
					extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture')
					break

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic')
					break

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc')
					break

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc')
					break

				default:
					extension = gl.getExtension(name)

			}

			extensions[name] = extension

			return extension

		}

		return {

			has: function (name) {

				return getExtension(name) !== null

			},

			init: function (capabilities) {

				if (capabilities.isWebGL2) {

					getExtension('EXT_color_buffer_float')

				} else {

					getExtension('WEBGL_depth_texture')
					getExtension('OES_texture_float')
					getExtension('OES_texture_half_float')
					getExtension('OES_texture_half_float_linear')
					getExtension('OES_standard_derivatives')
					getExtension('OES_element_index_uint')
					getExtension('OES_vertex_array_object')
					getExtension('ANGLE_instanced_arrays')

				}

				getExtension('OES_texture_float_linear')
				getExtension('EXT_color_buffer_half_float')

			},

			get: function (name) {

				const extension = getExtension(name)

				if (extension === null) {

					console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.')

				}

				return extension

			}

		}

	}

	function WebGLGeometries$1 (gl, attributes, info, bindingStates) {

		const geometries = {}
		const wireframeAttributes = new WeakMap()

		function onGeometryDispose (event) {

			const geometry = event.target

			if (geometry.index !== null) {

				attributes.remove(geometry.index)

			}

			for (const name in geometry.attributes) {

				attributes.remove(geometry.attributes[name])

			}

			geometry.removeEventListener('dispose', onGeometryDispose)

			delete geometries[geometry.id]

			const attribute = wireframeAttributes.get(geometry)

			if (attribute) {

				attributes.remove(attribute)
				wireframeAttributes.delete(geometry)

			}

			bindingStates.releaseStatesOfGeometry(geometry)

			if (geometry.isInstancedBufferGeometry === true) {

				delete geometry._maxInstanceCount

			}

			//

			info.memory.geometries--

		}

		function get (object, geometry) {

			if (geometries[geometry.id] === true) return geometry

			geometry.addEventListener('dispose', onGeometryDispose)

			geometries[geometry.id] = true

			info.memory.geometries++

			return geometry

		}

		function update (geometry) {

			const geometryAttributes = geometry.attributes

			// Updating index buffer in VAO now. See WebGLBindingStates.

			for (const name in geometryAttributes) {

				attributes.update(geometryAttributes[name], 34962)

			}

			// morph targets

			const morphAttributes = geometry.morphAttributes

			for (const name in morphAttributes) {

				const array = morphAttributes[name]

				for (let i = 0, l = array.length; i < l; i++) {

					attributes.update(array[i], 34962)

				}

			}

		}

		function updateWireframeAttribute (geometry) {

			const indices = []

			const geometryIndex = geometry.index
			const geometryPosition = geometry.attributes.position
			let version = 0

			if (geometryIndex !== null) {

				const array = geometryIndex.array
				version = geometryIndex.version

				for (let i = 0, l = array.length; i < l; i += 3) {

					const a = array[i + 0]
					const b = array[i + 1]
					const c = array[i + 2]

					indices.push(a, b, b, c, c, a)

				}

			} else {

				const array = geometryPosition.array
				version = geometryPosition.version

				for (let i = 0, l = (array.length / 3) - 1; i < l; i += 3) {

					const a = i + 0
					const b = i + 1
					const c = i + 2

					indices.push(a, b, b, c, c, a)

				}

			}

			const attribute = new (arrayMax$1(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1)
			attribute.version = version

			// Updating index buffer in VAO now. See WebGLBindingStates

			//

			const previousAttribute = wireframeAttributes.get(geometry)

			if (previousAttribute) attributes.remove(previousAttribute)

			//

			wireframeAttributes.set(geometry, attribute)

		}

		function getWireframeAttribute (geometry) {

			const currentAttribute = wireframeAttributes.get(geometry)

			if (currentAttribute) {

				const geometryIndex = geometry.index

				if (geometryIndex !== null) {

					// if the attribute is obsolete, create a new one

					if (currentAttribute.version < geometryIndex.version) {

						updateWireframeAttribute(geometry)

					}

				}

			} else {

				updateWireframeAttribute(geometry)

			}

			return wireframeAttributes.get(geometry)

		}

		return {

			get: get,
			update: update,

			getWireframeAttribute: getWireframeAttribute

		}

	}

	function WebGLIndexedBufferRenderer$1 (gl, extensions, info, capabilities) {

		const isWebGL2 = capabilities.isWebGL2

		let mode

		function setMode (value) {

			mode = value

		}

		let type, bytesPerElement

		function setIndex (value) {

			type = value.type
			bytesPerElement = value.bytesPerElement

		}

		function render (start, count) {

			gl.drawElements(mode, count, type, start * bytesPerElement)

			info.update(count, mode, 1)

		}

		function renderInstances (start, count, primcount) {

			if (primcount === 0) return

			let extension, methodName

			if (isWebGL2) {

				extension = gl
				methodName = 'drawElementsInstanced'

			} else {

				extension = extensions.get('ANGLE_instanced_arrays')
				methodName = 'drawElementsInstancedANGLE'

				if (extension === null) {

					console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.')
					return

				}

			}

			extension[methodName](mode, count, type, start * bytesPerElement, primcount)

			info.update(count, mode, primcount)

		}

		//

		this.setMode = setMode
		this.setIndex = setIndex
		this.render = render
		this.renderInstances = renderInstances

	}

	function WebGLInfo$1 (gl) {

		const memory = {
			geometries: 0,
			textures: 0
		}

		const render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		}

		function update (count, mode, instanceCount) {

			render.calls++

			switch (mode) {

				case 4:
					render.triangles += instanceCount * (count / 3)
					break

				case 1:
					render.lines += instanceCount * (count / 2)
					break

				case 3:
					render.lines += instanceCount * (count - 1)
					break

				case 2:
					render.lines += instanceCount * count
					break

				case 0:
					render.points += instanceCount * count
					break

				default:
					console.error('THREE.WebGLInfo: Unknown draw mode:', mode)
					break

			}

		}

		function reset () {

			render.frame++
			render.calls = 0
			render.triangles = 0
			render.points = 0
			render.lines = 0

		}

		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		}

	}

	function numericalSort$1 (a, b) {

		return a[0] - b[0]

	}

	function absNumericalSort$1 (a, b) {

		return Math.abs(b[1]) - Math.abs(a[1])

	}

	function WebGLMorphtargets$1 (gl) {

		const influencesList = {}
		const morphInfluences = new Float32Array(8)

		const workInfluences = []

		for (let i = 0; i < 8; i++) {

			workInfluences[i] = [i, 0]

		}

		function update (object, geometry, material, program) {

			const objectInfluences = object.morphTargetInfluences

			// When object doesn't have morph target influences defined, we treat it as a 0-length array
			// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

			const length = objectInfluences === undefined ? 0 : objectInfluences.length

			let influences = influencesList[geometry.id]

			if (influences === undefined || influences.length !== length) {

				// initialise list

				influences = []

				for (let i = 0; i < length; i++) {

					influences[i] = [i, 0]

				}

				influencesList[geometry.id] = influences

			}

			// Collect influences

			for (let i = 0; i < length; i++) {

				const influence = influences[i]

				influence[0] = i
				influence[1] = objectInfluences[i]

			}

			influences.sort(absNumericalSort$1)

			for (let i = 0; i < 8; i++) {

				if (i < length && influences[i][1]) {

					workInfluences[i][0] = influences[i][0]
					workInfluences[i][1] = influences[i][1]

				} else {

					workInfluences[i][0] = Number.MAX_SAFE_INTEGER
					workInfluences[i][1] = 0

				}

			}

			workInfluences.sort(numericalSort$1)

			const morphTargets = geometry.morphAttributes.position
			const morphNormals = geometry.morphAttributes.normal

			let morphInfluencesSum = 0

			for (let i = 0; i < 8; i++) {

				const influence = workInfluences[i]
				const index = influence[0]
				const value = influence[1]

				if (index !== Number.MAX_SAFE_INTEGER && value) {

					if (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {

						geometry.setAttribute('morphTarget' + i, morphTargets[index])

					}

					if (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {

						geometry.setAttribute('morphNormal' + i, morphNormals[index])

					}

					morphInfluences[i] = value
					morphInfluencesSum += value

				} else {

					if (morphTargets && geometry.hasAttribute('morphTarget' + i) === true) {

						geometry.deleteAttribute('morphTarget' + i)

					}

					if (morphNormals && geometry.hasAttribute('morphNormal' + i) === true) {

						geometry.deleteAttribute('morphNormal' + i)

					}

					morphInfluences[i] = 0

				}

			}

			// GLSL shader uses formula baseinfluence * base + sum(target * influence)
			// This allows us to switch between absolute morphs and relative morphs without changing shader code
			// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum

			program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence)
			program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences)

		}

		return {

			update: update

		}

	}

	function WebGLObjects$1 (gl, geometries, attributes, info) {

		let updateMap = new WeakMap()

		function update (object) {

			const frame = info.render.frame

			const geometry = object.geometry
			const buffergeometry = geometries.get(object, geometry)

			// Update once per frame

			if (updateMap.get(buffergeometry) !== frame) {

				geometries.update(buffergeometry)

				updateMap.set(buffergeometry, frame)

			}

			if (object.isInstancedMesh) {

				if (object.hasEventListener('dispose', onInstancedMeshDispose) === false) {

					object.addEventListener('dispose', onInstancedMeshDispose)

				}

				attributes.update(object.instanceMatrix, 34962)

				if (object.instanceColor !== null) {

					attributes.update(object.instanceColor, 34962)

				}

			}

			return buffergeometry

		}

		function dispose () {

			updateMap = new WeakMap()

		}

		function onInstancedMeshDispose (event) {

			const instancedMesh = event.target

			instancedMesh.removeEventListener('dispose', onInstancedMeshDispose)

			attributes.remove(instancedMesh.instanceMatrix)

			if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor)

		}

		return {

			update: update,
			dispose: dispose

		}

	}

	class DataTexture2DArray extends Texture {

		constructor(data = null, width = 1, height = 1, depth = 1) {

			super(null)

			this.image = { data, width, height, depth }

			this.magFilter = NearestFilter
			this.minFilter = NearestFilter

			this.wrapR = ClampToEdgeWrapping

			this.generateMipmaps = false
			this.flipY = false
			this.unpackAlignment = 1

			this.needsUpdate = true

		}

	}

	DataTexture2DArray.prototype.isDataTexture2DArray = true

	class DataTexture3D extends Texture {

		constructor(data = null, width = 1, height = 1, depth = 1) {

			// We're going to add .setXXX() methods for setting properties later.
			// Users can still set in DataTexture3D directly.
			//
			//	const texture = new THREE.DataTexture3D( data, width, height, depth );
			// 	texture.anisotropy = 16;
			//
			// See #14839

			super(null)

			this.image = { data, width, height, depth }

			this.magFilter = NearestFilter
			this.minFilter = NearestFilter

			this.wrapR = ClampToEdgeWrapping

			this.generateMipmaps = false
			this.flipY = false
			this.unpackAlignment = 1

			this.needsUpdate = true

		}

	}

	DataTexture3D.prototype.isDataTexture3D = true

	/**
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */

	const emptyTexture$1 = new Texture()
	const emptyTexture2dArray$1 = new DataTexture2DArray()
	const emptyTexture3d$1 = new DataTexture3D()
	const emptyCubeTexture$1 = new CubeTexture()

	// --- Utilities ---

	// Array Caches (provide typed arrays for temporary by size)

	const arrayCacheF32$1 = []
	const arrayCacheI32$1 = []

	// Float32Array caches used for uploading Matrix uniforms

	const mat4array$1 = new Float32Array(16)
	const mat3array$1 = new Float32Array(9)
	const mat2array$1 = new Float32Array(4)

	// Flattening for arrays of vectors and matrices

	function flatten$1 (array, nBlocks, blockSize) {

		const firstElem = array[0]

		if (firstElem <= 0 || firstElem > 0) return array
		// unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		const n = nBlocks * blockSize
		let r = arrayCacheF32$1[n]

		if (r === undefined) {

			r = new Float32Array(n)
			arrayCacheF32$1[n] = r

		}

		if (nBlocks !== 0) {

			firstElem.toArray(r, 0)

			for (let i = 1, offset = 0; i !== nBlocks; ++i) {

				offset += blockSize
				array[i].toArray(r, offset)

			}

		}

		return r

	}

	function arraysEqual$1 (a, b) {

		if (a.length !== b.length) return false

		for (let i = 0, l = a.length; i < l; i++) {

			if (a[i] !== b[i]) return false

		}

		return true

	}

	function copyArray$1 (a, b) {

		for (let i = 0, l = b.length; i < l; i++) {

			a[i] = b[i]

		}

	}

	// Texture unit allocation

	function allocTexUnits$1 (textures, n) {

		let r = arrayCacheI32$1[n]

		if (r === undefined) {

			r = new Int32Array(n)
			arrayCacheI32$1[n] = r

		}

		for (let i = 0; i !== n; ++i) {

			r[i] = textures.allocateTextureUnit()

		}

		return r

	}

	// --- Setters ---

	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.

	// Single scalar

	function setValueV1f$1 (gl, v) {

		const cache = this.cache

		if (cache[0] === v) return

		gl.uniform1f(this.addr, v)

		cache[0] = v

	}

	// Single float vector (from flat array or THREE.VectorN)

	function setValueV2f$1 (gl, v) {

		const cache = this.cache

		if (v.x !== undefined) {

			if (cache[0] !== v.x || cache[1] !== v.y) {

				gl.uniform2f(this.addr, v.x, v.y)

				cache[0] = v.x
				cache[1] = v.y

			}

		} else {

			if (arraysEqual$1(cache, v)) return

			gl.uniform2fv(this.addr, v)

			copyArray$1(cache, v)

		}

	}

	function setValueV3f$1 (gl, v) {

		const cache = this.cache

		if (v.x !== undefined) {

			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {

				gl.uniform3f(this.addr, v.x, v.y, v.z)

				cache[0] = v.x
				cache[1] = v.y
				cache[2] = v.z

			}

		} else if (v.r !== undefined) {

			if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {

				gl.uniform3f(this.addr, v.r, v.g, v.b)

				cache[0] = v.r
				cache[1] = v.g
				cache[2] = v.b

			}

		} else {

			if (arraysEqual$1(cache, v)) return

			gl.uniform3fv(this.addr, v)

			copyArray$1(cache, v)

		}

	}

	function setValueV4f$1 (gl, v) {

		const cache = this.cache

		if (v.x !== undefined) {

			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {

				gl.uniform4f(this.addr, v.x, v.y, v.z, v.w)

				cache[0] = v.x
				cache[1] = v.y
				cache[2] = v.z
				cache[3] = v.w

			}

		} else {

			if (arraysEqual$1(cache, v)) return

			gl.uniform4fv(this.addr, v)

			copyArray$1(cache, v)

		}

	}

	// Single matrix (from flat array or THREE.MatrixN)

	function setValueM2$1 (gl, v) {

		const cache = this.cache
		const elements = v.elements

		if (elements === undefined) {

			if (arraysEqual$1(cache, v)) return

			gl.uniformMatrix2fv(this.addr, false, v)

			copyArray$1(cache, v)

		} else {

			if (arraysEqual$1(cache, elements)) return

			mat2array$1.set(elements)

			gl.uniformMatrix2fv(this.addr, false, mat2array$1)

			copyArray$1(cache, elements)

		}

	}

	function setValueM3$1 (gl, v) {

		const cache = this.cache
		const elements = v.elements

		if (elements === undefined) {

			if (arraysEqual$1(cache, v)) return

			gl.uniformMatrix3fv(this.addr, false, v)

			copyArray$1(cache, v)

		} else {

			if (arraysEqual$1(cache, elements)) return

			mat3array$1.set(elements)

			gl.uniformMatrix3fv(this.addr, false, mat3array$1)

			copyArray$1(cache, elements)

		}

	}

	function setValueM4$1 (gl, v) {

		const cache = this.cache
		const elements = v.elements

		if (elements === undefined) {

			if (arraysEqual$1(cache, v)) return

			gl.uniformMatrix4fv(this.addr, false, v)

			copyArray$1(cache, v)

		} else {

			if (arraysEqual$1(cache, elements)) return

			mat4array$1.set(elements)

			gl.uniformMatrix4fv(this.addr, false, mat4array$1)

			copyArray$1(cache, elements)

		}

	}

	// Single integer / boolean

	function setValueV1i$1 (gl, v) {

		const cache = this.cache

		if (cache[0] === v) return

		gl.uniform1i(this.addr, v)

		cache[0] = v

	}

	// Single integer / boolean vector (from flat array)

	function setValueV2i$1 (gl, v) {

		const cache = this.cache

		if (arraysEqual$1(cache, v)) return

		gl.uniform2iv(this.addr, v)

		copyArray$1(cache, v)

	}

	function setValueV3i$1 (gl, v) {

		const cache = this.cache

		if (arraysEqual$1(cache, v)) return

		gl.uniform3iv(this.addr, v)

		copyArray$1(cache, v)

	}

	function setValueV4i$1 (gl, v) {

		const cache = this.cache

		if (arraysEqual$1(cache, v)) return

		gl.uniform4iv(this.addr, v)

		copyArray$1(cache, v)

	}

	// Single unsigned integer

	function setValueV1ui$1 (gl, v) {

		const cache = this.cache

		if (cache[0] === v) return

		gl.uniform1ui(this.addr, v)

		cache[0] = v

	}

	// Single unsigned integer vector (from flat array)

	function setValueV2ui$1 (gl, v) {

		const cache = this.cache

		if (arraysEqual$1(cache, v)) return

		gl.uniform2uiv(this.addr, v)

		copyArray$1(cache, v)

	}

	function setValueV3ui$1 (gl, v) {

		const cache = this.cache

		if (arraysEqual$1(cache, v)) return

		gl.uniform3uiv(this.addr, v)

		copyArray$1(cache, v)

	}

	function setValueV4ui$1 (gl, v) {

		const cache = this.cache

		if (arraysEqual$1(cache, v)) return

		gl.uniform4uiv(this.addr, v)

		copyArray$1(cache, v)

	}


	// Single texture (2D / Cube)

	function setValueT1$1 (gl, v, textures) {

		const cache = this.cache
		const unit = textures.allocateTextureUnit()

		if (cache[0] !== unit) {

			gl.uniform1i(this.addr, unit)
			cache[0] = unit

		}

		textures.safeSetTexture2D(v || emptyTexture$1, unit)

	}

	function setValueT3D1$1 (gl, v, textures) {

		const cache = this.cache
		const unit = textures.allocateTextureUnit()

		if (cache[0] !== unit) {

			gl.uniform1i(this.addr, unit)
			cache[0] = unit

		}

		textures.setTexture3D(v || emptyTexture3d$1, unit)

	}

	function setValueT6$1 (gl, v, textures) {

		const cache = this.cache
		const unit = textures.allocateTextureUnit()

		if (cache[0] !== unit) {

			gl.uniform1i(this.addr, unit)
			cache[0] = unit

		}

		textures.safeSetTextureCube(v || emptyCubeTexture$1, unit)

	}

	function setValueT2DArray1$1 (gl, v, textures) {

		const cache = this.cache
		const unit = textures.allocateTextureUnit()

		if (cache[0] !== unit) {

			gl.uniform1i(this.addr, unit)
			cache[0] = unit

		}

		textures.setTexture2DArray(v || emptyTexture2dArray$1, unit)

	}

	// Helper to pick the right setter for the singular case

	function getSingularSetter$1 (type) {

		switch (type) {

			case 0x1406: return setValueV1f$1 // FLOAT
			case 0x8b50: return setValueV2f$1 // _VEC2
			case 0x8b51: return setValueV3f$1 // _VEC3
			case 0x8b52: return setValueV4f$1 // _VEC4

			case 0x8b5a: return setValueM2$1 // _MAT2
			case 0x8b5b: return setValueM3$1 // _MAT3
			case 0x8b5c: return setValueM4$1 // _MAT4

			case 0x1404: case 0x8b56: return setValueV1i$1 // INT, BOOL
			case 0x8b53: case 0x8b57: return setValueV2i$1 // _VEC2
			case 0x8b54: case 0x8b58: return setValueV3i$1 // _VEC3
			case 0x8b55: case 0x8b59: return setValueV4i$1 // _VEC4

			case 0x1405: return setValueV1ui$1 // UINT
			case 0x8dc6: return setValueV2ui$1 // _VEC2
			case 0x8dc7: return setValueV3ui$1 // _VEC3
			case 0x8dc8: return setValueV4ui$1 // _VEC4

			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1$1

			case 0x8b5f: // SAMPLER_3D
			case 0x8dcb: // INT_SAMPLER_3D
			case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
				return setValueT3D1$1

			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6$1

			case 0x8dc1: // SAMPLER_2D_ARRAY
			case 0x8dcf: // INT_SAMPLER_2D_ARRAY
			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
			case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArray1$1

		}

	}


	// Array of scalars

	function setValueV1fArray$1 (gl, v) {

		gl.uniform1fv(this.addr, v)

	}

	// Array of vectors (from flat array or array of THREE.VectorN)

	function setValueV2fArray$1 (gl, v) {

		const data = flatten$1(v, this.size, 2)

		gl.uniform2fv(this.addr, data)

	}

	function setValueV3fArray$1 (gl, v) {

		const data = flatten$1(v, this.size, 3)

		gl.uniform3fv(this.addr, data)

	}

	function setValueV4fArray$1 (gl, v) {

		const data = flatten$1(v, this.size, 4)

		gl.uniform4fv(this.addr, data)

	}

	// Array of matrices (from flat array or array of THREE.MatrixN)

	function setValueM2Array$1 (gl, v) {

		const data = flatten$1(v, this.size, 4)

		gl.uniformMatrix2fv(this.addr, false, data)

	}

	function setValueM3Array$1 (gl, v) {

		const data = flatten$1(v, this.size, 9)

		gl.uniformMatrix3fv(this.addr, false, data)

	}

	function setValueM4Array$1 (gl, v) {

		const data = flatten$1(v, this.size, 16)

		gl.uniformMatrix4fv(this.addr, false, data)

	}

	// Array of integer / boolean

	function setValueV1iArray$1 (gl, v) {

		gl.uniform1iv(this.addr, v)

	}

	// Array of integer / boolean vectors (from flat array)

	function setValueV2iArray$1 (gl, v) {

		gl.uniform2iv(this.addr, v)

	}

	function setValueV3iArray$1 (gl, v) {

		gl.uniform3iv(this.addr, v)

	}

	function setValueV4iArray$1 (gl, v) {

		gl.uniform4iv(this.addr, v)

	}

	// Array of unsigned integer

	function setValueV1uiArray$1 (gl, v) {

		gl.uniform1uiv(this.addr, v)

	}

	// Array of unsigned integer vectors (from flat array)

	function setValueV2uiArray$1 (gl, v) {

		gl.uniform2uiv(this.addr, v)

	}

	function setValueV3uiArray$1 (gl, v) {

		gl.uniform3uiv(this.addr, v)

	}

	function setValueV4uiArray$1 (gl, v) {

		gl.uniform4uiv(this.addr, v)

	}


	// Array of textures (2D / Cube)

	function setValueT1Array$1 (gl, v, textures) {

		const n = v.length

		const units = allocTexUnits$1(textures, n)

		gl.uniform1iv(this.addr, units)

		for (let i = 0; i !== n; ++i) {

			textures.safeSetTexture2D(v[i] || emptyTexture$1, units[i])

		}

	}

	function setValueT6Array$1 (gl, v, textures) {

		const n = v.length

		const units = allocTexUnits$1(textures, n)

		gl.uniform1iv(this.addr, units)

		for (let i = 0; i !== n; ++i) {

			textures.safeSetTextureCube(v[i] || emptyCubeTexture$1, units[i])

		}

	}

	// Helper to pick the right setter for a pure (bottom-level) array

	function getPureArraySetter$1 (type) {

		switch (type) {

			case 0x1406: return setValueV1fArray$1 // FLOAT
			case 0x8b50: return setValueV2fArray$1 // _VEC2
			case 0x8b51: return setValueV3fArray$1 // _VEC3
			case 0x8b52: return setValueV4fArray$1 // _VEC4

			case 0x8b5a: return setValueM2Array$1 // _MAT2
			case 0x8b5b: return setValueM3Array$1 // _MAT3
			case 0x8b5c: return setValueM4Array$1 // _MAT4

			case 0x1404: case 0x8b56: return setValueV1iArray$1 // INT, BOOL
			case 0x8b53: case 0x8b57: return setValueV2iArray$1 // _VEC2
			case 0x8b54: case 0x8b58: return setValueV3iArray$1 // _VEC3
			case 0x8b55: case 0x8b59: return setValueV4iArray$1 // _VEC4

			case 0x1405: return setValueV1uiArray$1 // UINT
			case 0x8dc6: return setValueV2uiArray$1 // _VEC2
			case 0x8dc7: return setValueV3uiArray$1 // _VEC3
			case 0x8dc8: return setValueV4uiArray$1 // _VEC4

			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1Array$1

			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6Array$1

		}

	}

	// --- Uniform Classes ---

	function SingleUniform$1 (id, activeInfo, addr) {

		this.id = id
		this.addr = addr
		this.cache = []
		this.setValue = getSingularSetter$1(activeInfo.type)

		// this.path = activeInfo.name; // DEBUG

	}

	function PureArrayUniform$1 (id, activeInfo, addr) {

		this.id = id
		this.addr = addr
		this.cache = []
		this.size = activeInfo.size
		this.setValue = getPureArraySetter$1(activeInfo.type)

		// this.path = activeInfo.name; // DEBUG

	}

	PureArrayUniform$1.prototype.updateCache = function (data) {

		const cache = this.cache

		if (data instanceof Float32Array && cache.length !== data.length) {

			this.cache = new Float32Array(data.length)

		}

		copyArray$1(cache, data)

	}

	function StructuredUniform$1 (id) {

		this.id = id

		this.seq = []
		this.map = {}

	}

	StructuredUniform$1.prototype.setValue = function (gl, value, textures) {

		const seq = this.seq

		for (let i = 0, n = seq.length; i !== n; ++i) {

			const u = seq[i]
			u.setValue(gl, value[u.id], textures)

		}

	}

	// --- Top-level ---

	// Parser - builds up the property tree from the path strings

	const RePathPart$1 = /(\w+)(\])?(\[|\.)?/g

	// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform$1 (container, uniformObject) {

		container.seq.push(uniformObject)
		container.map[uniformObject.id] = uniformObject

	}

	function parseUniform$1 (activeInfo, addr, container) {

		const path = activeInfo.name,
			pathLength = path.length

		// reset RegExp object, because of the early exit of a previous run
		RePathPart$1.lastIndex = 0

		while (true) {

			const match = RePathPart$1.exec(path),
				matchEnd = RePathPart$1.lastIndex

			let id = match[1]
			const idIsIndex = match[2] === ']',
				subscript = match[3]

			if (idIsIndex) id = id | 0 // convert to integer

			if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {

				// bare name or "pure" bottom-level array "[0]" suffix

				addUniform$1(container, subscript === undefined ?
					new SingleUniform$1(id, activeInfo, addr) :
					new PureArrayUniform$1(id, activeInfo, addr))

				break

			} else {

				// step into inner node / create it in case it doesn't exist

				const map = container.map
				let next = map[id]

				if (next === undefined) {

					next = new StructuredUniform$1(id)
					addUniform$1(container, next)

				}

				container = next

			}

		}

	}

	// Root Container

	function WebGLUniforms$1 (gl, program) {

		this.seq = []
		this.map = {}

		const n = gl.getProgramParameter(program, 35718)

		for (let i = 0; i < n; ++i) {

			const info = gl.getActiveUniform(program, i),
				addr = gl.getUniformLocation(program, info.name)

			parseUniform$1(info, addr, this)

		}

	}

	WebGLUniforms$1.prototype.setValue = function (gl, name, value, textures) {

		const u = this.map[name]

		if (u !== undefined) u.setValue(gl, value, textures)

	}

	WebGLUniforms$1.prototype.setOptional = function (gl, object, name) {

		const v = object[name]

		if (v !== undefined) this.setValue(gl, name, v)

	}


	// Static interface

	WebGLUniforms$1.upload = function (gl, seq, values, textures) {

		for (let i = 0, n = seq.length; i !== n; ++i) {

			const u = seq[i],
				v = values[u.id]

			if (v.needsUpdate !== false) {

				// note: always updating when .needsUpdate is undefined
				u.setValue(gl, v.value, textures)

			}

		}

	}

	WebGLUniforms$1.seqWithValue = function (seq, values) {

		const r = []

		for (let i = 0, n = seq.length; i !== n; ++i) {

			const u = seq[i]
			if (u.id in values) r.push(u)

		}

		return r

	}

	function WebGLShader$1 (gl, type, string) {

		const shader = gl.createShader(type)

		gl.shaderSource(shader, string)
		gl.compileShader(shader)

		return shader

	}

	let programIdCount$1 = 0

	function addLineNumbers$1 (string) {

		const lines = string.split('\n')

		for (let i = 0; i < lines.length; i++) {

			lines[i] = (i + 1) + ': ' + lines[i]

		}

		return lines.join('\n')

	}

	function getEncodingComponents$1 (encoding) {

		switch (encoding) {

			case LinearEncoding:
				return ['Linear', '( value )']
			case sRGBEncoding:
				return ['sRGB', '( value )']
			case RGBEEncoding:
				return ['RGBE', '( value )']
			case RGBM7Encoding:
				return ['RGBM', '( value, 7.0 )']
			case RGBM16Encoding:
				return ['RGBM', '( value, 16.0 )']
			case RGBDEncoding:
				return ['RGBD', '( value, 256.0 )']
			case GammaEncoding:
				return ['Gamma', '( value, float( GAMMA_FACTOR ) )']
			case LogLuvEncoding:
				return ['LogLuv', '( value )']
			default:
				console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding)
				return ['Linear', '( value )']

		}

	}

	function getShaderErrors$1 (gl, shader, type) {

		const status = gl.getShaderParameter(shader, 35713)
		const log = gl.getShaderInfoLog(shader).trim()

		if (status && log === '') return ''

		// --enable-privileged-webgl-extension
		// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		const source = gl.getShaderSource(shader)

		return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers$1(source)

	}

	function getTexelDecodingFunction$1 (functionName, encoding) {

		const components = getEncodingComponents$1(encoding)
		return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }'

	}

	function getTexelEncodingFunction$1 (functionName, encoding) {

		const components = getEncodingComponents$1(encoding)
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }'

	}

	function getToneMappingFunction$1 (functionName, toneMapping) {

		let toneMappingName

		switch (toneMapping) {

			case LinearToneMapping:
				toneMappingName = 'Linear'
				break

			case ReinhardToneMapping:
				toneMappingName = 'Reinhard'
				break

			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon'
				break

			case ACESFilmicToneMapping:
				toneMappingName = 'ACESFilmic'
				break

			case CustomToneMapping:
				toneMappingName = 'Custom'
				break

			default:
				console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping)
				toneMappingName = 'Linear'

		}

		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }'

	}

	function generateExtensions$1 (parameters) {

		const chunks = [
			(parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical') ? '#extension GL_OES_standard_derivatives : enable' : '',
			(parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
			(parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers) ? '#extension GL_EXT_draw_buffers : require' : '',
			(parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission > 0.0) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
		]

		return chunks.filter(filterEmptyLine$1).join('\n')

	}

	function generateDefines$1 (defines) {

		const chunks = []

		for (const name in defines) {

			const value = defines[name]

			if (value === false) continue

			chunks.push('#define ' + name + ' ' + value)

		}

		return chunks.join('\n')

	}

	function fetchAttributeLocations$1 (gl, program) {

		const attributes = {}

		const n = gl.getProgramParameter(program, 35721)

		for (let i = 0; i < n; i++) {

			const info = gl.getActiveAttrib(program, i)
			const name = info.name

			// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[name] = gl.getAttribLocation(program, name)

		}

		return attributes

	}

	function filterEmptyLine$1 (string) {

		return string !== ''

	}

	function replaceLightNums$1 (string, parameters) {

		return string
			.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights)
			.replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights)
			.replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights)
			.replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights)
			.replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights)
			.replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows)
			.replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows)
			.replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows)

	}

	function replaceClippingPlaneNums$1 (string, parameters) {

		return string
			.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes)
			.replace(/UNION_CLIPPING_PLANES/g, (parameters.numClippingPlanes - parameters.numClipIntersection))

	}

	// Resolve Includes

	const includePattern$1 = /^[ \t]*#include +<([\w\d./]+)>/gm

	function resolveIncludes$1 (string) {

		return string.replace(includePattern$1, includeReplacer$1)

	}

	function includeReplacer$1 (match, include) {

		const string = ShaderChunk$1[include]

		if (string === undefined) {

			throw new Error('Can not resolve #include <' + include + '>')

		}

		return resolveIncludes$1(string)

	}

	// Unroll Loops

	const deprecatedUnrollLoopPattern$1 = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g
	const unrollLoopPattern$1 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g

	function unrollLoops$1 (string) {

		return string
			.replace(unrollLoopPattern$1, loopReplacer$1)
			.replace(deprecatedUnrollLoopPattern$1, deprecatedLoopReplacer$1)

	}

	function deprecatedLoopReplacer$1 (match, start, end, snippet) {

		console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.')
		return loopReplacer$1(match, start, end, snippet)

	}

	function loopReplacer$1 (match, start, end, snippet) {

		let string = ''

		for (let i = parseInt(start); i < parseInt(end); i++) {

			string += snippet
				.replace(/\[\s*i\s*\]/g, '[ ' + i + ' ]')
				.replace(/UNROLLED_LOOP_INDEX/g, i)

		}

		return string

	}

	//

	function generatePrecision$1 (parameters) {

		let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;'

		if (parameters.precision === 'highp') {

			precisionstring += '\n#define HIGH_PRECISION'

		} else if (parameters.precision === 'mediump') {

			precisionstring += '\n#define MEDIUM_PRECISION'

		} else if (parameters.precision === 'lowp') {

			precisionstring += '\n#define LOW_PRECISION'

		}

		return precisionstring

	}

	function generateShadowMapTypeDefine$1 (parameters) {

		let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC'

		if (parameters.shadowMapType === PCFShadowMap) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF'

		} else if (parameters.shadowMapType === PCFSoftShadowMap) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT'

		} else if (parameters.shadowMapType === VSMShadowMap) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM'

		}

		return shadowMapTypeDefine

	}

	function generateEnvMapTypeDefine$1 (parameters) {

		let envMapTypeDefine = 'ENVMAP_TYPE_CUBE'

		if (parameters.envMap) {

			switch (parameters.envMapMode) {

				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE'
					break

				case CubeUVReflectionMapping:
				case CubeUVRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV'
					break

			}

		}

		return envMapTypeDefine

	}

	function generateEnvMapModeDefine$1 (parameters) {

		let envMapModeDefine = 'ENVMAP_MODE_REFLECTION'

		if (parameters.envMap) {

			switch (parameters.envMapMode) {

				case CubeRefractionMapping:
				case CubeUVRefractionMapping:

					envMapModeDefine = 'ENVMAP_MODE_REFRACTION'
					break

			}

		}

		return envMapModeDefine

	}

	function generateEnvMapBlendingDefine$1 (parameters) {

		let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE'

		if (parameters.envMap) {

			switch (parameters.combine) {

				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY'
					break

				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX'
					break

				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD'
					break

			}

		}

		return envMapBlendingDefine

	}

	function WebGLProgram$1 (renderer, cacheKey, parameters, bindingStates) {

		const gl = renderer.getContext()

		const defines = parameters.defines

		let vertexShader = parameters.vertexShader
		let fragmentShader = parameters.fragmentShader

		const shadowMapTypeDefine = generateShadowMapTypeDefine$1(parameters)
		const envMapTypeDefine = generateEnvMapTypeDefine$1(parameters)
		const envMapModeDefine = generateEnvMapModeDefine$1(parameters)
		const envMapBlendingDefine = generateEnvMapBlendingDefine$1(parameters)


		const gammaFactorDefine = (renderer.gammaFactor > 0) ? renderer.gammaFactor : 1.0

		const customExtensions = parameters.isWebGL2 ? '' : generateExtensions$1(parameters)

		const customDefines = generateDefines$1(defines)

		const program = gl.createProgram()

		let prefixVertex, prefixFragment
		let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : ''

		if (parameters.isRawShaderMaterial) {

			prefixVertex = [

				customDefines

			].filter(filterEmptyLine$1).join('\n')

			if (prefixVertex.length > 0) {

				prefixVertex += '\n'

			}

			prefixFragment = [

				customExtensions,
				customDefines

			].filter(filterEmptyLine$1).join('\n')

			if (prefixFragment.length > 0) {

				prefixFragment += '\n'

			}

		} else {

			prefixVertex = [

				generatePrecision$1(parameters),

				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines,

				parameters.instancing ? '#define USE_INSTANCING' : '',
				parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',

				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				'#define MAX_BONES ' + parameters.maxBones,
				(parameters.useFog && parameters.fog) ? '#define USE_FOG' : '',
				(parameters.useFog && parameters.fogExp2) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				(parameters.normalMap && parameters.objectSpaceNormalMap) ? '#define OBJECTSPACE_NORMALMAP' : '',
				(parameters.normalMap && parameters.tangentSpaceNormalMap) ? '#define TANGENTSPACE_NORMALMAP' : '',

				parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
				parameters.specularTintMap ? '#define USE_SPECULARTINTMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.transmission ? '#define USE_TRANSMISSION' : '',
				parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
				parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

				parameters.vertexTangents ? '#define USE_TANGENT' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',
				parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
				parameters.vertexUvs ? '#define USE_UV' : '',
				parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',
				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				(parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',

				'#ifdef USE_INSTANCING',

				'	attribute mat4 instanceMatrix;',

				'#endif',

				'#ifdef USE_INSTANCING_COLOR',

				'	attribute vec3 instanceColor;',

				'#endif',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',

				'#ifdef USE_TANGENT',

				'	attribute vec4 tangent;',

				'#endif',

				'#if defined( USE_COLOR_ALPHA )',

				'	attribute vec4 color;',

				'#elif defined( USE_COLOR )',

				'	attribute vec3 color;',

				'#endif',

				'#ifdef USE_MORPHTARGETS',

				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',

				'	#ifdef USE_MORPHNORMALS',

				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',

				'	#else',

				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',

				'	#endif',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				'\n'

			].filter(filterEmptyLine$1).join('\n')

			prefixFragment = [

				customExtensions,

				generatePrecision$1(parameters),

				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines,

				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '', // add '.0' if integer

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				(parameters.useFog && parameters.fog) ? '#define USE_FOG' : '',
				(parameters.useFog && parameters.fogExp2) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.matcap ? '#define USE_MATCAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				(parameters.normalMap && parameters.objectSpaceNormalMap) ? '#define OBJECTSPACE_NORMALMAP' : '',
				(parameters.normalMap && parameters.tangentSpaceNormalMap) ? '#define TANGENTSPACE_NORMALMAP' : '',
				parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
				parameters.specularTintMap ? '#define USE_SPECULARTINTMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

				parameters.sheen ? '#define USE_SHEEN' : '',
				parameters.transmission ? '#define USE_TRANSMISSION' : '',
				parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
				parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

				parameters.vertexTangents ? '#define USE_TANGENT' : '',
				parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
				parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
				parameters.vertexUvs ? '#define USE_UV' : '',
				parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

				parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

				parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				(parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				((parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod) ? '#define TEXTURE_LOD_EXT' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',

				(parameters.toneMapping !== NoToneMapping) ? '#define TONE_MAPPING' : '',
				(parameters.toneMapping !== NoToneMapping) ? ShaderChunk$1['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below
				(parameters.toneMapping !== NoToneMapping) ? getToneMappingFunction$1('toneMapping', parameters.toneMapping) : '',

				parameters.dithering ? '#define DITHERING' : '',

				ShaderChunk$1['encodings_pars_fragment'], // this code is required here because it is used by the various encoding/decoding function defined below
				parameters.map ? getTexelDecodingFunction$1('mapTexelToLinear', parameters.mapEncoding) : '',
				parameters.matcap ? getTexelDecodingFunction$1('matcapTexelToLinear', parameters.matcapEncoding) : '',
				parameters.envMap ? getTexelDecodingFunction$1('envMapTexelToLinear', parameters.envMapEncoding) : '',
				parameters.emissiveMap ? getTexelDecodingFunction$1('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '',
				parameters.specularTintMap ? getTexelDecodingFunction$1('specularTintMapTexelToLinear', parameters.specularTintMapEncoding) : '',
				parameters.lightMap ? getTexelDecodingFunction$1('lightMapTexelToLinear', parameters.lightMapEncoding) : '',
				getTexelEncodingFunction$1('linearToOutputTexel', parameters.outputEncoding),

				parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

				'\n'

			].filter(filterEmptyLine$1).join('\n')

		}

		vertexShader = resolveIncludes$1(vertexShader)
		vertexShader = replaceLightNums$1(vertexShader, parameters)
		vertexShader = replaceClippingPlaneNums$1(vertexShader, parameters)

		fragmentShader = resolveIncludes$1(fragmentShader)
		fragmentShader = replaceLightNums$1(fragmentShader, parameters)
		fragmentShader = replaceClippingPlaneNums$1(fragmentShader, parameters)

		vertexShader = unrollLoops$1(vertexShader)
		fragmentShader = unrollLoops$1(fragmentShader)

		if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {

			// GLSL 3.0 conversion for built-in materials and ShaderMaterial

			versionString = '#version 300 es\n'

			prefixVertex = [
				'#define attribute in',
				'#define varying out',
				'#define texture2D texture'
			].join('\n') + '\n' + prefixVertex

			prefixFragment = [
				'#define varying in',
				(parameters.glslVersion === GLSL3) ? '' : 'out highp vec4 pc_fragColor;',
				(parameters.glslVersion === GLSL3) ? '' : '#define gl_FragColor pc_fragColor',
				'#define gl_FragDepthEXT gl_FragDepth',
				'#define texture2D texture',
				'#define textureCube texture',
				'#define texture2DProj textureProj',
				'#define texture2DLodEXT textureLod',
				'#define texture2DProjLodEXT textureProjLod',
				'#define textureCubeLodEXT textureLod',
				'#define texture2DGradEXT textureGrad',
				'#define texture2DProjGradEXT textureProjGrad',
				'#define textureCubeGradEXT textureGrad'
			].join('\n') + '\n' + prefixFragment

		}

		const vertexGlsl = versionString + prefixVertex + vertexShader
		const fragmentGlsl = versionString + prefixFragment + fragmentShader

		// console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		const glVertexShader = WebGLShader$1(gl, 35633, vertexGlsl)
		const glFragmentShader = WebGLShader$1(gl, 35632, fragmentGlsl)

		gl.attachShader(program, glVertexShader)
		gl.attachShader(program, glFragmentShader)

		// Force a particular attribute to index 0.

		if (parameters.index0AttributeName !== undefined) {

			gl.bindAttribLocation(program, 0, parameters.index0AttributeName)

		} else if (parameters.morphTargets === true) {

			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation(program, 0, 'position')

		}

		gl.linkProgram(program)

		// check for link errors
		if (renderer.debug.checkShaderErrors) {

			const programLog = gl.getProgramInfoLog(program).trim()
			const vertexLog = gl.getShaderInfoLog(glVertexShader).trim()
			const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim()

			let runnable = true
			let haveDiagnostics = true

			if (gl.getProgramParameter(program, 35714) === false) {

				runnable = false

				const vertexErrors = getShaderErrors$1(gl, glVertexShader, 'vertex')
				const fragmentErrors = getShaderErrors$1(gl, glFragmentShader, 'fragment')

				console.error('THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter(program, 35715), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors)

			} else if (programLog !== '') {

				console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog)

			} else if (vertexLog === '' || fragmentLog === '') {

				haveDiagnostics = false

			}

			if (haveDiagnostics) {

				this.diagnostics = {

					runnable: runnable,

					programLog: programLog,

					vertexShader: {

						log: vertexLog,
						prefix: prefixVertex

					},

					fragmentShader: {

						log: fragmentLog,
						prefix: prefixFragment

					}

				}

			}

		}

		// Clean up

		// Crashes in iOS9 and iOS10. #18402
		// gl.detachShader( program, glVertexShader );
		// gl.detachShader( program, glFragmentShader );

		gl.deleteShader(glVertexShader)
		gl.deleteShader(glFragmentShader)

		// set up caching for uniform locations

		let cachedUniforms

		this.getUniforms = function () {

			if (cachedUniforms === undefined) {

				cachedUniforms = new WebGLUniforms$1(gl, program)

			}

			return cachedUniforms

		}

		// set up caching for attribute locations

		let cachedAttributes

		this.getAttributes = function () {

			if (cachedAttributes === undefined) {

				cachedAttributes = fetchAttributeLocations$1(gl, program)

			}

			return cachedAttributes

		}

		// free resource

		this.destroy = function () {

			bindingStates.releaseStatesOfProgram(this)

			gl.deleteProgram(program)
			this.program = undefined

		}

		//

		this.name = parameters.shaderName
		this.id = programIdCount$1++
		this.cacheKey = cacheKey
		this.usedTimes = 1
		this.program = program
		this.vertexShader = glVertexShader
		this.fragmentShader = glFragmentShader

		return this

	}

	function WebGLPrograms$1 (renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {

		const programs = []

		const isWebGL2 = capabilities.isWebGL2
		const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer
		const floatVertexTextures = capabilities.floatVertexTextures
		const maxVertexUniforms = capabilities.maxVertexUniforms
		const vertexTextures = capabilities.vertexTextures

		let precision = capabilities.precision

		const shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'toon',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		}

		const parameterNames = [
			'precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor',
			'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV',
			'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap',
			'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap',
			'specularMap', 'specularIntensityMap', 'specularTintMap', 'specularTintMapEncoding', 'roughnessMap', 'metalnessMap', 'gradientMap',
			'alphaMap', 'combine', 'vertexColors', 'vertexAlphas', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2',
			'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning',
			'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'premultipliedAlpha',
			'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights',
			'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows',
			'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights',
			'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering',
			'sheen', 'transmission', 'transmissionMap', 'thicknessMap'
		]

		function getMaxBones (object) {

			const skeleton = object.skeleton
			const bones = skeleton.bones

			if (floatVertexTextures) {

				return 1024

			} else {

				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)

				const nVertexUniforms = maxVertexUniforms
				const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4)

				const maxBones = Math.min(nVertexMatrices, bones.length)

				if (maxBones < bones.length) {

					console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.')
					return 0

				}

				return maxBones

			}

		}

		function getTextureEncodingFromMap (map) {

			let encoding

			if (map && map.isTexture) {

				encoding = map.encoding

			} else if (map && map.isWebGLRenderTarget) {

				console.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.')
				encoding = map.texture.encoding

			} else {

				encoding = LinearEncoding

			}

			return encoding

		}

		function getParameters (material, lights, shadows, scene, object) {

			const fog = scene.fog
			const environment = material.isMeshStandardMaterial ? scene.environment : null

			const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment)

			const shaderID = shaderIDs[material.type]

			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0

			if (material.precision !== null) {

				precision = capabilities.getMaxPrecision(material.precision)

				if (precision !== material.precision) {

					console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.')

				}

			}

			let vertexShader, fragmentShader

			if (shaderID) {

				const shader = ShaderLib$1[shaderID]

				vertexShader = shader.vertexShader
				fragmentShader = shader.fragmentShader

			} else {

				vertexShader = material.vertexShader
				fragmentShader = material.fragmentShader

			}

			const currentRenderTarget = renderer.getRenderTarget()

			const parameters = {

				isWebGL2: isWebGL2,

				shaderID: shaderID,
				shaderName: material.type,

				vertexShader: vertexShader,
				fragmentShader: fragmentShader,
				defines: material.defines,

				isRawShaderMaterial: material.isRawShaderMaterial === true,
				glslVersion: material.glslVersion,

				precision: precision,

				instancing: object.isInstancedMesh === true,
				instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,

				supportsVertexTextures: vertexTextures,
				outputEncoding: (currentRenderTarget !== null) ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
				map: !!material.map,
				mapEncoding: getTextureEncodingFromMap(material.map),
				matcap: !!material.matcap,
				matcapEncoding: getTextureEncodingFromMap(material.matcap),
				envMap: !!envMap,
				envMapMode: envMap && envMap.mapping,
				envMapEncoding: getTextureEncodingFromMap(envMap),
				envMapCubeUV: (!!envMap) && ((envMap.mapping === CubeUVReflectionMapping) || (envMap.mapping === CubeUVRefractionMapping)),
				lightMap: !!material.lightMap,
				lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
				aoMap: !!material.aoMap,
				emissiveMap: !!material.emissiveMap,
				emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
				bumpMap: !!material.bumpMap,
				normalMap: !!material.normalMap,
				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
				tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
				clearcoatMap: !!material.clearcoatMap,
				clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
				clearcoatNormalMap: !!material.clearcoatNormalMap,
				displacementMap: !!material.displacementMap,
				roughnessMap: !!material.roughnessMap,
				metalnessMap: !!material.metalnessMap,
				specularMap: !!material.specularMap,
				specularIntensityMap: !!material.specularIntensityMap,
				specularTintMap: !!material.specularTintMap,
				specularTintMapEncoding: getTextureEncodingFromMap(material.specularTintMap),
				alphaMap: !!material.alphaMap,

				gradientMap: !!material.gradientMap,

				sheen: !!material.sheen,

				transmission: !!material.transmission,
				transmissionMap: !!material.transmissionMap,
				thicknessMap: !!material.thicknessMap,

				combine: material.combine,

				vertexTangents: (!!material.normalMap && !!object.geometry && !!object.geometry.attributes.tangent),
				vertexColors: material.vertexColors,
				vertexAlphas: material.vertexColors === true && !!object.geometry && !!object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
				vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularTintMap,
				uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmission || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularTintMap) && !!material.displacementMap,

				fog: !!fog,
				useFog: material.fog,
				fogExp2: (fog && fog.isFogExp2),

				flatShading: !!material.flatShading,

				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: logarithmicDepthBuffer,

				skinning: object.isSkinnedMesh === true && maxBones > 0,
				maxBones: maxBones,
				useVertexTexture: floatVertexTextures,

				morphTargets: !!object.geometry && !!object.geometry.morphAttributes.position,
				morphNormals: !!object.geometry && !!object.geometry.morphAttributes.normal,

				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,

				numDirLightShadows: lights.directionalShadowMap.length,
				numPointLightShadows: lights.pointShadowMap.length,
				numSpotLightShadows: lights.spotShadowMap.length,

				numClippingPlanes: clipping.numPlanes,
				numClipIntersection: clipping.numIntersection,

				dithering: material.dithering,

				shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,

				toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,

				premultipliedAlpha: material.premultipliedAlpha,

				alphaTest: material.alphaTest,
				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,

				depthPacking: (material.depthPacking !== undefined) ? material.depthPacking : false,

				index0AttributeName: material.index0AttributeName,

				extensionDerivatives: material.extensions && material.extensions.derivatives,
				extensionFragDepth: material.extensions && material.extensions.fragDepth,
				extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
				extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

				rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
				rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),
				rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),

				customProgramCacheKey: material.customProgramCacheKey()

			}

			return parameters

		}

		function getProgramCacheKey (parameters) {

			const array = []

			if (parameters.shaderID) {

				array.push(parameters.shaderID)

			} else {

				array.push(parameters.fragmentShader)
				array.push(parameters.vertexShader)

			}

			if (parameters.defines !== undefined) {

				for (const name in parameters.defines) {

					array.push(name)
					array.push(parameters.defines[name])

				}

			}

			if (parameters.isRawShaderMaterial === false) {

				for (let i = 0; i < parameterNames.length; i++) {

					array.push(parameters[parameterNames[i]])

				}

				array.push(renderer.outputEncoding)
				array.push(renderer.gammaFactor)

			}

			array.push(parameters.customProgramCacheKey)

			return array.join()

		}

		function getUniforms (material) {

			const shaderID = shaderIDs[material.type]
			let uniforms

			if (shaderID) {

				const shader = ShaderLib$1[shaderID]
				uniforms = UniformsUtils$1.clone(shader.uniforms)

			} else {

				uniforms = material.uniforms

			}

			return uniforms

		}

		function acquireProgram (parameters, cacheKey) {

			let program

			// Check if code has been already compiled
			for (let p = 0, pl = programs.length; p < pl; p++) {

				const preexistingProgram = programs[p]

				if (preexistingProgram.cacheKey === cacheKey) {

					program = preexistingProgram
					++program.usedTimes

					break

				}

			}

			if (program === undefined) {

				program = new WebGLProgram$1(renderer, cacheKey, parameters, bindingStates)
				programs.push(program)

			}

			return program

		}

		function releaseProgram (program) {

			if (--program.usedTimes === 0) {

				// Remove from unordered set
				const i = programs.indexOf(program)
				programs[i] = programs[programs.length - 1]
				programs.pop()

				// Free WebGL resources
				program.destroy()

			}

		}

		return {
			getParameters: getParameters,
			getProgramCacheKey: getProgramCacheKey,
			getUniforms: getUniforms,
			acquireProgram: acquireProgram,
			releaseProgram: releaseProgram,
			// Exposed for resource monitoring & error feedback via renderer.info:
			programs: programs
		}

	}

	function WebGLProperties$1 () {

		let properties = new WeakMap()

		function get (object) {

			let map = properties.get(object)

			if (map === undefined) {

				map = {}
				properties.set(object, map)

			}

			return map

		}

		function remove (object) {

			properties.delete(object)

		}

		function update (object, key, value) {

			properties.get(object)[key] = value

		}

		function dispose () {

			properties = new WeakMap()

		}

		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		}

	}

	function painterSortStable$1 (a, b) {

		if (a.groupOrder !== b.groupOrder) {

			return a.groupOrder - b.groupOrder

		} else if (a.renderOrder !== b.renderOrder) {

			return a.renderOrder - b.renderOrder

		} else if (a.program !== b.program) {

			return a.program.id - b.program.id

		} else if (a.material.id !== b.material.id) {

			return a.material.id - b.material.id

		} else if (a.z !== b.z) {

			return a.z - b.z

		} else {

			return a.id - b.id

		}

	}

	function reversePainterSortStable$1 (a, b) {

		if (a.groupOrder !== b.groupOrder) {

			return a.groupOrder - b.groupOrder

		} else if (a.renderOrder !== b.renderOrder) {

			return a.renderOrder - b.renderOrder

		} else if (a.z !== b.z) {

			return b.z - a.z

		} else {

			return a.id - b.id

		}

	}


	function WebGLRenderList$1 (properties) {

		const renderItems = []
		let renderItemsIndex = 0

		const opaque = []
		const transmissive = []
		const transparent = []

		const defaultProgram = { id: - 1 }

		function init () {

			renderItemsIndex = 0

			opaque.length = 0
			transmissive.length = 0
			transparent.length = 0

		}

		function getNextRenderItem (object, geometry, material, groupOrder, z, group) {

			let renderItem = renderItems[renderItemsIndex]
			const materialProperties = properties.get(material)

			if (renderItem === undefined) {

				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					program: materialProperties.program || defaultProgram,
					groupOrder: groupOrder,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				}

				renderItems[renderItemsIndex] = renderItem

			} else {

				renderItem.id = object.id
				renderItem.object = object
				renderItem.geometry = geometry
				renderItem.material = material
				renderItem.program = materialProperties.program || defaultProgram
				renderItem.groupOrder = groupOrder
				renderItem.renderOrder = object.renderOrder
				renderItem.z = z
				renderItem.group = group

			}

			renderItemsIndex++

			return renderItem

		}

		function push (object, geometry, material, groupOrder, z, group) {

			const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group)

			if (material.transmission > 0.0) {

				transmissive.push(renderItem)

			} else if (material.transparent === true) {

				transparent.push(renderItem)

			} else {

				opaque.push(renderItem)

			}

		}

		function unshift (object, geometry, material, groupOrder, z, group) {

			const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group)

			if (material.transmission > 0.0) {

				transmissive.unshift(renderItem)

			} else if (material.transparent === true) {

				transparent.unshift(renderItem)

			} else {

				opaque.unshift(renderItem)

			}

		}

		function sort (customOpaqueSort, customTransparentSort) {

			if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable$1)
			if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable$1)
			if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable$1)

		}

		function finish () {

			// Clear references from inactive renderItems in the list

			for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {

				const renderItem = renderItems[i]

				if (renderItem.id === null) break

				renderItem.id = null
				renderItem.object = null
				renderItem.geometry = null
				renderItem.material = null
				renderItem.program = null
				renderItem.group = null

			}

		}

		return {

			opaque: opaque,
			transmissive: transmissive,
			transparent: transparent,

			init: init,
			push: push,
			unshift: unshift,
			finish: finish,

			sort: sort
		}

	}

	function WebGLRenderLists$1 (properties) {

		let lists = new WeakMap()

		function get (scene, renderCallDepth) {

			let list

			if (lists.has(scene) === false) {

				list = new WebGLRenderList$1(properties)
				lists.set(scene, [list])

			} else {

				if (renderCallDepth >= lists.get(scene).length) {

					list = new WebGLRenderList$1(properties)
					lists.get(scene).push(list)

				} else {

					list = lists.get(scene)[renderCallDepth]

				}

			}

			return list

		}

		function dispose () {

			lists = new WeakMap()

		}

		return {
			get: get,
			dispose: dispose
		}

	}

	function UniformsCache$1 () {

		const lights = {}

		return {

			get: function (light) {

				if (lights[light.id] !== undefined) {

					return lights[light.id]

				}

				let uniforms

				switch (light.type) {

					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color()
						}
						break

					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0
						}
						break

					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0
						}
						break

					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						}
						break

					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
						}
						break

				}

				lights[light.id] = uniforms

				return uniforms

			}

		}

	}

	function ShadowUniformsCache$1 () {

		const lights = {}

		return {

			get: function (light) {

				if (lights[light.id] !== undefined) {

					return lights[light.id]

				}

				let uniforms

				switch (light.type) {

					case 'DirectionalLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						}
						break

					case 'SpotLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						}
						break

					case 'PointLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						}
						break

					// TODO (abelnation): set RectAreaLight shadow uniforms

				}

				lights[light.id] = uniforms

				return uniforms

			}

		}

	}



	let nextVersion$1 = 0

	function shadowCastingLightsFirst$1 (lightA, lightB) {

		return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0)

	}

	function WebGLLights$1 (extensions, capabilities) {

		const cache = new UniformsCache$1()

		const shadowCache = ShadowUniformsCache$1()

		const state = {

			version: 0,

			hash: {
				directionalLength: - 1,
				pointLength: - 1,
				spotLength: - 1,
				rectAreaLength: - 1,
				hemiLength: - 1,

				numDirectionalShadows: - 1,
				numPointShadows: - 1,
				numSpotShadows: - 1
			},

			ambient: [0, 0, 0],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadow: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []

		}

		for (let i = 0; i < 9; i++) state.probe.push(new Vector3())

		const vector3 = new Vector3()
		const matrix4 = new Matrix4()
		const matrix42 = new Matrix4()

		function setup (lights) {

			let r = 0, g = 0, b = 0

			for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0)

			let directionalLength = 0
			let pointLength = 0
			let spotLength = 0
			let rectAreaLength = 0
			let hemiLength = 0

			let numDirectionalShadows = 0
			let numPointShadows = 0
			let numSpotShadows = 0

			lights.sort(shadowCastingLightsFirst$1)

			for (let i = 0, l = lights.length; i < l; i++) {

				const light = lights[i]

				const color = light.color
				const intensity = light.intensity
				const distance = light.distance

				const shadowMap = (light.shadow && light.shadow.map) ? light.shadow.map.texture : null

				if (light.isAmbientLight) {

					r += color.r * intensity
					g += color.g * intensity
					b += color.b * intensity

				} else if (light.isLightProbe) {

					for (let j = 0; j < 9; j++) {

						state.probe[j].addScaledVector(light.sh.coefficients[j], intensity)

					}

				} else if (light.isDirectionalLight) {

					const uniforms = cache.get(light)

					uniforms.color.copy(light.color).multiplyScalar(light.intensity)

					if (light.castShadow) {

						const shadow = light.shadow

						const shadowUniforms = shadowCache.get(light)

						shadowUniforms.shadowBias = shadow.bias
						shadowUniforms.shadowNormalBias = shadow.normalBias
						shadowUniforms.shadowRadius = shadow.radius
						shadowUniforms.shadowMapSize = shadow.mapSize

						state.directionalShadow[directionalLength] = shadowUniforms
						state.directionalShadowMap[directionalLength] = shadowMap
						state.directionalShadowMatrix[directionalLength] = light.shadow.matrix

						numDirectionalShadows++

					}

					state.directional[directionalLength] = uniforms

					directionalLength++

				} else if (light.isSpotLight) {

					const uniforms = cache.get(light)

					uniforms.position.setFromMatrixPosition(light.matrixWorld)

					uniforms.color.copy(color).multiplyScalar(intensity)
					uniforms.distance = distance

					uniforms.coneCos = Math.cos(light.angle)
					uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra))
					uniforms.decay = light.decay

					if (light.castShadow) {

						const shadow = light.shadow

						const shadowUniforms = shadowCache.get(light)

						shadowUniforms.shadowBias = shadow.bias
						shadowUniforms.shadowNormalBias = shadow.normalBias
						shadowUniforms.shadowRadius = shadow.radius
						shadowUniforms.shadowMapSize = shadow.mapSize

						state.spotShadow[spotLength] = shadowUniforms
						state.spotShadowMap[spotLength] = shadowMap
						state.spotShadowMatrix[spotLength] = light.shadow.matrix

						numSpotShadows++

					}

					state.spot[spotLength] = uniforms

					spotLength++

				} else if (light.isRectAreaLight) {

					const uniforms = cache.get(light)

					// (a) intensity is the total visible light emitted
					//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

					// (b) intensity is the brightness of the light
					uniforms.color.copy(color).multiplyScalar(intensity)

					uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0)
					uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0)

					state.rectArea[rectAreaLength] = uniforms

					rectAreaLength++

				} else if (light.isPointLight) {

					const uniforms = cache.get(light)

					uniforms.color.copy(light.color).multiplyScalar(light.intensity)
					uniforms.distance = light.distance
					uniforms.decay = light.decay

					if (light.castShadow) {

						const shadow = light.shadow

						const shadowUniforms = shadowCache.get(light)

						shadowUniforms.shadowBias = shadow.bias
						shadowUniforms.shadowNormalBias = shadow.normalBias
						shadowUniforms.shadowRadius = shadow.radius
						shadowUniforms.shadowMapSize = shadow.mapSize
						shadowUniforms.shadowCameraNear = shadow.camera.near
						shadowUniforms.shadowCameraFar = shadow.camera.far

						state.pointShadow[pointLength] = shadowUniforms
						state.pointShadowMap[pointLength] = shadowMap
						state.pointShadowMatrix[pointLength] = light.shadow.matrix

						numPointShadows++

					}

					state.point[pointLength] = uniforms

					pointLength++

				} else if (light.isHemisphereLight) {

					const uniforms = cache.get(light)

					uniforms.skyColor.copy(light.color).multiplyScalar(intensity)
					uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity)

					state.hemi[hemiLength] = uniforms

					hemiLength++

				}

			}

			if (rectAreaLength > 0) {

				if (capabilities.isWebGL2) {

					// WebGL 2

					state.rectAreaLTC1 = UniformsLib$1.LTC_FLOAT_1
					state.rectAreaLTC2 = UniformsLib$1.LTC_FLOAT_2

				} else {

					// WebGL 1

					if (extensions.has('OES_texture_float_linear') === true) {

						state.rectAreaLTC1 = UniformsLib$1.LTC_FLOAT_1
						state.rectAreaLTC2 = UniformsLib$1.LTC_FLOAT_2

					} else if (extensions.has('OES_texture_half_float_linear') === true) {

						state.rectAreaLTC1 = UniformsLib$1.LTC_HALF_1
						state.rectAreaLTC2 = UniformsLib$1.LTC_HALF_2

					} else {

						console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.')

					}

				}

			}

			state.ambient[0] = r
			state.ambient[1] = g
			state.ambient[2] = b

			const hash = state.hash

			if (hash.directionalLength !== directionalLength ||
				hash.pointLength !== pointLength ||
				hash.spotLength !== spotLength ||
				hash.rectAreaLength !== rectAreaLength ||
				hash.hemiLength !== hemiLength ||
				hash.numDirectionalShadows !== numDirectionalShadows ||
				hash.numPointShadows !== numPointShadows ||
				hash.numSpotShadows !== numSpotShadows) {

				state.directional.length = directionalLength
				state.spot.length = spotLength
				state.rectArea.length = rectAreaLength
				state.point.length = pointLength
				state.hemi.length = hemiLength

				state.directionalShadow.length = numDirectionalShadows
				state.directionalShadowMap.length = numDirectionalShadows
				state.pointShadow.length = numPointShadows
				state.pointShadowMap.length = numPointShadows
				state.spotShadow.length = numSpotShadows
				state.spotShadowMap.length = numSpotShadows
				state.directionalShadowMatrix.length = numDirectionalShadows
				state.pointShadowMatrix.length = numPointShadows
				state.spotShadowMatrix.length = numSpotShadows

				hash.directionalLength = directionalLength
				hash.pointLength = pointLength
				hash.spotLength = spotLength
				hash.rectAreaLength = rectAreaLength
				hash.hemiLength = hemiLength

				hash.numDirectionalShadows = numDirectionalShadows
				hash.numPointShadows = numPointShadows
				hash.numSpotShadows = numSpotShadows

				state.version = nextVersion$1++

			}

		}

		function setupView (lights, camera) {

			let directionalLength = 0
			let pointLength = 0
			let spotLength = 0
			let rectAreaLength = 0
			let hemiLength = 0

			const viewMatrix = camera.matrixWorldInverse

			for (let i = 0, l = lights.length; i < l; i++) {

				const light = lights[i]

				if (light.isDirectionalLight) {

					const uniforms = state.directional[directionalLength]

					uniforms.direction.setFromMatrixPosition(light.matrixWorld)
					vector3.setFromMatrixPosition(light.target.matrixWorld)
					uniforms.direction.sub(vector3)
					uniforms.direction.transformDirection(viewMatrix)

					directionalLength++

				} else if (light.isSpotLight) {

					const uniforms = state.spot[spotLength]

					uniforms.position.setFromMatrixPosition(light.matrixWorld)
					uniforms.position.applyMatrix4(viewMatrix)

					uniforms.direction.setFromMatrixPosition(light.matrixWorld)
					vector3.setFromMatrixPosition(light.target.matrixWorld)
					uniforms.direction.sub(vector3)
					uniforms.direction.transformDirection(viewMatrix)

					spotLength++

				} else if (light.isRectAreaLight) {

					const uniforms = state.rectArea[rectAreaLength]

					uniforms.position.setFromMatrixPosition(light.matrixWorld)
					uniforms.position.applyMatrix4(viewMatrix)

					// extract local rotation of light to derive width/height half vectors
					matrix42.identity()
					matrix4.copy(light.matrixWorld)
					matrix4.premultiply(viewMatrix)
					matrix42.extractRotation(matrix4)

					uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0)
					uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0)

					uniforms.halfWidth.applyMatrix4(matrix42)
					uniforms.halfHeight.applyMatrix4(matrix42)

					rectAreaLength++

				} else if (light.isPointLight) {

					const uniforms = state.point[pointLength]

					uniforms.position.setFromMatrixPosition(light.matrixWorld)
					uniforms.position.applyMatrix4(viewMatrix)

					pointLength++

				} else if (light.isHemisphereLight) {

					const uniforms = state.hemi[hemiLength]

					uniforms.direction.setFromMatrixPosition(light.matrixWorld)
					uniforms.direction.transformDirection(viewMatrix)
					uniforms.direction.normalize()

					hemiLength++

				}

			}

		}

		return {
			setup: setup,
			setupView: setupView,
			state: state
		}

	}

	function WebGLRenderState$1 (extensions, capabilities) {

		const lights = new WebGLLights$1(extensions, capabilities)

		const lightsArray = []
		const shadowsArray = []

		function init () {

			lightsArray.length = 0
			shadowsArray.length = 0

		}

		function pushLight (light) {

			lightsArray.push(light)

		}

		function pushShadow (shadowLight) {

			shadowsArray.push(shadowLight)

		}

		function setupLights () {

			lights.setup(lightsArray)

		}

		function setupLightsView (camera) {

			lights.setupView(lightsArray, camera)

		}

		const state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,

			lights: lights
		}

		return {
			init: init,
			state: state,
			setupLights: setupLights,
			setupLightsView: setupLightsView,

			pushLight: pushLight,
			pushShadow: pushShadow
		}

	}

	function WebGLRenderStates$1 (extensions, capabilities) {

		let renderStates = new WeakMap()

		function get (scene, renderCallDepth = 0) {

			let renderState

			if (renderStates.has(scene) === false) {

				renderState = new WebGLRenderState$1(extensions, capabilities)
				renderStates.set(scene, [renderState])

			} else {

				if (renderCallDepth >= renderStates.get(scene).length) {

					renderState = new WebGLRenderState$1(extensions, capabilities)
					renderStates.get(scene).push(renderState)

				} else {

					renderState = renderStates.get(scene)[renderCallDepth]

				}

			}

			return renderState

		}

		function dispose () {

			renderStates = new WeakMap()

		}

		return {
			get: get,
			dispose: dispose
		}

	}

	/**
	 * parameters = {
	 *
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	class MeshDepthMaterial extends Material {

		constructor(parameters) {

			super()

			this.type = 'MeshDepthMaterial'

			this.depthPacking = BasicDepthPacking

			this.map = null

			this.alphaMap = null

			this.displacementMap = null
			this.displacementScale = 1
			this.displacementBias = 0

			this.wireframe = false
			this.wireframeLinewidth = 1

			this.fog = false

			this.setValues(parameters)

		}

		copy (source) {

			super.copy(source)

			this.depthPacking = source.depthPacking

			this.map = source.map

			this.alphaMap = source.alphaMap

			this.displacementMap = source.displacementMap
			this.displacementScale = source.displacementScale
			this.displacementBias = source.displacementBias

			this.wireframe = source.wireframe
			this.wireframeLinewidth = source.wireframeLinewidth

			return this

		}

	}

	MeshDepthMaterial.prototype.isMeshDepthMaterial = true

	/**
	 * parameters = {
	 *
	 *  referencePosition: <float>,
	 *  nearDistance: <float>,
	 *  farDistance: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>
	 *
	 * }
	 */

	class MeshDistanceMaterial extends Material {

		constructor(parameters) {

			super()

			this.type = 'MeshDistanceMaterial'

			this.referencePosition = new Vector3()
			this.nearDistance = 1
			this.farDistance = 1000

			this.map = null

			this.alphaMap = null

			this.displacementMap = null
			this.displacementScale = 1
			this.displacementBias = 0

			this.fog = false

			this.setValues(parameters)

		}

		copy (source) {

			super.copy(source)

			this.referencePosition.copy(source.referencePosition)
			this.nearDistance = source.nearDistance
			this.farDistance = source.farDistance

			this.map = source.map

			this.alphaMap = source.alphaMap

			this.displacementMap = source.displacementMap
			this.displacementScale = source.displacementScale
			this.displacementBias = source.displacementBias

			return this

		}

	}

	MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true

	var vsm_frag$1 = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"

	var vsm_vert$1 = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}"

	function WebGLShadowMap$1 (_renderer, _objects, _capabilities) {

		let _frustum = new Frustum()

		const _shadowMapSize = new Vector2(),
			_viewportSize = new Vector2(),

			_viewport = new Vector4(),

			_depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
			_distanceMaterial = new MeshDistanceMaterial(),

			_materialCache = {},

			_maxTextureSize = _capabilities.maxTextureSize

		const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide }

		const shadowMaterialVertical = new ShaderMaterial({

			defines: {
				SAMPLE_RATE: 2.0 / 8.0,
				HALF_SAMPLE_RATE: 1.0 / 8.0
			},

			uniforms: {
				shadow_pass: { value: null },
				resolution: { value: new Vector2() },
				radius: { value: 4.0 }
			},

			vertexShader: vsm_vert$1,

			fragmentShader: vsm_frag$1

		})

		const shadowMaterialHorizontal = shadowMaterialVertical.clone()
		shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1

		const fullScreenTri = new BufferGeometry()
		fullScreenTri.setAttribute(
			'position',
			new BufferAttribute(
				new Float32Array([- 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5]),
				3
			)
		)

		const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical)

		const scope = this

		this.enabled = false

		this.autoUpdate = true
		this.needsUpdate = false

		this.type = PCFShadowMap

		this.render = function (lights, scene, camera) {

			if (scope.enabled === false) return
			if (scope.autoUpdate === false && scope.needsUpdate === false) return

			if (lights.length === 0) return

			const currentRenderTarget = _renderer.getRenderTarget()
			const activeCubeFace = _renderer.getActiveCubeFace()
			const activeMipmapLevel = _renderer.getActiveMipmapLevel()

			const _state = _renderer.state

			// Set GL state for depth map.
			_state.setBlending(NoBlending)
			_state.buffers.color.setClear(1, 1, 1, 1)
			_state.buffers.depth.setTest(true)
			_state.setScissorTest(false)

			// render depth map

			for (let i = 0, il = lights.length; i < il; i++) {

				const light = lights[i]
				const shadow = light.shadow

				if (shadow === undefined) {

					console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.')
					continue

				}

				if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue

				_shadowMapSize.copy(shadow.mapSize)

				const shadowFrameExtents = shadow.getFrameExtents()

				_shadowMapSize.multiply(shadowFrameExtents)

				_viewportSize.copy(shadow.mapSize)

				if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {

					if (_shadowMapSize.x > _maxTextureSize) {

						_viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x)
						_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x
						shadow.mapSize.x = _viewportSize.x

					}

					if (_shadowMapSize.y > _maxTextureSize) {

						_viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y)
						_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y
						shadow.mapSize.y = _viewportSize.y

					}

				}

				if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {

					const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat }

					shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars)
					shadow.map.texture.name = light.name + '.shadowMap'

					shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars)

					shadow.camera.updateProjectionMatrix()

				}

				if (shadow.map === null) {

					const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat }

					shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars)
					shadow.map.texture.name = light.name + '.shadowMap'

					shadow.camera.updateProjectionMatrix()

				}

				_renderer.setRenderTarget(shadow.map)
				_renderer.clear()

				const viewportCount = shadow.getViewportCount()

				for (let vp = 0; vp < viewportCount; vp++) {

					const viewport = shadow.getViewport(vp)

					_viewport.set(
						_viewportSize.x * viewport.x,
						_viewportSize.y * viewport.y,
						_viewportSize.x * viewport.z,
						_viewportSize.y * viewport.w
					)

					_state.viewport(_viewport)

					shadow.updateMatrices(light, vp)

					_frustum = shadow.getFrustum()

					renderObject(scene, camera, shadow.camera, light, this.type)

				}

				// do blur pass for VSM

				if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {

					VSMPass(shadow, camera)

				}

				shadow.needsUpdate = false

			}

			scope.needsUpdate = false

			_renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel)

		}

		function VSMPass (shadow, camera) {

			const geometry = _objects.update(fullScreenMesh)

			// vertical pass

			shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture
			shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize
			shadowMaterialVertical.uniforms.radius.value = shadow.radius
			_renderer.setRenderTarget(shadow.mapPass)
			_renderer.clear()
			_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null)

			// horizontal pass

			shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture
			shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize
			shadowMaterialHorizontal.uniforms.radius.value = shadow.radius
			_renderer.setRenderTarget(shadow.map)
			_renderer.clear()
			_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null)

		}

		function getDepthMaterial (object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {

			let result = null

			const customMaterial = (light.isPointLight === true) ? object.customDistanceMaterial : object.customDepthMaterial

			if (customMaterial !== undefined) {

				result = customMaterial

			} else {

				result = (light.isPointLight === true) ? _distanceMaterial : _depthMaterial

			}

			if (_renderer.localClippingEnabled &&
				material.clipShadows === true &&
				material.clippingPlanes.length !== 0) {

				// in this case we need a unique material instance reflecting the
				// appropriate state

				const keyA = result.uuid, keyB = material.uuid

				let materialsForVariant = _materialCache[keyA]

				if (materialsForVariant === undefined) {

					materialsForVariant = {}
					_materialCache[keyA] = materialsForVariant

				}

				let cachedMaterial = materialsForVariant[keyB]

				if (cachedMaterial === undefined) {

					cachedMaterial = result.clone()
					materialsForVariant[keyB] = cachedMaterial

				}

				result = cachedMaterial

			}

			result.visible = material.visible
			result.wireframe = material.wireframe

			if (type === VSMShadowMap) {

				result.side = (material.shadowSide !== null) ? material.shadowSide : material.side

			} else {

				result.side = (material.shadowSide !== null) ? material.shadowSide : shadowSide[material.side]

			}

			result.clipShadows = material.clipShadows
			result.clippingPlanes = material.clippingPlanes
			result.clipIntersection = material.clipIntersection

			result.wireframeLinewidth = material.wireframeLinewidth
			result.linewidth = material.linewidth

			if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {

				result.referencePosition.setFromMatrixPosition(light.matrixWorld)
				result.nearDistance = shadowCameraNear
				result.farDistance = shadowCameraFar

			}

			return result

		}

		function renderObject (object, camera, shadowCamera, light, type) {

			if (object.visible === false) return

			const visible = object.layers.test(camera.layers)

			if (visible && (object.isMesh || object.isLine || object.isPoints)) {

				if ((object.castShadow || (object.receiveShadow && type === VSMShadowMap)) && (!object.frustumCulled || _frustum.intersectsObject(object))) {

					object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld)

					const geometry = _objects.update(object)
					const material = object.material

					if (Array.isArray(material)) {

						const groups = geometry.groups

						for (let k = 0, kl = groups.length; k < kl; k++) {

							const group = groups[k]
							const groupMaterial = material[group.materialIndex]

							if (groupMaterial && groupMaterial.visible) {

								const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type)

								_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group)

							}

						}

					} else if (material.visible) {

						const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type)

						_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null)

					}

				}

			}

			const children = object.children

			for (let i = 0, l = children.length; i < l; i++) {

				renderObject(children[i], camera, shadowCamera, light, type)

			}

		}

	}

	function WebGLState$1 (gl, extensions, capabilities) {

		const isWebGL2 = capabilities.isWebGL2

		function ColorBuffer () {

			let locked = false

			const color = new Vector4()
			let currentColorMask = null
			const currentColorClear = new Vector4(0, 0, 0, 0)

			return {

				setMask: function (colorMask) {

					if (currentColorMask !== colorMask && !locked) {

						gl.colorMask(colorMask, colorMask, colorMask, colorMask)
						currentColorMask = colorMask

					}

				},

				setLocked: function (lock) {

					locked = lock

				},

				setClear: function (r, g, b, a, premultipliedAlpha) {

					if (premultipliedAlpha === true) {

						r *= a; g *= a; b *= a

					}

					color.set(r, g, b, a)

					if (currentColorClear.equals(color) === false) {

						gl.clearColor(r, g, b, a)
						currentColorClear.copy(color)

					}

				},

				reset: function () {

					locked = false

					currentColorMask = null
					currentColorClear.set(- 1, 0, 0, 0) // set to invalid state

				}

			}

		}

		function DepthBuffer () {

			let locked = false

			let currentDepthMask = null
			let currentDepthFunc = null
			let currentDepthClear = null

			return {

				setTest: function (depthTest) {

					if (depthTest) {

						enable(2929)

					} else {

						disable(2929)

					}

				},

				setMask: function (depthMask) {

					if (currentDepthMask !== depthMask && !locked) {

						gl.depthMask(depthMask)
						currentDepthMask = depthMask

					}

				},

				setFunc: function (depthFunc) {

					if (currentDepthFunc !== depthFunc) {

						if (depthFunc) {

							switch (depthFunc) {

								case NeverDepth:

									gl.depthFunc(512)
									break

								case AlwaysDepth:

									gl.depthFunc(519)
									break

								case LessDepth:

									gl.depthFunc(513)
									break

								case LessEqualDepth:

									gl.depthFunc(515)
									break

								case EqualDepth:

									gl.depthFunc(514)
									break

								case GreaterEqualDepth:

									gl.depthFunc(518)
									break

								case GreaterDepth:

									gl.depthFunc(516)
									break

								case NotEqualDepth:

									gl.depthFunc(517)
									break

								default:

									gl.depthFunc(515)

							}

						} else {

							gl.depthFunc(515)

						}

						currentDepthFunc = depthFunc

					}

				},

				setLocked: function (lock) {

					locked = lock

				},

				setClear: function (depth) {

					if (currentDepthClear !== depth) {

						gl.clearDepth(depth)
						currentDepthClear = depth

					}

				},

				reset: function () {

					locked = false

					currentDepthMask = null
					currentDepthFunc = null
					currentDepthClear = null

				}

			}

		}

		function StencilBuffer () {

			let locked = false

			let currentStencilMask = null
			let currentStencilFunc = null
			let currentStencilRef = null
			let currentStencilFuncMask = null
			let currentStencilFail = null
			let currentStencilZFail = null
			let currentStencilZPass = null
			let currentStencilClear = null

			return {

				setTest: function (stencilTest) {

					if (!locked) {

						if (stencilTest) {

							enable(2960)

						} else {

							disable(2960)

						}

					}

				},

				setMask: function (stencilMask) {

					if (currentStencilMask !== stencilMask && !locked) {

						gl.stencilMask(stencilMask)
						currentStencilMask = stencilMask

					}

				},

				setFunc: function (stencilFunc, stencilRef, stencilMask) {

					if (currentStencilFunc !== stencilFunc ||
						currentStencilRef !== stencilRef ||
						currentStencilFuncMask !== stencilMask) {

						gl.stencilFunc(stencilFunc, stencilRef, stencilMask)

						currentStencilFunc = stencilFunc
						currentStencilRef = stencilRef
						currentStencilFuncMask = stencilMask

					}

				},

				setOp: function (stencilFail, stencilZFail, stencilZPass) {

					if (currentStencilFail !== stencilFail ||
						currentStencilZFail !== stencilZFail ||
						currentStencilZPass !== stencilZPass) {

						gl.stencilOp(stencilFail, stencilZFail, stencilZPass)

						currentStencilFail = stencilFail
						currentStencilZFail = stencilZFail
						currentStencilZPass = stencilZPass

					}

				},

				setLocked: function (lock) {

					locked = lock

				},

				setClear: function (stencil) {

					if (currentStencilClear !== stencil) {

						gl.clearStencil(stencil)
						currentStencilClear = stencil

					}

				},

				reset: function () {

					locked = false

					currentStencilMask = null
					currentStencilFunc = null
					currentStencilRef = null
					currentStencilFuncMask = null
					currentStencilFail = null
					currentStencilZFail = null
					currentStencilZPass = null
					currentStencilClear = null

				}

			}

		}

		//

		const colorBuffer = new ColorBuffer()
		const depthBuffer = new DepthBuffer()
		const stencilBuffer = new StencilBuffer()

		let enabledCapabilities = {}

		let xrFramebuffer = null
		let currentBoundFramebuffers = {}

		let currentProgram = null

		let currentBlendingEnabled = false
		let currentBlending = null
		let currentBlendEquation = null
		let currentBlendSrc = null
		let currentBlendDst = null
		let currentBlendEquationAlpha = null
		let currentBlendSrcAlpha = null
		let currentBlendDstAlpha = null
		let currentPremultipledAlpha = false

		let currentFlipSided = null
		let currentCullFace = null

		let currentLineWidth = null

		let currentPolygonOffsetFactor = null
		let currentPolygonOffsetUnits = null

		const maxTextures = gl.getParameter(35661)

		let lineWidthAvailable = false
		let version = 0
		const glVersion = gl.getParameter(7938)

		if (glVersion.indexOf('WebGL') !== - 1) {

			version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1])
			lineWidthAvailable = (version >= 1.0)

		} else if (glVersion.indexOf('OpenGL ES') !== - 1) {

			version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1])
			lineWidthAvailable = (version >= 2.0)

		}

		let currentTextureSlot = null
		let currentBoundTextures = {}

		const scissorParam = gl.getParameter(3088)
		const viewportParam = gl.getParameter(2978)

		const currentScissor = new Vector4().fromArray(scissorParam)
		const currentViewport = new Vector4().fromArray(viewportParam)

		function createTexture (type, target, count) {

			const data = new Uint8Array(4) // 4 is required to match default unpack alignment of 4.
			const texture = gl.createTexture()

			gl.bindTexture(type, texture)
			gl.texParameteri(type, 10241, 9728)
			gl.texParameteri(type, 10240, 9728)

			for (let i = 0; i < count; i++) {

				gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data)

			}

			return texture

		}

		const emptyTextures = {}
		emptyTextures[3553] = createTexture(3553, 3553, 1)
		emptyTextures[34067] = createTexture(34067, 34069, 6)

		// init

		colorBuffer.setClear(0, 0, 0, 1)
		depthBuffer.setClear(1)
		stencilBuffer.setClear(0)

		enable(2929)
		depthBuffer.setFunc(LessEqualDepth)

		setFlipSided(false)
		setCullFace(CullFaceBack)
		enable(2884)

		setBlending(NoBlending)

		//

		function enable (id) {

			if (enabledCapabilities[id] !== true) {

				gl.enable(id)
				enabledCapabilities[id] = true

			}

		}

		function disable (id) {

			if (enabledCapabilities[id] !== false) {

				gl.disable(id)
				enabledCapabilities[id] = false

			}

		}

		function bindXRFramebuffer (framebuffer) {

			if (framebuffer !== xrFramebuffer) {

				gl.bindFramebuffer(36160, framebuffer)

				xrFramebuffer = framebuffer

			}

		}

		function bindFramebuffer (target, framebuffer) {

			if (framebuffer === null && xrFramebuffer !== null) framebuffer = xrFramebuffer // use active XR framebuffer if available

			if (currentBoundFramebuffers[target] !== framebuffer) {

				gl.bindFramebuffer(target, framebuffer)

				currentBoundFramebuffers[target] = framebuffer

				if (isWebGL2) {

					// 36009 is equivalent to 36160

					if (target === 36009) {

						currentBoundFramebuffers[36160] = framebuffer

					}

					if (target === 36160) {

						currentBoundFramebuffers[36009] = framebuffer

					}

				}

				return true

			}

			return false

		}

		function useProgram (program) {

			if (currentProgram !== program) {

				gl.useProgram(program)

				currentProgram = program

				return true

			}

			return false

		}

		const equationToGL = {
			[AddEquation]: 32774,
			[SubtractEquation]: 32778,
			[ReverseSubtractEquation]: 32779
		}

		if (isWebGL2) {

			equationToGL[MinEquation] = 32775
			equationToGL[MaxEquation] = 32776

		} else {

			const extension = extensions.get('EXT_blend_minmax')

			if (extension !== null) {

				equationToGL[MinEquation] = extension.MIN_EXT
				equationToGL[MaxEquation] = extension.MAX_EXT

			}

		}

		const factorToGL = {
			[ZeroFactor]: 0,
			[OneFactor]: 1,
			[SrcColorFactor]: 768,
			[SrcAlphaFactor]: 770,
			[SrcAlphaSaturateFactor]: 776,
			[DstColorFactor]: 774,
			[DstAlphaFactor]: 772,
			[OneMinusSrcColorFactor]: 769,
			[OneMinusSrcAlphaFactor]: 771,
			[OneMinusDstColorFactor]: 775,
			[OneMinusDstAlphaFactor]: 773
		}

		function setBlending (blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {

			if (blending === NoBlending) {

				if (currentBlendingEnabled === true) {

					disable(3042)
					currentBlendingEnabled = false

				}

				return

			}

			if (currentBlendingEnabled === false) {

				enable(3042)
				currentBlendingEnabled = true

			}

			if (blending !== CustomBlending) {

				if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {

					if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {

						gl.blendEquation(32774)

						currentBlendEquation = AddEquation
						currentBlendEquationAlpha = AddEquation

					}

					if (premultipliedAlpha) {

						switch (blending) {

							case NormalBlending:
								gl.blendFuncSeparate(1, 771, 1, 771)
								break

							case AdditiveBlending:
								gl.blendFunc(1, 1)
								break

							case SubtractiveBlending:
								gl.blendFuncSeparate(0, 0, 769, 771)
								break

							case MultiplyBlending:
								gl.blendFuncSeparate(0, 768, 0, 770)
								break

							default:
								console.error('THREE.WebGLState: Invalid blending: ', blending)
								break

						}

					} else {

						switch (blending) {

							case NormalBlending:
								gl.blendFuncSeparate(770, 771, 1, 771)
								break

							case AdditiveBlending:
								gl.blendFunc(770, 1)
								break

							case SubtractiveBlending:
								gl.blendFunc(0, 769)
								break

							case MultiplyBlending:
								gl.blendFunc(0, 768)
								break

							default:
								console.error('THREE.WebGLState: Invalid blending: ', blending)
								break

						}

					}

					currentBlendSrc = null
					currentBlendDst = null
					currentBlendSrcAlpha = null
					currentBlendDstAlpha = null

					currentBlending = blending
					currentPremultipledAlpha = premultipliedAlpha

				}

				return

			}

			// custom blending

			blendEquationAlpha = blendEquationAlpha || blendEquation
			blendSrcAlpha = blendSrcAlpha || blendSrc
			blendDstAlpha = blendDstAlpha || blendDst

			if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {

				gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha])

				currentBlendEquation = blendEquation
				currentBlendEquationAlpha = blendEquationAlpha

			}

			if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {

				gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha])

				currentBlendSrc = blendSrc
				currentBlendDst = blendDst
				currentBlendSrcAlpha = blendSrcAlpha
				currentBlendDstAlpha = blendDstAlpha

			}

			currentBlending = blending
			currentPremultipledAlpha = null

		}

		function setMaterial (material, frontFaceCW) {

			material.side === DoubleSide
				? disable(2884)
				: enable(2884)

			let flipSided = (material.side === BackSide)
			if (frontFaceCW) flipSided = !flipSided

			setFlipSided(flipSided);

			(material.blending === NormalBlending && material.transparent === false)
				? setBlending(NoBlending)
				: setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha)

			depthBuffer.setFunc(material.depthFunc)
			depthBuffer.setTest(material.depthTest)
			depthBuffer.setMask(material.depthWrite)
			colorBuffer.setMask(material.colorWrite)

			const stencilWrite = material.stencilWrite
			stencilBuffer.setTest(stencilWrite)
			if (stencilWrite) {

				stencilBuffer.setMask(material.stencilWriteMask)
				stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask)
				stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass)

			}

			setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits)

			material.alphaToCoverage === true
				? enable(32926)
				: disable(32926)

		}

		//

		function setFlipSided (flipSided) {

			if (currentFlipSided !== flipSided) {

				if (flipSided) {

					gl.frontFace(2304)

				} else {

					gl.frontFace(2305)

				}

				currentFlipSided = flipSided

			}

		}

		function setCullFace (cullFace) {

			if (cullFace !== CullFaceNone) {

				enable(2884)

				if (cullFace !== currentCullFace) {

					if (cullFace === CullFaceBack) {

						gl.cullFace(1029)

					} else if (cullFace === CullFaceFront) {

						gl.cullFace(1028)

					} else {

						gl.cullFace(1032)

					}

				}

			} else {

				disable(2884)

			}

			currentCullFace = cullFace

		}

		function setLineWidth (width) {

			if (width !== currentLineWidth) {

				if (lineWidthAvailable) gl.lineWidth(width)

				currentLineWidth = width

			}

		}

		function setPolygonOffset (polygonOffset, factor, units) {

			if (polygonOffset) {

				enable(32823)

				if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {

					gl.polygonOffset(factor, units)

					currentPolygonOffsetFactor = factor
					currentPolygonOffsetUnits = units

				}

			} else {

				disable(32823)

			}

		}

		function setScissorTest (scissorTest) {

			if (scissorTest) {

				enable(3089)

			} else {

				disable(3089)

			}

		}

		// texture

		function activeTexture (webglSlot) {

			if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1

			if (currentTextureSlot !== webglSlot) {

				gl.activeTexture(webglSlot)
				currentTextureSlot = webglSlot

			}

		}

		function bindTexture (webglType, webglTexture) {

			if (currentTextureSlot === null) {

				activeTexture()

			}

			let boundTexture = currentBoundTextures[currentTextureSlot]

			if (boundTexture === undefined) {

				boundTexture = { type: undefined, texture: undefined }
				currentBoundTextures[currentTextureSlot] = boundTexture

			}

			if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {

				gl.bindTexture(webglType, webglTexture || emptyTextures[webglType])

				boundTexture.type = webglType
				boundTexture.texture = webglTexture

			}

		}

		function unbindTexture () {

			const boundTexture = currentBoundTextures[currentTextureSlot]

			if (boundTexture !== undefined && boundTexture.type !== undefined) {

				gl.bindTexture(boundTexture.type, null)

				boundTexture.type = undefined
				boundTexture.texture = undefined

			}

		}

		function compressedTexImage2D () {

			try {

				gl.compressedTexImage2D.apply(gl, arguments)

			} catch (error) {

				console.error('THREE.WebGLState:', error)

			}

		}

		function texImage2D () {

			try {

				gl.texImage2D.apply(gl, arguments)

			} catch (error) {

				console.error('THREE.WebGLState:', error)

			}

		}

		function texImage3D () {

			try {

				gl.texImage3D.apply(gl, arguments)

			} catch (error) {

				console.error('THREE.WebGLState:', error)

			}

		}

		//

		function scissor (scissor) {

			if (currentScissor.equals(scissor) === false) {

				gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w)
				currentScissor.copy(scissor)

			}

		}

		function viewport (viewport) {

			if (currentViewport.equals(viewport) === false) {

				gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w)
				currentViewport.copy(viewport)

			}

		}

		//

		function reset () {

			// reset state

			gl.disable(3042)
			gl.disable(2884)
			gl.disable(2929)
			gl.disable(32823)
			gl.disable(3089)
			gl.disable(2960)
			gl.disable(32926)

			gl.blendEquation(32774)
			gl.blendFunc(1, 0)
			gl.blendFuncSeparate(1, 0, 1, 0)

			gl.colorMask(true, true, true, true)
			gl.clearColor(0, 0, 0, 0)

			gl.depthMask(true)
			gl.depthFunc(513)
			gl.clearDepth(1)

			gl.stencilMask(0xffffffff)
			gl.stencilFunc(519, 0, 0xffffffff)
			gl.stencilOp(7680, 7680, 7680)
			gl.clearStencil(0)

			gl.cullFace(1029)
			gl.frontFace(2305)

			gl.polygonOffset(0, 0)

			gl.activeTexture(33984)

			gl.bindFramebuffer(36160, null)

			if (isWebGL2 === true) {

				gl.bindFramebuffer(36009, null)
				gl.bindFramebuffer(36008, null)

			}

			gl.useProgram(null)

			gl.lineWidth(1)

			gl.scissor(0, 0, gl.canvas.width, gl.canvas.height)
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)

			// reset internals

			enabledCapabilities = {}

			currentTextureSlot = null
			currentBoundTextures = {}

			xrFramebuffer = null
			currentBoundFramebuffers = {}

			currentProgram = null

			currentBlendingEnabled = false
			currentBlending = null
			currentBlendEquation = null
			currentBlendSrc = null
			currentBlendDst = null
			currentBlendEquationAlpha = null
			currentBlendSrcAlpha = null
			currentBlendDstAlpha = null
			currentPremultipledAlpha = false

			currentFlipSided = null
			currentCullFace = null

			currentLineWidth = null

			currentPolygonOffsetFactor = null
			currentPolygonOffsetUnits = null

			currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height)
			currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height)

			colorBuffer.reset()
			depthBuffer.reset()
			stencilBuffer.reset()

		}

		return {

			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},

			enable: enable,
			disable: disable,

			bindFramebuffer: bindFramebuffer,
			bindXRFramebuffer: bindXRFramebuffer,

			useProgram: useProgram,

			setBlending: setBlending,
			setMaterial: setMaterial,

			setFlipSided: setFlipSided,
			setCullFace: setCullFace,

			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,

			setScissorTest: setScissorTest,

			activeTexture: activeTexture,
			bindTexture: bindTexture,
			unbindTexture: unbindTexture,
			compressedTexImage2D: compressedTexImage2D,
			texImage2D: texImage2D,
			texImage3D: texImage3D,

			scissor: scissor,
			viewport: viewport,

			reset: reset

		}

	}

	function WebGLTextures$1 (_gl, extensions, state, properties, capabilities, utils, info) {

		const isWebGL2 = capabilities.isWebGL2
		const maxTextures = capabilities.maxTextures
		const maxCubemapSize = capabilities.maxCubemapSize
		const maxTextureSize = capabilities.maxTextureSize
		const maxSamples = capabilities.maxSamples

		const _videoTextures = new WeakMap()
		let _canvas

		// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
		// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
		// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

		let useOffscreenCanvas = false

		try {

			useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
				&& (new OffscreenCanvas(1, 1).getContext('2d')) !== null

		} catch (err) {

			// Ignore any errors

		}

		function createCanvas (width, height) {

			// Use OffscreenCanvas when available. Specially needed in web workers

			return useOffscreenCanvas ?
				new OffscreenCanvas(width, height) :
				document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas')

		}

		function resizeImage (image, needsPowerOfTwo, needsNewCanvas, maxSize) {

			let scale = 1

			// handle case if texture exceeds max size

			if (image.width > maxSize || image.height > maxSize) {

				scale = maxSize / Math.max(image.width, image.height)

			}

			// only perform resize if necessary

			if (scale < 1 || needsPowerOfTwo === true) {

				// only perform resize for certain image types

				if ((typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) ||
					(typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement) ||
					(typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)) {

					const floor = needsPowerOfTwo ? floorPowerOfTwo$1 : Math.floor

					const width = floor(scale * image.width)
					const height = floor(scale * image.height)

					if (_canvas === undefined) _canvas = createCanvas(width, height)

					// cube textures can't reuse the same canvas

					const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas

					canvas.width = width
					canvas.height = height

					const context = canvas.getContext('2d')
					context.drawImage(image, 0, 0, width, height)

					console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').')

					return canvas

				} else {

					if ('data' in image) {

						console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').')

					}

					return image

				}

			}

			return image

		}

		function isPowerOfTwo$1$1 (image) {

			return isPowerOfTwo$1(image.width) && isPowerOfTwo$1(image.height)

		}

		function textureNeedsPowerOfTwo (texture) {

			if (isWebGL2) return false

			return (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) ||
				(texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter)

		}

		function textureNeedsGenerateMipmaps (texture, supportsMips) {

			return texture.generateMipmaps && supportsMips &&
				texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter

		}

		function generateMipmap (target, texture, width, height, depth = 1) {

			_gl.generateMipmap(target)

			const textureProperties = properties.get(texture)

			textureProperties.__maxMipLevel = Math.log2(Math.max(width, height, depth))

		}

		function getInternalFormat (internalFormatName, glFormat, glType) {

			if (isWebGL2 === false) return glFormat

			if (internalFormatName !== null) {

				if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName]

				console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'')

			}

			let internalFormat = glFormat

			if (glFormat === 6403) {

				if (glType === 5126) internalFormat = 33326
				if (glType === 5131) internalFormat = 33325
				if (glType === 5121) internalFormat = 33321

			}

			if (glFormat === 6407) {

				if (glType === 5126) internalFormat = 34837
				if (glType === 5131) internalFormat = 34843
				if (glType === 5121) internalFormat = 32849

			}

			if (glFormat === 6408) {

				if (glType === 5126) internalFormat = 34836
				if (glType === 5131) internalFormat = 34842
				if (glType === 5121) internalFormat = 32856

			}

			if (internalFormat === 33325 || internalFormat === 33326 ||
				internalFormat === 34842 || internalFormat === 34836) {

				extensions.get('EXT_color_buffer_float')

			}

			return internalFormat

		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback (f) {

			if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {

				return 9728

			}

			return 9729

		}

		//

		function onTextureDispose (event) {

			const texture = event.target

			texture.removeEventListener('dispose', onTextureDispose)

			deallocateTexture(texture)

			if (texture.isVideoTexture) {

				_videoTextures.delete(texture)

			}

			info.memory.textures--

		}

		function onRenderTargetDispose (event) {

			const renderTarget = event.target

			renderTarget.removeEventListener('dispose', onRenderTargetDispose)

			deallocateRenderTarget(renderTarget)

		}

		//

		function deallocateTexture (texture) {

			const textureProperties = properties.get(texture)

			if (textureProperties.__webglInit === undefined) return

			_gl.deleteTexture(textureProperties.__webglTexture)

			properties.remove(texture)

		}

		function deallocateRenderTarget (renderTarget) {

			const texture = renderTarget.texture

			const renderTargetProperties = properties.get(renderTarget)
			const textureProperties = properties.get(texture)

			if (!renderTarget) return

			if (textureProperties.__webglTexture !== undefined) {

				_gl.deleteTexture(textureProperties.__webglTexture)

				info.memory.textures--

			}

			if (renderTarget.depthTexture) {

				renderTarget.depthTexture.dispose()

			}

			if (renderTarget.isWebGLCubeRenderTarget) {

				for (let i = 0; i < 6; i++) {

					_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i])
					if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i])

				}

			} else {

				_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer)
				if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer)
				if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer)
				if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer)
				if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer)

			}

			if (renderTarget.isWebGLMultipleRenderTargets) {

				for (let i = 0, il = texture.length; i < il; i++) {

					const attachmentProperties = properties.get(texture[i])

					if (attachmentProperties.__webglTexture) {

						_gl.deleteTexture(attachmentProperties.__webglTexture)

						info.memory.textures--

					}

					properties.remove(texture[i])

				}

			}

			properties.remove(texture)
			properties.remove(renderTarget)

		}

		//

		let textureUnits = 0

		function resetTextureUnits () {

			textureUnits = 0

		}

		function allocateTextureUnit () {

			const textureUnit = textureUnits

			if (textureUnit >= maxTextures) {

				console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures)

			}

			textureUnits += 1

			return textureUnit

		}

		//

		function setTexture2D (texture, slot) {

			const textureProperties = properties.get(texture)

			if (texture.isVideoTexture) updateVideoTexture(texture)

			if (texture.version > 0 && textureProperties.__version !== texture.version) {

				const image = texture.image

				if (image === undefined) {

					console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined')

				} else if (image.complete === false) {

					console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete')

				} else {

					uploadTexture(textureProperties, texture, slot)
					return

				}

			}

			state.activeTexture(33984 + slot)
			state.bindTexture(3553, textureProperties.__webglTexture)

		}

		function setTexture2DArray (texture, slot) {

			const textureProperties = properties.get(texture)

			if (texture.version > 0 && textureProperties.__version !== texture.version) {

				uploadTexture(textureProperties, texture, slot)
				return

			}

			state.activeTexture(33984 + slot)
			state.bindTexture(35866, textureProperties.__webglTexture)

		}

		function setTexture3D (texture, slot) {

			const textureProperties = properties.get(texture)

			if (texture.version > 0 && textureProperties.__version !== texture.version) {

				uploadTexture(textureProperties, texture, slot)
				return

			}

			state.activeTexture(33984 + slot)
			state.bindTexture(32879, textureProperties.__webglTexture)

		}

		function setTextureCube (texture, slot) {

			const textureProperties = properties.get(texture)

			if (texture.version > 0 && textureProperties.__version !== texture.version) {

				uploadCubeTexture(textureProperties, texture, slot)
				return

			}

			state.activeTexture(33984 + slot)
			state.bindTexture(34067, textureProperties.__webglTexture)

		}

		const wrappingToGL = {
			[RepeatWrapping]: 10497,
			[ClampToEdgeWrapping]: 33071,
			[MirroredRepeatWrapping]: 33648
		}

		const filterToGL = {
			[NearestFilter]: 9728,
			[NearestMipmapNearestFilter]: 9984,
			[NearestMipmapLinearFilter]: 9986,

			[LinearFilter]: 9729,
			[LinearMipmapNearestFilter]: 9985,
			[LinearMipmapLinearFilter]: 9987
		}

		function setTextureParameters (textureType, texture, supportsMips) {

			if (supportsMips) {

				_gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS])
				_gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT])

				if (textureType === 32879 || textureType === 35866) {

					_gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR])

				}

				_gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter])
				_gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter])

			} else {

				_gl.texParameteri(textureType, 10242, 33071)
				_gl.texParameteri(textureType, 10243, 33071)

				if (textureType === 32879 || textureType === 35866) {

					_gl.texParameteri(textureType, 32882, 33071)

				}

				if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {

					console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.')

				}

				_gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter))
				_gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter))

				if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {

					console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.')

				}

			}

			if (extensions.has('EXT_texture_filter_anisotropic') === true) {

				const extension = extensions.get('EXT_texture_filter_anisotropic')

				if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return // verify extension for WebGL 1 and WebGL 2
				if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has('OES_texture_half_float_linear') === false)) return // verify extension for WebGL 1 only

				if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {

					_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()))
					properties.get(texture).__currentAnisotropy = texture.anisotropy

				}

			}

		}

		function initTexture (textureProperties, texture) {

			if (textureProperties.__webglInit === undefined) {

				textureProperties.__webglInit = true

				texture.addEventListener('dispose', onTextureDispose)

				textureProperties.__webglTexture = _gl.createTexture()

				info.memory.textures++

			}

		}

		function uploadTexture (textureProperties, texture, slot) {

			let textureType = 3553

			if (texture.isDataTexture2DArray) textureType = 35866
			if (texture.isDataTexture3D) textureType = 32879

			initTexture(textureProperties, texture)

			state.activeTexture(33984 + slot)
			state.bindTexture(textureType, textureProperties.__webglTexture)

			_gl.pixelStorei(37440, texture.flipY)
			_gl.pixelStorei(37441, texture.premultiplyAlpha)
			_gl.pixelStorei(3317, texture.unpackAlignment)
			_gl.pixelStorei(37443, 0)

			const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1$1(texture.image) === false
			const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize)

			const supportsMips = isPowerOfTwo$1$1(image) || isWebGL2,
				glFormat = utils.convert(texture.format)

			let glType = utils.convert(texture.type),
				glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType)

			setTextureParameters(textureType, texture, supportsMips)

			let mipmap
			const mipmaps = texture.mipmaps

			if (texture.isDepthTexture) {

				// populate depth texture with dummy data

				glInternalFormat = 6402

				if (isWebGL2) {

					if (texture.type === FloatType) {

						glInternalFormat = 36012

					} else if (texture.type === UnsignedIntType) {

						glInternalFormat = 33190

					} else if (texture.type === UnsignedInt248Type) {

						glInternalFormat = 35056

					} else {

						glInternalFormat = 33189 // WebGL2 requires sized internalformat for glTexImage2D

					}

				} else {

					if (texture.type === FloatType) {

						console.error('WebGLRenderer: Floating point depth texture requires WebGL2.')

					}

				}

				// validation checks for WebGL 1

				if (texture.format === DepthFormat && glInternalFormat === 6402) {

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {

						console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.')

						texture.type = UnsignedShortType
						glType = utils.convert(texture.type)

					}

				}

				if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {

					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					glInternalFormat = 34041

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if (texture.type !== UnsignedInt248Type) {

						console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.')

						texture.type = UnsignedInt248Type
						glType = utils.convert(texture.type)

					}

				}

				//

				state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null)

			} else if (texture.isDataTexture) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if (mipmaps.length > 0 && supportsMips) {

					for (let i = 0, il = mipmaps.length; i < il; i++) {

						mipmap = mipmaps[i]
						state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data)

					}

					texture.generateMipmaps = false
					textureProperties.__maxMipLevel = mipmaps.length - 1

				} else {

					state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data)
					textureProperties.__maxMipLevel = 0

				}

			} else if (texture.isCompressedTexture) {

				for (let i = 0, il = mipmaps.length; i < il; i++) {

					mipmap = mipmaps[i]

					if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {

						if (glFormat !== null) {

							state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data)

						} else {

							console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()')

						}

					} else {

						state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data)

					}

				}

				textureProperties.__maxMipLevel = mipmaps.length - 1

			} else if (texture.isDataTexture2DArray) {

				state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data)
				textureProperties.__maxMipLevel = 0

			} else if (texture.isDataTexture3D) {

				state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data)
				textureProperties.__maxMipLevel = 0

			} else {

				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if (mipmaps.length > 0 && supportsMips) {

					for (let i = 0, il = mipmaps.length; i < il; i++) {

						mipmap = mipmaps[i]
						state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap)

					}

					texture.generateMipmaps = false
					textureProperties.__maxMipLevel = mipmaps.length - 1

				} else {

					state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image)
					textureProperties.__maxMipLevel = 0

				}

			}

			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {

				generateMipmap(textureType, texture, image.width, image.height)

			}

			textureProperties.__version = texture.version

			if (texture.onUpdate) texture.onUpdate(texture)

		}

		function uploadCubeTexture (textureProperties, texture, slot) {

			if (texture.image.length !== 6) return

			initTexture(textureProperties, texture)

			state.activeTexture(33984 + slot)
			state.bindTexture(34067, textureProperties.__webglTexture)

			_gl.pixelStorei(37440, texture.flipY)
			_gl.pixelStorei(37441, texture.premultiplyAlpha)
			_gl.pixelStorei(3317, texture.unpackAlignment)
			_gl.pixelStorei(37443, 0)

			const isCompressed = (texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture))
			const isDataTexture = (texture.image[0] && texture.image[0].isDataTexture)

			const cubeImage = []

			for (let i = 0; i < 6; i++) {

				if (!isCompressed && !isDataTexture) {

					cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize)

				} else {

					cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i]

				}

			}

			const image = cubeImage[0],
				supportsMips = isPowerOfTwo$1$1(image) || isWebGL2,
				glFormat = utils.convert(texture.format),
				glType = utils.convert(texture.type),
				glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType)

			setTextureParameters(34067, texture, supportsMips)

			let mipmaps

			if (isCompressed) {

				for (let i = 0; i < 6; i++) {

					mipmaps = cubeImage[i].mipmaps

					for (let j = 0; j < mipmaps.length; j++) {

						const mipmap = mipmaps[j]

						if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {

							if (glFormat !== null) {

								state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data)

							} else {

								console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()')

							}

						} else {

							state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data)

						}

					}

				}

				textureProperties.__maxMipLevel = mipmaps.length - 1

			} else {

				mipmaps = texture.mipmaps

				for (let i = 0; i < 6; i++) {

					if (isDataTexture) {

						state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data)

						for (let j = 0; j < mipmaps.length; j++) {

							const mipmap = mipmaps[j]
							const mipmapImage = mipmap.image[i].image

							state.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data)

						}

					} else {

						state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i])

						for (let j = 0; j < mipmaps.length; j++) {

							const mipmap = mipmaps[j]

							state.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i])

						}

					}

				}

				textureProperties.__maxMipLevel = mipmaps.length

			}

			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {

				// We assume images for cube map have the same size.
				generateMipmap(34067, texture, image.width, image.height)

			}

			textureProperties.__version = texture.version

			if (texture.onUpdate) texture.onUpdate(texture)

		}

		// Render targets

		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture (framebuffer, renderTarget, texture, attachment, textureTarget) {

			const glFormat = utils.convert(texture.format)
			const glType = utils.convert(texture.type)
			const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType)

			if (textureTarget === 32879 || textureTarget === 35866) {

				state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null)

			} else {

				state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null)

			}

			state.bindFramebuffer(36160, framebuffer)
			_gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0)
			state.bindFramebuffer(36160, null)

		}

		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage (renderbuffer, renderTarget, isMultisample) {

			_gl.bindRenderbuffer(36161, renderbuffer)

			if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {

				let glInternalFormat = 33189

				if (isMultisample) {

					const depthTexture = renderTarget.depthTexture

					if (depthTexture && depthTexture.isDepthTexture) {

						if (depthTexture.type === FloatType) {

							glInternalFormat = 36012

						} else if (depthTexture.type === UnsignedIntType) {

							glInternalFormat = 33190

						}

					}

					const samples = getRenderTargetSamples(renderTarget)

					_gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height)

				} else {

					_gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height)

				}

				_gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer)

			} else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {

				if (isMultisample) {

					const samples = getRenderTargetSamples(renderTarget)

					_gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height)

				} else {

					_gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height)

				}


				_gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer)

			} else {

				// Use the first texture for MRT so far
				const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture

				const glFormat = utils.convert(texture.format)
				const glType = utils.convert(texture.type)
				const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType)

				if (isMultisample) {

					const samples = getRenderTargetSamples(renderTarget)

					_gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height)

				} else {

					_gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height)

				}

			}

			_gl.bindRenderbuffer(36161, null)

		}

		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture (framebuffer, renderTarget) {

			const isCube = (renderTarget && renderTarget.isWebGLCubeRenderTarget)
			if (isCube) throw new Error('Depth Texture with cube render targets is not supported')

			state.bindFramebuffer(36160, framebuffer)

			if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {

				throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture')

			}

			// upload an empty depth texture with framebuffer size
			if (!properties.get(renderTarget.depthTexture).__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height) {

				renderTarget.depthTexture.image.width = renderTarget.width
				renderTarget.depthTexture.image.height = renderTarget.height
				renderTarget.depthTexture.needsUpdate = true

			}

			setTexture2D(renderTarget.depthTexture, 0)

			const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture

			if (renderTarget.depthTexture.format === DepthFormat) {

				_gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0)

			} else if (renderTarget.depthTexture.format === DepthStencilFormat) {

				_gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0)

			} else {

				throw new Error('Unknown depthTexture format')

			}

		}

		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer (renderTarget) {

			const renderTargetProperties = properties.get(renderTarget)

			const isCube = (renderTarget.isWebGLCubeRenderTarget === true)

			if (renderTarget.depthTexture) {

				if (isCube) throw new Error('target.depthTexture not supported in Cube render targets')

				setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget)

			} else {

				if (isCube) {

					renderTargetProperties.__webglDepthbuffer = []

					for (let i = 0; i < 6; i++) {

						state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i])
						renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer()
						setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false)

					}

				} else {

					state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer)
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer()
					setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false)

				}

			}

			state.bindFramebuffer(36160, null)

		}

		// Set up GL resources for the render target
		function setupRenderTarget (renderTarget) {

			const texture = renderTarget.texture

			const renderTargetProperties = properties.get(renderTarget)
			const textureProperties = properties.get(texture)

			renderTarget.addEventListener('dispose', onRenderTargetDispose)

			if (renderTarget.isWebGLMultipleRenderTargets !== true) {

				textureProperties.__webglTexture = _gl.createTexture()
				textureProperties.__version = texture.version
				info.memory.textures++

			}

			const isCube = (renderTarget.isWebGLCubeRenderTarget === true)
			const isMultipleRenderTargets = (renderTarget.isWebGLMultipleRenderTargets === true)
			const isMultisample = (renderTarget.isWebGLMultisampleRenderTarget === true)
			const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray
			const supportsMips = isPowerOfTwo$1$1(renderTarget) || isWebGL2

			// Handles WebGL2 RGBFormat fallback - #18858

			if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {

				texture.format = RGBAFormat

				console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.')

			}

			// Setup framebuffer

			if (isCube) {

				renderTargetProperties.__webglFramebuffer = []

				for (let i = 0; i < 6; i++) {

					renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer()

				}

			} else {

				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer()

				if (isMultipleRenderTargets) {

					if (capabilities.drawBuffers) {

						const textures = renderTarget.texture

						for (let i = 0, il = textures.length; i < il; i++) {

							const attachmentProperties = properties.get(textures[i])

							if (attachmentProperties.__webglTexture === undefined) {

								attachmentProperties.__webglTexture = _gl.createTexture()

								info.memory.textures++

							}

						}

					} else {

						console.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.')

					}

				} else if (isMultisample) {

					if (isWebGL2) {

						renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer()
						renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer()

						_gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer)

						const glFormat = utils.convert(texture.format)
						const glType = utils.convert(texture.type)
						const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType)
						const samples = getRenderTargetSamples(renderTarget)
						_gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height)

						state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer)
						_gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer)
						_gl.bindRenderbuffer(36161, null)

						if (renderTarget.depthBuffer) {

							renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer()
							setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true)

						}

						state.bindFramebuffer(36160, null)


					} else {

						console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.')

					}

				}

			}

			// Setup color buffer

			if (isCube) {

				state.bindTexture(34067, textureProperties.__webglTexture)
				setTextureParameters(34067, texture, supportsMips)

				for (let i = 0; i < 6; i++) {

					setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, 36064, 34069 + i)

				}

				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {

					generateMipmap(34067, texture, renderTarget.width, renderTarget.height)

				}

				state.bindTexture(34067, null)

			} else if (isMultipleRenderTargets) {

				const textures = renderTarget.texture

				for (let i = 0, il = textures.length; i < il; i++) {

					const attachment = textures[i]
					const attachmentProperties = properties.get(attachment)

					state.bindTexture(3553, attachmentProperties.__webglTexture)
					setTextureParameters(3553, attachment, supportsMips)
					setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i, 3553)

					if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {

						generateMipmap(3553, attachment, renderTarget.width, renderTarget.height)

					}

				}

				state.bindTexture(3553, null)

			} else {

				let glTextureType = 3553

				if (isRenderTarget3D) {

					// Render targets containing layers, i.e: Texture 3D and 2d arrays

					if (isWebGL2) {

						const isTexture3D = texture.isDataTexture3D
						glTextureType = isTexture3D ? 32879 : 35866

					} else {

						console.warn('THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.')

					}

				}

				state.bindTexture(glTextureType, textureProperties.__webglTexture)
				setTextureParameters(glTextureType, texture, supportsMips)
				setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType)

				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {

					generateMipmap(glTextureType, texture, renderTarget.width, renderTarget.height, renderTarget.depth)

				}

				state.bindTexture(glTextureType, null)

			}

			// Setup depth and stencil buffers

			if (renderTarget.depthBuffer) {

				setupDepthRenderbuffer(renderTarget)

			}

		}

		function updateRenderTargetMipmap (renderTarget) {

			const supportsMips = isPowerOfTwo$1$1(renderTarget) || isWebGL2

			const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture]

			for (let i = 0, il = textures.length; i < il; i++) {

				const texture = textures[i]

				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {

					const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553
					const webglTexture = properties.get(texture).__webglTexture

					state.bindTexture(target, webglTexture)
					generateMipmap(target, texture, renderTarget.width, renderTarget.height)
					state.bindTexture(target, null)

				}

			}

		}

		function updateMultisampleRenderTarget (renderTarget) {

			if (renderTarget.isWebGLMultisampleRenderTarget) {

				if (isWebGL2) {

					const width = renderTarget.width
					const height = renderTarget.height
					let mask = 16384

					if (renderTarget.depthBuffer) mask |= 256
					if (renderTarget.stencilBuffer) mask |= 1024

					const renderTargetProperties = properties.get(renderTarget)

					state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer)
					state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer)

					_gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728)

					state.bindFramebuffer(36008, null)
					state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer)

				} else {

					console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.')

				}

			}

		}

		function getRenderTargetSamples (renderTarget) {

			return (isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget) ?
				Math.min(maxSamples, renderTarget.samples) : 0

		}

		function updateVideoTexture (texture) {

			const frame = info.render.frame

			// Check the last frame we updated the VideoTexture

			if (_videoTextures.get(texture) !== frame) {

				_videoTextures.set(texture, frame)
				texture.update()

			}

		}

		// backwards compatibility

		let warnedTexture2D = false
		let warnedTextureCube = false

		function safeSetTexture2D (texture, slot) {

			if (texture && texture.isWebGLRenderTarget) {

				if (warnedTexture2D === false) {

					console.warn('THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.')
					warnedTexture2D = true

				}

				texture = texture.texture

			}

			setTexture2D(texture, slot)

		}

		function safeSetTextureCube (texture, slot) {

			if (texture && texture.isWebGLCubeRenderTarget) {

				if (warnedTextureCube === false) {

					console.warn('THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.')
					warnedTextureCube = true

				}

				texture = texture.texture

			}


			setTextureCube(texture, slot)

		}

		//

		this.allocateTextureUnit = allocateTextureUnit
		this.resetTextureUnits = resetTextureUnits

		this.setTexture2D = setTexture2D
		this.setTexture2DArray = setTexture2DArray
		this.setTexture3D = setTexture3D
		this.setTextureCube = setTextureCube
		this.setupRenderTarget = setupRenderTarget
		this.updateRenderTargetMipmap = updateRenderTargetMipmap
		this.updateMultisampleRenderTarget = updateMultisampleRenderTarget

		this.safeSetTexture2D = safeSetTexture2D
		this.safeSetTextureCube = safeSetTextureCube

	}

	function WebGLUtils$1 (gl, extensions, capabilities) {

		const isWebGL2 = capabilities.isWebGL2

		function convert (p) {

			let extension

			if (p === UnsignedByteType) return 5121
			if (p === UnsignedShort4444Type) return 32819
			if (p === UnsignedShort5551Type) return 32820
			if (p === UnsignedShort565Type) return 33635

			if (p === ByteType) return 5120
			if (p === ShortType) return 5122
			if (p === UnsignedShortType) return 5123
			if (p === IntType) return 5124
			if (p === UnsignedIntType) return 5125
			if (p === FloatType) return 5126

			if (p === HalfFloatType) {

				if (isWebGL2) return 5131

				extension = extensions.get('OES_texture_half_float')

				if (extension !== null) {

					return extension.HALF_FLOAT_OES

				} else {

					return null

				}

			}

			if (p === AlphaFormat) return 6406
			if (p === RGBFormat) return 6407
			if (p === RGBAFormat) return 6408
			if (p === LuminanceFormat) return 6409
			if (p === LuminanceAlphaFormat) return 6410
			if (p === DepthFormat) return 6402
			if (p === DepthStencilFormat) return 34041
			if (p === RedFormat) return 6403

			// WebGL2 formats.

			if (p === RedIntegerFormat) return 36244
			if (p === RGFormat) return 33319
			if (p === RGIntegerFormat) return 33320
			if (p === RGBIntegerFormat) return 36248
			if (p === RGBAIntegerFormat) return 36249

			if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
				p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {

				extension = extensions.get('WEBGL_compressed_texture_s3tc')

				if (extension !== null) {

					if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT
					if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT
					if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT
					if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT

				} else {

					return null

				}

			}

			if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
				p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {

				extension = extensions.get('WEBGL_compressed_texture_pvrtc')

				if (extension !== null) {

					if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
					if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG
					if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
					if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG

				} else {

					return null

				}

			}

			if (p === RGB_ETC1_Format) {

				extension = extensions.get('WEBGL_compressed_texture_etc1')

				if (extension !== null) {

					return extension.COMPRESSED_RGB_ETC1_WEBGL

				} else {

					return null

				}

			}

			if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {

				extension = extensions.get('WEBGL_compressed_texture_etc')

				if (extension !== null) {

					if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2
					if (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC

				}

			}

			if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
				p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
				p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
				p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
				p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ||
				p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format ||
				p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format ||
				p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format ||
				p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format ||
				p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {

				extension = extensions.get('WEBGL_compressed_texture_astc')

				if (extension !== null) {

					// TODO Complete?

					return p

				} else {

					return null

				}

			}

			if (p === RGBA_BPTC_Format) {

				extension = extensions.get('EXT_texture_compression_bptc')

				if (extension !== null) {

					// TODO Complete?

					return p

				} else {

					return null

				}

			}

			if (p === UnsignedInt248Type) {

				if (isWebGL2) return 34042

				extension = extensions.get('WEBGL_depth_texture')

				if (extension !== null) {

					return extension.UNSIGNED_INT_24_8_WEBGL

				} else {

					return null

				}

			}

		}

		return { convert: convert }

	}

	class ArrayCamera extends PerspectiveCamera {

		constructor(array = []) {

			super()

			this.cameras = array

		}

	}

	ArrayCamera.prototype.isArrayCamera = true

	class Group$1 extends Object3D {

		constructor() {

			super()

			this.type = 'Group'

		}

	}

	Group$1.prototype.isGroup = true

	const _moveEvent$1 = { type: 'move' }

	class WebXRController$1 {

		constructor() {

			this._targetRay = null
			this._grip = null
			this._hand = null

		}

		getHandSpace () {

			if (this._hand === null) {

				this._hand = new Group$1()
				this._hand.matrixAutoUpdate = false
				this._hand.visible = false

				this._hand.joints = {}
				this._hand.inputState = { pinching: false }

			}

			return this._hand

		}

		getTargetRaySpace () {

			if (this._targetRay === null) {

				this._targetRay = new Group$1()
				this._targetRay.matrixAutoUpdate = false
				this._targetRay.visible = false
				this._targetRay.hasLinearVelocity = false
				this._targetRay.linearVelocity = new Vector3()
				this._targetRay.hasAngularVelocity = false
				this._targetRay.angularVelocity = new Vector3()

			}

			return this._targetRay

		}

		getGripSpace () {

			if (this._grip === null) {

				this._grip = new Group$1()
				this._grip.matrixAutoUpdate = false
				this._grip.visible = false
				this._grip.hasLinearVelocity = false
				this._grip.linearVelocity = new Vector3()
				this._grip.hasAngularVelocity = false
				this._grip.angularVelocity = new Vector3()

			}

			return this._grip

		}

		dispatchEvent (event) {

			if (this._targetRay !== null) {

				this._targetRay.dispatchEvent(event)

			}

			if (this._grip !== null) {

				this._grip.dispatchEvent(event)

			}

			if (this._hand !== null) {

				this._hand.dispatchEvent(event)

			}

			return this

		}

		disconnect (inputSource) {

			this.dispatchEvent({ type: 'disconnected', data: inputSource })

			if (this._targetRay !== null) {

				this._targetRay.visible = false

			}

			if (this._grip !== null) {

				this._grip.visible = false

			}

			if (this._hand !== null) {

				this._hand.visible = false

			}

			return this

		}

		update (inputSource, frame, referenceSpace) {

			let inputPose = null
			let gripPose = null
			let handPose = null

			const targetRay = this._targetRay
			const grip = this._grip
			const hand = this._hand

			if (inputSource && frame.session.visibilityState !== 'visible-blurred') {

				if (targetRay !== null) {

					inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace)

					if (inputPose !== null) {

						targetRay.matrix.fromArray(inputPose.transform.matrix)
						targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale)

						if (inputPose.linearVelocity) {

							targetRay.hasLinearVelocity = true
							targetRay.linearVelocity.copy(inputPose.linearVelocity)

						} else {

							targetRay.hasLinearVelocity = false

						}

						if (inputPose.angularVelocity) {

							targetRay.hasAngularVelocity = true
							targetRay.angularVelocity.copy(inputPose.angularVelocity)

						} else {

							targetRay.hasAngularVelocity = false

						}

						this.dispatchEvent(_moveEvent$1)

					}

				}

				if (hand && inputSource.hand) {

					handPose = true

					for (const inputjoint of inputSource.hand.values()) {

						// Update the joints groups with the XRJoint poses
						const jointPose = frame.getJointPose(inputjoint, referenceSpace)

						if (hand.joints[inputjoint.jointName] === undefined) {

							// The transform of this joint will be updated with the joint pose on each frame
							const joint = new Group$1()
							joint.matrixAutoUpdate = false
							joint.visible = false
							hand.joints[inputjoint.jointName] = joint
							// ??
							hand.add(joint)

						}

						const joint = hand.joints[inputjoint.jointName]

						if (jointPose !== null) {

							joint.matrix.fromArray(jointPose.transform.matrix)
							joint.matrix.decompose(joint.position, joint.rotation, joint.scale)
							joint.jointRadius = jointPose.radius

						}

						joint.visible = jointPose !== null

					}

					// Custom events

					// Check pinchz
					const indexTip = hand.joints['index-finger-tip']
					const thumbTip = hand.joints['thumb-tip']
					const distance = indexTip.position.distanceTo(thumbTip.position)

					const distanceToPinch = 0.02
					const threshold = 0.005

					if (hand.inputState.pinching && distance > distanceToPinch + threshold) {

						hand.inputState.pinching = false
						this.dispatchEvent({
							type: 'pinchend',
							handedness: inputSource.handedness,
							target: this
						})

					} else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {

						hand.inputState.pinching = true
						this.dispatchEvent({
							type: 'pinchstart',
							handedness: inputSource.handedness,
							target: this
						})

					}

				} else {

					if (grip !== null && inputSource.gripSpace) {

						gripPose = frame.getPose(inputSource.gripSpace, referenceSpace)

						if (gripPose !== null) {

							grip.matrix.fromArray(gripPose.transform.matrix)
							grip.matrix.decompose(grip.position, grip.rotation, grip.scale)

							if (gripPose.linearVelocity) {

								grip.hasLinearVelocity = true
								grip.linearVelocity.copy(gripPose.linearVelocity)

							} else {

								grip.hasLinearVelocity = false

							}

							if (gripPose.angularVelocity) {

								grip.hasAngularVelocity = true
								grip.angularVelocity.copy(gripPose.angularVelocity)

							} else {

								grip.hasAngularVelocity = false

							}

						}

					}

				}

			}

			if (targetRay !== null) {

				targetRay.visible = (inputPose !== null)

			}

			if (grip !== null) {

				grip.visible = (gripPose !== null)

			}

			if (hand !== null) {

				hand.visible = (handPose !== null)

			}

			return this

		}

	}

	class WebXRManager$1 extends EventDispatcher {

		constructor(renderer, gl) {

			super()

			const scope = this
			const state = renderer.state

			let session = null
			let framebufferScaleFactor = 1.0

			let referenceSpace = null
			let referenceSpaceType = 'local-floor'

			let pose = null
			let glBinding = null
			let glFramebuffer = null
			let glProjLayer = null
			let glBaseLayer = null

			const controllers = []
			const inputSourcesMap = new Map()

			//

			const cameraL = new PerspectiveCamera()
			cameraL.layers.enable(1)
			cameraL.viewport = new Vector4()

			const cameraR = new PerspectiveCamera()
			cameraR.layers.enable(2)
			cameraR.viewport = new Vector4()

			const cameras = [cameraL, cameraR]

			const cameraVR = new ArrayCamera()
			cameraVR.layers.enable(1)
			cameraVR.layers.enable(2)

			let _currentDepthNear = null
			let _currentDepthFar = null

			//

			this.cameraAutoUpdate = true
			this.enabled = false

			this.isPresenting = false

			this.getController = function (index) {

				let controller = controllers[index]

				if (controller === undefined) {

					controller = new WebXRController$1()
					controllers[index] = controller

				}

				return controller.getTargetRaySpace()

			}

			this.getControllerGrip = function (index) {

				let controller = controllers[index]

				if (controller === undefined) {

					controller = new WebXRController$1()
					controllers[index] = controller

				}

				return controller.getGripSpace()

			}

			this.getHand = function (index) {

				let controller = controllers[index]

				if (controller === undefined) {

					controller = new WebXRController$1()
					controllers[index] = controller

				}

				return controller.getHandSpace()

			}

			//

			function onSessionEvent (event) {

				const controller = inputSourcesMap.get(event.inputSource)

				if (controller) {

					controller.dispatchEvent({ type: event.type, data: event.inputSource })

				}

			}

			function onSessionEnd () {

				inputSourcesMap.forEach(function (controller, inputSource) {

					controller.disconnect(inputSource)

				})

				inputSourcesMap.clear()

				_currentDepthNear = null
				_currentDepthFar = null

				// restore framebuffer/rendering state

				state.bindXRFramebuffer(null)
				renderer.setRenderTarget(renderer.getRenderTarget())

				//

				animation.stop()

				scope.isPresenting = false

				scope.dispatchEvent({ type: 'sessionend' })

			}

			this.setFramebufferScaleFactor = function (value) {

				framebufferScaleFactor = value

				if (scope.isPresenting === true) {

					console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.')

				}

			}

			this.setReferenceSpaceType = function (value) {

				referenceSpaceType = value

				if (scope.isPresenting === true) {

					console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.')

				}

			}

			this.getReferenceSpace = function () {

				return referenceSpace

			}

			this.getSession = function () {

				return session

			}

			this.setSession = async function (value) {

				session = value

				if (session !== null) {

					session.addEventListener('select', onSessionEvent)
					session.addEventListener('selectstart', onSessionEvent)
					session.addEventListener('selectend', onSessionEvent)
					session.addEventListener('squeeze', onSessionEvent)
					session.addEventListener('squeezestart', onSessionEvent)
					session.addEventListener('squeezeend', onSessionEvent)
					session.addEventListener('end', onSessionEnd)
					session.addEventListener('inputsourceschange', onInputSourcesChange)

					const attributes = gl.getContextAttributes()

					if (attributes.xrCompatible !== true) {

						await gl.makeXRCompatible()

					}

					if (session.renderState.layers === undefined) {

						const layerInit = {
							antialias: attributes.antialias,
							alpha: attributes.alpha,
							depth: attributes.depth,
							stencil: attributes.stencil,
							framebufferScaleFactor: framebufferScaleFactor
						}

						glBaseLayer = new XRWebGLLayer(session, gl, layerInit)

						session.updateRenderState({ baseLayer: glBaseLayer })

					} else {

						let depthFormat = 0

						// for anti-aliased output, use classic webgllayer for now
						if (attributes.antialias) {

							const layerInit = {
								antialias: true,
								alpha: attributes.alpha,
								depth: attributes.depth,
								stencil: attributes.stencil,
								framebufferScaleFactor: framebufferScaleFactor
							}

							glBaseLayer = new XRWebGLLayer(session, gl, layerInit)

							session.updateRenderState({ layers: [glBaseLayer] })

						} else {

							if (attributes.depth) {

								depthFormat = attributes.stencil ? 34041 : 6402

							}

							const projectionlayerInit = {
								colorFormat: attributes.alpha ? 6408 : 6407,
								depthFormat: depthFormat,
								scaleFactor: framebufferScaleFactor
							}

							glBinding = new XRWebGLBinding(session, gl)

							glProjLayer = glBinding.createProjectionLayer(projectionlayerInit)

							glFramebuffer = gl.createFramebuffer()

							session.updateRenderState({ layers: [glProjLayer] })

						}

					}

					referenceSpace = await session.requestReferenceSpace(referenceSpaceType)

					animation.setContext(session)
					animation.start()

					scope.isPresenting = true

					scope.dispatchEvent({ type: 'sessionstart' })

				}

			}

			function onInputSourcesChange (event) {

				const inputSources = session.inputSources

				// Assign inputSources to available controllers

				for (let i = 0; i < controllers.length; i++) {

					inputSourcesMap.set(inputSources[i], controllers[i])

				}

				// Notify disconnected

				for (let i = 0; i < event.removed.length; i++) {

					const inputSource = event.removed[i]
					const controller = inputSourcesMap.get(inputSource)

					if (controller) {

						controller.dispatchEvent({ type: 'disconnected', data: inputSource })
						inputSourcesMap.delete(inputSource)

					}

				}

				// Notify connected

				for (let i = 0; i < event.added.length; i++) {

					const inputSource = event.added[i]
					const controller = inputSourcesMap.get(inputSource)

					if (controller) {

						controller.dispatchEvent({ type: 'connected', data: inputSource })

					}

				}

			}

			//

			const cameraLPos = new Vector3()
			const cameraRPos = new Vector3()

			/**
			 * Assumes 2 cameras that are parallel and share an X-axis, and that
			 * the cameras' projection and world matrices have already been set.
			 * And that near and far planes are identical for both cameras.
			 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
			 */
			function setProjectionFromUnion (camera, cameraL, cameraR) {

				cameraLPos.setFromMatrixPosition(cameraL.matrixWorld)
				cameraRPos.setFromMatrixPosition(cameraR.matrixWorld)

				const ipd = cameraLPos.distanceTo(cameraRPos)

				const projL = cameraL.projectionMatrix.elements
				const projR = cameraR.projectionMatrix.elements

				// VR systems will have identical far and near planes, and
				// most likely identical top and bottom frustum extents.
				// Use the left camera for these values.
				const near = projL[14] / (projL[10] - 1)
				const far = projL[14] / (projL[10] + 1)
				const topFov = (projL[9] + 1) / projL[5]
				const bottomFov = (projL[9] - 1) / projL[5]

				const leftFov = (projL[8] - 1) / projL[0]
				const rightFov = (projR[8] + 1) / projR[0]
				const left = near * leftFov
				const right = near * rightFov

				// Calculate the new camera's position offset from the
				// left camera. xOffset should be roughly half `ipd`.
				const zOffset = ipd / (- leftFov + rightFov)
				const xOffset = zOffset * - leftFov

				// TODO: Better way to apply this offset?
				cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale)
				camera.translateX(xOffset)
				camera.translateZ(zOffset)
				camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale)
				camera.matrixWorldInverse.copy(camera.matrixWorld).invert()

				// Find the union of the frustum values of the cameras and scale
				// the values so that the near plane's position does not change in world space,
				// although must now be relative to the new union camera.
				const near2 = near + zOffset
				const far2 = far + zOffset
				const left2 = left - xOffset
				const right2 = right + (ipd - xOffset)
				const top2 = topFov * far / far2 * near2
				const bottom2 = bottomFov * far / far2 * near2

				camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2)

			}

			function updateCamera (camera, parent) {

				if (parent === null) {

					camera.matrixWorld.copy(camera.matrix)

				} else {

					camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix)

				}

				camera.matrixWorldInverse.copy(camera.matrixWorld).invert()

			}

			this.updateCamera = function (camera) {

				if (session === null) return

				cameraVR.near = cameraR.near = cameraL.near = camera.near
				cameraVR.far = cameraR.far = cameraL.far = camera.far

				if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {

					// Note that the new renderState won't apply until the next frame. See #18320

					session.updateRenderState({
						depthNear: cameraVR.near,
						depthFar: cameraVR.far
					})

					_currentDepthNear = cameraVR.near
					_currentDepthFar = cameraVR.far

				}

				const parent = camera.parent
				const cameras = cameraVR.cameras

				updateCamera(cameraVR, parent)

				for (let i = 0; i < cameras.length; i++) {

					updateCamera(cameras[i], parent)

				}

				cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale)

				// update user camera and its children

				camera.position.copy(cameraVR.position)
				camera.quaternion.copy(cameraVR.quaternion)
				camera.scale.copy(cameraVR.scale)
				camera.matrix.copy(cameraVR.matrix)
				camera.matrixWorld.copy(cameraVR.matrixWorld)

				const children = camera.children

				for (let i = 0, l = children.length; i < l; i++) {

					children[i].updateMatrixWorld(true)

				}

				// update projection matrix for proper view frustum culling

				if (cameras.length === 2) {

					setProjectionFromUnion(cameraVR, cameraL, cameraR)

				} else {

					// assume single camera setup (AR)

					cameraVR.projectionMatrix.copy(cameraL.projectionMatrix)

				}

			}

			this.getCamera = function () {

				return cameraVR

			}

			this.getFoveation = function () {

				if (glProjLayer !== null) {

					return glProjLayer.fixedFoveation

				}

				if (glBaseLayer !== null) {

					return glBaseLayer.fixedFoveation

				}

				return undefined

			}

			this.setFoveation = function (foveation) {

				// 0 = no foveation = full resolution
				// 1 = maximum foveation = the edges render at lower resolution

				if (glProjLayer !== null) {

					glProjLayer.fixedFoveation = foveation

				}

				if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) {

					glBaseLayer.fixedFoveation = foveation

				}

			}

			// Animation Loop

			let onAnimationFrameCallback = null

			function onAnimationFrame (time, frame) {

				pose = frame.getViewerPose(referenceSpace)

				if (pose !== null) {

					const views = pose.views

					if (glBaseLayer !== null) {

						state.bindXRFramebuffer(glBaseLayer.framebuffer)

					}

					let cameraVRNeedsUpdate = false

					// check if it's necessary to rebuild cameraVR's camera list

					if (views.length !== cameraVR.cameras.length) {

						cameraVR.cameras.length = 0

						cameraVRNeedsUpdate = true


					}

					for (let i = 0; i < views.length; i++) {

						const view = views[i]

						let viewport = null

						if (glBaseLayer !== null) {

							viewport = glBaseLayer.getViewport(view)

						} else {

							const glSubImage = glBinding.getViewSubImage(glProjLayer, view)

							state.bindXRFramebuffer(glFramebuffer)

							if (glSubImage.depthStencilTexture !== undefined) {

								gl.framebufferTexture2D(36160, 36096, 3553, glSubImage.depthStencilTexture, 0)

							}

							gl.framebufferTexture2D(36160, 36064, 3553, glSubImage.colorTexture, 0)

							viewport = glSubImage.viewport

						}

						const camera = cameras[i]

						camera.matrix.fromArray(view.transform.matrix)

						camera.projectionMatrix.fromArray(view.projectionMatrix)

						camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height)

						if (i === 0) {

							cameraVR.matrix.copy(camera.matrix)

						}

						if (cameraVRNeedsUpdate === true) {

							cameraVR.cameras.push(camera)

						}

					}

				}

				//

				const inputSources = session.inputSources

				for (let i = 0; i < controllers.length; i++) {

					const controller = controllers[i]
					const inputSource = inputSources[i]

					controller.update(inputSource, frame, referenceSpace)

				}

				if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame)

			}

			const animation = new WebGLAnimation$1()

			animation.setAnimationLoop(onAnimationFrame)

			this.setAnimationLoop = function (callback) {

				onAnimationFrameCallback = callback

			}

			this.dispose = function () { }

		}

	}

	function WebGLMaterials$1 (properties) {

		function refreshFogUniforms (uniforms, fog) {

			uniforms.fogColor.value.copy(fog.color)

			if (fog.isFog) {

				uniforms.fogNear.value = fog.near
				uniforms.fogFar.value = fog.far

			} else if (fog.isFogExp2) {

				uniforms.fogDensity.value = fog.density

			}

		}

		function refreshMaterialUniforms (uniforms, material, pixelRatio, height, transmissionRenderTarget) {

			if (material.isMeshBasicMaterial) {

				refreshUniformsCommon(uniforms, material)

			} else if (material.isMeshLambertMaterial) {

				refreshUniformsCommon(uniforms, material)
				refreshUniformsLambert(uniforms, material)

			} else if (material.isMeshToonMaterial) {

				refreshUniformsCommon(uniforms, material)
				refreshUniformsToon(uniforms, material)

			} else if (material.isMeshPhongMaterial) {

				refreshUniformsCommon(uniforms, material)
				refreshUniformsPhong(uniforms, material)

			} else if (material.isMeshStandardMaterial) {

				refreshUniformsCommon(uniforms, material)

				if (material.isMeshPhysicalMaterial) {

					refreshUniformsPhysical(uniforms, material, transmissionRenderTarget)

				} else {

					refreshUniformsStandard(uniforms, material)

				}

			} else if (material.isMeshMatcapMaterial) {

				refreshUniformsCommon(uniforms, material)
				refreshUniformsMatcap(uniforms, material)

			} else if (material.isMeshDepthMaterial) {

				refreshUniformsCommon(uniforms, material)
				refreshUniformsDepth(uniforms, material)

			} else if (material.isMeshDistanceMaterial) {

				refreshUniformsCommon(uniforms, material)
				refreshUniformsDistance(uniforms, material)

			} else if (material.isMeshNormalMaterial) {

				refreshUniformsCommon(uniforms, material)
				refreshUniformsNormal(uniforms, material)

			} else if (material.isLineBasicMaterial) {

				refreshUniformsLine(uniforms, material)

				if (material.isLineDashedMaterial) {

					refreshUniformsDash(uniforms, material)

				}

			} else if (material.isPointsMaterial) {

				refreshUniformsPoints(uniforms, material, pixelRatio, height)

			} else if (material.isSpriteMaterial) {

				refreshUniformsSprites(uniforms, material)

			} else if (material.isShadowMaterial) {

				uniforms.color.value.copy(material.color)
				uniforms.opacity.value = material.opacity

			} else if (material.isShaderMaterial) {

				material.uniformsNeedUpdate = false // #15581

			}

		}

		function refreshUniformsCommon (uniforms, material) {

			uniforms.opacity.value = material.opacity

			if (material.color) {

				uniforms.diffuse.value.copy(material.color)

			}

			if (material.emissive) {

				uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity)

			}

			if (material.map) {

				uniforms.map.value = material.map

			}

			if (material.alphaMap) {

				uniforms.alphaMap.value = material.alphaMap

			}

			if (material.specularMap) {

				uniforms.specularMap.value = material.specularMap

			}

			const envMap = properties.get(material).envMap

			if (envMap) {

				uniforms.envMap.value = envMap

				uniforms.flipEnvMap.value = (envMap.isCubeTexture && envMap.isRenderTargetTexture === false) ? - 1 : 1

				uniforms.reflectivity.value = material.reflectivity
				uniforms.refractionRatio.value = material.refractionRatio

				const maxMipLevel = properties.get(envMap).__maxMipLevel

				if (maxMipLevel !== undefined) {

					uniforms.maxMipLevel.value = maxMipLevel

				}

			}

			if (material.lightMap) {

				uniforms.lightMap.value = material.lightMap
				uniforms.lightMapIntensity.value = material.lightMapIntensity

			}

			if (material.aoMap) {

				uniforms.aoMap.value = material.aoMap
				uniforms.aoMapIntensity.value = material.aoMapIntensity

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. displacementMap map
			// 4. normal map
			// 5. bump map
			// 6. roughnessMap map
			// 7. metalnessMap map
			// 8. alphaMap map
			// 9. emissiveMap map
			// 10. clearcoat map
			// 11. clearcoat normal map
			// 12. clearcoat roughnessMap map
			// 13. specular intensity map
			// 14. specular tint map

			let uvScaleMap

			if (material.map) {

				uvScaleMap = material.map

			} else if (material.specularMap) {

				uvScaleMap = material.specularMap

			} else if (material.displacementMap) {

				uvScaleMap = material.displacementMap

			} else if (material.normalMap) {

				uvScaleMap = material.normalMap

			} else if (material.bumpMap) {

				uvScaleMap = material.bumpMap

			} else if (material.roughnessMap) {

				uvScaleMap = material.roughnessMap

			} else if (material.metalnessMap) {

				uvScaleMap = material.metalnessMap

			} else if (material.alphaMap) {

				uvScaleMap = material.alphaMap

			} else if (material.emissiveMap) {

				uvScaleMap = material.emissiveMap

			} else if (material.clearcoatMap) {

				uvScaleMap = material.clearcoatMap

			} else if (material.clearcoatNormalMap) {

				uvScaleMap = material.clearcoatNormalMap

			} else if (material.clearcoatRoughnessMap) {

				uvScaleMap = material.clearcoatRoughnessMap

			} else if (material.specularIntensityMap) {

				uvScaleMap = material.specularIntensityMap

			} else if (material.specularTintMap) {

				uvScaleMap = material.specularTintMap

			}

			if (uvScaleMap !== undefined) {

				// backwards compatibility
				if (uvScaleMap.isWebGLRenderTarget) {

					uvScaleMap = uvScaleMap.texture

				}

				if (uvScaleMap.matrixAutoUpdate === true) {

					uvScaleMap.updateMatrix()

				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix)

			}

			// uv repeat and offset setting priorities for uv2
			// 1. ao map
			// 2. light map

			let uv2ScaleMap

			if (material.aoMap) {

				uv2ScaleMap = material.aoMap

			} else if (material.lightMap) {

				uv2ScaleMap = material.lightMap

			}

			if (uv2ScaleMap !== undefined) {

				// backwards compatibility
				if (uv2ScaleMap.isWebGLRenderTarget) {

					uv2ScaleMap = uv2ScaleMap.texture

				}

				if (uv2ScaleMap.matrixAutoUpdate === true) {

					uv2ScaleMap.updateMatrix()

				}

				uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix)

			}

		}

		function refreshUniformsLine (uniforms, material) {

			uniforms.diffuse.value.copy(material.color)
			uniforms.opacity.value = material.opacity

		}

		function refreshUniformsDash (uniforms, material) {

			uniforms.dashSize.value = material.dashSize
			uniforms.totalSize.value = material.dashSize + material.gapSize
			uniforms.scale.value = material.scale

		}

		function refreshUniformsPoints (uniforms, material, pixelRatio, height) {

			uniforms.diffuse.value.copy(material.color)
			uniforms.opacity.value = material.opacity
			uniforms.size.value = material.size * pixelRatio
			uniforms.scale.value = height * 0.5

			if (material.map) {

				uniforms.map.value = material.map

			}

			if (material.alphaMap) {

				uniforms.alphaMap.value = material.alphaMap

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map

			let uvScaleMap

			if (material.map) {

				uvScaleMap = material.map

			} else if (material.alphaMap) {

				uvScaleMap = material.alphaMap

			}

			if (uvScaleMap !== undefined) {

				if (uvScaleMap.matrixAutoUpdate === true) {

					uvScaleMap.updateMatrix()

				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix)

			}

		}

		function refreshUniformsSprites (uniforms, material) {

			uniforms.diffuse.value.copy(material.color)
			uniforms.opacity.value = material.opacity
			uniforms.rotation.value = material.rotation

			if (material.map) {

				uniforms.map.value = material.map

			}

			if (material.alphaMap) {

				uniforms.alphaMap.value = material.alphaMap

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map

			let uvScaleMap

			if (material.map) {

				uvScaleMap = material.map

			} else if (material.alphaMap) {

				uvScaleMap = material.alphaMap

			}

			if (uvScaleMap !== undefined) {

				if (uvScaleMap.matrixAutoUpdate === true) {

					uvScaleMap.updateMatrix()

				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix)

			}

		}

		function refreshUniformsLambert (uniforms, material) {

			if (material.emissiveMap) {

				uniforms.emissiveMap.value = material.emissiveMap

			}

		}

		function refreshUniformsPhong (uniforms, material) {

			uniforms.specular.value.copy(material.specular)
			uniforms.shininess.value = Math.max(material.shininess, 1e-4) // to prevent pow( 0.0, 0.0 )

			if (material.emissiveMap) {

				uniforms.emissiveMap.value = material.emissiveMap

			}

			if (material.bumpMap) {

				uniforms.bumpMap.value = material.bumpMap
				uniforms.bumpScale.value = material.bumpScale
				if (material.side === BackSide) uniforms.bumpScale.value *= - 1

			}

			if (material.normalMap) {

				uniforms.normalMap.value = material.normalMap
				uniforms.normalScale.value.copy(material.normalScale)
				if (material.side === BackSide) uniforms.normalScale.value.negate()

			}

			if (material.displacementMap) {

				uniforms.displacementMap.value = material.displacementMap
				uniforms.displacementScale.value = material.displacementScale
				uniforms.displacementBias.value = material.displacementBias

			}

		}

		function refreshUniformsToon (uniforms, material) {

			if (material.gradientMap) {

				uniforms.gradientMap.value = material.gradientMap

			}

			if (material.emissiveMap) {

				uniforms.emissiveMap.value = material.emissiveMap

			}

			if (material.bumpMap) {

				uniforms.bumpMap.value = material.bumpMap
				uniforms.bumpScale.value = material.bumpScale
				if (material.side === BackSide) uniforms.bumpScale.value *= - 1

			}

			if (material.normalMap) {

				uniforms.normalMap.value = material.normalMap
				uniforms.normalScale.value.copy(material.normalScale)
				if (material.side === BackSide) uniforms.normalScale.value.negate()

			}

			if (material.displacementMap) {

				uniforms.displacementMap.value = material.displacementMap
				uniforms.displacementScale.value = material.displacementScale
				uniforms.displacementBias.value = material.displacementBias

			}

		}

		function refreshUniformsStandard (uniforms, material) {

			uniforms.roughness.value = material.roughness
			uniforms.metalness.value = material.metalness

			if (material.roughnessMap) {

				uniforms.roughnessMap.value = material.roughnessMap

			}

			if (material.metalnessMap) {

				uniforms.metalnessMap.value = material.metalnessMap

			}

			if (material.emissiveMap) {

				uniforms.emissiveMap.value = material.emissiveMap

			}

			if (material.bumpMap) {

				uniforms.bumpMap.value = material.bumpMap
				uniforms.bumpScale.value = material.bumpScale
				if (material.side === BackSide) uniforms.bumpScale.value *= - 1

			}

			if (material.normalMap) {

				uniforms.normalMap.value = material.normalMap
				uniforms.normalScale.value.copy(material.normalScale)
				if (material.side === BackSide) uniforms.normalScale.value.negate()

			}

			if (material.displacementMap) {

				uniforms.displacementMap.value = material.displacementMap
				uniforms.displacementScale.value = material.displacementScale
				uniforms.displacementBias.value = material.displacementBias

			}

			const envMap = properties.get(material).envMap

			if (envMap) {

				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity

			}

		}

		function refreshUniformsPhysical (uniforms, material, transmissionRenderTarget) {

			refreshUniformsStandard(uniforms, material)

			uniforms.reflectivity.value = material.reflectivity // also part of uniforms common

			uniforms.clearcoat.value = material.clearcoat
			uniforms.clearcoatRoughness.value = material.clearcoatRoughness

			if (material.sheen) uniforms.sheen.value.copy(material.sheen)

			if (material.clearcoatMap) {

				uniforms.clearcoatMap.value = material.clearcoatMap

			}

			if (material.clearcoatRoughnessMap) {

				uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap

			}

			if (material.clearcoatNormalMap) {

				uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale)
				uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap

				if (material.side === BackSide) {

					uniforms.clearcoatNormalScale.value.negate()

				}

			}

			uniforms.transmission.value = material.transmission

			if (material.transmissionMap) {

				uniforms.transmissionMap.value = material.transmissionMap

			}

			if (material.transmission > 0.0) {

				uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture
				uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height)

			}

			uniforms.thickness.value = material.thickness

			if (material.thicknessMap) {

				uniforms.thicknessMap.value = material.thicknessMap

			}

			uniforms.attenuationDistance.value = material.attenuationDistance
			uniforms.attenuationTint.value.copy(material.attenuationTint)

			uniforms.specularIntensity.value = material.specularIntensity
			uniforms.specularTint.value.copy(material.specularTint)

			if (material.specularIntensityMap) {

				uniforms.specularIntensityMap.value = material.specularIntensityMap

			}

			if (material.specularTintMap) {

				uniforms.specularTintMap.value = material.specularTintMap

			}

		}

		function refreshUniformsMatcap (uniforms, material) {

			if (material.matcap) {

				uniforms.matcap.value = material.matcap

			}

			if (material.bumpMap) {

				uniforms.bumpMap.value = material.bumpMap
				uniforms.bumpScale.value = material.bumpScale
				if (material.side === BackSide) uniforms.bumpScale.value *= - 1

			}

			if (material.normalMap) {

				uniforms.normalMap.value = material.normalMap
				uniforms.normalScale.value.copy(material.normalScale)
				if (material.side === BackSide) uniforms.normalScale.value.negate()

			}

			if (material.displacementMap) {

				uniforms.displacementMap.value = material.displacementMap
				uniforms.displacementScale.value = material.displacementScale
				uniforms.displacementBias.value = material.displacementBias

			}

		}

		function refreshUniformsDepth (uniforms, material) {

			if (material.displacementMap) {

				uniforms.displacementMap.value = material.displacementMap
				uniforms.displacementScale.value = material.displacementScale
				uniforms.displacementBias.value = material.displacementBias

			}

		}

		function refreshUniformsDistance (uniforms, material) {

			if (material.displacementMap) {

				uniforms.displacementMap.value = material.displacementMap
				uniforms.displacementScale.value = material.displacementScale
				uniforms.displacementBias.value = material.displacementBias

			}

			uniforms.referencePosition.value.copy(material.referencePosition)
			uniforms.nearDistance.value = material.nearDistance
			uniforms.farDistance.value = material.farDistance

		}

		function refreshUniformsNormal (uniforms, material) {

			if (material.bumpMap) {

				uniforms.bumpMap.value = material.bumpMap
				uniforms.bumpScale.value = material.bumpScale
				if (material.side === BackSide) uniforms.bumpScale.value *= - 1

			}

			if (material.normalMap) {

				uniforms.normalMap.value = material.normalMap
				uniforms.normalScale.value.copy(material.normalScale)
				if (material.side === BackSide) uniforms.normalScale.value.negate()

			}

			if (material.displacementMap) {

				uniforms.displacementMap.value = material.displacementMap
				uniforms.displacementScale.value = material.displacementScale
				uniforms.displacementBias.value = material.displacementBias

			}

		}

		return {
			refreshFogUniforms: refreshFogUniforms,
			refreshMaterialUniforms: refreshMaterialUniforms
		}

	}

	function createCanvasElement$1 () {

		const canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas')
		canvas.style.display = 'block'
		return canvas

	}

	function WebGLRenderer$1 (parameters = {}) {

		const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement$1(),
			_context = parameters.context !== undefined ? parameters.context : null,

			_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
			_depth = parameters.depth !== undefined ? parameters.depth : true,
			_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
			_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
			_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
			_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
			_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
			_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false

		let currentRenderList = null
		let currentRenderState = null

		// render() can be called from within a callback triggered by another render.
		// We track this so that the nested render call gets its list and state isolated from the parent render call.

		const renderListStack = []
		const renderStateStack = []

		// public properties

		this.domElement = _canvas

		// Debug configuration container
		this.debug = {

			/**
			 * Enables error checking and reporting when shader programs are being compiled
			 * @type {boolean}
			 */
			checkShaderErrors: true
		}

		// clearing

		this.autoClear = true
		this.autoClearColor = true
		this.autoClearDepth = true
		this.autoClearStencil = true

		// scene graph

		this.sortObjects = true

		// user-defined clipping

		this.clippingPlanes = []
		this.localClippingEnabled = false

		// physically based shading

		this.gammaFactor = 2.0	// for backwards compatibility
		this.outputEncoding = LinearEncoding

		// physical lights

		this.physicallyCorrectLights = false

		// tone mapping

		this.toneMapping = NoToneMapping
		this.toneMappingExposure = 1.0

		// internal properties

		const _this = this

		let _isContextLost = false

		// internal state cache

		let _currentActiveCubeFace = 0
		let _currentActiveMipmapLevel = 0
		let _currentRenderTarget = null
		let _currentMaterialId = - 1

		let _currentCamera = null

		const _currentViewport = new Vector4()
		const _currentScissor = new Vector4()
		let _currentScissorTest = null

		//

		let _width = _canvas.width
		let _height = _canvas.height

		let _pixelRatio = 1
		let _opaqueSort = null
		let _transparentSort = null

		const _viewport = new Vector4(0, 0, _width, _height)
		const _scissor = new Vector4(0, 0, _width, _height)
		let _scissorTest = false

		//

		const _currentDrawBuffers = []

		// frustum

		const _frustum = new Frustum()

		// clipping

		let _clippingEnabled = false
		let _localClippingEnabled = false

		// transmission

		let _transmissionRenderTarget = null

		// camera matrices cache

		const _projScreenMatrix = new Matrix4()

		const _vector3 = new Vector3()

		const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true }

		function getTargetPixelRatio () {

			return _currentRenderTarget === null ? _pixelRatio : 1

		}

		// initialize

		let _gl = _context

		function getContext (contextNames, contextAttributes) {

			for (let i = 0; i < contextNames.length; i++) {

				const contextName = contextNames[i]
				const context = _canvas.getContext(contextName, contextAttributes)
				if (context !== null) return context

			}

			return null

		}

		try {

			const contextAttributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference,
				failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
			}

			// event listeners must be registered before WebGL context is created, see #12753

			_canvas.addEventListener('webglcontextlost', onContextLost, false)
			_canvas.addEventListener('webglcontextrestored', onContextRestore, false)

			if (_gl === null) {

				const contextNames = ['webgl2', 'webgl', 'experimental-webgl']

				if (_this.isWebGL1Renderer === true) {

					contextNames.shift()

				}

				_gl = getContext(contextNames, contextAttributes)

				if (_gl === null) {

					if (getContext(contextNames)) {

						throw new Error('Error creating WebGL context with your selected attributes.')

					} else {

						throw new Error('Error creating WebGL context.')

					}

				}

			}

			// Some experimental-webgl implementations do not have getShaderPrecisionFormat

			if (_gl.getShaderPrecisionFormat === undefined) {

				_gl.getShaderPrecisionFormat = function () {

					return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 }

				}

			}

		} catch (error) {

			console.error('THREE.WebGLRenderer: ' + error.message)
			throw error

		}

		let extensions, capabilities, state, info
		let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects
		let programCache, materials, renderLists, renderStates, clipping, shadowMap

		let background, morphtargets, bufferRenderer, indexedBufferRenderer

		let utils, bindingStates

		function initGLContext () {

			extensions = new WebGLExtensions$1(_gl)

			capabilities = new WebGLCapabilities$1(_gl, extensions, parameters)

			extensions.init(capabilities)

			utils = new WebGLUtils$1(_gl, extensions, capabilities)

			state = new WebGLState$1(_gl, extensions, capabilities)

			_currentDrawBuffers[0] = 1029

			info = new WebGLInfo$1()
			properties = new WebGLProperties$1()
			textures = new WebGLTextures$1(_gl, extensions, state, properties, capabilities, utils, info)
			cubemaps = new WebGLCubeMaps$1(_this)
			cubeuvmaps = new WebGLCubeUVMaps$1(_this)
			attributes = new WebGLAttributes$1(_gl, capabilities)
			bindingStates = new WebGLBindingStates$1(_gl, extensions, attributes, capabilities)
			geometries = new WebGLGeometries$1(_gl, attributes, info, bindingStates)
			objects = new WebGLObjects$1(_gl, geometries, attributes, info)
			morphtargets = new WebGLMorphtargets$1(_gl)
			clipping = new WebGLClipping$1(properties)
			programCache = new WebGLPrograms$1(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping)
			materials = new WebGLMaterials$1(properties)
			renderLists = new WebGLRenderLists$1(properties)
			renderStates = new WebGLRenderStates$1(extensions, capabilities)
			background = new WebGLBackground$1(_this, cubemaps, state, objects, _premultipliedAlpha)
			shadowMap = new WebGLShadowMap$1(_this, objects, capabilities)

			bufferRenderer = new WebGLBufferRenderer$1(_gl, extensions, info, capabilities)
			indexedBufferRenderer = new WebGLIndexedBufferRenderer$1(_gl, extensions, info, capabilities)

			info.programs = programCache.programs

			_this.capabilities = capabilities
			_this.extensions = extensions
			_this.properties = properties
			_this.renderLists = renderLists
			_this.shadowMap = shadowMap
			_this.state = state
			_this.info = info

		}

		initGLContext()

		// xr

		const xr = new WebXRManager$1(_this, _gl)

		this.xr = xr

		// API

		this.getContext = function () {

			return _gl

		}

		this.getContextAttributes = function () {

			return _gl.getContextAttributes()

		}

		this.forceContextLoss = function () {

			const extension = extensions.get('WEBGL_lose_context')
			if (extension) extension.loseContext()

		}

		this.forceContextRestore = function () {

			const extension = extensions.get('WEBGL_lose_context')
			if (extension) extension.restoreContext()

		}

		this.getPixelRatio = function () {

			return _pixelRatio

		}

		this.setPixelRatio = function (value) {

			if (value === undefined) return

			_pixelRatio = value

			this.setSize(_width, _height, false)

		}

		this.getSize = function (target) {

			return target.set(_width, _height)

		}

		this.setSize = function (width, height, updateStyle) {

			if (xr.isPresenting) {

				console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.')
				return

			}

			_width = width
			_height = height

			_canvas.width = Math.floor(width * _pixelRatio)
			_canvas.height = Math.floor(height * _pixelRatio)

			if (updateStyle !== false) {

				_canvas.style.width = width + 'px'
				_canvas.style.height = height + 'px'

			}

			this.setViewport(0, 0, width, height)

		}

		this.getDrawingBufferSize = function (target) {

			return target.set(_width * _pixelRatio, _height * _pixelRatio).floor()

		}

		this.setDrawingBufferSize = function (width, height, pixelRatio) {

			_width = width
			_height = height

			_pixelRatio = pixelRatio

			_canvas.width = Math.floor(width * pixelRatio)
			_canvas.height = Math.floor(height * pixelRatio)

			this.setViewport(0, 0, width, height)

		}

		this.getCurrentViewport = function (target) {

			return target.copy(_currentViewport)

		}

		this.getViewport = function (target) {

			return target.copy(_viewport)

		}

		this.setViewport = function (x, y, width, height) {

			if (x.isVector4) {

				_viewport.set(x.x, x.y, x.z, x.w)

			} else {

				_viewport.set(x, y, width, height)

			}

			state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor())

		}

		this.getScissor = function (target) {

			return target.copy(_scissor)

		}

		this.setScissor = function (x, y, width, height) {

			if (x.isVector4) {

				_scissor.set(x.x, x.y, x.z, x.w)

			} else {

				_scissor.set(x, y, width, height)

			}

			state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor())

		}

		this.getScissorTest = function () {

			return _scissorTest

		}

		this.setScissorTest = function (boolean) {

			state.setScissorTest(_scissorTest = boolean)

		}

		this.setOpaqueSort = function (method) {

			_opaqueSort = method

		}

		this.setTransparentSort = function (method) {

			_transparentSort = method

		}

		// Clearing

		this.getClearColor = function (target) {

			return target.copy(background.getClearColor())

		}

		this.setClearColor = function () {

			background.setClearColor.apply(background, arguments)

		}

		this.getClearAlpha = function () {

			return background.getClearAlpha()

		}

		this.setClearAlpha = function () {

			background.setClearAlpha.apply(background, arguments)

		}

		this.clear = function (color, depth, stencil) {

			let bits = 0

			if (color === undefined || color) bits |= 16384
			if (depth === undefined || depth) bits |= 256
			if (stencil === undefined || stencil) bits |= 1024

			_gl.clear(bits)

		}

		this.clearColor = function () {

			this.clear(true, false, false)

		}

		this.clearDepth = function () {

			this.clear(false, true, false)

		}

		this.clearStencil = function () {

			this.clear(false, false, true)

		}

		//

		this.dispose = function () {

			_canvas.removeEventListener('webglcontextlost', onContextLost, false)
			_canvas.removeEventListener('webglcontextrestored', onContextRestore, false)

			renderLists.dispose()
			renderStates.dispose()
			properties.dispose()
			cubemaps.dispose()
			cubeuvmaps.dispose()
			objects.dispose()
			bindingStates.dispose()

			xr.dispose()

			xr.removeEventListener('sessionstart', onXRSessionStart)
			xr.removeEventListener('sessionend', onXRSessionEnd)

			if (_transmissionRenderTarget) {

				_transmissionRenderTarget.dispose()
				_transmissionRenderTarget = null

			}

			animation.stop()

		}

		// Events

		function onContextLost (event) {

			event.preventDefault()

			console.log('THREE.WebGLRenderer: Context Lost.')

			_isContextLost = true

		}

		function onContextRestore ( /* event */) {

			console.log('THREE.WebGLRenderer: Context Restored.')

			_isContextLost = false

			const infoAutoReset = info.autoReset
			const shadowMapEnabled = shadowMap.enabled
			const shadowMapAutoUpdate = shadowMap.autoUpdate
			const shadowMapNeedsUpdate = shadowMap.needsUpdate
			const shadowMapType = shadowMap.type

			initGLContext()

			info.autoReset = infoAutoReset
			shadowMap.enabled = shadowMapEnabled
			shadowMap.autoUpdate = shadowMapAutoUpdate
			shadowMap.needsUpdate = shadowMapNeedsUpdate
			shadowMap.type = shadowMapType

		}

		function onMaterialDispose (event) {

			const material = event.target

			material.removeEventListener('dispose', onMaterialDispose)

			deallocateMaterial(material)

		}

		// Buffer deallocation

		function deallocateMaterial (material) {

			releaseMaterialProgramReferences(material)

			properties.remove(material)

		}


		function releaseMaterialProgramReferences (material) {

			const programs = properties.get(material).programs

			if (programs !== undefined) {

				programs.forEach(function (program) {

					programCache.releaseProgram(program)

				})

			}

		}

		// Buffer rendering

		function renderObjectImmediate (object, program) {

			object.render(function (object) {

				_this.renderBufferImmediate(object, program)

			})

		}

		this.renderBufferImmediate = function (object, program) {

			bindingStates.initAttributes()

			const buffers = properties.get(object)

			if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer()
			if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer()
			if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer()
			if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer()

			const programAttributes = program.getAttributes()

			if (object.hasPositions) {

				_gl.bindBuffer(34962, buffers.position)
				_gl.bufferData(34962, object.positionArray, 35048)

				bindingStates.enableAttribute(programAttributes.position)
				_gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0)

			}

			if (object.hasNormals) {

				_gl.bindBuffer(34962, buffers.normal)
				_gl.bufferData(34962, object.normalArray, 35048)

				bindingStates.enableAttribute(programAttributes.normal)
				_gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0)

			}

			if (object.hasUvs) {

				_gl.bindBuffer(34962, buffers.uv)
				_gl.bufferData(34962, object.uvArray, 35048)

				bindingStates.enableAttribute(programAttributes.uv)
				_gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0)

			}

			if (object.hasColors) {

				_gl.bindBuffer(34962, buffers.color)
				_gl.bufferData(34962, object.colorArray, 35048)

				bindingStates.enableAttribute(programAttributes.color)
				_gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0)

			}

			bindingStates.disableUnusedAttributes()

			_gl.drawArrays(4, 0, object.count)

			object.count = 0

		}

		this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {

			if (scene === null) scene = _emptyScene // renderBufferDirect second parameter used to be fog (could be null)

			const frontFaceCW = (object.isMesh && object.matrixWorld.determinant() < 0)

			const program = setProgram(camera, scene, material, object)

			state.setMaterial(material, frontFaceCW)

			//

			let index = geometry.index
			const position = geometry.attributes.position

			//

			if (index === null) {

				if (position === undefined || position.count === 0) return

			} else if (index.count === 0) {

				return

			}

			//

			let rangeFactor = 1

			if (material.wireframe === true) {

				index = geometries.getWireframeAttribute(geometry)
				rangeFactor = 2

			}

			if (geometry.morphAttributes.position !== undefined || geometry.morphAttributes.normal !== undefined) {

				morphtargets.update(object, geometry, material, program)

			}

			bindingStates.setup(object, material, program, geometry, index)

			let attribute
			let renderer = bufferRenderer

			if (index !== null) {

				attribute = attributes.get(index)

				renderer = indexedBufferRenderer
				renderer.setIndex(attribute)

			}

			//

			const dataCount = (index !== null) ? index.count : position.count

			const rangeStart = geometry.drawRange.start * rangeFactor
			const rangeCount = geometry.drawRange.count * rangeFactor

			const groupStart = group !== null ? group.start * rangeFactor : 0
			const groupCount = group !== null ? group.count * rangeFactor : Infinity

			const drawStart = Math.max(rangeStart, groupStart)
			const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1

			const drawCount = Math.max(0, drawEnd - drawStart + 1)

			if (drawCount === 0) return

			//

			if (object.isMesh) {

				if (material.wireframe === true) {

					state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio())
					renderer.setMode(1)

				} else {

					renderer.setMode(4)

				}

			} else if (object.isLine) {

				let lineWidth = material.linewidth

				if (lineWidth === undefined) lineWidth = 1 // Not using Line*Material

				state.setLineWidth(lineWidth * getTargetPixelRatio())

				if (object.isLineSegments) {

					renderer.setMode(1)

				} else if (object.isLineLoop) {

					renderer.setMode(2)

				} else {

					renderer.setMode(3)

				}

			} else if (object.isPoints) {

				renderer.setMode(0)

			} else if (object.isSprite) {

				renderer.setMode(4)

			}

			if (object.isInstancedMesh) {

				renderer.renderInstances(drawStart, drawCount, object.count)

			} else if (geometry.isInstancedBufferGeometry) {

				const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount)

				renderer.renderInstances(drawStart, drawCount, instanceCount)

			} else {

				renderer.render(drawStart, drawCount)

			}

		}

		// Compile

		this.compile = function (scene, camera) {

			currentRenderState = renderStates.get(scene)
			currentRenderState.init()

			renderStateStack.push(currentRenderState)

			scene.traverseVisible(function (object) {

				if (object.isLight && object.layers.test(camera.layers)) {

					currentRenderState.pushLight(object)

					if (object.castShadow) {

						currentRenderState.pushShadow(object)

					}

				}

			})

			currentRenderState.setupLights()

			scene.traverse(function (object) {

				const material = object.material

				if (material) {

					if (Array.isArray(material)) {

						for (let i = 0; i < material.length; i++) {

							const material2 = material[i]

							getProgram(material2, scene, object)

						}

					} else {

						getProgram(material, scene, object)

					}

				}

			})

			renderStateStack.pop()
			currentRenderState = null

		}

		// Animation Loop

		let onAnimationFrameCallback = null

		function onAnimationFrame (time) {

			if (onAnimationFrameCallback) onAnimationFrameCallback(time)

		}

		function onXRSessionStart () {

			animation.stop()

		}

		function onXRSessionEnd () {

			animation.start()

		}

		const animation = new WebGLAnimation$1()
		animation.setAnimationLoop(onAnimationFrame)

		if (typeof window !== 'undefined') animation.setContext(window)

		this.setAnimationLoop = function (callback) {

			onAnimationFrameCallback = callback
			xr.setAnimationLoop(callback);

			(callback === null) ? animation.stop() : animation.start()

		}

		xr.addEventListener('sessionstart', onXRSessionStart)
		xr.addEventListener('sessionend', onXRSessionEnd)

		// Rendering

		this.render = function (scene, camera) {

			if (camera !== undefined && camera.isCamera !== true) {

				console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.')
				return

			}

			if (_isContextLost === true) return

			// update scene graph

			if (scene.autoUpdate === true) scene.updateMatrixWorld()

			// update camera matrices and frustum

			if (camera.parent === null) camera.updateMatrixWorld()

			if (xr.enabled === true && xr.isPresenting === true) {

				if (xr.cameraAutoUpdate === true) xr.updateCamera(camera)

				camera = xr.getCamera() // use XR camera for rendering

			}

			//
			if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget)

			currentRenderState = renderStates.get(scene, renderStateStack.length)
			currentRenderState.init()

			renderStateStack.push(currentRenderState)

			_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse)
			_frustum.setFromProjectionMatrix(_projScreenMatrix)

			_localClippingEnabled = this.localClippingEnabled
			_clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera)

			currentRenderList = renderLists.get(scene, renderListStack.length)
			currentRenderList.init()

			renderListStack.push(currentRenderList)

			projectObject(scene, camera, 0, _this.sortObjects)

			currentRenderList.finish()

			if (_this.sortObjects === true) {

				currentRenderList.sort(_opaqueSort, _transparentSort)

			}

			//

			if (_clippingEnabled === true) clipping.beginShadows()

			const shadowsArray = currentRenderState.state.shadowsArray

			shadowMap.render(shadowsArray, scene, camera)

			currentRenderState.setupLights()
			currentRenderState.setupLightsView(camera)

			if (_clippingEnabled === true) clipping.endShadows()

			//

			if (this.info.autoReset === true) this.info.reset()

			//

			background.render(currentRenderList, scene)

			// render scene

			const opaqueObjects = currentRenderList.opaque
			const transmissiveObjects = currentRenderList.transmissive
			const transparentObjects = currentRenderList.transparent

			if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera)
			if (transmissiveObjects.length > 0) renderTransmissiveObjects(opaqueObjects, transmissiveObjects, scene, camera)
			if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera)

			//

			if (_currentRenderTarget !== null) {

				// resolve multisample renderbuffers to a single-sample texture if necessary

				textures.updateMultisampleRenderTarget(_currentRenderTarget)

				// Generate mipmap if we're using any kind of mipmap filtering

				textures.updateRenderTargetMipmap(_currentRenderTarget)

			}

			//

			if (scene.isScene === true) scene.onAfterRender(_this, scene, camera)

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest(true)
			state.buffers.depth.setMask(true)
			state.buffers.color.setMask(true)

			state.setPolygonOffset(false)

			// _gl.finish();

			bindingStates.resetDefaultState()
			_currentMaterialId = - 1
			_currentCamera = null

			renderStateStack.pop()

			if (renderStateStack.length > 0) {

				currentRenderState = renderStateStack[renderStateStack.length - 1]

			} else {

				currentRenderState = null

			}

			renderListStack.pop()

			if (renderListStack.length > 0) {

				currentRenderList = renderListStack[renderListStack.length - 1]

			} else {

				currentRenderList = null

			}

		}

		function projectObject (object, camera, groupOrder, sortObjects) {

			if (object.visible === false) return

			const visible = object.layers.test(camera.layers)

			if (visible) {

				if (object.isGroup) {

					groupOrder = object.renderOrder

				} else if (object.isLOD) {

					if (object.autoUpdate === true) object.update(camera)

				} else if (object.isLight) {

					currentRenderState.pushLight(object)

					if (object.castShadow) {

						currentRenderState.pushShadow(object)

					}

				} else if (object.isSprite) {

					if (!object.frustumCulled || _frustum.intersectsSprite(object)) {

						if (sortObjects) {

							_vector3.setFromMatrixPosition(object.matrixWorld)
								.applyMatrix4(_projScreenMatrix)

						}

						const geometry = objects.update(object)
						const material = object.material

						if (material.visible) {

							currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null)

						}

					}

				} else if (object.isImmediateRenderObject) {

					if (sortObjects) {

						_vector3.setFromMatrixPosition(object.matrixWorld)
							.applyMatrix4(_projScreenMatrix)

					}

					currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null)

				} else if (object.isMesh || object.isLine || object.isPoints) {

					if (object.isSkinnedMesh) {

						// update skeleton only once in a frame

						if (object.skeleton.frame !== info.render.frame) {

							object.skeleton.update()
							object.skeleton.frame = info.render.frame

						}

					}

					if (!object.frustumCulled || _frustum.intersectsObject(object)) {

						if (sortObjects) {

							_vector3.setFromMatrixPosition(object.matrixWorld)
								.applyMatrix4(_projScreenMatrix)

						}

						const geometry = objects.update(object)
						const material = object.material

						if (Array.isArray(material)) {

							const groups = geometry.groups

							for (let i = 0, l = groups.length; i < l; i++) {

								const group = groups[i]
								const groupMaterial = material[group.materialIndex]

								if (groupMaterial && groupMaterial.visible) {

									currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group)

								}

							}

						} else if (material.visible) {

							currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null)

						}

					}

				}

			}

			const children = object.children

			for (let i = 0, l = children.length; i < l; i++) {

				projectObject(children[i], camera, groupOrder, sortObjects)

			}

		}

		function renderTransmissiveObjects (opaqueObjects, transmissiveObjects, scene, camera) {

			if (_transmissionRenderTarget === null) {

				const needsAntialias = _antialias === true && capabilities.isWebGL2 === true
				const renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget : WebGLRenderTarget

				_transmissionRenderTarget = new renderTargetType(1024, 1024, {
					generateMipmaps: true,
					type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
					minFilter: LinearMipmapLinearFilter,
					magFilter: NearestFilter,
					wrapS: ClampToEdgeWrapping,
					wrapT: ClampToEdgeWrapping
				})

			}

			const currentRenderTarget = _this.getRenderTarget()
			_this.setRenderTarget(_transmissionRenderTarget)
			_this.clear()

			// Turn off the features which can affect the frag color for opaque objects pass.
			// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
			const currentToneMapping = _this.toneMapping
			_this.toneMapping = NoToneMapping

			renderObjects(opaqueObjects, scene, camera)

			_this.toneMapping = currentToneMapping

			textures.updateMultisampleRenderTarget(_transmissionRenderTarget)
			textures.updateRenderTargetMipmap(_transmissionRenderTarget)

			_this.setRenderTarget(currentRenderTarget)

			renderObjects(transmissiveObjects, scene, camera)

		}

		function renderObjects (renderList, scene, camera) {

			const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null

			if (camera.isArrayCamera) {

				const cameras = camera.cameras

				for (let i = 0, l = cameras.length; i < l; i++) {

					const camera2 = cameras[i]

					state.viewport(_currentViewport.copy(camera2.viewport))

					currentRenderState.setupLightsView(camera2)

					for (let j = 0, jl = renderList.length; j < jl; j++) {

						const renderItem = renderList[j]

						const object = renderItem.object
						const geometry = renderItem.geometry
						const material = overrideMaterial === null ? renderItem.material : overrideMaterial
						const group = renderItem.group

						if (object.layers.test(camera2.layers)) {

							renderObject(object, scene, camera2, geometry, material, group)

						}

					}

				}

			} else {

				for (let j = 0, jl = renderList.length; j < jl; j++) {

					const renderItem = renderList[j]

					const object = renderItem.object
					const geometry = renderItem.geometry
					const material = overrideMaterial === null ? renderItem.material : overrideMaterial
					const group = renderItem.group

					renderObject(object, scene, camera, geometry, material, group)

				}

			}

		}

		function renderObject (object, scene, camera, geometry, material, group) {

			object.onBeforeRender(_this, scene, camera, geometry, material, group)

			object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld)
			object.normalMatrix.getNormalMatrix(object.modelViewMatrix)

			if (object.isImmediateRenderObject) {

				const program = setProgram(camera, scene, material, object)

				state.setMaterial(material)

				bindingStates.reset()

				renderObjectImmediate(object, program)

			} else {

				if (material.transparent === true && material.side === DoubleSide) {

					material.side = BackSide
					material.needsUpdate = true
					_this.renderBufferDirect(camera, scene, geometry, material, object, group)

					material.side = FrontSide
					material.needsUpdate = true
					_this.renderBufferDirect(camera, scene, geometry, material, object, group)

					material.side = DoubleSide

				} else {

					_this.renderBufferDirect(camera, scene, geometry, material, object, group)

				}

			}

			object.onAfterRender(_this, scene, camera, geometry, material, group)

		}

		function getProgram (material, scene, object) {

			if (scene.isScene !== true) scene = _emptyScene // scene could be a Mesh, Line, Points, ...

			const materialProperties = properties.get(material)

			const lights = currentRenderState.state.lights
			const shadowsArray = currentRenderState.state.shadowsArray

			const lightsStateVersion = lights.state.version

			const parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object)
			const programCacheKey = programCache.getProgramCacheKey(parameters)

			let programs = materialProperties.programs

			// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

			materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null
			materialProperties.fog = scene.fog
			materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment)

			if (programs === undefined) {

				// new material

				material.addEventListener('dispose', onMaterialDispose)

				programs = new Map()
				materialProperties.programs = programs

			}

			let program = programs.get(programCacheKey)

			if (program !== undefined) {

				// early out if program and light state is identical

				if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {

					updateCommonMaterialProperties(material, parameters)

					return program

				}

			} else {

				parameters.uniforms = programCache.getUniforms(material)

				material.onBuild(parameters, _this)

				material.onBeforeCompile(parameters, _this)

				program = programCache.acquireProgram(parameters, programCacheKey)
				programs.set(programCacheKey, program)

				materialProperties.uniforms = parameters.uniforms

			}

			const uniforms = materialProperties.uniforms

			if ((!material.isShaderMaterial && !material.isRawShaderMaterial) || material.clipping === true) {

				uniforms.clippingPlanes = clipping.uniform

			}

			updateCommonMaterialProperties(material, parameters)

			// store the light setup it was created for

			materialProperties.needsLights = materialNeedsLights(material)
			materialProperties.lightsStateVersion = lightsStateVersion

			if (materialProperties.needsLights) {

				// wire up the material to this renderer's lighting state

				uniforms.ambientLightColor.value = lights.state.ambient
				uniforms.lightProbe.value = lights.state.probe
				uniforms.directionalLights.value = lights.state.directional
				uniforms.directionalLightShadows.value = lights.state.directionalShadow
				uniforms.spotLights.value = lights.state.spot
				uniforms.spotLightShadows.value = lights.state.spotShadow
				uniforms.rectAreaLights.value = lights.state.rectArea
				uniforms.ltc_1.value = lights.state.rectAreaLTC1
				uniforms.ltc_2.value = lights.state.rectAreaLTC2
				uniforms.pointLights.value = lights.state.point
				uniforms.pointLightShadows.value = lights.state.pointShadow
				uniforms.hemisphereLights.value = lights.state.hemi

				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix
				uniforms.spotShadowMap.value = lights.state.spotShadowMap
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix
				uniforms.pointShadowMap.value = lights.state.pointShadowMap
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix
				// TODO (abelnation): add area lights shadow info to uniforms

			}

			const progUniforms = program.getUniforms()
			const uniformsList = WebGLUniforms$1.seqWithValue(progUniforms.seq, uniforms)

			materialProperties.currentProgram = program
			materialProperties.uniformsList = uniformsList

			return program

		}

		function updateCommonMaterialProperties (material, parameters) {

			const materialProperties = properties.get(material)

			materialProperties.outputEncoding = parameters.outputEncoding
			materialProperties.instancing = parameters.instancing
			materialProperties.skinning = parameters.skinning
			materialProperties.morphTargets = parameters.morphTargets
			materialProperties.morphNormals = parameters.morphNormals
			materialProperties.numClippingPlanes = parameters.numClippingPlanes
			materialProperties.numIntersection = parameters.numClipIntersection
			materialProperties.vertexAlphas = parameters.vertexAlphas
			materialProperties.vertexTangents = parameters.vertexTangents

		}

		function setProgram (camera, scene, material, object) {

			if (scene.isScene !== true) scene = _emptyScene // scene could be a Mesh, Line, Points, ...

			textures.resetTextureUnits()

			const fog = scene.fog
			const environment = material.isMeshStandardMaterial ? scene.environment : null
			const encoding = (_currentRenderTarget === null) ? _this.outputEncoding : _currentRenderTarget.texture.encoding
			const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment)
			const vertexAlphas = material.vertexColors === true && !!object.geometry && !!object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4
			const vertexTangents = !!object.geometry && !!object.geometry.attributes.tangent
			const morphTargets = !!object.geometry && !!object.geometry.morphAttributes.position
			const morphNormals = !!object.geometry && !!object.geometry.morphAttributes.normal

			const materialProperties = properties.get(material)
			const lights = currentRenderState.state.lights

			if (_clippingEnabled === true) {

				if (_localClippingEnabled === true || camera !== _currentCamera) {

					const useCache =
						camera === _currentCamera &&
						material.id === _currentMaterialId

					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					clipping.setState(material, camera, useCache)

				}

			}

			//

			let needsProgramChange = false

			if (material.version === materialProperties.__version) {

				if (materialProperties.needsLights && (materialProperties.lightsStateVersion !== lights.state.version)) {

					needsProgramChange = true

				} else if (materialProperties.outputEncoding !== encoding) {

					needsProgramChange = true

				} else if (object.isInstancedMesh && materialProperties.instancing === false) {

					needsProgramChange = true

				} else if (!object.isInstancedMesh && materialProperties.instancing === true) {

					needsProgramChange = true

				} else if (object.isSkinnedMesh && materialProperties.skinning === false) {

					needsProgramChange = true

				} else if (!object.isSkinnedMesh && materialProperties.skinning === true) {

					needsProgramChange = true

				} else if (materialProperties.envMap !== envMap) {

					needsProgramChange = true

				} else if (material.fog && materialProperties.fog !== fog) {

					needsProgramChange = true

				} else if (materialProperties.numClippingPlanes !== undefined &&
					(materialProperties.numClippingPlanes !== clipping.numPlanes ||
						materialProperties.numIntersection !== clipping.numIntersection)) {

					needsProgramChange = true

				} else if (materialProperties.vertexAlphas !== vertexAlphas) {

					needsProgramChange = true

				} else if (materialProperties.vertexTangents !== vertexTangents) {

					needsProgramChange = true

				} else if (materialProperties.morphTargets !== morphTargets) {

					needsProgramChange = true

				} else if (materialProperties.morphNormals !== morphNormals) {

					needsProgramChange = true

				}

			} else {

				needsProgramChange = true
				materialProperties.__version = material.version

			}

			//

			let program = materialProperties.currentProgram

			if (needsProgramChange === true) {

				program = getProgram(material, scene, object)

			}

			let refreshProgram = false
			let refreshMaterial = false
			let refreshLights = false

			const p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.uniforms

			if (state.useProgram(program.program)) {

				refreshProgram = true
				refreshMaterial = true
				refreshLights = true

			}

			if (material.id !== _currentMaterialId) {

				_currentMaterialId = material.id

				refreshMaterial = true

			}

			if (refreshProgram || _currentCamera !== camera) {

				p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix)

				if (capabilities.logarithmicDepthBuffer) {

					p_uniforms.setValue(_gl, 'logDepthBufFC',
						2.0 / (Math.log(camera.far + 1.0) / Math.LN2))

				}

				if (_currentCamera !== camera) {

					_currentCamera = camera

					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true		// set to true on material change
					refreshLights = true		// remains set until update done

				}

				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)

				if (material.isShaderMaterial ||
					material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshStandardMaterial ||
					material.envMap) {

					const uCamPos = p_uniforms.map.cameraPosition

					if (uCamPos !== undefined) {

						uCamPos.setValue(_gl,
							_vector3.setFromMatrixPosition(camera.matrixWorld))

					}

				}

				if (material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial) {

					p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true)

				}

				if (material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ||
					material.isShadowMaterial ||
					object.isSkinnedMesh) {

					p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse)

				}

			}

			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// otherwise textures used for skinning can take over texture units reserved for other material textures

			if (object.isSkinnedMesh) {

				p_uniforms.setOptional(_gl, object, 'bindMatrix')
				p_uniforms.setOptional(_gl, object, 'bindMatrixInverse')

				const skeleton = object.skeleton

				if (skeleton) {

					if (capabilities.floatVertexTextures) {

						if (skeleton.boneTexture === null) skeleton.computeBoneTexture()

						p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures)
						p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize)

					} else {

						p_uniforms.setOptional(_gl, skeleton, 'boneMatrices')

					}

				}

			}

			if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {

				materialProperties.receiveShadow = object.receiveShadow
				p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow)

			}

			if (refreshMaterial) {

				p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure)

				if (materialProperties.needsLights) {

					// the current material requires lighting info

					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required

					markUniformsLightsNeedsUpdate(m_uniforms, refreshLights)

				}

				// refresh uniforms common to several materials

				if (fog && material.fog) {

					materials.refreshFogUniforms(m_uniforms, fog)

				}

				materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget)

				WebGLUniforms$1.upload(_gl, materialProperties.uniformsList, m_uniforms, textures)

			}

			if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {

				WebGLUniforms$1.upload(_gl, materialProperties.uniformsList, m_uniforms, textures)
				material.uniformsNeedUpdate = false

			}

			if (material.isSpriteMaterial) {

				p_uniforms.setValue(_gl, 'center', object.center)

			}

			// common matrices

			p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix)
			p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix)
			p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld)

			return program

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate (uniforms, value) {

			uniforms.ambientLightColor.needsUpdate = value
			uniforms.lightProbe.needsUpdate = value

			uniforms.directionalLights.needsUpdate = value
			uniforms.directionalLightShadows.needsUpdate = value
			uniforms.pointLights.needsUpdate = value
			uniforms.pointLightShadows.needsUpdate = value
			uniforms.spotLights.needsUpdate = value
			uniforms.spotLightShadows.needsUpdate = value
			uniforms.rectAreaLights.needsUpdate = value
			uniforms.hemisphereLights.needsUpdate = value

		}

		function materialNeedsLights (material) {

			return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
				material.isMeshStandardMaterial || material.isShadowMaterial ||
				(material.isShaderMaterial && material.lights === true)

		}

		this.getActiveCubeFace = function () {

			return _currentActiveCubeFace

		}

		this.getActiveMipmapLevel = function () {

			return _currentActiveMipmapLevel

		}

		this.getRenderTarget = function () {

			return _currentRenderTarget

		}

		this.setRenderTarget = function (renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {

			_currentRenderTarget = renderTarget
			_currentActiveCubeFace = activeCubeFace
			_currentActiveMipmapLevel = activeMipmapLevel

			if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {

				textures.setupRenderTarget(renderTarget)

			}

			let framebuffer = null
			let isCube = false
			let isRenderTarget3D = false

			if (renderTarget) {

				const texture = renderTarget.texture

				if (texture.isDataTexture3D || texture.isDataTexture2DArray) {

					isRenderTarget3D = true

				}

				const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer

				if (renderTarget.isWebGLCubeRenderTarget) {

					framebuffer = __webglFramebuffer[activeCubeFace]
					isCube = true

				} else if (renderTarget.isWebGLMultisampleRenderTarget) {

					framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer

				} else {

					framebuffer = __webglFramebuffer

				}

				_currentViewport.copy(renderTarget.viewport)
				_currentScissor.copy(renderTarget.scissor)
				_currentScissorTest = renderTarget.scissorTest

			} else {

				_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor()
				_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor()
				_currentScissorTest = _scissorTest

			}

			const framebufferBound = state.bindFramebuffer(36160, framebuffer)

			if (framebufferBound && capabilities.drawBuffers) {

				let needsUpdate = false

				if (renderTarget) {

					if (renderTarget.isWebGLMultipleRenderTargets) {

						const textures = renderTarget.texture

						if (_currentDrawBuffers.length !== textures.length || _currentDrawBuffers[0] !== 36064) {

							for (let i = 0, il = textures.length; i < il; i++) {

								_currentDrawBuffers[i] = 36064 + i

							}

							_currentDrawBuffers.length = textures.length

							needsUpdate = true

						}

					} else {

						if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 36064) {

							_currentDrawBuffers[0] = 36064
							_currentDrawBuffers.length = 1

							needsUpdate = true

						}

					}

				} else {

					if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 1029) {

						_currentDrawBuffers[0] = 1029
						_currentDrawBuffers.length = 1

						needsUpdate = true

					}

				}

				if (needsUpdate) {

					if (capabilities.isWebGL2) {

						_gl.drawBuffers(_currentDrawBuffers)

					} else {

						extensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(_currentDrawBuffers)

					}

				}

			}

			state.viewport(_currentViewport)
			state.scissor(_currentScissor)
			state.setScissorTest(_currentScissorTest)

			if (isCube) {

				const textureProperties = properties.get(renderTarget.texture)
				_gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel)

			} else if (isRenderTarget3D) {

				const textureProperties = properties.get(renderTarget.texture)
				const layer = activeCubeFace || 0
				_gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer)

			}

		}

		this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {

			if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {

				console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.')
				return

			}

			let framebuffer = properties.get(renderTarget).__webglFramebuffer

			if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {

				framebuffer = framebuffer[activeCubeFaceIndex]

			}

			if (framebuffer) {

				state.bindFramebuffer(36160, framebuffer)

				try {

					const texture = renderTarget.texture
					const textureFormat = texture.format
					const textureType = texture.type

					if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {

						console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.')
						return

					}

					const halfFloatSupportedByExt = (textureType === HalfFloatType) && (extensions.has('EXT_color_buffer_half_float') || (capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float')))

					if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && // Edge and Chrome Mac < 52 (#9513)
						!(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
						!halfFloatSupportedByExt) {

						console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.')
						return

					}

					if (_gl.checkFramebufferStatus(36160) === 36053) {

						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

						if ((x >= 0 && x <= (renderTarget.width - width)) && (y >= 0 && y <= (renderTarget.height - height))) {

							_gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer)

						}

					} else {

						console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.')

					}

				} finally {

					// restore framebuffer of current render target if necessary

					const framebuffer = (_currentRenderTarget !== null) ? properties.get(_currentRenderTarget).__webglFramebuffer : null
					state.bindFramebuffer(36160, framebuffer)

				}

			}

		}

		this.copyFramebufferToTexture = function (position, texture, level = 0) {

			const levelScale = Math.pow(2, - level)
			const width = Math.floor(texture.image.width * levelScale)
			const height = Math.floor(texture.image.height * levelScale)

			let glFormat = utils.convert(texture.format)

			if (capabilities.isWebGL2) {

				// Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100
				// Not needed in Chrome 93+

				if (glFormat === 6407) glFormat = 32849
				if (glFormat === 6408) glFormat = 32856

			}

			textures.setTexture2D(texture, 0)

			_gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0)

			state.unbindTexture()

		}

		this.copyTextureToTexture = function (position, srcTexture, dstTexture, level = 0) {

			const width = srcTexture.image.width
			const height = srcTexture.image.height
			const glFormat = utils.convert(dstTexture.format)
			const glType = utils.convert(dstTexture.type)

			textures.setTexture2D(dstTexture, 0)

			// As another texture upload may have changed pixelStorei
			// parameters, make sure they are correct for the dstTexture
			_gl.pixelStorei(37440, dstTexture.flipY)
			_gl.pixelStorei(37441, dstTexture.premultiplyAlpha)
			_gl.pixelStorei(3317, dstTexture.unpackAlignment)

			if (srcTexture.isDataTexture) {

				_gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data)

			} else {

				if (srcTexture.isCompressedTexture) {

					_gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data)

				} else {

					_gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image)

				}

			}

			// Generate mipmaps only when copying level 0
			if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(3553)

			state.unbindTexture()

		}

		this.copyTextureToTexture3D = function (sourceBox, position, srcTexture, dstTexture, level = 0) {

			if (_this.isWebGL1Renderer) {

				console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.')
				return

			}

			const width = sourceBox.max.x - sourceBox.min.x + 1
			const height = sourceBox.max.y - sourceBox.min.y + 1
			const depth = sourceBox.max.z - sourceBox.min.z + 1
			const glFormat = utils.convert(dstTexture.format)
			const glType = utils.convert(dstTexture.type)
			let glTarget

			if (dstTexture.isDataTexture3D) {

				textures.setTexture3D(dstTexture, 0)
				glTarget = 32879

			} else if (dstTexture.isDataTexture2DArray) {

				textures.setTexture2DArray(dstTexture, 0)
				glTarget = 35866

			} else {

				console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.')
				return

			}

			_gl.pixelStorei(37440, dstTexture.flipY)
			_gl.pixelStorei(37441, dstTexture.premultiplyAlpha)
			_gl.pixelStorei(3317, dstTexture.unpackAlignment)

			const unpackRowLen = _gl.getParameter(3314)
			const unpackImageHeight = _gl.getParameter(32878)
			const unpackSkipPixels = _gl.getParameter(3316)
			const unpackSkipRows = _gl.getParameter(3315)
			const unpackSkipImages = _gl.getParameter(32877)

			const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image

			_gl.pixelStorei(3314, image.width)
			_gl.pixelStorei(32878, image.height)
			_gl.pixelStorei(3316, sourceBox.min.x)
			_gl.pixelStorei(3315, sourceBox.min.y)
			_gl.pixelStorei(32877, sourceBox.min.z)

			if (srcTexture.isDataTexture || srcTexture.isDataTexture3D) {

				_gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data)

			} else {

				if (srcTexture.isCompressedTexture) {

					console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.')
					_gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data)

				} else {

					_gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image)

				}

			}

			_gl.pixelStorei(3314, unpackRowLen)
			_gl.pixelStorei(32878, unpackImageHeight)
			_gl.pixelStorei(3316, unpackSkipPixels)
			_gl.pixelStorei(3315, unpackSkipRows)
			_gl.pixelStorei(32877, unpackSkipImages)

			// Generate mipmaps only when copying level 0
			if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget)

			state.unbindTexture()

		}

		this.initTexture = function (texture) {

			textures.setTexture2D(texture, 0)

			state.unbindTexture()

		}

		this.resetState = function () {

			_currentActiveCubeFace = 0
			_currentActiveMipmapLevel = 0
			_currentRenderTarget = null

			state.reset()
			bindingStates.reset()

		}

		if (typeof __THREE_DEVTOOLS__ !== 'undefined') {

			__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this })) // eslint-disable-line no-undef

		}

	}

	class WebGL1Renderer extends WebGLRenderer$1 { }

	WebGL1Renderer.prototype.isWebGL1Renderer = true

	class FogExp2 {

		constructor(color, density = 0.00025) {

			this.name = ''

			this.color = new Color(color)
			this.density = density

		}

		clone () {

			return new FogExp2(this.color, this.density)

		}

		toJSON ( /* meta */) {

			return {
				type: 'FogExp2',
				color: this.color.getHex(),
				density: this.density
			}

		}

	}

	FogExp2.prototype.isFogExp2 = true

	class Fog {

		constructor(color, near = 1, far = 1000) {

			this.name = ''

			this.color = new Color(color)

			this.near = near
			this.far = far

		}

		clone () {

			return new Fog(this.color, this.near, this.far)

		}

		toJSON ( /* meta */) {

			return {
				type: 'Fog',
				color: this.color.getHex(),
				near: this.near,
				far: this.far
			}

		}

	}

	Fog.prototype.isFog = true

	class Scene extends Object3D {

		constructor() {

			super()

			this.type = 'Scene'

			this.background = null
			this.environment = null
			this.fog = null

			this.overrideMaterial = null

			this.autoUpdate = true // checked by the renderer

			if (typeof __THREE_DEVTOOLS__ !== 'undefined') {

				__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this })) // eslint-disable-line no-undef

			}

		}

		copy (source, recursive) {

			super.copy(source, recursive)

			if (source.background !== null) this.background = source.background.clone()
			if (source.environment !== null) this.environment = source.environment.clone()
			if (source.fog !== null) this.fog = source.fog.clone()

			if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone()

			this.autoUpdate = source.autoUpdate
			this.matrixAutoUpdate = source.matrixAutoUpdate

			return this

		}

		toJSON (meta) {

			const data = super.toJSON(meta)

			if (this.fog !== null) data.object.fog = this.fog.toJSON()

			return data

		}

	}

	Scene.prototype.isScene = true

	class InterleavedBuffer {

		constructor(array, stride) {

			this.array = array
			this.stride = stride
			this.count = array !== undefined ? array.length / stride : 0

			this.usage = StaticDrawUsage
			this.updateRange = { offset: 0, count: - 1 }

			this.version = 0

			this.uuid = generateUUID()

		}

		onUploadCallback () { }

		set needsUpdate (value) {

			if (value === true) this.version++

		}

		setUsage (value) {

			this.usage = value

			return this

		}

		copy (source) {

			this.array = new source.array.constructor(source.array)
			this.count = source.count
			this.stride = source.stride
			this.usage = source.usage

			return this

		}

		copyAt (index1, attribute, index2) {

			index1 *= this.stride
			index2 *= attribute.stride

			for (let i = 0, l = this.stride; i < l; i++) {

				this.array[index1 + i] = attribute.array[index2 + i]

			}

			return this

		}

		set (value, offset = 0) {

			this.array.set(value, offset)

			return this

		}

		clone (data) {

			if (data.arrayBuffers === undefined) {

				data.arrayBuffers = {}

			}

			if (this.array.buffer._uuid === undefined) {

				this.array.buffer._uuid = generateUUID()

			}

			if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {

				data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer

			}

			const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid])

			const ib = new this.constructor(array, this.stride)
			ib.setUsage(this.usage)

			return ib

		}

		onUpload (callback) {

			this.onUploadCallback = callback

			return this

		}

		toJSON (data) {

			if (data.arrayBuffers === undefined) {

				data.arrayBuffers = {}

			}

			// generate UUID for array buffer if necessary

			if (this.array.buffer._uuid === undefined) {

				this.array.buffer._uuid = generateUUID()

			}

			if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {

				data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))

			}

			//

			return {
				uuid: this.uuid,
				buffer: this.array.buffer._uuid,
				type: this.array.constructor.name,
				stride: this.stride
			}

		}

	}

	InterleavedBuffer.prototype.isInterleavedBuffer = true

	const _vector$6 = /*@__PURE__*/ new Vector3()

	class InterleavedBufferAttribute {

		constructor(interleavedBuffer, itemSize, offset, normalized = false) {

			this.name = ''

			this.data = interleavedBuffer
			this.itemSize = itemSize
			this.offset = offset

			this.normalized = normalized === true

		}

		get count () {

			return this.data.count

		}

		get array () {

			return this.data.array

		}

		set needsUpdate (value) {

			this.data.needsUpdate = value

		}

		applyMatrix4 (m) {

			for (let i = 0, l = this.data.count; i < l; i++) {

				_vector$6.x = this.getX(i)
				_vector$6.y = this.getY(i)
				_vector$6.z = this.getZ(i)

				_vector$6.applyMatrix4(m)

				this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z)

			}

			return this

		}

		applyNormalMatrix (m) {

			for (let i = 0, l = this.count; i < l; i++) {

				_vector$6.x = this.getX(i)
				_vector$6.y = this.getY(i)
				_vector$6.z = this.getZ(i)

				_vector$6.applyNormalMatrix(m)

				this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z)

			}

			return this

		}

		transformDirection (m) {

			for (let i = 0, l = this.count; i < l; i++) {

				_vector$6.x = this.getX(i)
				_vector$6.y = this.getY(i)
				_vector$6.z = this.getZ(i)

				_vector$6.transformDirection(m)

				this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z)

			}

			return this

		}

		setX (index, x) {

			this.data.array[index * this.data.stride + this.offset] = x

			return this

		}

		setY (index, y) {

			this.data.array[index * this.data.stride + this.offset + 1] = y

			return this

		}

		setZ (index, z) {

			this.data.array[index * this.data.stride + this.offset + 2] = z

			return this

		}

		setW (index, w) {

			this.data.array[index * this.data.stride + this.offset + 3] = w

			return this

		}

		getX (index) {

			return this.data.array[index * this.data.stride + this.offset]

		}

		getY (index) {

			return this.data.array[index * this.data.stride + this.offset + 1]

		}

		getZ (index) {

			return this.data.array[index * this.data.stride + this.offset + 2]

		}

		getW (index) {

			return this.data.array[index * this.data.stride + this.offset + 3]

		}

		setXY (index, x, y) {

			index = index * this.data.stride + this.offset

			this.data.array[index + 0] = x
			this.data.array[index + 1] = y

			return this

		}

		setXYZ (index, x, y, z) {

			index = index * this.data.stride + this.offset

			this.data.array[index + 0] = x
			this.data.array[index + 1] = y
			this.data.array[index + 2] = z

			return this

		}

		setXYZW (index, x, y, z, w) {

			index = index * this.data.stride + this.offset

			this.data.array[index + 0] = x
			this.data.array[index + 1] = y
			this.data.array[index + 2] = z
			this.data.array[index + 3] = w

			return this

		}

		clone (data) {

			if (data === undefined) {

				console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.')

				const array = []

				for (let i = 0; i < this.count; i++) {

					const index = i * this.data.stride + this.offset

					for (let j = 0; j < this.itemSize; j++) {

						array.push(this.data.array[index + j])

					}

				}

				return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized)

			} else {

				if (data.interleavedBuffers === undefined) {

					data.interleavedBuffers = {}

				}

				if (data.interleavedBuffers[this.data.uuid] === undefined) {

					data.interleavedBuffers[this.data.uuid] = this.data.clone(data)

				}

				return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)

			}

		}

		toJSON (data) {

			if (data === undefined) {

				console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.')

				const array = []

				for (let i = 0; i < this.count; i++) {

					const index = i * this.data.stride + this.offset

					for (let j = 0; j < this.itemSize; j++) {

						array.push(this.data.array[index + j])

					}

				}

				// deinterleave data and save it as an ordinary buffer attribute for now

				return {
					itemSize: this.itemSize,
					type: this.array.constructor.name,
					array: array,
					normalized: this.normalized
				}

			} else {

				// save as true interlaved attribtue

				if (data.interleavedBuffers === undefined) {

					data.interleavedBuffers = {}

				}

				if (data.interleavedBuffers[this.data.uuid] === undefined) {

					data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data)

				}

				return {
					isInterleavedBufferAttribute: true,
					itemSize: this.itemSize,
					data: this.data.uuid,
					offset: this.offset,
					normalized: this.normalized
				}

			}

		}

	}

	InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  map: new THREE.Texture( <Image> ),
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *  rotation: <float>,
	 *  sizeAttenuation: <bool>
	 * }
	 */

	class SpriteMaterial extends Material {

		constructor(parameters) {

			super()

			this.type = 'SpriteMaterial'

			this.color = new Color(0xffffff)

			this.map = null

			this.alphaMap = null

			this.rotation = 0

			this.sizeAttenuation = true

			this.transparent = true

			this.setValues(parameters)

		}

		copy (source) {

			super.copy(source)

			this.color.copy(source.color)

			this.map = source.map

			this.alphaMap = source.alphaMap

			this.rotation = source.rotation

			this.sizeAttenuation = source.sizeAttenuation

			return this

		}

	}

	SpriteMaterial.prototype.isSpriteMaterial = true

	let _geometry$3

	const _intersectPoint = /*@__PURE__*/ new Vector3()
	const _worldScale = /*@__PURE__*/ new Vector3()
	const _mvPosition = /*@__PURE__*/ new Vector3()

	const _alignedPosition = /*@__PURE__*/ new Vector2()
	const _rotatedPosition = /*@__PURE__*/ new Vector2()
	const _viewWorldMatrix = /*@__PURE__*/ new Matrix4()

	const _vA$2 = /*@__PURE__*/ new Vector3()
	const _vB$2 = /*@__PURE__*/ new Vector3()
	const _vC$2 = /*@__PURE__*/ new Vector3()

	const _uvA = /*@__PURE__*/ new Vector2()
	const _uvB = /*@__PURE__*/ new Vector2()
	const _uvC = /*@__PURE__*/ new Vector2()

	class Sprite extends Object3D {

		constructor(material) {

			super()

			this.type = 'Sprite'

			if (_geometry$3 === undefined) {

				_geometry$3 = new BufferGeometry()

				const float32Array = new Float32Array([
					- 0.5, - 0.5, 0, 0, 0,
					0.5, - 0.5, 0, 1, 0,
					0.5, 0.5, 0, 1, 1,
					- 0.5, 0.5, 0, 0, 1
				])

				const interleavedBuffer = new InterleavedBuffer(float32Array, 5)

				_geometry$3.setIndex([0, 1, 2, 0, 2, 3])
				_geometry$3.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false))
				_geometry$3.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false))

			}

			this.geometry = _geometry$3
			this.material = (material !== undefined) ? material : new SpriteMaterial()

			this.center = new Vector2(0.5, 0.5)

		}

		raycast (raycaster, intersects) {

			if (raycaster.camera === null) {

				console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.')

			}

			_worldScale.setFromMatrixScale(this.matrixWorld)

			_viewWorldMatrix.copy(raycaster.camera.matrixWorld)
			this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld)

			_mvPosition.setFromMatrixPosition(this.modelViewMatrix)

			if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {

				_worldScale.multiplyScalar(- _mvPosition.z)

			}

			const rotation = this.material.rotation
			let sin, cos

			if (rotation !== 0) {

				cos = Math.cos(rotation)
				sin = Math.sin(rotation)

			}

			const center = this.center

			transformVertex(_vA$2.set(- 0.5, - 0.5, 0), _mvPosition, center, _worldScale, sin, cos)
			transformVertex(_vB$2.set(0.5, - 0.5, 0), _mvPosition, center, _worldScale, sin, cos)
			transformVertex(_vC$2.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos)

			_uvA.set(0, 0)
			_uvB.set(1, 0)
			_uvC.set(1, 1)

			// check first triangle
			let intersect = raycaster.ray.intersectTriangle(_vA$2, _vB$2, _vC$2, false, _intersectPoint)

			if (intersect === null) {

				// check second triangle
				transformVertex(_vB$2.set(- 0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos)
				_uvB.set(0, 1)

				intersect = raycaster.ray.intersectTriangle(_vA$2, _vC$2, _vB$2, false, _intersectPoint)
				if (intersect === null) {

					return

				}

			}

			const distance = raycaster.ray.origin.distanceTo(_intersectPoint)

			if (distance < raycaster.near || distance > raycaster.far) return

			intersects.push({

				distance: distance,
				point: _intersectPoint.clone(),
				uv: Triangle.getUV(_intersectPoint, _vA$2, _vB$2, _vC$2, _uvA, _uvB, _uvC, new Vector2()),
				face: null,
				object: this

			})

		}

		copy (source) {

			super.copy(source)

			if (source.center !== undefined) this.center.copy(source.center)

			this.material = source.material

			return this

		}

	}

	Sprite.prototype.isSprite = true

	function transformVertex (vertexPosition, mvPosition, center, scale, sin, cos) {

		// compute position in camera space
		_alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale)

		// to check if rotation is not zero
		if (sin !== undefined) {

			_rotatedPosition.x = (cos * _alignedPosition.x) - (sin * _alignedPosition.y)
			_rotatedPosition.y = (sin * _alignedPosition.x) + (cos * _alignedPosition.y)

		} else {

			_rotatedPosition.copy(_alignedPosition)

		}


		vertexPosition.copy(mvPosition)
		vertexPosition.x += _rotatedPosition.x
		vertexPosition.y += _rotatedPosition.y

		// transform to world space
		vertexPosition.applyMatrix4(_viewWorldMatrix)

	}

	const _v1$2 = /*@__PURE__*/ new Vector3()
	const _v2$1 = /*@__PURE__*/ new Vector3()

	class LOD extends Object3D {

		constructor() {

			super()

			this._currentLevel = 0

			this.type = 'LOD'

			Object.defineProperties(this, {
				levels: {
					enumerable: true,
					value: []
				},
				isLOD: {
					value: true,
				}
			})

			this.autoUpdate = true

		}

		copy (source) {

			super.copy(source, false)

			const levels = source.levels

			for (let i = 0, l = levels.length; i < l; i++) {

				const level = levels[i]

				this.addLevel(level.object.clone(), level.distance)

			}

			this.autoUpdate = source.autoUpdate

			return this

		}

		addLevel (object, distance = 0) {

			distance = Math.abs(distance)

			const levels = this.levels

			let l

			for (l = 0; l < levels.length; l++) {

				if (distance < levels[l].distance) {

					break

				}

			}

			levels.splice(l, 0, { distance: distance, object: object })

			this.add(object)

			return this

		}

		getCurrentLevel () {

			return this._currentLevel

		}

		getObjectForDistance (distance) {

			const levels = this.levels

			if (levels.length > 0) {

				let i, l

				for (i = 1, l = levels.length; i < l; i++) {

					if (distance < levels[i].distance) {

						break

					}

				}

				return levels[i - 1].object

			}

			return null

		}

		raycast (raycaster, intersects) {

			const levels = this.levels

			if (levels.length > 0) {

				_v1$2.setFromMatrixPosition(this.matrixWorld)

				const distance = raycaster.ray.origin.distanceTo(_v1$2)

				this.getObjectForDistance(distance).raycast(raycaster, intersects)

			}

		}

		update (camera) {

			const levels = this.levels

			if (levels.length > 1) {

				_v1$2.setFromMatrixPosition(camera.matrixWorld)
				_v2$1.setFromMatrixPosition(this.matrixWorld)

				const distance = _v1$2.distanceTo(_v2$1) / camera.zoom

				levels[0].object.visible = true

				let i, l

				for (i = 1, l = levels.length; i < l; i++) {

					if (distance >= levels[i].distance) {

						levels[i - 1].object.visible = false
						levels[i].object.visible = true

					} else {

						break

					}

				}

				this._currentLevel = i - 1

				for (; i < l; i++) {

					levels[i].object.visible = false

				}

			}

		}

		toJSON (meta) {

			const data = super.toJSON(meta)

			if (this.autoUpdate === false) data.object.autoUpdate = false

			data.object.levels = []

			const levels = this.levels

			for (let i = 0, l = levels.length; i < l; i++) {

				const level = levels[i]

				data.object.levels.push({
					object: level.object.uuid,
					distance: level.distance
				})

			}

			return data

		}

	}

	const _basePosition = /*@__PURE__*/ new Vector3()

	const _skinIndex = /*@__PURE__*/ new Vector4()
	const _skinWeight = /*@__PURE__*/ new Vector4()

	const _vector$5 = /*@__PURE__*/ new Vector3()
	const _matrix = /*@__PURE__*/ new Matrix4()

	class SkinnedMesh extends Mesh {

		constructor(geometry, material) {

			super(geometry, material)

			this.type = 'SkinnedMesh'

			this.bindMode = 'attached'
			this.bindMatrix = new Matrix4()
			this.bindMatrixInverse = new Matrix4()

		}

		copy (source) {

			super.copy(source)

			this.bindMode = source.bindMode
			this.bindMatrix.copy(source.bindMatrix)
			this.bindMatrixInverse.copy(source.bindMatrixInverse)

			this.skeleton = source.skeleton

			return this

		}

		bind (skeleton, bindMatrix) {

			this.skeleton = skeleton

			if (bindMatrix === undefined) {

				this.updateMatrixWorld(true)

				this.skeleton.calculateInverses()

				bindMatrix = this.matrixWorld

			}

			this.bindMatrix.copy(bindMatrix)
			this.bindMatrixInverse.copy(bindMatrix).invert()

		}

		pose () {

			this.skeleton.pose()

		}

		normalizeSkinWeights () {

			const vector = new Vector4()

			const skinWeight = this.geometry.attributes.skinWeight

			for (let i = 0, l = skinWeight.count; i < l; i++) {

				vector.x = skinWeight.getX(i)
				vector.y = skinWeight.getY(i)
				vector.z = skinWeight.getZ(i)
				vector.w = skinWeight.getW(i)

				const scale = 1.0 / vector.manhattanLength()

				if (scale !== Infinity) {

					vector.multiplyScalar(scale)

				} else {

					vector.set(1, 0, 0, 0) // do something reasonable

				}

				skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w)

			}

		}

		updateMatrixWorld (force) {

			super.updateMatrixWorld(force)

			if (this.bindMode === 'attached') {

				this.bindMatrixInverse.copy(this.matrixWorld).invert()

			} else if (this.bindMode === 'detached') {

				this.bindMatrixInverse.copy(this.bindMatrix).invert()

			} else {

				console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode)

			}

		}

		boneTransform (index, target) {

			const skeleton = this.skeleton
			const geometry = this.geometry

			_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index)
			_skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index)

			_basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix)

			target.set(0, 0, 0)

			for (let i = 0; i < 4; i++) {

				const weight = _skinWeight.getComponent(i)

				if (weight !== 0) {

					const boneIndex = _skinIndex.getComponent(i)

					_matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex])

					target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight)

				}

			}

			return target.applyMatrix4(this.bindMatrixInverse)

		}

	}

	SkinnedMesh.prototype.isSkinnedMesh = true

	class Bone extends Object3D {

		constructor() {

			super()

			this.type = 'Bone'

		}

	}

	Bone.prototype.isBone = true

	class DataTexture extends Texture {

		constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {

			super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding)

			this.image = { data: data, width: width, height: height }

			this.magFilter = magFilter
			this.minFilter = minFilter

			this.generateMipmaps = false
			this.flipY = false
			this.unpackAlignment = 1

			this.needsUpdate = true

		}

	}

	DataTexture.prototype.isDataTexture = true

	const _offsetMatrix = /*@__PURE__*/ new Matrix4()
	const _identityMatrix = /*@__PURE__*/ new Matrix4()

	class Skeleton {

		constructor(bones = [], boneInverses = []) {

			this.uuid = generateUUID()

			this.bones = bones.slice(0)
			this.boneInverses = boneInverses
			this.boneMatrices = null

			this.boneTexture = null
			this.boneTextureSize = 0

			this.frame = - 1

			this.init()

		}

		init () {

			const bones = this.bones
			const boneInverses = this.boneInverses

			this.boneMatrices = new Float32Array(bones.length * 16)

			// calculate inverse bone matrices if necessary

			if (boneInverses.length === 0) {

				this.calculateInverses()

			} else {

				// handle special case

				if (bones.length !== boneInverses.length) {

					console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.')

					this.boneInverses = []

					for (let i = 0, il = this.bones.length; i < il; i++) {

						this.boneInverses.push(new Matrix4())

					}

				}

			}

		}

		calculateInverses () {

			this.boneInverses.length = 0

			for (let i = 0, il = this.bones.length; i < il; i++) {

				const inverse = new Matrix4()

				if (this.bones[i]) {

					inverse.copy(this.bones[i].matrixWorld).invert()

				}

				this.boneInverses.push(inverse)

			}

		}

		pose () {

			// recover the bind-time world matrices

			for (let i = 0, il = this.bones.length; i < il; i++) {

				const bone = this.bones[i]

				if (bone) {

					bone.matrixWorld.copy(this.boneInverses[i]).invert()

				}

			}

			// compute the local matrices, positions, rotations and scales

			for (let i = 0, il = this.bones.length; i < il; i++) {

				const bone = this.bones[i]

				if (bone) {

					if (bone.parent && bone.parent.isBone) {

						bone.matrix.copy(bone.parent.matrixWorld).invert()
						bone.matrix.multiply(bone.matrixWorld)

					} else {

						bone.matrix.copy(bone.matrixWorld)

					}

					bone.matrix.decompose(bone.position, bone.quaternion, bone.scale)

				}

			}

		}

		update () {

			const bones = this.bones
			const boneInverses = this.boneInverses
			const boneMatrices = this.boneMatrices
			const boneTexture = this.boneTexture

			// flatten bone matrices to array

			for (let i = 0, il = bones.length; i < il; i++) {

				// compute the offset between the current and the original transform

				const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix

				_offsetMatrix.multiplyMatrices(matrix, boneInverses[i])
				_offsetMatrix.toArray(boneMatrices, i * 16)

			}

			if (boneTexture !== null) {

				boneTexture.needsUpdate = true

			}

		}

		clone () {

			return new Skeleton(this.bones, this.boneInverses)

		}

		computeBoneTexture () {

			// layout (1 matrix = 4 pixels)
			//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
			//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
			//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
			//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

			let size = Math.sqrt(this.bones.length * 4) // 4 pixels needed for 1 matrix
			size = ceilPowerOfTwo(size)
			size = Math.max(size, 4)

			const boneMatrices = new Float32Array(size * size * 4) // 4 floats per RGBA pixel
			boneMatrices.set(this.boneMatrices) // copy current values

			const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType)

			this.boneMatrices = boneMatrices
			this.boneTexture = boneTexture
			this.boneTextureSize = size

			return this

		}

		getBoneByName (name) {

			for (let i = 0, il = this.bones.length; i < il; i++) {

				const bone = this.bones[i]

				if (bone.name === name) {

					return bone

				}

			}

			return undefined

		}

		dispose () {

			if (this.boneTexture !== null) {

				this.boneTexture.dispose()

				this.boneTexture = null

			}

		}

		fromJSON (json, bones) {

			this.uuid = json.uuid

			for (let i = 0, l = json.bones.length; i < l; i++) {

				const uuid = json.bones[i]
				let bone = bones[uuid]

				if (bone === undefined) {

					console.warn('THREE.Skeleton: No bone found with UUID:', uuid)
					bone = new Bone()

				}

				this.bones.push(bone)
				this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]))

			}

			this.init()

			return this

		}

		toJSON () {

			const data = {
				metadata: {
					version: 4.5,
					type: 'Skeleton',
					generator: 'Skeleton.toJSON'
				},
				bones: [],
				boneInverses: []
			}

			data.uuid = this.uuid

			const bones = this.bones
			const boneInverses = this.boneInverses

			for (let i = 0, l = bones.length; i < l; i++) {

				const bone = bones[i]
				data.bones.push(bone.uuid)

				const boneInverse = boneInverses[i]
				data.boneInverses.push(boneInverse.toArray())

			}

			return data

		}

	}

	const _instanceLocalMatrix = /*@__PURE__*/ new Matrix4()
	const _instanceWorldMatrix = /*@__PURE__*/ new Matrix4()

	const _instanceIntersects = []

	const _mesh = /*@__PURE__*/ new Mesh()

	class InstancedMesh extends Mesh {

		constructor(geometry, material, count) {

			super(geometry, material)

			this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16)
			this.instanceColor = null

			this.count = count

			this.frustumCulled = false

		}

		copy (source) {

			super.copy(source)

			this.instanceMatrix.copy(source.instanceMatrix)

			if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone()

			this.count = source.count

			return this

		}

		getColorAt (index, color) {

			color.fromArray(this.instanceColor.array, index * 3)

		}

		getMatrixAt (index, matrix) {

			matrix.fromArray(this.instanceMatrix.array, index * 16)

		}

		raycast (raycaster, intersects) {

			const matrixWorld = this.matrixWorld
			const raycastTimes = this.count

			_mesh.geometry = this.geometry
			_mesh.material = this.material

			if (_mesh.material === undefined) return

			for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {

				// calculate the world matrix for each instance

				this.getMatrixAt(instanceId, _instanceLocalMatrix)

				_instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix)

				// the mesh represents this single instance

				_mesh.matrixWorld = _instanceWorldMatrix

				_mesh.raycast(raycaster, _instanceIntersects)

				// process the result of raycast

				for (let i = 0, l = _instanceIntersects.length; i < l; i++) {

					const intersect = _instanceIntersects[i]
					intersect.instanceId = instanceId
					intersect.object = this
					intersects.push(intersect)

				}

				_instanceIntersects.length = 0

			}

		}

		setColorAt (index, color) {

			if (this.instanceColor === null) {

				this.instanceColor = new BufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3)

			}

			color.toArray(this.instanceColor.array, index * 3)

		}

		setMatrixAt (index, matrix) {

			matrix.toArray(this.instanceMatrix.array, index * 16)

		}

		updateMorphTargets () {

		}

		dispose () {

			this.dispatchEvent({ type: 'dispose' })

		}

	}

	InstancedMesh.prototype.isInstancedMesh = true

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round"
	 * }
	 */

	class LineBasicMaterial extends Material {

		constructor(parameters) {

			super()

			this.type = 'LineBasicMaterial'

			this.color = new Color(0xffffff)

			this.linewidth = 1
			this.linecap = 'round'
			this.linejoin = 'round'

			this.setValues(parameters)

		}


		copy (source) {

			super.copy(source)

			this.color.copy(source.color)

			this.linewidth = source.linewidth
			this.linecap = source.linecap
			this.linejoin = source.linejoin

			return this

		}

	}

	LineBasicMaterial.prototype.isLineBasicMaterial = true

	const _start$1 = /*@__PURE__*/ new Vector3()
	const _end$1 = /*@__PURE__*/ new Vector3()
	const _inverseMatrix$1 = /*@__PURE__*/ new Matrix4()
	const _ray$1 = /*@__PURE__*/ new Ray()
	const _sphere$1 = /*@__PURE__*/ new Sphere()

	class Line extends Object3D {

		constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {

			super()

			this.type = 'Line'

			this.geometry = geometry
			this.material = material

			this.updateMorphTargets()

		}

		copy (source) {

			super.copy(source)

			this.material = source.material
			this.geometry = source.geometry

			return this

		}

		computeLineDistances () {

			const geometry = this.geometry

			if (geometry.isBufferGeometry) {

				// we assume non-indexed geometry

				if (geometry.index === null) {

					const positionAttribute = geometry.attributes.position
					const lineDistances = [0]

					for (let i = 1, l = positionAttribute.count; i < l; i++) {

						_start$1.fromBufferAttribute(positionAttribute, i - 1)
						_end$1.fromBufferAttribute(positionAttribute, i)

						lineDistances[i] = lineDistances[i - 1]
						lineDistances[i] += _start$1.distanceTo(_end$1)

					}

					geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1))

				} else {

					console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.')

				}

			} else if (geometry.isGeometry) {

				console.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.')

			}

			return this

		}

		raycast (raycaster, intersects) {

			const geometry = this.geometry
			const matrixWorld = this.matrixWorld
			const threshold = raycaster.params.Line.threshold
			const drawRange = geometry.drawRange

			// Checking boundingSphere distance to ray

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere()

			_sphere$1.copy(geometry.boundingSphere)
			_sphere$1.applyMatrix4(matrixWorld)
			_sphere$1.radius += threshold

			if (raycaster.ray.intersectsSphere(_sphere$1) === false) return

			//

			_inverseMatrix$1.copy(matrixWorld).invert()
			_ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1)

			const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3)
			const localThresholdSq = localThreshold * localThreshold

			const vStart = new Vector3()
			const vEnd = new Vector3()
			const interSegment = new Vector3()
			const interRay = new Vector3()
			const step = this.isLineSegments ? 2 : 1

			if (geometry.isBufferGeometry) {

				const index = geometry.index
				const attributes = geometry.attributes
				const positionAttribute = attributes.position

				if (index !== null) {

					const start = Math.max(0, drawRange.start)
					const end = Math.min(index.count, (drawRange.start + drawRange.count))

					for (let i = start, l = end - 1; i < l; i += step) {

						const a = index.getX(i)
						const b = index.getX(i + 1)

						vStart.fromBufferAttribute(positionAttribute, a)
						vEnd.fromBufferAttribute(positionAttribute, b)

						const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment)

						if (distSq > localThresholdSq) continue

						interRay.applyMatrix4(this.matrixWorld) //Move back to world space for distance calculation

						const distance = raycaster.ray.origin.distanceTo(interRay)

						if (distance < raycaster.near || distance > raycaster.far) continue

						intersects.push({

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4(this.matrixWorld),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						})

					}

				} else {

					const start = Math.max(0, drawRange.start)
					const end = Math.min(positionAttribute.count, (drawRange.start + drawRange.count))

					for (let i = start, l = end - 1; i < l; i += step) {

						vStart.fromBufferAttribute(positionAttribute, i)
						vEnd.fromBufferAttribute(positionAttribute, i + 1)

						const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment)

						if (distSq > localThresholdSq) continue

						interRay.applyMatrix4(this.matrixWorld) //Move back to world space for distance calculation

						const distance = raycaster.ray.origin.distanceTo(interRay)

						if (distance < raycaster.near || distance > raycaster.far) continue

						intersects.push({

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4(this.matrixWorld),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						})

					}

				}

			} else if (geometry.isGeometry) {

				console.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.')

			}

		}

		updateMorphTargets () {

			const geometry = this.geometry

			if (geometry.isBufferGeometry) {

				const morphAttributes = geometry.morphAttributes
				const keys = Object.keys(morphAttributes)

				if (keys.length > 0) {

					const morphAttribute = morphAttributes[keys[0]]

					if (morphAttribute !== undefined) {

						this.morphTargetInfluences = []
						this.morphTargetDictionary = {}

						for (let m = 0, ml = morphAttribute.length; m < ml; m++) {

							const name = morphAttribute[m].name || String(m)

							this.morphTargetInfluences.push(0)
							this.morphTargetDictionary[name] = m

						}

					}

				}

			} else {

				const morphTargets = geometry.morphTargets

				if (morphTargets !== undefined && morphTargets.length > 0) {

					console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.')

				}

			}

		}

	}

	Line.prototype.isLine = true

	const _start$2 = /*@__PURE__*/ new Vector3()
	const _end$2 = /*@__PURE__*/ new Vector3()

	class LineSegments extends Line {

		constructor(geometry, material) {

			super(geometry, material)

			this.type = 'LineSegments'

		}

		computeLineDistances () {

			const geometry = this.geometry

			if (geometry.isBufferGeometry) {

				// we assume non-indexed geometry

				if (geometry.index === null) {

					const positionAttribute = geometry.attributes.position
					const lineDistances = []

					for (let i = 0, l = positionAttribute.count; i < l; i += 2) {

						_start$2.fromBufferAttribute(positionAttribute, i)
						_end$2.fromBufferAttribute(positionAttribute, i + 1)

						lineDistances[i] = (i === 0) ? 0 : lineDistances[i - 1]
						lineDistances[i + 1] = lineDistances[i] + _start$2.distanceTo(_end$2)

					}

					geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1))

				} else {

					console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.')

				}

			} else if (geometry.isGeometry) {

				console.error('THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.')

			}

			return this

		}

	}

	LineSegments.prototype.isLineSegments = true

	class LineLoop extends Line {

		constructor(geometry, material) {

			super(geometry, material)

			this.type = 'LineLoop'

		}

	}

	LineLoop.prototype.isLineLoop = true

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>
	 *
	 * }
	 */

	class PointsMaterial extends Material {

		constructor(parameters) {

			super()

			this.type = 'PointsMaterial'

			this.color = new Color(0xffffff)

			this.map = null

			this.alphaMap = null

			this.size = 1
			this.sizeAttenuation = true

			this.setValues(parameters)

		}

		copy (source) {

			super.copy(source)

			this.color.copy(source.color)

			this.map = source.map

			this.alphaMap = source.alphaMap

			this.size = source.size
			this.sizeAttenuation = source.sizeAttenuation

			return this

		}

	}

	PointsMaterial.prototype.isPointsMaterial = true

	const _inverseMatrix = /*@__PURE__*/ new Matrix4()
	const _ray = /*@__PURE__*/ new Ray()
	const _sphere$4 = /*@__PURE__*/ new Sphere()
	const _position$2 = /*@__PURE__*/ new Vector3()

	class Points extends Object3D {

		constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {

			super()

			this.type = 'Points'

			this.geometry = geometry
			this.material = material

			this.updateMorphTargets()

		}

		copy (source) {

			super.copy(source)

			this.material = source.material
			this.geometry = source.geometry

			return this

		}

		raycast (raycaster, intersects) {

			const geometry = this.geometry
			const matrixWorld = this.matrixWorld
			const threshold = raycaster.params.Points.threshold
			const drawRange = geometry.drawRange

			// Checking boundingSphere distance to ray

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere()

			_sphere$4.copy(geometry.boundingSphere)
			_sphere$4.applyMatrix4(matrixWorld)
			_sphere$4.radius += threshold

			if (raycaster.ray.intersectsSphere(_sphere$4) === false) return

			//

			_inverseMatrix.copy(matrixWorld).invert()
			_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix)

			const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3)
			const localThresholdSq = localThreshold * localThreshold

			if (geometry.isBufferGeometry) {

				const index = geometry.index
				const attributes = geometry.attributes
				const positionAttribute = attributes.position

				if (index !== null) {

					const start = Math.max(0, drawRange.start)
					const end = Math.min(index.count, (drawRange.start + drawRange.count))

					for (let i = start, il = end; i < il; i++) {

						const a = index.getX(i)

						_position$2.fromBufferAttribute(positionAttribute, a)

						testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this)

					}

				} else {

					const start = Math.max(0, drawRange.start)
					const end = Math.min(positionAttribute.count, (drawRange.start + drawRange.count))

					for (let i = start, l = end; i < l; i++) {

						_position$2.fromBufferAttribute(positionAttribute, i)

						testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this)

					}

				}

			} else {

				console.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.')

			}

		}

		updateMorphTargets () {

			const geometry = this.geometry

			if (geometry.isBufferGeometry) {

				const morphAttributes = geometry.morphAttributes
				const keys = Object.keys(morphAttributes)

				if (keys.length > 0) {

					const morphAttribute = morphAttributes[keys[0]]

					if (morphAttribute !== undefined) {

						this.morphTargetInfluences = []
						this.morphTargetDictionary = {}

						for (let m = 0, ml = morphAttribute.length; m < ml; m++) {

							const name = morphAttribute[m].name || String(m)

							this.morphTargetInfluences.push(0)
							this.morphTargetDictionary[name] = m

						}

					}

				}

			} else {

				const morphTargets = geometry.morphTargets

				if (morphTargets !== undefined && morphTargets.length > 0) {

					console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.')

				}

			}

		}

	}

	Points.prototype.isPoints = true

	function testPoint (point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {

		const rayPointDistanceSq = _ray.distanceSqToPoint(point)

		if (rayPointDistanceSq < localThresholdSq) {

			const intersectPoint = new Vector3()

			_ray.closestPointToPoint(point, intersectPoint)
			intersectPoint.applyMatrix4(matrixWorld)

			const distance = raycaster.ray.origin.distanceTo(intersectPoint)

			if (distance < raycaster.near || distance > raycaster.far) return

			intersects.push({

				distance: distance,
				distanceToRay: Math.sqrt(rayPointDistanceSq),
				point: intersectPoint,
				index: index,
				face: null,
				object: object

			})

		}

	}

	class VideoTexture extends Texture {

		constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {

			super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy)

			this.format = format !== undefined ? format : RGBFormat

			this.minFilter = minFilter !== undefined ? minFilter : LinearFilter
			this.magFilter = magFilter !== undefined ? magFilter : LinearFilter

			this.generateMipmaps = false

			const scope = this

			function updateVideo () {

				scope.needsUpdate = true
				video.requestVideoFrameCallback(updateVideo)

			}

			if ('requestVideoFrameCallback' in video) {

				video.requestVideoFrameCallback(updateVideo)

			}

		}

		clone () {

			return new this.constructor(this.image).copy(this)

		}

		update () {

			const video = this.image
			const hasVideoFrameCallback = 'requestVideoFrameCallback' in video

			if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {

				this.needsUpdate = true

			}

		}

	}

	VideoTexture.prototype.isVideoTexture = true

	class CompressedTexture extends Texture {

		constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {

			super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding)

			this.image = { width: width, height: height }
			this.mipmaps = mipmaps

			// no flipping for cube textures
			// (also flipping doesn't work for compressed textures )

			this.flipY = false

			// can't generate mipmaps for compressed textures
			// mips must be embedded in DDS files

			this.generateMipmaps = false

		}

	}

	CompressedTexture.prototype.isCompressedTexture = true

	class CanvasTexture extends Texture {

		constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {

			super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy)

			this.needsUpdate = true

		}

	}

	CanvasTexture.prototype.isCanvasTexture = true

	class DepthTexture extends Texture {

		constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {

			format = format !== undefined ? format : DepthFormat

			if (format !== DepthFormat && format !== DepthStencilFormat) {

				throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat')

			}

			if (type === undefined && format === DepthFormat) type = UnsignedShortType
			if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type

			super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy)

			this.image = { width: width, height: height }

			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter

			this.flipY = false
			this.generateMipmaps = false

		}


	}

	DepthTexture.prototype.isDepthTexture = true

	class CircleGeometry extends BufferGeometry {

		constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {

			super()

			this.type = 'CircleGeometry'

			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			}

			segments = Math.max(3, segments)

			// buffers

			const indices = []
			const vertices = []
			const normals = []
			const uvs = []

			// helper variables

			const vertex = new Vector3()
			const uv = new Vector2()

			// center point

			vertices.push(0, 0, 0)
			normals.push(0, 0, 1)
			uvs.push(0.5, 0.5)

			for (let s = 0, i = 3; s <= segments; s++, i += 3) {

				const segment = thetaStart + s / segments * thetaLength

				// vertex

				vertex.x = radius * Math.cos(segment)
				vertex.y = radius * Math.sin(segment)

				vertices.push(vertex.x, vertex.y, vertex.z)

				// normal

				normals.push(0, 0, 1)

				// uvs

				uv.x = (vertices[i] / radius + 1) / 2
				uv.y = (vertices[i + 1] / radius + 1) / 2

				uvs.push(uv.x, uv.y)

			}

			// indices

			for (let i = 1; i <= segments; i++) {

				indices.push(i, i + 1, 0)

			}

			// build geometry

			this.setIndex(indices)
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))

		}

		static fromJSON (data) {

			return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength)

		}

	}

	class CylinderGeometry extends BufferGeometry {

		constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {

			super()
			this.type = 'CylinderGeometry'

			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			}

			const scope = this

			radialSegments = Math.floor(radialSegments)
			heightSegments = Math.floor(heightSegments)

			// buffers

			const indices = []
			const vertices = []
			const normals = []
			const uvs = []

			// helper variables

			let index = 0
			const indexArray = []
			const halfHeight = height / 2
			let groupStart = 0

			// generate geometry

			generateTorso()

			if (openEnded === false) {

				if (radiusTop > 0) generateCap(true)
				if (radiusBottom > 0) generateCap(false)

			}

			// build geometry

			this.setIndex(indices)
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))

			function generateTorso () {

				const normal = new Vector3()
				const vertex = new Vector3()

				let groupCount = 0

				// this will be used to calculate the normal
				const slope = (radiusBottom - radiusTop) / height

				// generate vertices, normals and uvs

				for (let y = 0; y <= heightSegments; y++) {

					const indexRow = []

					const v = y / heightSegments

					// calculate the radius of the current row

					const radius = v * (radiusBottom - radiusTop) + radiusTop

					for (let x = 0; x <= radialSegments; x++) {

						const u = x / radialSegments

						const theta = u * thetaLength + thetaStart

						const sinTheta = Math.sin(theta)
						const cosTheta = Math.cos(theta)

						// vertex

						vertex.x = radius * sinTheta
						vertex.y = - v * height + halfHeight
						vertex.z = radius * cosTheta
						vertices.push(vertex.x, vertex.y, vertex.z)

						// normal

						normal.set(sinTheta, slope, cosTheta).normalize()
						normals.push(normal.x, normal.y, normal.z)

						// uv

						uvs.push(u, 1 - v)

						// save index of vertex in respective row

						indexRow.push(index++)

					}

					// now save vertices of the row in our index array

					indexArray.push(indexRow)

				}

				// generate indices

				for (let x = 0; x < radialSegments; x++) {

					for (let y = 0; y < heightSegments; y++) {

						// we use the index array to access the correct indices

						const a = indexArray[y][x]
						const b = indexArray[y + 1][x]
						const c = indexArray[y + 1][x + 1]
						const d = indexArray[y][x + 1]

						// faces

						indices.push(a, b, d)
						indices.push(b, c, d)

						// update group counter

						groupCount += 6

					}

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup(groupStart, groupCount, 0)

				// calculate new start value for groups

				groupStart += groupCount

			}

			function generateCap (top) {

				// save the index of the first center vertex
				const centerIndexStart = index

				const uv = new Vector2()
				const vertex = new Vector3()

				let groupCount = 0

				const radius = (top === true) ? radiusTop : radiusBottom
				const sign = (top === true) ? 1 : - 1

				// first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment

				for (let x = 1; x <= radialSegments; x++) {

					// vertex

					vertices.push(0, halfHeight * sign, 0)

					// normal

					normals.push(0, sign, 0)

					// uv

					uvs.push(0.5, 0.5)

					// increase index

					index++

				}

				// save the index of the last center vertex
				const centerIndexEnd = index

				// now we generate the surrounding vertices, normals and uvs

				for (let x = 0; x <= radialSegments; x++) {

					const u = x / radialSegments
					const theta = u * thetaLength + thetaStart

					const cosTheta = Math.cos(theta)
					const sinTheta = Math.sin(theta)

					// vertex

					vertex.x = radius * sinTheta
					vertex.y = halfHeight * sign
					vertex.z = radius * cosTheta
					vertices.push(vertex.x, vertex.y, vertex.z)

					// normal

					normals.push(0, sign, 0)

					// uv

					uv.x = (cosTheta * 0.5) + 0.5
					uv.y = (sinTheta * 0.5 * sign) + 0.5
					uvs.push(uv.x, uv.y)

					// increase index

					index++

				}

				// generate indices

				for (let x = 0; x < radialSegments; x++) {

					const c = centerIndexStart + x
					const i = centerIndexEnd + x

					if (top === true) {

						// face top

						indices.push(i, i + 1, c)

					} else {

						// face bottom

						indices.push(i + 1, i, c)

					}

					groupCount += 3

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup(groupStart, groupCount, top === true ? 1 : 2)

				// calculate new start value for groups

				groupStart += groupCount

			}

		}

		static fromJSON (data) {

			return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength)

		}

	}

	class ConeGeometry extends CylinderGeometry {

		constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {

			super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength)

			this.type = 'ConeGeometry'

			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			}

		}

		static fromJSON (data) {

			return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength)

		}

	}

	class PolyhedronGeometry extends BufferGeometry {

		constructor(vertices, indices, radius = 1, detail = 0) {

			super()

			this.type = 'PolyhedronGeometry'

			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			}

			// default buffer data

			const vertexBuffer = []
			const uvBuffer = []

			// the subdivision creates the vertex buffer data

			subdivide(detail)

			// all vertices should lie on a conceptual sphere with a given radius

			applyRadius(radius)

			// finally, create the uv data

			generateUVs()

			// build non-indexed geometry

			this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3))
			this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3))
			this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2))

			if (detail === 0) {

				this.computeVertexNormals() // flat normals

			} else {

				this.normalizeNormals() // smooth normals

			}

			// helper functions

			function subdivide (detail) {

				const a = new Vector3()
				const b = new Vector3()
				const c = new Vector3()

				// iterate over all faces and apply a subdivison with the given detail value

				for (let i = 0; i < indices.length; i += 3) {

					// get the vertices of the face

					getVertexByIndex(indices[i + 0], a)
					getVertexByIndex(indices[i + 1], b)
					getVertexByIndex(indices[i + 2], c)

					// perform subdivision

					subdivideFace(a, b, c, detail)

				}

			}

			function subdivideFace (a, b, c, detail) {

				const cols = detail + 1

				// we use this multidimensional array as a data structure for creating the subdivision

				const v = []

				// construct all of the vertices for this subdivision

				for (let i = 0; i <= cols; i++) {

					v[i] = []

					const aj = a.clone().lerp(c, i / cols)
					const bj = b.clone().lerp(c, i / cols)

					const rows = cols - i

					for (let j = 0; j <= rows; j++) {

						if (j === 0 && i === cols) {

							v[i][j] = aj

						} else {

							v[i][j] = aj.clone().lerp(bj, j / rows)

						}

					}

				}

				// construct all of the faces

				for (let i = 0; i < cols; i++) {

					for (let j = 0; j < 2 * (cols - i) - 1; j++) {

						const k = Math.floor(j / 2)

						if (j % 2 === 0) {

							pushVertex(v[i][k + 1])
							pushVertex(v[i + 1][k])
							pushVertex(v[i][k])

						} else {

							pushVertex(v[i][k + 1])
							pushVertex(v[i + 1][k + 1])
							pushVertex(v[i + 1][k])

						}

					}

				}

			}

			function applyRadius (radius) {

				const vertex = new Vector3()

				// iterate over the entire buffer and apply the radius to each vertex

				for (let i = 0; i < vertexBuffer.length; i += 3) {

					vertex.x = vertexBuffer[i + 0]
					vertex.y = vertexBuffer[i + 1]
					vertex.z = vertexBuffer[i + 2]

					vertex.normalize().multiplyScalar(radius)

					vertexBuffer[i + 0] = vertex.x
					vertexBuffer[i + 1] = vertex.y
					vertexBuffer[i + 2] = vertex.z

				}

			}

			function generateUVs () {

				const vertex = new Vector3()

				for (let i = 0; i < vertexBuffer.length; i += 3) {

					vertex.x = vertexBuffer[i + 0]
					vertex.y = vertexBuffer[i + 1]
					vertex.z = vertexBuffer[i + 2]

					const u = azimuth(vertex) / 2 / Math.PI + 0.5
					const v = inclination(vertex) / Math.PI + 0.5
					uvBuffer.push(u, 1 - v)

				}

				correctUVs()

				correctSeam()

			}

			function correctSeam () {

				// handle case when face straddles the seam, see #3269

				for (let i = 0; i < uvBuffer.length; i += 6) {

					// uv data of a single face

					const x0 = uvBuffer[i + 0]
					const x1 = uvBuffer[i + 2]
					const x2 = uvBuffer[i + 4]

					const max = Math.max(x0, x1, x2)
					const min = Math.min(x0, x1, x2)

					// 0.9 is somewhat arbitrary

					if (max > 0.9 && min < 0.1) {

						if (x0 < 0.2) uvBuffer[i + 0] += 1
						if (x1 < 0.2) uvBuffer[i + 2] += 1
						if (x2 < 0.2) uvBuffer[i + 4] += 1

					}

				}

			}

			function pushVertex (vertex) {

				vertexBuffer.push(vertex.x, vertex.y, vertex.z)

			}

			function getVertexByIndex (index, vertex) {

				const stride = index * 3

				vertex.x = vertices[stride + 0]
				vertex.y = vertices[stride + 1]
				vertex.z = vertices[stride + 2]

			}

			function correctUVs () {

				const a = new Vector3()
				const b = new Vector3()
				const c = new Vector3()

				const centroid = new Vector3()

				const uvA = new Vector2()
				const uvB = new Vector2()
				const uvC = new Vector2()

				for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {

					a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2])
					b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5])
					c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8])

					uvA.set(uvBuffer[j + 0], uvBuffer[j + 1])
					uvB.set(uvBuffer[j + 2], uvBuffer[j + 3])
					uvC.set(uvBuffer[j + 4], uvBuffer[j + 5])

					centroid.copy(a).add(b).add(c).divideScalar(3)

					const azi = azimuth(centroid)

					correctUV(uvA, j + 0, a, azi)
					correctUV(uvB, j + 2, b, azi)
					correctUV(uvC, j + 4, c, azi)

				}

			}

			function correctUV (uv, stride, vector, azimuth) {

				if ((azimuth < 0) && (uv.x === 1)) {

					uvBuffer[stride] = uv.x - 1

				}

				if ((vector.x === 0) && (vector.z === 0)) {

					uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5

				}

			}

			// Angle around the Y axis, counter-clockwise when looking from above.

			function azimuth (vector) {

				return Math.atan2(vector.z, - vector.x)

			}


			// Angle above the XZ plane.

			function inclination (vector) {

				return Math.atan2(- vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)))

			}

		}

		static fromJSON (data) {

			return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details)

		}

	}

	class DodecahedronGeometry extends PolyhedronGeometry {

		constructor(radius = 1, detail = 0) {

			const t = (1 + Math.sqrt(5)) / 2
			const r = 1 / t

			const vertices = [

				// (1, 1, 1)
				- 1, - 1, - 1, - 1, - 1, 1,
				- 1, 1, - 1, - 1, 1, 1,
				1, - 1, - 1, 1, - 1, 1,
				1, 1, - 1, 1, 1, 1,

				// (0, 1/, )
				0, - r, - t, 0, - r, t,
				0, r, - t, 0, r, t,

				// (1/, , 0)
				- r, - t, 0, - r, t, 0,
				r, - t, 0, r, t, 0,

				// (, 0, 1/)
				- t, 0, - r, t, 0, - r,
				- t, 0, r, t, 0, r
			]

			const indices = [
				3, 11, 7, 3, 7, 15, 3, 15, 13,
				7, 19, 17, 7, 17, 6, 7, 6, 15,
				17, 4, 8, 17, 8, 10, 17, 10, 6,
				8, 0, 16, 8, 16, 2, 8, 2, 10,
				0, 12, 1, 0, 1, 18, 0, 18, 16,
				6, 10, 2, 6, 2, 13, 6, 13, 15,
				2, 16, 18, 2, 18, 3, 2, 3, 13,
				18, 1, 9, 18, 9, 11, 18, 11, 3,
				4, 14, 12, 4, 12, 0, 4, 0, 8,
				11, 9, 5, 11, 5, 19, 11, 19, 7,
				19, 5, 14, 19, 14, 4, 19, 4, 17,
				1, 12, 14, 1, 14, 5, 1, 5, 9
			]

			super(vertices, indices, radius, detail)

			this.type = 'DodecahedronGeometry'

			this.parameters = {
				radius: radius,
				detail: detail
			}

		}

		static fromJSON (data) {

			return new DodecahedronGeometry(data.radius, data.detail)

		}

	}

	const _v0 = new Vector3()
	const _v1$1 = new Vector3()
	const _normal = new Vector3()
	const _triangle = new Triangle()

	class EdgesGeometry extends BufferGeometry {

		constructor(geometry, thresholdAngle) {

			super()

			this.type = 'EdgesGeometry'

			this.parameters = {
				thresholdAngle: thresholdAngle
			}

			thresholdAngle = (thresholdAngle !== undefined) ? thresholdAngle : 1

			if (geometry.isGeometry === true) {

				console.error('THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.')
				return

			}

			const thresholdDot = Math.cos(DEG2RAD * thresholdAngle)

			const indexAttr = geometry.getIndex()
			const positionAttr = geometry.getAttribute('position')
			const indexCount = indexAttr ? indexAttr.count : positionAttr.count

			const indexArr = [0, 0, 0]
			const vertKeys = ['a', 'b', 'c']
			const hashes = new Array(3)

			const edgeData = {}
			const vertices = []
			for (let i = 0; i < indexCount; i += 3) {

				if (indexAttr) {

					indexArr[0] = indexAttr.getX(i)
					indexArr[1] = indexAttr.getX(i + 1)
					indexArr[2] = indexAttr.getX(i + 2)

				} else {

					indexArr[0] = i
					indexArr[1] = i + 1
					indexArr[2] = i + 2

				}

				const { a, b, c } = _triangle
				a.fromBufferAttribute(positionAttr, indexArr[0])
				b.fromBufferAttribute(positionAttr, indexArr[1])
				c.fromBufferAttribute(positionAttr, indexArr[2])
				_triangle.getNormal(_normal)

				// create hashes for the edge from the vertices
				hashes[0] = `${a.x},${a.y},${a.z}`
				hashes[1] = `${b.x},${b.y},${b.z}`
				hashes[2] = `${c.x},${c.y},${c.z}`

				// skip degenerate triangles
				if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {

					continue

				}

				// iterate over every edge
				for (let j = 0; j < 3; j++) {

					// get the first and next vertex making up the edge
					const jNext = (j + 1) % 3
					const vecHash0 = hashes[j]
					const vecHash1 = hashes[jNext]
					const v0 = _triangle[vertKeys[j]]
					const v1 = _triangle[vertKeys[jNext]]

					const hash = `${vecHash0}_${vecHash1}`
					const reverseHash = `${vecHash1}_${vecHash0}`

					if (reverseHash in edgeData && edgeData[reverseHash]) {

						// if we found a sibling edge add it into the vertex array if
						// it meets the angle threshold and delete the edge from the map.
						if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {

							vertices.push(v0.x, v0.y, v0.z)
							vertices.push(v1.x, v1.y, v1.z)

						}

						edgeData[reverseHash] = null

					} else if (!(hash in edgeData)) {

						// if we've already got an edge here then skip adding a new one
						edgeData[hash] = {

							index0: indexArr[j],
							index1: indexArr[jNext],
							normal: _normal.clone(),

						}

					}

				}

			}

			// iterate over all remaining, unmatched edges and add them to the vertex array
			for (const key in edgeData) {

				if (edgeData[key]) {

					const { index0, index1 } = edgeData[key]
					_v0.fromBufferAttribute(positionAttr, index0)
					_v1$1.fromBufferAttribute(positionAttr, index1)

					vertices.push(_v0.x, _v0.y, _v0.z)
					vertices.push(_v1$1.x, _v1$1.y, _v1$1.z)

				}

			}

			this.setAttribute('position', new Float32BufferAttribute(vertices, 3))

		}

	}

	/**
	 * Extensible curve object.
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **/

	class Curve {

		constructor() {

			this.type = 'Curve'

			this.arcLengthDivisions = 200

		}

		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]

		getPoint ( /* t, optionalTarget */) {

			console.warn('THREE.Curve: .getPoint() not implemented.')
			return null

		}

		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]

		getPointAt (u, optionalTarget) {

			const t = this.getUtoTmapping(u)
			return this.getPoint(t, optionalTarget)

		}

		// Get sequence of points using getPoint( t )

		getPoints (divisions = 5) {

			const points = []

			for (let d = 0; d <= divisions; d++) {

				points.push(this.getPoint(d / divisions))

			}

			return points

		}

		// Get sequence of points using getPointAt( u )

		getSpacedPoints (divisions = 5) {

			const points = []

			for (let d = 0; d <= divisions; d++) {

				points.push(this.getPointAt(d / divisions))

			}

			return points

		}

		// Get total curve arc length

		getLength () {

			const lengths = this.getLengths()
			return lengths[lengths.length - 1]

		}

		// Get list of cumulative segment lengths

		getLengths (divisions = this.arcLengthDivisions) {

			if (this.cacheArcLengths &&
				(this.cacheArcLengths.length === divisions + 1) &&
				!this.needsUpdate) {

				return this.cacheArcLengths

			}

			this.needsUpdate = false

			const cache = []
			let current, last = this.getPoint(0)
			let sum = 0

			cache.push(0)

			for (let p = 1; p <= divisions; p++) {

				current = this.getPoint(p / divisions)
				sum += current.distanceTo(last)
				cache.push(sum)
				last = current

			}

			this.cacheArcLengths = cache

			return cache // { sums: cache, sum: sum }; Sum is in the last element.

		}

		updateArcLengths () {

			this.needsUpdate = true
			this.getLengths()

		}

		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

		getUtoTmapping (u, distance) {

			const arcLengths = this.getLengths()

			let i = 0
			const il = arcLengths.length

			let targetArcLength // The targeted u distance value to get

			if (distance) {

				targetArcLength = distance

			} else {

				targetArcLength = u * arcLengths[il - 1]

			}

			// binary search for the index with largest value smaller than target u distance

			let low = 0, high = il - 1, comparison

			while (low <= high) {

				i = Math.floor(low + (high - low) / 2) // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

				comparison = arcLengths[i] - targetArcLength

				if (comparison < 0) {

					low = i + 1

				} else if (comparison > 0) {

					high = i - 1

				} else {

					high = i
					break

					// DONE

				}

			}

			i = high

			if (arcLengths[i] === targetArcLength) {

				return i / (il - 1)

			}

			// we could get finer grain at lengths, or use simple interpolation between two points

			const lengthBefore = arcLengths[i]
			const lengthAfter = arcLengths[i + 1]

			const segmentLength = lengthAfter - lengthBefore

			// determine where we are between the 'before' and 'after' points

			const segmentFraction = (targetArcLength - lengthBefore) / segmentLength

			// add that fractional amount to t

			const t = (i + segmentFraction) / (il - 1)

			return t

		}

		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation

		getTangent (t, optionalTarget) {

			const delta = 0.0001
			let t1 = t - delta
			let t2 = t + delta

			// Capping in case of danger

			if (t1 < 0) t1 = 0
			if (t2 > 1) t2 = 1

			const pt1 = this.getPoint(t1)
			const pt2 = this.getPoint(t2)

			const tangent = optionalTarget || ((pt1.isVector2) ? new Vector2() : new Vector3())

			tangent.copy(pt2).sub(pt1).normalize()

			return tangent

		}

		getTangentAt (u, optionalTarget) {

			const t = this.getUtoTmapping(u)
			return this.getTangent(t, optionalTarget)

		}

		computeFrenetFrames (segments, closed) {

			// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

			const normal = new Vector3()

			const tangents = []
			const normals = []
			const binormals = []

			const vec = new Vector3()
			const mat = new Matrix4()

			// compute the tangent vectors for each segment on the curve

			for (let i = 0; i <= segments; i++) {

				const u = i / segments

				tangents[i] = this.getTangentAt(u, new Vector3())
				tangents[i].normalize()

			}

			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the minimum tangent xyz component

			normals[0] = new Vector3()
			binormals[0] = new Vector3()
			let min = Number.MAX_VALUE
			const tx = Math.abs(tangents[0].x)
			const ty = Math.abs(tangents[0].y)
			const tz = Math.abs(tangents[0].z)

			if (tx <= min) {

				min = tx
				normal.set(1, 0, 0)

			}

			if (ty <= min) {

				min = ty
				normal.set(0, 1, 0)

			}

			if (tz <= min) {

				normal.set(0, 0, 1)

			}

			vec.crossVectors(tangents[0], normal).normalize()

			normals[0].crossVectors(tangents[0], vec)
			binormals[0].crossVectors(tangents[0], normals[0])


			// compute the slowly-varying normal and binormal vectors for each segment on the curve

			for (let i = 1; i <= segments; i++) {

				normals[i] = normals[i - 1].clone()

				binormals[i] = binormals[i - 1].clone()

				vec.crossVectors(tangents[i - 1], tangents[i])

				if (vec.length() > Number.EPSILON) {

					vec.normalize()

					const theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), - 1, 1)) // clamp for floating pt errors

					normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta))

				}

				binormals[i].crossVectors(tangents[i], normals[i])

			}

			// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

			if (closed === true) {

				let theta = Math.acos(clamp(normals[0].dot(normals[segments]), - 1, 1))
				theta /= segments

				if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {

					theta = - theta

				}

				for (let i = 1; i <= segments; i++) {

					// twist a little...
					normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i))
					binormals[i].crossVectors(tangents[i], normals[i])

				}

			}

			return {
				tangents: tangents,
				normals: normals,
				binormals: binormals
			}

		}

		clone () {

			return new this.constructor().copy(this)

		}

		copy (source) {

			this.arcLengthDivisions = source.arcLengthDivisions

			return this

		}

		toJSON () {

			const data = {
				metadata: {
					version: 4.5,
					type: 'Curve',
					generator: 'Curve.toJSON'
				}
			}

			data.arcLengthDivisions = this.arcLengthDivisions
			data.type = this.type

			return data

		}

		fromJSON (json) {

			this.arcLengthDivisions = json.arcLengthDivisions

			return this

		}

	}

	class EllipseCurve extends Curve {

		constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {

			super()

			this.type = 'EllipseCurve'

			this.aX = aX
			this.aY = aY

			this.xRadius = xRadius
			this.yRadius = yRadius

			this.aStartAngle = aStartAngle
			this.aEndAngle = aEndAngle

			this.aClockwise = aClockwise

			this.aRotation = aRotation

		}

		getPoint (t, optionalTarget) {

			const point = optionalTarget || new Vector2()

			const twoPi = Math.PI * 2
			let deltaAngle = this.aEndAngle - this.aStartAngle
			const samePoints = Math.abs(deltaAngle) < Number.EPSILON

			// ensures that deltaAngle is 0 .. 2 PI
			while (deltaAngle < 0) deltaAngle += twoPi
			while (deltaAngle > twoPi) deltaAngle -= twoPi

			if (deltaAngle < Number.EPSILON) {

				if (samePoints) {

					deltaAngle = 0

				} else {

					deltaAngle = twoPi

				}

			}

			if (this.aClockwise === true && !samePoints) {

				if (deltaAngle === twoPi) {

					deltaAngle = - twoPi

				} else {

					deltaAngle = deltaAngle - twoPi

				}

			}

			const angle = this.aStartAngle + t * deltaAngle
			let x = this.aX + this.xRadius * Math.cos(angle)
			let y = this.aY + this.yRadius * Math.sin(angle)

			if (this.aRotation !== 0) {

				const cos = Math.cos(this.aRotation)
				const sin = Math.sin(this.aRotation)

				const tx = x - this.aX
				const ty = y - this.aY

				// Rotate the point about the center of the ellipse.
				x = tx * cos - ty * sin + this.aX
				y = tx * sin + ty * cos + this.aY

			}

			return point.set(x, y)

		}

		copy (source) {

			super.copy(source)

			this.aX = source.aX
			this.aY = source.aY

			this.xRadius = source.xRadius
			this.yRadius = source.yRadius

			this.aStartAngle = source.aStartAngle
			this.aEndAngle = source.aEndAngle

			this.aClockwise = source.aClockwise

			this.aRotation = source.aRotation

			return this

		}

		toJSON () {

			const data = super.toJSON()

			data.aX = this.aX
			data.aY = this.aY

			data.xRadius = this.xRadius
			data.yRadius = this.yRadius

			data.aStartAngle = this.aStartAngle
			data.aEndAngle = this.aEndAngle

			data.aClockwise = this.aClockwise

			data.aRotation = this.aRotation

			return data

		}

		fromJSON (json) {

			super.fromJSON(json)

			this.aX = json.aX
			this.aY = json.aY

			this.xRadius = json.xRadius
			this.yRadius = json.yRadius

			this.aStartAngle = json.aStartAngle
			this.aEndAngle = json.aEndAngle

			this.aClockwise = json.aClockwise

			this.aRotation = json.aRotation

			return this

		}

	}

	EllipseCurve.prototype.isEllipseCurve = true

	class ArcCurve extends EllipseCurve {

		constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {

			super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise)

			this.type = 'ArcCurve'

		}

	}

	ArcCurve.prototype.isArcCurve = true

	/**
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */


	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly () {

		let c0 = 0, c1 = 0, c2 = 0, c3 = 0

		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		function init (x0, x1, t0, t1) {

			c0 = x0
			c1 = t0
			c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1
			c3 = 2 * x0 - 2 * x1 + t0 + t1

		}

		return {

			initCatmullRom: function (x0, x1, x2, x3, tension) {

				init(x1, x2, tension * (x2 - x0), tension * (x3 - x1))

			},

			initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {

				// compute tangents when parameterized in [t1,t2]
				let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1
				let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2

				// rescale tangents for parametrization in [0,1]
				t1 *= dt1
				t2 *= dt1

				init(x1, x2, t1, t2)

			},

			calc: function (t) {

				const t2 = t * t
				const t3 = t2 * t
				return c0 + c1 * t + c2 * t2 + c3 * t3

			}

		}

	}

	//

	const tmp = new Vector3()
	const px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly()

	class CatmullRomCurve3 extends Curve {

		constructor(points = [], closed = false, curveType = 'centripetal', tension = 0.5) {

			super()

			this.type = 'CatmullRomCurve3'

			this.points = points
			this.closed = closed
			this.curveType = curveType
			this.tension = tension

		}

		getPoint (t, optionalTarget = new Vector3()) {

			const point = optionalTarget

			const points = this.points
			const l = points.length

			const p = (l - (this.closed ? 0 : 1)) * t
			let intPoint = Math.floor(p)
			let weight = p - intPoint

			if (this.closed) {

				intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l

			} else if (weight === 0 && intPoint === l - 1) {

				intPoint = l - 2
				weight = 1

			}

			let p0, p3 // 4 points (p1 & p2 defined below)

			if (this.closed || intPoint > 0) {

				p0 = points[(intPoint - 1) % l]

			} else {

				// extrapolate first point
				tmp.subVectors(points[0], points[1]).add(points[0])
				p0 = tmp

			}

			const p1 = points[intPoint % l]
			const p2 = points[(intPoint + 1) % l]

			if (this.closed || intPoint + 2 < l) {

				p3 = points[(intPoint + 2) % l]

			} else {

				// extrapolate last point
				tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1])
				p3 = tmp

			}

			if (this.curveType === 'centripetal' || this.curveType === 'chordal') {

				// init Centripetal / Chordal Catmull-Rom
				const pow = this.curveType === 'chordal' ? 0.5 : 0.25
				let dt0 = Math.pow(p0.distanceToSquared(p1), pow)
				let dt1 = Math.pow(p1.distanceToSquared(p2), pow)
				let dt2 = Math.pow(p2.distanceToSquared(p3), pow)

				// safety check for repeated points
				if (dt1 < 1e-4) dt1 = 1.0
				if (dt0 < 1e-4) dt0 = dt1
				if (dt2 < 1e-4) dt2 = dt1

				px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2)
				py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2)
				pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2)

			} else if (this.curveType === 'catmullrom') {

				px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension)
				py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension)
				pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension)

			}

			point.set(
				px.calc(weight),
				py.calc(weight),
				pz.calc(weight)
			)

			return point

		}

		copy (source) {

			super.copy(source)

			this.points = []

			for (let i = 0, l = source.points.length; i < l; i++) {

				const point = source.points[i]

				this.points.push(point.clone())

			}

			this.closed = source.closed
			this.curveType = source.curveType
			this.tension = source.tension

			return this

		}

		toJSON () {

			const data = super.toJSON()

			data.points = []

			for (let i = 0, l = this.points.length; i < l; i++) {

				const point = this.points[i]
				data.points.push(point.toArray())

			}

			data.closed = this.closed
			data.curveType = this.curveType
			data.tension = this.tension

			return data

		}

		fromJSON (json) {

			super.fromJSON(json)

			this.points = []

			for (let i = 0, l = json.points.length; i < l; i++) {

				const point = json.points[i]
				this.points.push(new Vector3().fromArray(point))

			}

			this.closed = json.closed
			this.curveType = json.curveType
			this.tension = json.tension

			return this

		}

	}

	CatmullRomCurve3.prototype.isCatmullRomCurve3 = true

	/**
	 * Bezier Curves formulas obtained from
	 * http://en.wikipedia.org/wiki/Bzier_curve
	 */

	function CatmullRom (t, p0, p1, p2, p3) {

		const v0 = (p2 - p0) * 0.5
		const v1 = (p3 - p1) * 0.5
		const t2 = t * t
		const t3 = t * t2
		return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (- 3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1

	}

	//

	function QuadraticBezierP0 (t, p) {

		const k = 1 - t
		return k * k * p

	}

	function QuadraticBezierP1 (t, p) {

		return 2 * (1 - t) * t * p

	}

	function QuadraticBezierP2 (t, p) {

		return t * t * p

	}

	function QuadraticBezier (t, p0, p1, p2) {

		return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) +
			QuadraticBezierP2(t, p2)

	}

	//

	function CubicBezierP0 (t, p) {

		const k = 1 - t
		return k * k * k * p

	}

	function CubicBezierP1 (t, p) {

		const k = 1 - t
		return 3 * k * k * t * p

	}

	function CubicBezierP2 (t, p) {

		return 3 * (1 - t) * t * t * p

	}

	function CubicBezierP3 (t, p) {

		return t * t * t * p

	}

	function CubicBezier (t, p0, p1, p2, p3) {

		return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) +
			CubicBezierP3(t, p3)

	}

	class CubicBezierCurve extends Curve {

		constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {

			super()

			this.type = 'CubicBezierCurve'

			this.v0 = v0
			this.v1 = v1
			this.v2 = v2
			this.v3 = v3

		}

		getPoint (t, optionalTarget = new Vector2()) {

			const point = optionalTarget

			const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3

			point.set(
				CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
				CubicBezier(t, v0.y, v1.y, v2.y, v3.y)
			)

			return point

		}

		copy (source) {

			super.copy(source)

			this.v0.copy(source.v0)
			this.v1.copy(source.v1)
			this.v2.copy(source.v2)
			this.v3.copy(source.v3)

			return this

		}

		toJSON () {

			const data = super.toJSON()

			data.v0 = this.v0.toArray()
			data.v1 = this.v1.toArray()
			data.v2 = this.v2.toArray()
			data.v3 = this.v3.toArray()

			return data

		}

		fromJSON (json) {

			super.fromJSON(json)

			this.v0.fromArray(json.v0)
			this.v1.fromArray(json.v1)
			this.v2.fromArray(json.v2)
			this.v3.fromArray(json.v3)

			return this

		}

	}

	CubicBezierCurve.prototype.isCubicBezierCurve = true

	class CubicBezierCurve3 extends Curve {

		constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {

			super()

			this.type = 'CubicBezierCurve3'

			this.v0 = v0
			this.v1 = v1
			this.v2 = v2
			this.v3 = v3

		}

		getPoint (t, optionalTarget = new Vector3()) {

			const point = optionalTarget

			const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3

			point.set(
				CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
				CubicBezier(t, v0.y, v1.y, v2.y, v3.y),
				CubicBezier(t, v0.z, v1.z, v2.z, v3.z)
			)

			return point

		}

		copy (source) {

			super.copy(source)

			this.v0.copy(source.v0)
			this.v1.copy(source.v1)
			this.v2.copy(source.v2)
			this.v3.copy(source.v3)

			return this

		}

		toJSON () {

			const data = super.toJSON()

			data.v0 = this.v0.toArray()
			data.v1 = this.v1.toArray()
			data.v2 = this.v2.toArray()
			data.v3 = this.v3.toArray()

			return data

		}

		fromJSON (json) {

			super.fromJSON(json)

			this.v0.fromArray(json.v0)
			this.v1.fromArray(json.v1)
			this.v2.fromArray(json.v2)
			this.v3.fromArray(json.v3)

			return this

		}

	}

	CubicBezierCurve3.prototype.isCubicBezierCurve3 = true

	class LineCurve extends Curve {

		constructor(v1 = new Vector2(), v2 = new Vector2()) {

			super()

			this.type = 'LineCurve'

			this.v1 = v1
			this.v2 = v2

		}

		getPoint (t, optionalTarget = new Vector2()) {

			const point = optionalTarget

			if (t === 1) {

				point.copy(this.v2)

			} else {

				point.copy(this.v2).sub(this.v1)
				point.multiplyScalar(t).add(this.v1)

			}

			return point

		}

		// Line curve is linear, so we can overwrite default getPointAt
		getPointAt (u, optionalTarget) {

			return this.getPoint(u, optionalTarget)

		}

		getTangent (t, optionalTarget) {

			const tangent = optionalTarget || new Vector2()

			tangent.copy(this.v2).sub(this.v1).normalize()

			return tangent

		}

		copy (source) {

			super.copy(source)

			this.v1.copy(source.v1)
			this.v2.copy(source.v2)

			return this

		}

		toJSON () {

			const data = super.toJSON()

			data.v1 = this.v1.toArray()
			data.v2 = this.v2.toArray()

			return data

		}

		fromJSON (json) {

			super.fromJSON(json)

			this.v1.fromArray(json.v1)
			this.v2.fromArray(json.v2)

			return this

		}

	}

	LineCurve.prototype.isLineCurve = true

	class LineCurve3 extends Curve {

		constructor(v1 = new Vector3(), v2 = new Vector3()) {

			super()

			this.type = 'LineCurve3'
			this.isLineCurve3 = true

			this.v1 = v1
			this.v2 = v2

		}
		getPoint (t, optionalTarget = new Vector3()) {

			const point = optionalTarget

			if (t === 1) {

				point.copy(this.v2)

			} else {

				point.copy(this.v2).sub(this.v1)
				point.multiplyScalar(t).add(this.v1)

			}

			return point

		}
		// Line curve is linear, so we can overwrite default getPointAt
		getPointAt (u, optionalTarget) {

			return this.getPoint(u, optionalTarget)

		}
		copy (source) {

			super.copy(source)

			this.v1.copy(source.v1)
			this.v2.copy(source.v2)

			return this

		}
		toJSON () {

			const data = super.toJSON()

			data.v1 = this.v1.toArray()
			data.v2 = this.v2.toArray()

			return data

		}
		fromJSON (json) {

			super.fromJSON(json)

			this.v1.fromArray(json.v1)
			this.v2.fromArray(json.v2)

			return this

		}

	}

	class QuadraticBezierCurve extends Curve {

		constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {

			super()

			this.type = 'QuadraticBezierCurve'

			this.v0 = v0
			this.v1 = v1
			this.v2 = v2

		}

		getPoint (t, optionalTarget = new Vector2()) {

			const point = optionalTarget

			const v0 = this.v0, v1 = this.v1, v2 = this.v2

			point.set(
				QuadraticBezier(t, v0.x, v1.x, v2.x),
				QuadraticBezier(t, v0.y, v1.y, v2.y)
			)

			return point

		}

		copy (source) {

			super.copy(source)

			this.v0.copy(source.v0)
			this.v1.copy(source.v1)
			this.v2.copy(source.v2)

			return this

		}

		toJSON () {

			const data = super.toJSON()

			data.v0 = this.v0.toArray()
			data.v1 = this.v1.toArray()
			data.v2 = this.v2.toArray()

			return data

		}

		fromJSON (json) {

			super.fromJSON(json)

			this.v0.fromArray(json.v0)
			this.v1.fromArray(json.v1)
			this.v2.fromArray(json.v2)

			return this

		}

	}

	QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true

	class QuadraticBezierCurve3 extends Curve {

		constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {

			super()

			this.type = 'QuadraticBezierCurve3'

			this.v0 = v0
			this.v1 = v1
			this.v2 = v2

		}

		getPoint (t, optionalTarget = new Vector3()) {

			const point = optionalTarget

			const v0 = this.v0, v1 = this.v1, v2 = this.v2

			point.set(
				QuadraticBezier(t, v0.x, v1.x, v2.x),
				QuadraticBezier(t, v0.y, v1.y, v2.y),
				QuadraticBezier(t, v0.z, v1.z, v2.z)
			)

			return point

		}

		copy (source) {

			super.copy(source)

			this.v0.copy(source.v0)
			this.v1.copy(source.v1)
			this.v2.copy(source.v2)

			return this

		}

		toJSON () {

			const data = super.toJSON()

			data.v0 = this.v0.toArray()
			data.v1 = this.v1.toArray()
			data.v2 = this.v2.toArray()

			return data

		}

		fromJSON (json) {

			super.fromJSON(json)

			this.v0.fromArray(json.v0)
			this.v1.fromArray(json.v1)
			this.v2.fromArray(json.v2)

			return this

		}

	}

	QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true

	class SplineCurve extends Curve {

		constructor(points = []) {

			super()

			this.type = 'SplineCurve'

			this.points = points

		}

		getPoint (t, optionalTarget = new Vector2()) {

			const point = optionalTarget

			const points = this.points
			const p = (points.length - 1) * t

			const intPoint = Math.floor(p)
			const weight = p - intPoint

			const p0 = points[intPoint === 0 ? intPoint : intPoint - 1]
			const p1 = points[intPoint]
			const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1]
			const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2]

			point.set(
				CatmullRom(weight, p0.x, p1.x, p2.x, p3.x),
				CatmullRom(weight, p0.y, p1.y, p2.y, p3.y)
			)

			return point

		}

		copy (source) {

			super.copy(source)

			this.points = []

			for (let i = 0, l = source.points.length; i < l; i++) {

				const point = source.points[i]

				this.points.push(point.clone())

			}

			return this

		}

		toJSON () {

			const data = super.toJSON()

			data.points = []

			for (let i = 0, l = this.points.length; i < l; i++) {

				const point = this.points[i]
				data.points.push(point.toArray())

			}

			return data

		}

		fromJSON (json) {

			super.fromJSON(json)

			this.points = []

			for (let i = 0, l = json.points.length; i < l; i++) {

				const point = json.points[i]
				this.points.push(new Vector2().fromArray(point))

			}

			return this

		}

	}

	SplineCurve.prototype.isSplineCurve = true

	var Curves = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ArcCurve: ArcCurve,
		CatmullRomCurve3: CatmullRomCurve3,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		EllipseCurve: EllipseCurve,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		SplineCurve: SplineCurve
	})

	/**
	 * Port from https://github.com/mapbox/earcut (v2.2.2)
	 */

	const Earcut = {

		triangulate: function (data, holeIndices, dim = 2) {

			const hasHoles = holeIndices && holeIndices.length
			const outerLen = hasHoles ? holeIndices[0] * dim : data.length
			let outerNode = linkedList$1(data, 0, outerLen, dim, true)
			const triangles = []

			if (!outerNode || outerNode.next === outerNode.prev) return triangles

			let minX, minY, maxX, maxY, x, y, invSize

			if (hasHoles) outerNode = eliminateHoles$1(data, holeIndices, outerNode, dim)

			// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
			if (data.length > 80 * dim) {

				minX = maxX = data[0]
				minY = maxY = data[1]

				for (let i = dim; i < outerLen; i += dim) {

					x = data[i]
					y = data[i + 1]
					if (x < minX) minX = x
					if (y < minY) minY = y
					if (x > maxX) maxX = x
					if (y > maxY) maxY = y

				}

				// minX, minY and invSize are later used to transform coords into integers for z-order calculation
				invSize = Math.max(maxX - minX, maxY - minY)
				invSize = invSize !== 0 ? 1 / invSize : 0

			}

			earcutLinked$1(outerNode, triangles, dim, minX, minY, invSize)

			return triangles

		}

	}

	// create a circular doubly linked list from polygon points in the specified winding order
	function linkedList$1 (data, start, end, dim, clockwise) {

		let i, last

		if (clockwise === (signedArea$1(data, start, end, dim) > 0)) {

			for (i = start; i < end; i += dim) last = insertNode$1(i, data[i], data[i + 1], last)

		} else {

			for (i = end - dim; i >= start; i -= dim) last = insertNode$1(i, data[i], data[i + 1], last)

		}

		if (last && equals$1(last, last.next)) {

			removeNode$1(last)
			last = last.next

		}

		return last

	}

	// eliminate colinear or duplicate points
	function filterPoints$1 (start, end) {

		if (!start) return start
		if (!end) end = start

		let p = start,
			again
		do {

			again = false

			if (!p.steiner && (equals$1(p, p.next) || area$1(p.prev, p, p.next) === 0)) {

				removeNode$1(p)
				p = end = p.prev
				if (p === p.next) break
				again = true

			} else {

				p = p.next

			}

		} while (again || p !== end)

		return end

	}

	// main ear slicing loop which triangulates a polygon (given as a linked list)
	function earcutLinked$1 (ear, triangles, dim, minX, minY, invSize, pass) {

		if (!ear) return

		// interlink polygon nodes in z-order
		if (!pass && invSize) indexCurve$1(ear, minX, minY, invSize)

		let stop = ear,
			prev, next

		// iterate through ears, slicing them one by one
		while (ear.prev !== ear.next) {

			prev = ear.prev
			next = ear.next

			if (invSize ? isEarHashed$1(ear, minX, minY, invSize) : isEar$1(ear)) {

				// cut off the triangle
				triangles.push(prev.i / dim)
				triangles.push(ear.i / dim)
				triangles.push(next.i / dim)

				removeNode$1(ear)

				// skipping the next vertex leads to less sliver triangles
				ear = next.next
				stop = next.next

				continue

			}

			ear = next

			// if we looped through the whole remaining polygon and can't find any more ears
			if (ear === stop) {

				// try filtering points and slicing again
				if (!pass) {

					earcutLinked$1(filterPoints$1(ear), triangles, dim, minX, minY, invSize, 1)

					// if this didn't work, try curing all small self-intersections locally

				} else if (pass === 1) {

					ear = cureLocalIntersections$1(filterPoints$1(ear), triangles, dim)
					earcutLinked$1(ear, triangles, dim, minX, minY, invSize, 2)

					// as a last resort, try splitting the remaining polygon into two

				} else if (pass === 2) {

					splitEarcut$1(ear, triangles, dim, minX, minY, invSize)

				}

				break

			}

		}

	}

	// check whether a polygon node forms a valid ear with adjacent nodes
	function isEar$1 (ear) {

		const a = ear.prev,
			b = ear,
			c = ear.next

		if (area$1(a, b, c) >= 0) return false // reflex, can't be an ear

		// now make sure we don't have other points inside the potential ear
		let p = ear.next.next

		while (p !== ear.prev) {

			if (pointInTriangle$1(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
				area$1(p.prev, p, p.next) >= 0) return false
			p = p.next

		}

		return true

	}

	function isEarHashed$1 (ear, minX, minY, invSize) {

		const a = ear.prev,
			b = ear,
			c = ear.next

		if (area$1(a, b, c) >= 0) return false // reflex, can't be an ear

		// triangle bbox; min & max are calculated like this for speed
		const minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
			minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
			maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
			maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y)

		// z-order range for the current triangle bbox;
		const minZ = zOrder$1(minTX, minTY, minX, minY, invSize),
			maxZ = zOrder$1(maxTX, maxTY, minX, minY, invSize)

		let p = ear.prevZ,
			n = ear.nextZ

		// look for points inside the triangle in both directions
		while (p && p.z >= minZ && n && n.z <= maxZ) {

			if (p !== ear.prev && p !== ear.next &&
				pointInTriangle$1(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
				area$1(p.prev, p, p.next) >= 0) return false
			p = p.prevZ

			if (n !== ear.prev && n !== ear.next &&
				pointInTriangle$1(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
				area$1(n.prev, n, n.next) >= 0) return false
			n = n.nextZ

		}

		// look for remaining points in decreasing z-order
		while (p && p.z >= minZ) {

			if (p !== ear.prev && p !== ear.next &&
				pointInTriangle$1(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
				area$1(p.prev, p, p.next) >= 0) return false
			p = p.prevZ

		}

		// look for remaining points in increasing z-order
		while (n && n.z <= maxZ) {

			if (n !== ear.prev && n !== ear.next &&
				pointInTriangle$1(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
				area$1(n.prev, n, n.next) >= 0) return false
			n = n.nextZ

		}

		return true

	}

	// go through all polygon nodes and cure small local self-intersections
	function cureLocalIntersections$1 (start, triangles, dim) {

		let p = start
		do {

			const a = p.prev,
				b = p.next.next

			if (!equals$1(a, b) && intersects$1(a, p, p.next, b) && locallyInside$1(a, b) && locallyInside$1(b, a)) {

				triangles.push(a.i / dim)
				triangles.push(p.i / dim)
				triangles.push(b.i / dim)

				// remove two nodes involved
				removeNode$1(p)
				removeNode$1(p.next)

				p = start = b

			}

			p = p.next

		} while (p !== start)

		return filterPoints$1(p)

	}

	// try splitting polygon into two and triangulate them independently
	function splitEarcut$1 (start, triangles, dim, minX, minY, invSize) {

		// look for a valid diagonal that divides the polygon into two
		let a = start
		do {

			let b = a.next.next
			while (b !== a.prev) {

				if (a.i !== b.i && isValidDiagonal$1(a, b)) {

					// split the polygon in two by the diagonal
					let c = splitPolygon$1(a, b)

					// filter colinear points around the cuts
					a = filterPoints$1(a, a.next)
					c = filterPoints$1(c, c.next)

					// run earcut on each half
					earcutLinked$1(a, triangles, dim, minX, minY, invSize)
					earcutLinked$1(c, triangles, dim, minX, minY, invSize)
					return

				}

				b = b.next

			}

			a = a.next

		} while (a !== start)

	}

	// link every hole into the outer loop, producing a single-ring polygon without holes
	function eliminateHoles$1 (data, holeIndices, outerNode, dim) {

		const queue = []
		let i, len, start, end, list

		for (i = 0, len = holeIndices.length; i < len; i++) {

			start = holeIndices[i] * dim
			end = i < len - 1 ? holeIndices[i + 1] * dim : data.length
			list = linkedList$1(data, start, end, dim, false)
			if (list === list.next) list.steiner = true
			queue.push(getLeftmost$1(list))

		}

		queue.sort(compareX$1)

		// process holes from left to right
		for (i = 0; i < queue.length; i++) {

			eliminateHole$1(queue[i], outerNode)
			outerNode = filterPoints$1(outerNode, outerNode.next)

		}

		return outerNode

	}

	function compareX$1 (a, b) {

		return a.x - b.x

	}

	// find a bridge between vertices that connects hole with an outer ring and and link it
	function eliminateHole$1 (hole, outerNode) {

		outerNode = findHoleBridge$1(hole, outerNode)
		if (outerNode) {

			const b = splitPolygon$1(outerNode, hole)

			// filter collinear points around the cuts
			filterPoints$1(outerNode, outerNode.next)
			filterPoints$1(b, b.next)

		}

	}

	// David Eberly's algorithm for finding a bridge between hole and outer polygon
	function findHoleBridge$1 (hole, outerNode) {

		let p = outerNode
		const hx = hole.x
		const hy = hole.y
		let qx = - Infinity, m

		// find a segment intersected by a ray from the hole's leftmost point to the left;
		// segment's endpoint with lesser x will be potential connection point
		do {

			if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {

				const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y)
				if (x <= hx && x > qx) {

					qx = x
					if (x === hx) {

						if (hy === p.y) return p
						if (hy === p.next.y) return p.next

					}

					m = p.x < p.next.x ? p : p.next

				}

			}

			p = p.next

		} while (p !== outerNode)

		if (!m) return null

		if (hx === qx) return m // hole touches outer segment; pick leftmost endpoint

		// look for points inside the triangle of hole point, segment intersection and endpoint;
		// if there are no points found, we have a valid connection;
		// otherwise choose the point of the minimum angle with the ray as connection point

		const stop = m,
			mx = m.x,
			my = m.y
		let tanMin = Infinity, tan

		p = m

		do {

			if (hx >= p.x && p.x >= mx && hx !== p.x &&
				pointInTriangle$1(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

				tan = Math.abs(hy - p.y) / (hx - p.x) // tangential

				if (locallyInside$1(p, hole) && (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector$1(m, p)))))) {

					m = p
					tanMin = tan

				}

			}

			p = p.next

		} while (p !== stop)

		return m

	}

	// whether sector in vertex m contains sector in vertex p in the same coordinates
	function sectorContainsSector$1 (m, p) {

		return area$1(m.prev, m, p.prev) < 0 && area$1(p.next, m, m.next) < 0

	}

	// interlink polygon nodes in z-order
	function indexCurve$1 (start, minX, minY, invSize) {

		let p = start
		do {

			if (p.z === null) p.z = zOrder$1(p.x, p.y, minX, minY, invSize)
			p.prevZ = p.prev
			p.nextZ = p.next
			p = p.next

		} while (p !== start)

		p.prevZ.nextZ = null
		p.prevZ = null

		sortLinked$1(p)

	}

	// Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
	function sortLinked$1 (list) {

		let i, p, q, e, tail, numMerges, pSize, qSize,
			inSize = 1

		do {

			p = list
			list = null
			tail = null
			numMerges = 0

			while (p) {

				numMerges++
				q = p
				pSize = 0
				for (i = 0; i < inSize; i++) {

					pSize++
					q = q.nextZ
					if (!q) break

				}

				qSize = inSize

				while (pSize > 0 || (qSize > 0 && q)) {

					if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {

						e = p
						p = p.nextZ
						pSize--

					} else {

						e = q
						q = q.nextZ
						qSize--

					}

					if (tail) tail.nextZ = e
					else list = e

					e.prevZ = tail
					tail = e

				}

				p = q

			}

			tail.nextZ = null
			inSize *= 2

		} while (numMerges > 1)

		return list

	}

	// z-order of a point given coords and inverse of the longer side of data bbox
	function zOrder$1 (x, y, minX, minY, invSize) {

		// coords are transformed into non-negative 15-bit integer range
		x = 32767 * (x - minX) * invSize
		y = 32767 * (y - minY) * invSize

		x = (x | (x << 8)) & 0x00FF00FF
		x = (x | (x << 4)) & 0x0F0F0F0F
		x = (x | (x << 2)) & 0x33333333
		x = (x | (x << 1)) & 0x55555555

		y = (y | (y << 8)) & 0x00FF00FF
		y = (y | (y << 4)) & 0x0F0F0F0F
		y = (y | (y << 2)) & 0x33333333
		y = (y | (y << 1)) & 0x55555555

		return x | (y << 1)

	}

	// find the leftmost node of a polygon ring
	function getLeftmost$1 (start) {

		let p = start,
			leftmost = start
		do {

			if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p
			p = p.next

		} while (p !== start)

		return leftmost

	}

	// check if a point lies within a convex triangle
	function pointInTriangle$1 (ax, ay, bx, by, cx, cy, px, py) {

		return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
			(ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
			(bx - px) * (cy - py) - (cx - px) * (by - py) >= 0

	}

	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
	function isValidDiagonal$1 (a, b) {

		return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon$1(a, b) && // dones't intersect other edges
			(locallyInside$1(a, b) && locallyInside$1(b, a) && middleInside$1(a, b) && // locally visible
				(area$1(a.prev, a, b.prev) || area$1(a, b.prev, b)) || // does not create opposite-facing sectors
				equals$1(a, b) && area$1(a.prev, a, a.next) > 0 && area$1(b.prev, b, b.next) > 0) // special zero-length case

	}

	// signed area of a triangle
	function area$1 (p, q, r) {

		return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)

	}

	// check if two points are equal
	function equals$1 (p1, p2) {

		return p1.x === p2.x && p1.y === p2.y

	}

	// check if two segments intersect
	function intersects$1 (p1, q1, p2, q2) {

		const o1 = sign$1(area$1(p1, q1, p2))
		const o2 = sign$1(area$1(p1, q1, q2))
		const o3 = sign$1(area$1(p2, q2, p1))
		const o4 = sign$1(area$1(p2, q2, q1))

		if (o1 !== o2 && o3 !== o4) return true // general case

		if (o1 === 0 && onSegment$1(p1, p2, q1)) return true // p1, q1 and p2 are collinear and p2 lies on p1q1
		if (o2 === 0 && onSegment$1(p1, q2, q1)) return true // p1, q1 and q2 are collinear and q2 lies on p1q1
		if (o3 === 0 && onSegment$1(p2, p1, q2)) return true // p2, q2 and p1 are collinear and p1 lies on p2q2
		if (o4 === 0 && onSegment$1(p2, q1, q2)) return true // p2, q2 and q1 are collinear and q1 lies on p2q2

		return false

	}

	// for collinear points p, q, r, check if point q lies on segment pr
	function onSegment$1 (p, q, r) {

		return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y)

	}

	function sign$1 (num) {

		return num > 0 ? 1 : num < 0 ? - 1 : 0

	}

	// check if a polygon diagonal intersects any polygon segments
	function intersectsPolygon$1 (a, b) {

		let p = a
		do {

			if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
				intersects$1(p, p.next, a, b)) return true
			p = p.next

		} while (p !== a)

		return false

	}

	// check if a polygon diagonal is locally inside the polygon
	function locallyInside$1 (a, b) {

		return area$1(a.prev, a, a.next) < 0 ?
			area$1(a, b, a.next) >= 0 && area$1(a, a.prev, b) >= 0 :
			area$1(a, b, a.prev) < 0 || area$1(a, a.next, b) < 0

	}

	// check if the middle point of a polygon diagonal is inside the polygon
	function middleInside$1 (a, b) {

		let p = a,
			inside = false
		const px = (a.x + b.x) / 2,
			py = (a.y + b.y) / 2
		do {

			if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
				(px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
				inside = !inside
			p = p.next

		} while (p !== a)

		return inside

	}

	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring
	function splitPolygon$1 (a, b) {

		const a2 = new Node$1(a.i, a.x, a.y),
			b2 = new Node$1(b.i, b.x, b.y),
			an = a.next,
			bp = b.prev

		a.next = b
		b.prev = a

		a2.next = an
		an.prev = a2

		b2.next = a2
		a2.prev = b2

		bp.next = b2
		b2.prev = bp

		return b2

	}

	// create a node and optionally link it with previous one (in a circular doubly linked list)
	function insertNode$1 (i, x, y, last) {

		const p = new Node$1(i, x, y)

		if (!last) {

			p.prev = p
			p.next = p

		} else {

			p.next = last.next
			p.prev = last
			last.next.prev = p
			last.next = p

		}

		return p

	}

	function removeNode$1 (p) {

		p.next.prev = p.prev
		p.prev.next = p.next

		if (p.prevZ) p.prevZ.nextZ = p.nextZ
		if (p.nextZ) p.nextZ.prevZ = p.prevZ

	}

	function Node$1 (i, x, y) {

		// vertex index in coordinates array
		this.i = i

		// vertex coordinates
		this.x = x
		this.y = y

		// previous and next vertex nodes in a polygon ring
		this.prev = null
		this.next = null

		// z-order curve value
		this.z = null

		// previous and next nodes in z-order
		this.prevZ = null
		this.nextZ = null

		// indicates whether this is a steiner point
		this.steiner = false

	}

	function signedArea$1 (data, start, end, dim) {

		let sum = 0
		for (let i = start, j = end - dim; i < end; i += dim) {

			sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1])
			j = i

		}

		return sum

	}

	class ShapeUtils {

		// calculate area of the contour polygon

		static area (contour) {

			const n = contour.length
			let a = 0.0

			for (let p = n - 1, q = 0; q < n; p = q++) {

				a += contour[p].x * contour[q].y - contour[q].x * contour[p].y

			}

			return a * 0.5

		}

		static isClockWise (pts) {

			return ShapeUtils.area(pts) < 0

		}

		static triangulateShape (contour, holes) {

			const vertices = [] // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
			const holeIndices = [] // array of hole indices
			const faces = [] // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

			removeDupEndPts(contour)
			addContour(vertices, contour)

			//

			let holeIndex = contour.length

			holes.forEach(removeDupEndPts)

			for (let i = 0; i < holes.length; i++) {

				holeIndices.push(holeIndex)
				holeIndex += holes[i].length
				addContour(vertices, holes[i])

			}

			//

			const triangles = Earcut.triangulate(vertices, holeIndices)

			//

			for (let i = 0; i < triangles.length; i += 3) {

				faces.push(triangles.slice(i, i + 3))

			}

			return faces

		}

	}

	function removeDupEndPts (points) {

		const l = points.length

		if (l > 2 && points[l - 1].equals(points[0])) {

			points.pop()

		}

	}

	function addContour (vertices, contour) {

		for (let i = 0; i < contour.length; i++) {

			vertices.push(contour[i].x)
			vertices.push(contour[i].y)

		}

	}

	/**
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  depth: <float>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
	 *  bevelOffset: <float>, // how far from shape outline does bevel start
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.Curve> // curve to extrude shape along
	 *
	 *  UVGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 */

	class ExtrudeGeometry extends BufferGeometry {

		constructor(shapes, options) {

			super()

			this.type = 'ExtrudeGeometry'

			this.parameters = {
				shapes: shapes,
				options: options
			}

			shapes = Array.isArray(shapes) ? shapes : [shapes]

			const scope = this

			const verticesArray = []
			const uvArray = []

			for (let i = 0, l = shapes.length; i < l; i++) {

				const shape = shapes[i]
				addShape(shape)

			}

			// build geometry

			this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3))
			this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2))

			this.computeVertexNormals()

			// functions

			function addShape (shape) {

				const placeholder = []

				// options

				const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12
				const steps = options.steps !== undefined ? options.steps : 1
				let depth = options.depth !== undefined ? options.depth : 100

				let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true
				let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6
				let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2
				let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0
				let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3

				const extrudePath = options.extrudePath

				const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator

				// deprecated options

				if (options.amount !== undefined) {

					console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.')
					depth = options.amount

				}

				//

				let extrudePts, extrudeByPath = false
				let splineTube, binormal, normal, position2

				if (extrudePath) {

					extrudePts = extrudePath.getSpacedPoints(steps)

					extrudeByPath = true
					bevelEnabled = false // bevels not supported for path extrusion

					// SETUP TNB variables

					// TODO1 - have a .isClosed in spline?

					splineTube = extrudePath.computeFrenetFrames(steps, false)

					// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

					binormal = new Vector3()
					normal = new Vector3()
					position2 = new Vector3()

				}

				// Safeguards if bevels are not enabled

				if (!bevelEnabled) {

					bevelSegments = 0
					bevelThickness = 0
					bevelSize = 0
					bevelOffset = 0

				}

				// Variables initialization

				const shapePoints = shape.extractPoints(curveSegments)

				let vertices = shapePoints.shape
				const holes = shapePoints.holes

				const reverse = !ShapeUtils.isClockWise(vertices)

				if (reverse) {

					vertices = vertices.reverse()

					// Maybe we should also check if holes are in the opposite direction, just to be safe ...

					for (let h = 0, hl = holes.length; h < hl; h++) {

						const ahole = holes[h]

						if (ShapeUtils.isClockWise(ahole)) {

							holes[h] = ahole.reverse()

						}

					}

				}


				const faces = ShapeUtils.triangulateShape(vertices, holes)

				/* Vertices */

				const contour = vertices // vertices has all points but contour has only points of circumference

				for (let h = 0, hl = holes.length; h < hl; h++) {

					const ahole = holes[h]

					vertices = vertices.concat(ahole)

				}


				function scalePt2 (pt, vec, size) {

					if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist')

					return vec.clone().multiplyScalar(size).add(pt)

				}

				const vlen = vertices.length, flen = faces.length


				// Find directions for point movement


				function getBevelVec (inPt, inPrev, inNext) {

					// computes for inPt the corresponding point inPt' on a new contour
					//   shifted by 1 unit (length of normalized vector) to the left
					// if we walk along contour clockwise, this new contour is outside the old one
					//
					// inPt' is the intersection of the two lines parallel to the two
					//  adjacent edges of inPt at a distance of 1 unit on the left side.

					let v_trans_x, v_trans_y, shrink_by // resulting translation vector for inPt

					// good reading for geometry algorithms (here: line-line intersection)
					// http://geomalgorithms.com/a05-_intersect-1.html

					const v_prev_x = inPt.x - inPrev.x,
						v_prev_y = inPt.y - inPrev.y
					const v_next_x = inNext.x - inPt.x,
						v_next_y = inNext.y - inPt.y

					const v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y)

					// check for collinear edges
					const collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x)

					if (Math.abs(collinear0) > Number.EPSILON) {

						// not collinear

						// length of vectors for normalizing

						const v_prev_len = Math.sqrt(v_prev_lensq)
						const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y)

						// shift adjacent points by unit vectors to the left

						const ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len)
						const ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len)

						const ptNextShift_x = (inNext.x - v_next_y / v_next_len)
						const ptNextShift_y = (inNext.y + v_next_x / v_next_len)

						// scaling factor for v_prev to intersection point

						const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y -
							(ptNextShift_y - ptPrevShift_y) * v_next_x) /
							(v_prev_x * v_next_y - v_prev_y * v_next_x)

						// vector from inPt to intersection point

						v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x)
						v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y)

						// Don't normalize!, otherwise sharp corners become ugly
						//  but prevent crazy spikes
						const v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y)
						if (v_trans_lensq <= 2) {

							return new Vector2(v_trans_x, v_trans_y)

						} else {

							shrink_by = Math.sqrt(v_trans_lensq / 2)

						}

					} else {

						// handle special case of collinear edges

						let direction_eq = false // assumes: opposite

						if (v_prev_x > Number.EPSILON) {

							if (v_next_x > Number.EPSILON) {

								direction_eq = true

							}

						} else {

							if (v_prev_x < - Number.EPSILON) {

								if (v_next_x < - Number.EPSILON) {

									direction_eq = true

								}

							} else {

								if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {

									direction_eq = true

								}

							}

						}

						if (direction_eq) {

							// console.log("Warning: lines are a straight sequence");
							v_trans_x = - v_prev_y
							v_trans_y = v_prev_x
							shrink_by = Math.sqrt(v_prev_lensq)

						} else {

							// console.log("Warning: lines are a straight spike");
							v_trans_x = v_prev_x
							v_trans_y = v_prev_y
							shrink_by = Math.sqrt(v_prev_lensq / 2)

						}

					}

					return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by)

				}


				const contourMovements = []

				for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {

					if (j === il) j = 0
					if (k === il) k = 0

					//  (j)---(i)---(k)
					// console.log('i,j,k', i, j , k)

					contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k])

				}

				const holesMovements = []
				let oneHoleMovements, verticesMovements = contourMovements.concat()

				for (let h = 0, hl = holes.length; h < hl; h++) {

					const ahole = holes[h]

					oneHoleMovements = []

					for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {

						if (j === il) j = 0
						if (k === il) k = 0

						//  (j)---(i)---(k)
						oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k])

					}

					holesMovements.push(oneHoleMovements)
					verticesMovements = verticesMovements.concat(oneHoleMovements)

				}


				// Loop bevelSegments, 1 for the front, 1 for the back

				for (let b = 0; b < bevelSegments; b++) {

					//for ( b = bevelSegments; b > 0; b -- ) {

					const t = b / bevelSegments
					const z = bevelThickness * Math.cos(t * Math.PI / 2)
					const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset

					// contract shape

					for (let i = 0, il = contour.length; i < il; i++) {

						const vert = scalePt2(contour[i], contourMovements[i], bs)

						v(vert.x, vert.y, - z)

					}

					// expand holes

					for (let h = 0, hl = holes.length; h < hl; h++) {

						const ahole = holes[h]
						oneHoleMovements = holesMovements[h]

						for (let i = 0, il = ahole.length; i < il; i++) {

							const vert = scalePt2(ahole[i], oneHoleMovements[i], bs)

							v(vert.x, vert.y, - z)

						}

					}

				}

				const bs = bevelSize + bevelOffset

				// Back facing vertices

				for (let i = 0; i < vlen; i++) {

					const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i]

					if (!extrudeByPath) {

						v(vert.x, vert.y, 0)

					} else {

						// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

						normal.copy(splineTube.normals[0]).multiplyScalar(vert.x)
						binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y)

						position2.copy(extrudePts[0]).add(normal).add(binormal)

						v(position2.x, position2.y, position2.z)

					}

				}

				// Add stepped vertices...
				// Including front facing vertices

				for (let s = 1; s <= steps; s++) {

					for (let i = 0; i < vlen; i++) {

						const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i]

						if (!extrudeByPath) {

							v(vert.x, vert.y, depth / steps * s)

						} else {

							// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

							normal.copy(splineTube.normals[s]).multiplyScalar(vert.x)
							binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y)

							position2.copy(extrudePts[s]).add(normal).add(binormal)

							v(position2.x, position2.y, position2.z)

						}

					}

				}


				// Add bevel segments planes

				//for ( b = 1; b <= bevelSegments; b ++ ) {
				for (let b = bevelSegments - 1; b >= 0; b--) {

					const t = b / bevelSegments
					const z = bevelThickness * Math.cos(t * Math.PI / 2)
					const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset

					// contract shape

					for (let i = 0, il = contour.length; i < il; i++) {

						const vert = scalePt2(contour[i], contourMovements[i], bs)
						v(vert.x, vert.y, depth + z)

					}

					// expand holes

					for (let h = 0, hl = holes.length; h < hl; h++) {

						const ahole = holes[h]
						oneHoleMovements = holesMovements[h]

						for (let i = 0, il = ahole.length; i < il; i++) {

							const vert = scalePt2(ahole[i], oneHoleMovements[i], bs)

							if (!extrudeByPath) {

								v(vert.x, vert.y, depth + z)

							} else {

								v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z)

							}

						}

					}

				}

				/* Faces */

				// Top and bottom faces

				buildLidFaces()

				// Sides faces

				buildSideFaces()


				/////  Internal functions

				function buildLidFaces () {

					const start = verticesArray.length / 3

					if (bevelEnabled) {

						let layer = 0 // steps + 1
						let offset = vlen * layer

						// Bottom faces

						for (let i = 0; i < flen; i++) {

							const face = faces[i]
							f3(face[2] + offset, face[1] + offset, face[0] + offset)

						}

						layer = steps + bevelSegments * 2
						offset = vlen * layer

						// Top faces

						for (let i = 0; i < flen; i++) {

							const face = faces[i]
							f3(face[0] + offset, face[1] + offset, face[2] + offset)

						}

					} else {

						// Bottom faces

						for (let i = 0; i < flen; i++) {

							const face = faces[i]
							f3(face[2], face[1], face[0])

						}

						// Top faces

						for (let i = 0; i < flen; i++) {

							const face = faces[i]
							f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps)

						}

					}

					scope.addGroup(start, verticesArray.length / 3 - start, 0)

				}

				// Create faces for the z-sides of the shape

				function buildSideFaces () {

					const start = verticesArray.length / 3
					let layeroffset = 0
					sidewalls(contour, layeroffset)
					layeroffset += contour.length

					for (let h = 0, hl = holes.length; h < hl; h++) {

						const ahole = holes[h]
						sidewalls(ahole, layeroffset)

						//, true
						layeroffset += ahole.length

					}


					scope.addGroup(start, verticesArray.length / 3 - start, 1)


				}

				function sidewalls (contour, layeroffset) {

					let i = contour.length

					while (--i >= 0) {

						const j = i
						let k = i - 1
						if (k < 0) k = contour.length - 1

						//console.log('b', i,j, i-1, k,vertices.length);

						for (let s = 0, sl = (steps + bevelSegments * 2); s < sl; s++) {

							const slen1 = vlen * s
							const slen2 = vlen * (s + 1)

							const a = layeroffset + j + slen1,
								b = layeroffset + k + slen1,
								c = layeroffset + k + slen2,
								d = layeroffset + j + slen2

							f4(a, b, c, d)

						}

					}

				}

				function v (x, y, z) {

					placeholder.push(x)
					placeholder.push(y)
					placeholder.push(z)

				}


				function f3 (a, b, c) {

					addVertex(a)
					addVertex(b)
					addVertex(c)

					const nextIndex = verticesArray.length / 3
					const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1)

					addUV(uvs[0])
					addUV(uvs[1])
					addUV(uvs[2])

				}

				function f4 (a, b, c, d) {

					addVertex(a)
					addVertex(b)
					addVertex(d)

					addVertex(b)
					addVertex(c)
					addVertex(d)


					const nextIndex = verticesArray.length / 3
					const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1)

					addUV(uvs[0])
					addUV(uvs[1])
					addUV(uvs[3])

					addUV(uvs[1])
					addUV(uvs[2])
					addUV(uvs[3])

				}

				function addVertex (index) {

					verticesArray.push(placeholder[index * 3 + 0])
					verticesArray.push(placeholder[index * 3 + 1])
					verticesArray.push(placeholder[index * 3 + 2])

				}


				function addUV (vector2) {

					uvArray.push(vector2.x)
					uvArray.push(vector2.y)

				}

			}

		}

		toJSON () {

			const data = super.toJSON()

			const shapes = this.parameters.shapes
			const options = this.parameters.options

			return toJSON$1(shapes, options, data)

		}

		static fromJSON (data, shapes) {

			const geometryShapes = []

			for (let j = 0, jl = data.shapes.length; j < jl; j++) {

				const shape = shapes[data.shapes[j]]

				geometryShapes.push(shape)

			}

			const extrudePath = data.options.extrudePath

			if (extrudePath !== undefined) {

				data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath)

			}

			return new ExtrudeGeometry(geometryShapes, data.options)

		}

	}

	const WorldUVGenerator = {

		generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {

			const a_x = vertices[indexA * 3]
			const a_y = vertices[indexA * 3 + 1]
			const b_x = vertices[indexB * 3]
			const b_y = vertices[indexB * 3 + 1]
			const c_x = vertices[indexC * 3]
			const c_y = vertices[indexC * 3 + 1]

			return [
				new Vector2(a_x, a_y),
				new Vector2(b_x, b_y),
				new Vector2(c_x, c_y)
			]

		},

		generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {

			const a_x = vertices[indexA * 3]
			const a_y = vertices[indexA * 3 + 1]
			const a_z = vertices[indexA * 3 + 2]
			const b_x = vertices[indexB * 3]
			const b_y = vertices[indexB * 3 + 1]
			const b_z = vertices[indexB * 3 + 2]
			const c_x = vertices[indexC * 3]
			const c_y = vertices[indexC * 3 + 1]
			const c_z = vertices[indexC * 3 + 2]
			const d_x = vertices[indexD * 3]
			const d_y = vertices[indexD * 3 + 1]
			const d_z = vertices[indexD * 3 + 2]

			if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {

				return [
					new Vector2(a_x, 1 - a_z),
					new Vector2(b_x, 1 - b_z),
					new Vector2(c_x, 1 - c_z),
					new Vector2(d_x, 1 - d_z)
				]

			} else {

				return [
					new Vector2(a_y, 1 - a_z),
					new Vector2(b_y, 1 - b_z),
					new Vector2(c_y, 1 - c_z),
					new Vector2(d_y, 1 - d_z)
				]

			}

		}

	}

	function toJSON$1 (shapes, options, data) {

		data.shapes = []

		if (Array.isArray(shapes)) {

			for (let i = 0, l = shapes.length; i < l; i++) {

				const shape = shapes[i]

				data.shapes.push(shape.uuid)

			}

		} else {

			data.shapes.push(shapes.uuid)

		}

		if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON()

		return data

	}

	class IcosahedronGeometry extends PolyhedronGeometry {

		constructor(radius = 1, detail = 0) {

			const t = (1 + Math.sqrt(5)) / 2

			const vertices = [
				- 1, t, 0, 1, t, 0, - 1, - t, 0, 1, - t, 0,
				0, - 1, t, 0, 1, t, 0, - 1, - t, 0, 1, - t,
				t, 0, - 1, t, 0, 1, - t, 0, - 1, - t, 0, 1
			]

			const indices = [
				0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11,
				1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8,
				3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
				4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1
			]

			super(vertices, indices, radius, detail)

			this.type = 'IcosahedronGeometry'

			this.parameters = {
				radius: radius,
				detail: detail
			}

		}

		static fromJSON (data) {

			return new IcosahedronGeometry(data.radius, data.detail)

		}

	}

	class LatheGeometry extends BufferGeometry {

		constructor(points, segments = 12, phiStart = 0, phiLength = Math.PI * 2) {

			super()

			this.type = 'LatheGeometry'

			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			}

			segments = Math.floor(segments)

			// clamp phiLength so it's in range of [ 0, 2PI ]

			phiLength = clamp(phiLength, 0, Math.PI * 2)

			// buffers

			const indices = []
			const vertices = []
			const uvs = []

			// helper variables

			const inverseSegments = 1.0 / segments
			const vertex = new Vector3()
			const uv = new Vector2()

			// generate vertices and uvs

			for (let i = 0; i <= segments; i++) {

				const phi = phiStart + i * inverseSegments * phiLength

				const sin = Math.sin(phi)
				const cos = Math.cos(phi)

				for (let j = 0; j <= (points.length - 1); j++) {

					// vertex

					vertex.x = points[j].x * sin
					vertex.y = points[j].y
					vertex.z = points[j].x * cos

					vertices.push(vertex.x, vertex.y, vertex.z)

					// uv

					uv.x = i / segments
					uv.y = j / (points.length - 1)

					uvs.push(uv.x, uv.y)


				}

			}

			// indices

			for (let i = 0; i < segments; i++) {

				for (let j = 0; j < (points.length - 1); j++) {

					const base = j + i * points.length

					const a = base
					const b = base + points.length
					const c = base + points.length + 1
					const d = base + 1

					// faces

					indices.push(a, b, d)
					indices.push(b, c, d)

				}

			}

			// build geometry

			this.setIndex(indices)
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))

			// generate normals

			this.computeVertexNormals()

			// if the geometry is closed, we need to average the normals along the seam.
			// because the corresponding vertices are identical (but still have different UVs).

			if (phiLength === Math.PI * 2) {

				const normals = this.attributes.normal.array
				const n1 = new Vector3()
				const n2 = new Vector3()
				const n = new Vector3()

				// this is the buffer offset for the last line of vertices

				const base = segments * points.length * 3

				for (let i = 0, j = 0; i < points.length; i++, j += 3) {

					// select the normal of the vertex in the first line

					n1.x = normals[j + 0]
					n1.y = normals[j + 1]
					n1.z = normals[j + 2]

					// select the normal of the vertex in the last line

					n2.x = normals[base + j + 0]
					n2.y = normals[base + j + 1]
					n2.z = normals[base + j + 2]

					// average normals

					n.addVectors(n1, n2).normalize()

					// assign the new values to both normals

					normals[j + 0] = normals[base + j + 0] = n.x
					normals[j + 1] = normals[base + j + 1] = n.y
					normals[j + 2] = normals[base + j + 2] = n.z

				}

			}

		}

		static fromJSON (data) {

			return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength)

		}

	}

	class OctahedronGeometry extends PolyhedronGeometry {

		constructor(radius = 1, detail = 0) {

			const vertices = [
				1, 0, 0, - 1, 0, 0, 0, 1, 0,
				0, - 1, 0, 0, 0, 1, 0, 0, - 1
			]

			const indices = [
				0, 2, 4, 0, 4, 3, 0, 3, 5,
				0, 5, 2, 1, 2, 5, 1, 5, 3,
				1, 3, 4, 1, 4, 2
			]

			super(vertices, indices, radius, detail)

			this.type = 'OctahedronGeometry'

			this.parameters = {
				radius: radius,
				detail: detail
			}

		}

		static fromJSON (data) {

			return new OctahedronGeometry(data.radius, data.detail)

		}

	}

	/**
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
	 */

	class ParametricGeometry extends BufferGeometry {

		constructor(func, slices, stacks) {

			super()

			this.type = 'ParametricGeometry'

			this.parameters = {
				func: func,
				slices: slices,
				stacks: stacks
			}

			// buffers

			const indices = []
			const vertices = []
			const normals = []
			const uvs = []

			const EPS = 0.00001

			const normal = new Vector3()

			const p0 = new Vector3(), p1 = new Vector3()
			const pu = new Vector3(), pv = new Vector3()

			if (func.length < 3) {

				console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.')

			}

			// generate vertices, normals and uvs

			const sliceCount = slices + 1

			for (let i = 0; i <= stacks; i++) {

				const v = i / stacks

				for (let j = 0; j <= slices; j++) {

					const u = j / slices

					// vertex

					func(u, v, p0)
					vertices.push(p0.x, p0.y, p0.z)

					// normal

					// approximate tangent vectors via finite differences

					if (u - EPS >= 0) {

						func(u - EPS, v, p1)
						pu.subVectors(p0, p1)

					} else {

						func(u + EPS, v, p1)
						pu.subVectors(p1, p0)

					}

					if (v - EPS >= 0) {

						func(u, v - EPS, p1)
						pv.subVectors(p0, p1)

					} else {

						func(u, v + EPS, p1)
						pv.subVectors(p1, p0)

					}

					// cross product of tangent vectors returns surface normal

					normal.crossVectors(pu, pv).normalize()
					normals.push(normal.x, normal.y, normal.z)

					// uv

					uvs.push(u, v)

				}

			}

			// generate indices

			for (let i = 0; i < stacks; i++) {

				for (let j = 0; j < slices; j++) {

					const a = i * sliceCount + j
					const b = i * sliceCount + j + 1
					const c = (i + 1) * sliceCount + j + 1
					const d = (i + 1) * sliceCount + j

					// faces one and two

					indices.push(a, b, d)
					indices.push(b, c, d)

				}

			}

			// build geometry

			this.setIndex(indices)
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))

		}

	}

	class RingGeometry extends BufferGeometry {

		constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {

			super()

			this.type = 'RingGeometry'

			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			}

			thetaSegments = Math.max(3, thetaSegments)
			phiSegments = Math.max(1, phiSegments)

			// buffers

			const indices = []
			const vertices = []
			const normals = []
			const uvs = []

			// some helper variables

			let radius = innerRadius
			const radiusStep = ((outerRadius - innerRadius) / phiSegments)
			const vertex = new Vector3()
			const uv = new Vector2()

			// generate vertices, normals and uvs

			for (let j = 0; j <= phiSegments; j++) {

				for (let i = 0; i <= thetaSegments; i++) {

					// values are generate from the inside of the ring to the outside

					const segment = thetaStart + i / thetaSegments * thetaLength

					// vertex

					vertex.x = radius * Math.cos(segment)
					vertex.y = radius * Math.sin(segment)

					vertices.push(vertex.x, vertex.y, vertex.z)

					// normal

					normals.push(0, 0, 1)

					// uv

					uv.x = (vertex.x / outerRadius + 1) / 2
					uv.y = (vertex.y / outerRadius + 1) / 2

					uvs.push(uv.x, uv.y)

				}

				// increase the radius for next row of vertices

				radius += radiusStep

			}

			// indices

			for (let j = 0; j < phiSegments; j++) {

				const thetaSegmentLevel = j * (thetaSegments + 1)

				for (let i = 0; i < thetaSegments; i++) {

					const segment = i + thetaSegmentLevel

					const a = segment
					const b = segment + thetaSegments + 1
					const c = segment + thetaSegments + 2
					const d = segment + 1

					// faces

					indices.push(a, b, d)
					indices.push(b, c, d)

				}

			}

			// build geometry

			this.setIndex(indices)
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))

		}

		static fromJSON (data) {

			return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength)

		}

	}

	class ShapeGeometry extends BufferGeometry {

		constructor(shapes, curveSegments = 12) {

			super()
			this.type = 'ShapeGeometry'

			this.parameters = {
				shapes: shapes,
				curveSegments: curveSegments
			}

			// buffers

			const indices = []
			const vertices = []
			const normals = []
			const uvs = []

			// helper variables

			let groupStart = 0
			let groupCount = 0

			// allow single and array values for "shapes" parameter

			if (Array.isArray(shapes) === false) {

				addShape(shapes)

			} else {

				for (let i = 0; i < shapes.length; i++) {

					addShape(shapes[i])

					this.addGroup(groupStart, groupCount, i) // enables MultiMaterial support

					groupStart += groupCount
					groupCount = 0

				}

			}

			// build geometry

			this.setIndex(indices)
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))


			// helper functions

			function addShape (shape) {

				const indexOffset = vertices.length / 3
				const points = shape.extractPoints(curveSegments)

				let shapeVertices = points.shape
				const shapeHoles = points.holes

				// check direction of vertices

				if (ShapeUtils.isClockWise(shapeVertices) === false) {

					shapeVertices = shapeVertices.reverse()

				}

				for (let i = 0, l = shapeHoles.length; i < l; i++) {

					const shapeHole = shapeHoles[i]

					if (ShapeUtils.isClockWise(shapeHole) === true) {

						shapeHoles[i] = shapeHole.reverse()

					}

				}

				const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles)

				// join vertices of inner and outer paths to a single array

				for (let i = 0, l = shapeHoles.length; i < l; i++) {

					const shapeHole = shapeHoles[i]
					shapeVertices = shapeVertices.concat(shapeHole)

				}

				// vertices, normals, uvs

				for (let i = 0, l = shapeVertices.length; i < l; i++) {

					const vertex = shapeVertices[i]

					vertices.push(vertex.x, vertex.y, 0)
					normals.push(0, 0, 1)
					uvs.push(vertex.x, vertex.y) // world uvs

				}

				// incides

				for (let i = 0, l = faces.length; i < l; i++) {

					const face = faces[i]

					const a = face[0] + indexOffset
					const b = face[1] + indexOffset
					const c = face[2] + indexOffset

					indices.push(a, b, c)
					groupCount += 3

				}

			}

		}

		toJSON () {

			const data = super.toJSON()

			const shapes = this.parameters.shapes

			return toJSON(shapes, data)

		}

		static fromJSON (data, shapes) {

			const geometryShapes = []

			for (let j = 0, jl = data.shapes.length; j < jl; j++) {

				const shape = shapes[data.shapes[j]]

				geometryShapes.push(shape)

			}

			return new ShapeGeometry(geometryShapes, data.curveSegments)

		}

	}

	function toJSON (shapes, data) {

		data.shapes = []

		if (Array.isArray(shapes)) {

			for (let i = 0, l = shapes.length; i < l; i++) {

				const shape = shapes[i]

				data.shapes.push(shape.uuid)

			}

		} else {

			data.shapes.push(shapes.uuid)

		}

		return data

	}

	class SphereGeometry extends BufferGeometry {

		constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {

			super()
			this.type = 'SphereGeometry'

			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			}

			widthSegments = Math.max(3, Math.floor(widthSegments))
			heightSegments = Math.max(2, Math.floor(heightSegments))

			const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI)

			let index = 0
			const grid = []

			const vertex = new Vector3()
			const normal = new Vector3()

			// buffers

			const indices = []
			const vertices = []
			const normals = []
			const uvs = []

			// generate vertices, normals and uvs

			for (let iy = 0; iy <= heightSegments; iy++) {

				const verticesRow = []

				const v = iy / heightSegments

				// special case for the poles

				let uOffset = 0

				if (iy == 0 && thetaStart == 0) {

					uOffset = 0.5 / widthSegments

				} else if (iy == heightSegments && thetaEnd == Math.PI) {

					uOffset = - 0.5 / widthSegments

				}

				for (let ix = 0; ix <= widthSegments; ix++) {

					const u = ix / widthSegments

					// vertex

					vertex.x = - radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength)
					vertex.y = radius * Math.cos(thetaStart + v * thetaLength)
					vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength)

					vertices.push(vertex.x, vertex.y, vertex.z)

					// normal

					normal.copy(vertex).normalize()
					normals.push(normal.x, normal.y, normal.z)

					// uv

					uvs.push(u + uOffset, 1 - v)

					verticesRow.push(index++)

				}

				grid.push(verticesRow)

			}

			// indices

			for (let iy = 0; iy < heightSegments; iy++) {

				for (let ix = 0; ix < widthSegments; ix++) {

					const a = grid[iy][ix + 1]
					const b = grid[iy][ix]
					const c = grid[iy + 1][ix]
					const d = grid[iy + 1][ix + 1]

					if (iy !== 0 || thetaStart > 0) indices.push(a, b, d)
					if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d)

				}

			}

			// build geometry

			this.setIndex(indices)
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))

		}

		static fromJSON (data) {

			return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength)

		}

	}

	class TetrahedronGeometry extends PolyhedronGeometry {

		constructor(radius = 1, detail = 0) {

			const vertices = [
				1, 1, 1, - 1, - 1, 1, - 1, 1, - 1, 1, - 1, - 1
			]

			const indices = [
				2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1
			]

			super(vertices, indices, radius, detail)

			this.type = 'TetrahedronGeometry'

			this.parameters = {
				radius: radius,
				detail: detail
			}

		}

		static fromJSON (data) {

			return new TetrahedronGeometry(data.radius, data.detail)

		}

	}

	/**
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  font: <THREE.Font>, // font
	 *
	 *  size: <float>, // size of the text
	 *  height: <float>, // thickness to extrude text
	 *  curveSegments: <int>, // number of points on the curves
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into text bevel goes
	 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
	 *  bevelOffset: <float> // how far from text outline does bevel start
	 * }
	 */

	class TextGeometry extends ExtrudeGeometry {

		constructor(text, parameters = {}) {

			const font = parameters.font

			if (!(font && font.isFont)) {

				console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.')
				return new BufferGeometry()

			}

			const shapes = font.generateShapes(text, parameters.size)

			// translate parameters to ExtrudeGeometry API

			parameters.depth = parameters.height !== undefined ? parameters.height : 50

			// defaults

			if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10
			if (parameters.bevelSize === undefined) parameters.bevelSize = 8
			if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false

			super(shapes, parameters)

			this.type = 'TextGeometry'

		}

	}

	class TorusGeometry extends BufferGeometry {

		constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {

			super()
			this.type = 'TorusGeometry'

			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			}

			radialSegments = Math.floor(radialSegments)
			tubularSegments = Math.floor(tubularSegments)

			// buffers

			const indices = []
			const vertices = []
			const normals = []
			const uvs = []

			// helper variables

			const center = new Vector3()
			const vertex = new Vector3()
			const normal = new Vector3()

			// generate vertices, normals and uvs

			for (let j = 0; j <= radialSegments; j++) {

				for (let i = 0; i <= tubularSegments; i++) {

					const u = i / tubularSegments * arc
					const v = j / radialSegments * Math.PI * 2

					// vertex

					vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u)
					vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u)
					vertex.z = tube * Math.sin(v)

					vertices.push(vertex.x, vertex.y, vertex.z)

					// normal

					center.x = radius * Math.cos(u)
					center.y = radius * Math.sin(u)
					normal.subVectors(vertex, center).normalize()

					normals.push(normal.x, normal.y, normal.z)

					// uv

					uvs.push(i / tubularSegments)
					uvs.push(j / radialSegments)

				}

			}

			// generate indices

			for (let j = 1; j <= radialSegments; j++) {

				for (let i = 1; i <= tubularSegments; i++) {

					// indices

					const a = (tubularSegments + 1) * j + i - 1
					const b = (tubularSegments + 1) * (j - 1) + i - 1
					const c = (tubularSegments + 1) * (j - 1) + i
					const d = (tubularSegments + 1) * j + i

					// faces

					indices.push(a, b, d)
					indices.push(b, c, d)

				}

			}

			// build geometry

			this.setIndex(indices)
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))

		}

		static fromJSON (data) {

			return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc)

		}

	}

	class TorusKnotGeometry extends BufferGeometry {

		constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {

			super()
			this.type = 'TorusKnotGeometry'

			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			}

			tubularSegments = Math.floor(tubularSegments)
			radialSegments = Math.floor(radialSegments)

			// buffers

			const indices = []
			const vertices = []
			const normals = []
			const uvs = []

			// helper variables

			const vertex = new Vector3()
			const normal = new Vector3()

			const P1 = new Vector3()
			const P2 = new Vector3()

			const B = new Vector3()
			const T = new Vector3()
			const N = new Vector3()

			// generate vertices, normals and uvs

			for (let i = 0; i <= tubularSegments; ++i) {

				// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

				const u = i / tubularSegments * p * Math.PI * 2

				// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
				// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

				calculatePositionOnCurve(u, p, q, radius, P1)
				calculatePositionOnCurve(u + 0.01, p, q, radius, P2)

				// calculate orthonormal basis

				T.subVectors(P2, P1)
				N.addVectors(P2, P1)
				B.crossVectors(T, N)
				N.crossVectors(B, T)

				// normalize B, N. T can be ignored, we don't use it

				B.normalize()
				N.normalize()

				for (let j = 0; j <= radialSegments; ++j) {

					// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
					// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

					const v = j / radialSegments * Math.PI * 2
					const cx = - tube * Math.cos(v)
					const cy = tube * Math.sin(v)

					// now calculate the final vertex position.
					// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

					vertex.x = P1.x + (cx * N.x + cy * B.x)
					vertex.y = P1.y + (cx * N.y + cy * B.y)
					vertex.z = P1.z + (cx * N.z + cy * B.z)

					vertices.push(vertex.x, vertex.y, vertex.z)

					// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

					normal.subVectors(vertex, P1).normalize()

					normals.push(normal.x, normal.y, normal.z)

					// uv

					uvs.push(i / tubularSegments)
					uvs.push(j / radialSegments)

				}

			}

			// generate indices

			for (let j = 1; j <= tubularSegments; j++) {

				for (let i = 1; i <= radialSegments; i++) {

					// indices

					const a = (radialSegments + 1) * (j - 1) + (i - 1)
					const b = (radialSegments + 1) * j + (i - 1)
					const c = (radialSegments + 1) * j + i
					const d = (radialSegments + 1) * (j - 1) + i

					// faces

					indices.push(a, b, d)
					indices.push(b, c, d)

				}

			}

			// build geometry

			this.setIndex(indices)
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))

			// this function calculates the current position on the torus curve

			function calculatePositionOnCurve (u, p, q, radius, position) {

				const cu = Math.cos(u)
				const su = Math.sin(u)
				const quOverP = q / p * u
				const cs = Math.cos(quOverP)

				position.x = radius * (2 + cs) * 0.5 * cu
				position.y = radius * (2 + cs) * su * 0.5
				position.z = radius * Math.sin(quOverP) * 0.5

			}

		}

		static fromJSON (data) {

			return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q)

		}

	}

	class TubeGeometry extends BufferGeometry {

		constructor(path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {

			super()
			this.type = 'TubeGeometry'

			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			}

			const frames = path.computeFrenetFrames(tubularSegments, closed)

			// expose internals

			this.tangents = frames.tangents
			this.normals = frames.normals
			this.binormals = frames.binormals

			// helper variables

			const vertex = new Vector3()
			const normal = new Vector3()
			const uv = new Vector2()
			let P = new Vector3()

			// buffer

			const vertices = []
			const normals = []
			const uvs = []
			const indices = []

			// create buffer data

			generateBufferData()

			// build geometry

			this.setIndex(indices)
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))

			// functions

			function generateBufferData () {

				for (let i = 0; i < tubularSegments; i++) {

					generateSegment(i)

				}

				// if the geometry is not closed, generate the last row of vertices and normals
				// at the regular position on the given path
				//
				// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

				generateSegment((closed === false) ? tubularSegments : 0)

				// uvs are generated in a separate function.
				// this makes it easy compute correct values for closed geometries

				generateUVs()

				// finally create faces

				generateIndices()

			}

			function generateSegment (i) {

				// we use getPointAt to sample evenly distributed points from the given path

				P = path.getPointAt(i / tubularSegments, P)

				// retrieve corresponding normal and binormal

				const N = frames.normals[i]
				const B = frames.binormals[i]

				// generate normals and vertices for the current segment

				for (let j = 0; j <= radialSegments; j++) {

					const v = j / radialSegments * Math.PI * 2

					const sin = Math.sin(v)
					const cos = - Math.cos(v)

					// normal

					normal.x = (cos * N.x + sin * B.x)
					normal.y = (cos * N.y + sin * B.y)
					normal.z = (cos * N.z + sin * B.z)
					normal.normalize()

					normals.push(normal.x, normal.y, normal.z)

					// vertex

					vertex.x = P.x + radius * normal.x
					vertex.y = P.y + radius * normal.y
					vertex.z = P.z + radius * normal.z

					vertices.push(vertex.x, vertex.y, vertex.z)

				}

			}

			function generateIndices () {

				for (let j = 1; j <= tubularSegments; j++) {

					for (let i = 1; i <= radialSegments; i++) {

						const a = (radialSegments + 1) * (j - 1) + (i - 1)
						const b = (radialSegments + 1) * j + (i - 1)
						const c = (radialSegments + 1) * j + i
						const d = (radialSegments + 1) * (j - 1) + i

						// faces

						indices.push(a, b, d)
						indices.push(b, c, d)

					}

				}

			}

			function generateUVs () {

				for (let i = 0; i <= tubularSegments; i++) {

					for (let j = 0; j <= radialSegments; j++) {

						uv.x = i / tubularSegments
						uv.y = j / radialSegments

						uvs.push(uv.x, uv.y)

					}

				}

			}

		}

		toJSON () {

			const data = super.toJSON()

			data.path = this.parameters.path.toJSON()

			return data

		}

		static fromJSON (data) {

			// This only works for built-in curves (e.g. CatmullRomCurve3).
			// User defined curves or instances of CurvePath will not be deserialized.
			return new TubeGeometry(
				new Curves[data.path.type]().fromJSON(data.path),
				data.tubularSegments,
				data.radius,
				data.radialSegments,
				data.closed
			)

		}

	}

	class WireframeGeometry extends BufferGeometry {

		constructor(geometry) {

			super()
			this.type = 'WireframeGeometry'

			if (geometry.isGeometry === true) {

				console.error('THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.')
				return

			}

			// buffer

			const vertices = []
			const edges = new Set()

			// helper variables

			const start = new Vector3()
			const end = new Vector3()

			if (geometry.index !== null) {

				// indexed BufferGeometry

				const position = geometry.attributes.position
				const indices = geometry.index
				let groups = geometry.groups

				if (groups.length === 0) {

					groups = [{ start: 0, count: indices.count, materialIndex: 0 }]

				}

				// create a data structure that contains all eges without duplicates

				for (let o = 0, ol = groups.length; o < ol; ++o) {

					const group = groups[o]

					const groupStart = group.start
					const groupCount = group.count

					for (let i = groupStart, l = (groupStart + groupCount); i < l; i += 3) {

						for (let j = 0; j < 3; j++) {

							const index1 = indices.getX(i + j)
							const index2 = indices.getX(i + (j + 1) % 3)

							start.fromBufferAttribute(position, index1)
							end.fromBufferAttribute(position, index2)

							if (isUniqueEdge(start, end, edges) === true) {

								vertices.push(start.x, start.y, start.z)
								vertices.push(end.x, end.y, end.z)

							}

						}

					}

				}

			} else {

				// non-indexed BufferGeometry

				const position = geometry.attributes.position

				for (let i = 0, l = (position.count / 3); i < l; i++) {

					for (let j = 0; j < 3; j++) {

						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

						const index1 = 3 * i + j
						const index2 = 3 * i + ((j + 1) % 3)

						start.fromBufferAttribute(position, index1)
						end.fromBufferAttribute(position, index2)

						if (isUniqueEdge(start, end, edges) === true) {

							vertices.push(start.x, start.y, start.z)
							vertices.push(end.x, end.y, end.z)

						}

					}

				}

			}

			// build geometry

			this.setAttribute('position', new Float32BufferAttribute(vertices, 3))

		}

	}

	function isUniqueEdge (start, end, edges) {

		const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`
		const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}` // coincident edge

		if (edges.has(hash1) === true || edges.has(hash2) === true) {

			return false

		} else {

			edges.add(hash1, hash2)
			return true

		}

	}

	var Geometries = /*#__PURE__*/Object.freeze({
		__proto__: null,
		BoxGeometry: BoxGeometry,
		BoxBufferGeometry: BoxGeometry,
		CircleGeometry: CircleGeometry,
		CircleBufferGeometry: CircleGeometry,
		ConeGeometry: ConeGeometry,
		ConeBufferGeometry: ConeGeometry,
		CylinderGeometry: CylinderGeometry,
		CylinderBufferGeometry: CylinderGeometry,
		DodecahedronGeometry: DodecahedronGeometry,
		DodecahedronBufferGeometry: DodecahedronGeometry,
		EdgesGeometry: EdgesGeometry,
		ExtrudeGeometry: ExtrudeGeometry,
		ExtrudeBufferGeometry: ExtrudeGeometry,
		IcosahedronGeometry: IcosahedronGeometry,
		IcosahedronBufferGeometry: IcosahedronGeometry,
		LatheGeometry: LatheGeometry,
		LatheBufferGeometry: LatheGeometry,
		OctahedronGeometry: OctahedronGeometry,
		OctahedronBufferGeometry: OctahedronGeometry,
		ParametricGeometry: ParametricGeometry,
		ParametricBufferGeometry: ParametricGeometry,
		PlaneGeometry: PlaneGeometry,
		PlaneBufferGeometry: PlaneGeometry,
		PolyhedronGeometry: PolyhedronGeometry,
		PolyhedronBufferGeometry: PolyhedronGeometry,
		RingGeometry: RingGeometry,
		RingBufferGeometry: RingGeometry,
		ShapeGeometry: ShapeGeometry,
		ShapeBufferGeometry: ShapeGeometry,
		SphereGeometry: SphereGeometry,
		SphereBufferGeometry: SphereGeometry,
		TetrahedronGeometry: TetrahedronGeometry,
		TetrahedronBufferGeometry: TetrahedronGeometry,
		TextGeometry: TextGeometry,
		TextBufferGeometry: TextGeometry,
		TorusGeometry: TorusGeometry,
		TorusBufferGeometry: TorusGeometry,
		TorusKnotGeometry: TorusKnotGeometry,
		TorusKnotBufferGeometry: TorusKnotGeometry,
		TubeGeometry: TubeGeometry,
		TubeBufferGeometry: TubeGeometry,
		WireframeGeometry: WireframeGeometry
	})

	/**
	 * parameters = {
	 *  color: <THREE.Color>
	 * }
	 */

	class ShadowMaterial extends Material {

		constructor(parameters) {

			super()

			this.type = 'ShadowMaterial'

			this.color = new Color(0x000000)
			this.transparent = true

			this.setValues(parameters)

		}

		copy (source) {

			super.copy(source)

			this.color.copy(source.color)

			return this

		}

	}

	ShadowMaterial.prototype.isShadowMaterial = true

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  roughness: <float>,
	 *  metalness: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *  metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  envMapIntensity: <float>
	 *
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  flatShading: <bool>
	 * }
	 */

	class MeshStandardMaterial extends Material {

		constructor(parameters) {

			super()

			this.defines = { 'STANDARD': '' }

			this.type = 'MeshStandardMaterial'

			this.color = new Color(0xffffff) // diffuse
			this.roughness = 1.0
			this.metalness = 0.0

			this.map = null

			this.lightMap = null
			this.lightMapIntensity = 1.0

			this.aoMap = null
			this.aoMapIntensity = 1.0

			this.emissive = new Color(0x000000)
			this.emissiveIntensity = 1.0
			this.emissiveMap = null

			this.bumpMap = null
			this.bumpScale = 1

			this.normalMap = null
			this.normalMapType = TangentSpaceNormalMap
			this.normalScale = new Vector2(1, 1)

			this.displacementMap = null
			this.displacementScale = 1
			this.displacementBias = 0

			this.roughnessMap = null

			this.metalnessMap = null

			this.alphaMap = null

			this.envMap = null
			this.envMapIntensity = 1.0

			this.refractionRatio = 0.98

			this.wireframe = false
			this.wireframeLinewidth = 1
			this.wireframeLinecap = 'round'
			this.wireframeLinejoin = 'round'

			this.flatShading = false

			this.setValues(parameters)

		}

		copy (source) {

			super.copy(source)

			this.defines = { 'STANDARD': '' }

			this.color.copy(source.color)
			this.roughness = source.roughness
			this.metalness = source.metalness

			this.map = source.map

			this.lightMap = source.lightMap
			this.lightMapIntensity = source.lightMapIntensity

			this.aoMap = source.aoMap
			this.aoMapIntensity = source.aoMapIntensity

			this.emissive.copy(source.emissive)
			this.emissiveMap = source.emissiveMap
			this.emissiveIntensity = source.emissiveIntensity

			this.bumpMap = source.bumpMap
			this.bumpScale = source.bumpScale

			this.normalMap = source.normalMap
			this.normalMapType = source.normalMapType
			this.normalScale.copy(source.normalScale)

			this.displacementMap = source.displacementMap
			this.displacementScale = source.displacementScale
			this.displacementBias = source.displacementBias

			this.roughnessMap = source.roughnessMap

			this.metalnessMap = source.metalnessMap

			this.alphaMap = source.alphaMap

			this.envMap = source.envMap
			this.envMapIntensity = source.envMapIntensity

			this.refractionRatio = source.refractionRatio

			this.wireframe = source.wireframe
			this.wireframeLinewidth = source.wireframeLinewidth
			this.wireframeLinecap = source.wireframeLinecap
			this.wireframeLinejoin = source.wireframeLinejoin

			this.flatShading = source.flatShading

			return this

		}

	}

	MeshStandardMaterial.prototype.isMeshStandardMaterial = true

	/**
	 * parameters = {
	 *  clearcoat: <float>,
	 *  clearcoatMap: new THREE.Texture( <Image> ),
	 *  clearcoatRoughness: <float>,
	 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
	 *  clearcoatNormalScale: <Vector2>,
	 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
	 *
	 *  reflectivity: <float>,
	 *  ior: <float>,
	 *
	 *  sheen: <Color>,
	 *
	 *  transmission: <float>,
	 *  transmissionMap: new THREE.Texture( <Image> ),
	 *
	 *  thickness: <float>,
	 *  thicknessMap: new THREE.Texture( <Image> ),
	 *  attenuationDistance: <float>,
	 *  attenuationTint: <Color>,
	 *
	 *  specularIntensity: <float>,
	 *  specularIntensityhMap: new THREE.Texture( <Image> ),
	 *  specularTint: <Color>,
	 *  specularTintMap: new THREE.Texture( <Image> )
	 * }
	 */

	class MeshPhysicalMaterial extends MeshStandardMaterial {

		constructor(parameters) {

			super()

			this.defines = {

				'STANDARD': '',
				'PHYSICAL': ''

			}

			this.type = 'MeshPhysicalMaterial'

			this.clearcoat = 0.0
			this.clearcoatMap = null
			this.clearcoatRoughness = 0.0
			this.clearcoatRoughnessMap = null
			this.clearcoatNormalScale = new Vector2(1, 1)
			this.clearcoatNormalMap = null

			this.reflectivity = 0.5 // maps to F0 = 0.04

			Object.defineProperty(this, 'ior', {
				get: function () {

					return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity)

				},
				set: function (ior) {

					this.reflectivity = clamp(2.5 * (ior - 1) / (ior + 1), 0, 1)

				}
			})

			this.sheen = null // null will disable sheen bsdf

			this.transmission = 0.0
			this.transmissionMap = null

			this.thickness = 0.01
			this.thicknessMap = null
			this.attenuationDistance = 0.0
			this.attenuationTint = new Color(1, 1, 1)

			this.specularIntensity = 1.0
			this.specularIntensityMap = null
			this.specularTint = new Color(1, 1, 1)
			this.specularTintMap = null

			this.setValues(parameters)

		}

		copy (source) {

			super.copy(source)

			this.defines = {

				'STANDARD': '',
				'PHYSICAL': ''

			}

			this.clearcoat = source.clearcoat
			this.clearcoatMap = source.clearcoatMap
			this.clearcoatRoughness = source.clearcoatRoughness
			this.clearcoatRoughnessMap = source.clearcoatRoughnessMap
			this.clearcoatNormalMap = source.clearcoatNormalMap
			this.clearcoatNormalScale.copy(source.clearcoatNormalScale)

			this.reflectivity = source.reflectivity

			if (source.sheen) {

				this.sheen = (this.sheen || new Color()).copy(source.sheen)

			} else {

				this.sheen = null

			}

			this.transmission = source.transmission
			this.transmissionMap = source.transmissionMap

			this.thickness = source.thickness
			this.thicknessMap = source.thicknessMap
			this.attenuationDistance = source.attenuationDistance
			this.attenuationTint.copy(source.attenuationTint)

			this.specularIntensity = source.specularIntensity
			this.specularIntensityMap = source.specularIntensityMap
			this.specularTint.copy(source.specularTint)
			this.specularTintMap = source.specularTintMap

			return this

		}

	}

	MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.MultiplyOperation,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  flatShading: <bool>
	 * }
	 */

	class MeshPhongMaterial extends Material {

		constructor(parameters) {

			super()

			this.type = 'MeshPhongMaterial'

			this.color = new Color(0xffffff) // diffuse
			this.specular = new Color(0x111111)
			this.shininess = 30

			this.map = null

			this.lightMap = null
			this.lightMapIntensity = 1.0

			this.aoMap = null
			this.aoMapIntensity = 1.0

			this.emissive = new Color(0x000000)
			this.emissiveIntensity = 1.0
			this.emissiveMap = null

			this.bumpMap = null
			this.bumpScale = 1

			this.normalMap = null
			this.normalMapType = TangentSpaceNormalMap
			this.normalScale = new Vector2(1, 1)

			this.displacementMap = null
			this.displacementScale = 1
			this.displacementBias = 0

			this.specularMap = null

			this.alphaMap = null

			this.envMap = null
			this.combine = MultiplyOperation
			this.reflectivity = 1
			this.refractionRatio = 0.98

			this.wireframe = false
			this.wireframeLinewidth = 1
			this.wireframeLinecap = 'round'
			this.wireframeLinejoin = 'round'

			this.flatShading = false

			this.setValues(parameters)

		}

		copy (source) {

			super.copy(source)

			this.color.copy(source.color)
			this.specular.copy(source.specular)
			this.shininess = source.shininess

			this.map = source.map

			this.lightMap = source.lightMap
			this.lightMapIntensity = source.lightMapIntensity

			this.aoMap = source.aoMap
			this.aoMapIntensity = source.aoMapIntensity

			this.emissive.copy(source.emissive)
			this.emissiveMap = source.emissiveMap
			this.emissiveIntensity = source.emissiveIntensity

			this.bumpMap = source.bumpMap
			this.bumpScale = source.bumpScale

			this.normalMap = source.normalMap
			this.normalMapType = source.normalMapType
			this.normalScale.copy(source.normalScale)

			this.displacementMap = source.displacementMap
			this.displacementScale = source.displacementScale
			this.displacementBias = source.displacementBias

			this.specularMap = source.specularMap

			this.alphaMap = source.alphaMap

			this.envMap = source.envMap
			this.combine = source.combine
			this.reflectivity = source.reflectivity
			this.refractionRatio = source.refractionRatio

			this.wireframe = source.wireframe
			this.wireframeLinewidth = source.wireframeLinewidth
			this.wireframeLinecap = source.wireframeLinecap
			this.wireframeLinejoin = source.wireframeLinejoin

			this.flatShading = source.flatShading

			return this

		}

	}

	MeshPhongMaterial.prototype.isMeshPhongMaterial = true

	/**
	 * parameters = {
	 *  color: <hex>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *  gradientMap: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 * }
	 */

	class MeshToonMaterial extends Material {

		constructor(parameters) {

			super()

			this.defines = { 'TOON': '' }

			this.type = 'MeshToonMaterial'

			this.color = new Color(0xffffff)

			this.map = null
			this.gradientMap = null

			this.lightMap = null
			this.lightMapIntensity = 1.0

			this.aoMap = null
			this.aoMapIntensity = 1.0

			this.emissive = new Color(0x000000)
			this.emissiveIntensity = 1.0
			this.emissiveMap = null

			this.bumpMap = null
			this.bumpScale = 1

			this.normalMap = null
			this.normalMapType = TangentSpaceNormalMap
			this.normalScale = new Vector2(1, 1)

			this.displacementMap = null
			this.displacementScale = 1
			this.displacementBias = 0

			this.alphaMap = null

			this.wireframe = false
			this.wireframeLinewidth = 1
			this.wireframeLinecap = 'round'
			this.wireframeLinejoin = 'round'

			this.setValues(parameters)

		}

		copy (source) {

			super.copy(source)

			this.color.copy(source.color)

			this.map = source.map
			this.gradientMap = source.gradientMap

			this.lightMap = source.lightMap
			this.lightMapIntensity = source.lightMapIntensity

			this.aoMap = source.aoMap
			this.aoMapIntensity = source.aoMapIntensity

			this.emissive.copy(source.emissive)
			this.emissiveMap = source.emissiveMap
			this.emissiveIntensity = source.emissiveIntensity

			this.bumpMap = source.bumpMap
			this.bumpScale = source.bumpScale

			this.normalMap = source.normalMap
			this.normalMapType = source.normalMapType
			this.normalScale.copy(source.normalScale)

			this.displacementMap = source.displacementMap
			this.displacementScale = source.displacementScale
			this.displacementBias = source.displacementBias

			this.alphaMap = source.alphaMap

			this.wireframe = source.wireframe
			this.wireframeLinewidth = source.wireframeLinewidth
			this.wireframeLinecap = source.wireframeLinecap
			this.wireframeLinejoin = source.wireframeLinejoin

			return this

		}

	}

	MeshToonMaterial.prototype.isMeshToonMaterial = true

	/**
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 *
	 *  flatShading: <bool>
	 * }
	 */

	class MeshNormalMaterial extends Material {

		constructor(parameters) {

			super()

			this.type = 'MeshNormalMaterial'

			this.bumpMap = null
			this.bumpScale = 1

			this.normalMap = null
			this.normalMapType = TangentSpaceNormalMap
			this.normalScale = new Vector2(1, 1)

			this.displacementMap = null
			this.displacementScale = 1
			this.displacementBias = 0

			this.wireframe = false
			this.wireframeLinewidth = 1

			this.fog = false

			this.flatShading = false

			this.setValues(parameters)

		}

		copy (source) {

			super.copy(source)

			this.bumpMap = source.bumpMap
			this.bumpScale = source.bumpScale

			this.normalMap = source.normalMap
			this.normalMapType = source.normalMapType
			this.normalScale.copy(source.normalScale)

			this.displacementMap = source.displacementMap
			this.displacementScale = source.displacementScale
			this.displacementBias = source.displacementBias

			this.wireframe = source.wireframe
			this.wireframeLinewidth = source.wireframeLinewidth

			this.flatShading = source.flatShading

			return this

		}

	}

	MeshNormalMaterial.prototype.isMeshNormalMaterial = true

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 * }
	 */

	class MeshLambertMaterial extends Material {

		constructor(parameters) {

			super()

			this.type = 'MeshLambertMaterial'

			this.color = new Color(0xffffff) // diffuse

			this.map = null

			this.lightMap = null
			this.lightMapIntensity = 1.0

			this.aoMap = null
			this.aoMapIntensity = 1.0

			this.emissive = new Color(0x000000)
			this.emissiveIntensity = 1.0
			this.emissiveMap = null

			this.specularMap = null

			this.alphaMap = null

			this.envMap = null
			this.combine = MultiplyOperation
			this.reflectivity = 1
			this.refractionRatio = 0.98

			this.wireframe = false
			this.wireframeLinewidth = 1
			this.wireframeLinecap = 'round'
			this.wireframeLinejoin = 'round'

			this.setValues(parameters)

		}

		copy (source) {

			super.copy(source)

			this.color.copy(source.color)

			this.map = source.map

			this.lightMap = source.lightMap
			this.lightMapIntensity = source.lightMapIntensity

			this.aoMap = source.aoMap
			this.aoMapIntensity = source.aoMapIntensity

			this.emissive.copy(source.emissive)
			this.emissiveMap = source.emissiveMap
			this.emissiveIntensity = source.emissiveIntensity

			this.specularMap = source.specularMap

			this.alphaMap = source.alphaMap

			this.envMap = source.envMap
			this.combine = source.combine
			this.reflectivity = source.reflectivity
			this.refractionRatio = source.refractionRatio

			this.wireframe = source.wireframe
			this.wireframeLinewidth = source.wireframeLinewidth
			this.wireframeLinecap = source.wireframeLinecap
			this.wireframeLinejoin = source.wireframeLinejoin

			return this

		}

	}

	MeshLambertMaterial.prototype.isMeshLambertMaterial = true

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  matcap: new THREE.Texture( <Image> ),
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  flatShading: <bool>
	 * }
	 */

	class MeshMatcapMaterial extends Material {

		constructor(parameters) {

			super()

			this.defines = { 'MATCAP': '' }

			this.type = 'MeshMatcapMaterial'

			this.color = new Color(0xffffff) // diffuse

			this.matcap = null

			this.map = null

			this.bumpMap = null
			this.bumpScale = 1

			this.normalMap = null
			this.normalMapType = TangentSpaceNormalMap
			this.normalScale = new Vector2(1, 1)

			this.displacementMap = null
			this.displacementScale = 1
			this.displacementBias = 0

			this.alphaMap = null

			this.flatShading = false

			this.setValues(parameters)

		}


		copy (source) {

			super.copy(source)

			this.defines = { 'MATCAP': '' }

			this.color.copy(source.color)

			this.matcap = source.matcap

			this.map = source.map

			this.bumpMap = source.bumpMap
			this.bumpScale = source.bumpScale

			this.normalMap = source.normalMap
			this.normalMapType = source.normalMapType
			this.normalScale.copy(source.normalScale)

			this.displacementMap = source.displacementMap
			this.displacementScale = source.displacementScale
			this.displacementBias = source.displacementBias

			this.alphaMap = source.alphaMap

			this.flatShading = source.flatShading

			return this

		}

	}

	MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>
	 * }
	 */

	class LineDashedMaterial extends LineBasicMaterial {

		constructor(parameters) {

			super()

			this.type = 'LineDashedMaterial'

			this.scale = 1
			this.dashSize = 3
			this.gapSize = 1

			this.setValues(parameters)

		}

		copy (source) {

			super.copy(source)

			this.scale = source.scale
			this.dashSize = source.dashSize
			this.gapSize = source.gapSize

			return this

		}

	}

	LineDashedMaterial.prototype.isLineDashedMaterial = true

	var Materials = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ShadowMaterial: ShadowMaterial,
		SpriteMaterial: SpriteMaterial,
		RawShaderMaterial: RawShaderMaterial,
		ShaderMaterial: ShaderMaterial,
		PointsMaterial: PointsMaterial,
		MeshPhysicalMaterial: MeshPhysicalMaterial,
		MeshStandardMaterial: MeshStandardMaterial,
		MeshPhongMaterial: MeshPhongMaterial,
		MeshToonMaterial: MeshToonMaterial,
		MeshNormalMaterial: MeshNormalMaterial,
		MeshLambertMaterial: MeshLambertMaterial,
		MeshDepthMaterial: MeshDepthMaterial,
		MeshDistanceMaterial: MeshDistanceMaterial,
		MeshBasicMaterial: MeshBasicMaterial,
		MeshMatcapMaterial: MeshMatcapMaterial,
		LineDashedMaterial: LineDashedMaterial,
		LineBasicMaterial: LineBasicMaterial,
		Material: Material
	})

	const AnimationUtils = {

		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function (array, from, to) {

			if (AnimationUtils.isTypedArray(array)) {

				// in ios9 array.subarray(from, undefined) will return empty array
				// but array.subarray(from) or array.subarray(from, len) is correct
				return new array.constructor(array.subarray(from, to !== undefined ? to : array.length))

			}

			return array.slice(from, to)

		},

		// converts an array to a specific type
		convertArray: function (array, type, forceClone) {

			if (!array || // let 'undefined' and 'null' pass
				!forceClone && array.constructor === type) return array

			if (typeof type.BYTES_PER_ELEMENT === 'number') {

				return new type(array) // create typed array

			}

			return Array.prototype.slice.call(array) // create Array

		},

		isTypedArray: function (object) {

			return ArrayBuffer.isView(object) &&
				!(object instanceof DataView)

		},

		// returns an array by which times and values can be sorted
		getKeyframeOrder: function (times) {

			function compareTime (i, j) {

				return times[i] - times[j]

			}

			const n = times.length
			const result = new Array(n)
			for (let i = 0; i !== n; ++i) result[i] = i

			result.sort(compareTime)

			return result

		},

		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function (values, stride, order) {

			const nValues = values.length
			const result = new values.constructor(nValues)

			for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {

				const srcOffset = order[i] * stride

				for (let j = 0; j !== stride; ++j) {

					result[dstOffset++] = values[srcOffset + j]

				}

			}

			return result

		},

		// function for parsing AOS keyframe formats
		flattenJSON: function (jsonKeys, times, values, valuePropertyName) {

			let i = 1, key = jsonKeys[0]

			while (key !== undefined && key[valuePropertyName] === undefined) {

				key = jsonKeys[i++]

			}

			if (key === undefined) return // no data

			let value = key[valuePropertyName]
			if (value === undefined) return // no data

			if (Array.isArray(value)) {

				do {

					value = key[valuePropertyName]

					if (value !== undefined) {

						times.push(key.time)
						values.push.apply(values, value) // push all elements

					}

					key = jsonKeys[i++]

				} while (key !== undefined)

			} else if (value.toArray !== undefined) {

				// ...assume THREE.Math-ish

				do {

					value = key[valuePropertyName]

					if (value !== undefined) {

						times.push(key.time)
						value.toArray(values, values.length)

					}

					key = jsonKeys[i++]

				} while (key !== undefined)

			} else {

				// otherwise push as-is

				do {

					value = key[valuePropertyName]

					if (value !== undefined) {

						times.push(key.time)
						values.push(value)

					}

					key = jsonKeys[i++]

				} while (key !== undefined)

			}

		},

		subclip: function (sourceClip, name, startFrame, endFrame, fps = 30) {

			const clip = sourceClip.clone()

			clip.name = name

			const tracks = []

			for (let i = 0; i < clip.tracks.length; ++i) {

				const track = clip.tracks[i]
				const valueSize = track.getValueSize()

				const times = []
				const values = []

				for (let j = 0; j < track.times.length; ++j) {

					const frame = track.times[j] * fps

					if (frame < startFrame || frame >= endFrame) continue

					times.push(track.times[j])

					for (let k = 0; k < valueSize; ++k) {

						values.push(track.values[j * valueSize + k])

					}

				}

				if (times.length === 0) continue

				track.times = AnimationUtils.convertArray(times, track.times.constructor)
				track.values = AnimationUtils.convertArray(values, track.values.constructor)

				tracks.push(track)

			}

			clip.tracks = tracks

			// find minimum .times value across all tracks in the trimmed clip

			let minStartTime = Infinity

			for (let i = 0; i < clip.tracks.length; ++i) {

				if (minStartTime > clip.tracks[i].times[0]) {

					minStartTime = clip.tracks[i].times[0]

				}

			}

			// shift all tracks such that clip begins at t=0

			for (let i = 0; i < clip.tracks.length; ++i) {

				clip.tracks[i].shift(- 1 * minStartTime)

			}

			clip.resetDuration()

			return clip

		},

		makeClipAdditive: function (targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {

			if (fps <= 0) fps = 30

			const numTracks = referenceClip.tracks.length
			const referenceTime = referenceFrame / fps

			// Make each track's values relative to the values at the reference frame
			for (let i = 0; i < numTracks; ++i) {

				const referenceTrack = referenceClip.tracks[i]
				const referenceTrackType = referenceTrack.ValueTypeName

				// Skip this track if it's non-numeric
				if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue

				// Find the track in the target clip whose name and type matches the reference track
				const targetTrack = targetClip.tracks.find(function (track) {

					return track.name === referenceTrack.name
						&& track.ValueTypeName === referenceTrackType

				})

				if (targetTrack === undefined) continue

				let referenceOffset = 0
				const referenceValueSize = referenceTrack.getValueSize()

				if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {

					referenceOffset = referenceValueSize / 3

				}

				let targetOffset = 0
				const targetValueSize = targetTrack.getValueSize()

				if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {

					targetOffset = targetValueSize / 3

				}

				const lastIndex = referenceTrack.times.length - 1
				let referenceValue

				// Find the value to subtract out of the track
				if (referenceTime <= referenceTrack.times[0]) {

					// Reference frame is earlier than the first keyframe, so just use the first keyframe
					const startIndex = referenceOffset
					const endIndex = referenceValueSize - referenceOffset
					referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex)

				} else if (referenceTime >= referenceTrack.times[lastIndex]) {

					// Reference frame is after the last keyframe, so just use the last keyframe
					const startIndex = lastIndex * referenceValueSize + referenceOffset
					const endIndex = startIndex + referenceValueSize - referenceOffset
					referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex)

				} else {

					// Interpolate to the reference value
					const interpolant = referenceTrack.createInterpolant()
					const startIndex = referenceOffset
					const endIndex = referenceValueSize - referenceOffset
					interpolant.evaluate(referenceTime)
					referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex)

				}

				// Conjugate the quaternion
				if (referenceTrackType === 'quaternion') {

					const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate()
					referenceQuat.toArray(referenceValue)

				}

				// Subtract the reference value from all of the track values

				const numTimes = targetTrack.times.length
				for (let j = 0; j < numTimes; ++j) {

					const valueStart = j * targetValueSize + targetOffset

					if (referenceTrackType === 'quaternion') {

						// Multiply the conjugate for quaternion track types
						Quaternion.multiplyQuaternionsFlat(
							targetTrack.values,
							valueStart,
							referenceValue,
							0,
							targetTrack.values,
							valueStart
						)

					} else {

						const valueEnd = targetValueSize - targetOffset * 2

						// Subtract each value for all other numeric track types
						for (let k = 0; k < valueEnd; ++k) {

							targetTrack.values[valueStart + k] -= referenceValue[k]

						}

					}

				}

			}

			targetClip.blendMode = AdditiveAnimationBlendMode

			return targetClip

		}

	}

	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 */

	class Interpolant {

		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {

			this.parameterPositions = parameterPositions
			this._cachedIndex = 0

			this.resultBuffer = resultBuffer !== undefined ?
				resultBuffer : new sampleValues.constructor(sampleSize)
			this.sampleValues = sampleValues
			this.valueSize = sampleSize

			this.settings = null
			this.DefaultSettings_ = {}

		}

		evaluate (t) {

			const pp = this.parameterPositions
			let i1 = this._cachedIndex,
				t1 = pp[i1],
				t0 = pp[i1 - 1]

			validate_interval: {

				seek: {

					let right

					linear_scan: {

						//- See http://jsperf.com/comparison-to-undefined/3
						//- slower code:
						//-
						//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if (!(t < t1)) {

							for (let giveUpAt = i1 + 2; ;) {

								if (t1 === undefined) {

									if (t < t0) break forward_scan

									// after end

									i1 = pp.length
									this._cachedIndex = i1
									return this.afterEnd_(i1 - 1, t, t0)

								}

								if (i1 === giveUpAt) break // this loop

								t0 = t1
								t1 = pp[++i1]

								if (t < t1) {

									// we have arrived at the sought interval
									break seek

								}

							}

							// prepare binary search on the right side of the index
							right = pp.length
							break linear_scan

						}

						//- slower code:
						//-					if ( t < t0 || t0 === undefined ) {
						if (!(t >= t0)) {

							// looping?

							const t1global = pp[1]

							if (t < t1global) {

								i1 = 2 // + 1, using the scan for the details
								t0 = t1global

							}

							// linear reverse scan

							for (let giveUpAt = i1 - 2; ;) {

								if (t0 === undefined) {

									// before start

									this._cachedIndex = 0
									return this.beforeStart_(0, t, t1)

								}

								if (i1 === giveUpAt) break // this loop

								t1 = t0
								t0 = pp[--i1 - 1]

								if (t >= t0) {

									// we have arrived at the sought interval
									break seek

								}

							}

							// prepare binary search on the left side of the index
							right = i1
							i1 = 0
							break linear_scan

						}

						// the interval is valid

						break validate_interval

					} // linear scan

					// binary search

					while (i1 < right) {

						const mid = (i1 + right) >>> 1

						if (t < pp[mid]) {

							right = mid

						} else {

							i1 = mid + 1

						}

					}

					t1 = pp[i1]
					t0 = pp[i1 - 1]

					// check boundary cases, again

					if (t0 === undefined) {

						this._cachedIndex = 0
						return this.beforeStart_(0, t, t1)

					}

					if (t1 === undefined) {

						i1 = pp.length
						this._cachedIndex = i1
						return this.afterEnd_(i1 - 1, t0, t)

					}

				} // seek

				this._cachedIndex = i1

				this.intervalChanged_(i1, t0, t1)

			} // validate_interval

			return this.interpolate_(i1, t0, t, t1)

		}

		getSettings_ () {

			return this.settings || this.DefaultSettings_

		}

		copySampleValue_ (index) {

			// copies a sample value to the result buffer

			const result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
				offset = index * stride

			for (let i = 0; i !== stride; ++i) {

				result[i] = values[offset + i]

			}

			return result

		}

		// Template methods for derived classes:

		interpolate_ ( /* i1, t0, t, t1 */) {

			throw new Error('call to abstract method')
			// implementations shall return this.resultBuffer

		}

		intervalChanged_ ( /* i1, t0, t1 */) {

			// empty

		}

	}

	// ALIAS DEFINITIONS

	Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_
	Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_

	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 */

	class CubicInterpolant extends Interpolant {

		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {

			super(parameterPositions, sampleValues, sampleSize, resultBuffer)

			this._weightPrev = - 0
			this._offsetPrev = - 0
			this._weightNext = - 0
			this._offsetNext = - 0

			this.DefaultSettings_ = {

				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding

			}

		}

		intervalChanged_ (i1, t0, t1) {

			const pp = this.parameterPositions
			let iPrev = i1 - 2,
				iNext = i1 + 1,

				tPrev = pp[iPrev],
				tNext = pp[iNext]

			if (tPrev === undefined) {

				switch (this.getSettings_().endingStart) {

					case ZeroSlopeEnding:

						// f'(t0) = 0
						iPrev = i1
						tPrev = 2 * t0 - t1

						break

					case WrapAroundEnding:

						// use the other end of the curve
						iPrev = pp.length - 2
						tPrev = t0 + pp[iPrev] - pp[iPrev + 1]

						break

					default: // ZeroCurvatureEnding

						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1
						tPrev = t1

				}

			}

			if (tNext === undefined) {

				switch (this.getSettings_().endingEnd) {

					case ZeroSlopeEnding:

						// f'(tN) = 0
						iNext = i1
						tNext = 2 * t1 - t0

						break

					case WrapAroundEnding:

						// use the other end of the curve
						iNext = 1
						tNext = t1 + pp[1] - pp[0]

						break

					default: // ZeroCurvatureEnding

						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1
						tNext = t0

				}

			}

			const halfDt = (t1 - t0) * 0.5,
				stride = this.valueSize

			this._weightPrev = halfDt / (t0 - tPrev)
			this._weightNext = halfDt / (tNext - t1)
			this._offsetPrev = iPrev * stride
			this._offsetNext = iNext * stride

		}

		interpolate_ (i1, t0, t, t1) {

			const result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				o1 = i1 * stride, o0 = o1 - stride,
				oP = this._offsetPrev, oN = this._offsetNext,
				wP = this._weightPrev, wN = this._weightNext,

				p = (t - t0) / (t1 - t0),
				pp = p * p,
				ppp = pp * p

			// evaluate polynomials

			const sP = - wP * ppp + 2 * wP * pp - wP * p
			const s0 = (1 + wP) * ppp + (- 1.5 - 2 * wP) * pp + (- 0.5 + wP) * p + 1
			const s1 = (- 1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p
			const sN = wN * ppp - wN * pp

			// combine data linearly

			for (let i = 0; i !== stride; ++i) {

				result[i] =
					sP * values[oP + i] +
					s0 * values[o0 + i] +
					s1 * values[o1 + i] +
					sN * values[oN + i]

			}

			return result

		}

	}

	class LinearInterpolant extends Interpolant {

		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {

			super(parameterPositions, sampleValues, sampleSize, resultBuffer)

		}

		interpolate_ (i1, t0, t, t1) {

			const result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				offset1 = i1 * stride,
				offset0 = offset1 - stride,

				weight1 = (t - t0) / (t1 - t0),
				weight0 = 1 - weight1

			for (let i = 0; i !== stride; ++i) {

				result[i] =
					values[offset0 + i] * weight0 +
					values[offset1 + i] * weight1

			}

			return result

		}

	}

	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 */

	class DiscreteInterpolant extends Interpolant {

		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {

			super(parameterPositions, sampleValues, sampleSize, resultBuffer)

		}

		interpolate_ (i1 /*, t0, t, t1 */) {

			return this.copySampleValue_(i1 - 1)

		}

	}

	class KeyframeTrack {

		constructor(name, times, values, interpolation) {

			if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined')
			if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name)

			this.name = name

			this.times = AnimationUtils.convertArray(times, this.TimeBufferType)
			this.values = AnimationUtils.convertArray(values, this.ValueBufferType)

			this.setInterpolation(interpolation || this.DefaultInterpolation)

		}

		// Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):

		static toJSON (track) {

			const trackType = track.constructor

			let json

			// derived classes can define a static toJSON method
			if (trackType.toJSON !== this.toJSON) {

				json = trackType.toJSON(track)

			} else {

				// by default, we assume the data can be serialized as-is
				json = {

					'name': track.name,
					'times': AnimationUtils.convertArray(track.times, Array),
					'values': AnimationUtils.convertArray(track.values, Array)

				}

				const interpolation = track.getInterpolation()

				if (interpolation !== track.DefaultInterpolation) {

					json.interpolation = interpolation

				}

			}

			json.type = track.ValueTypeName // mandatory

			return json

		}

		InterpolantFactoryMethodDiscrete (result) {

			return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result)

		}

		InterpolantFactoryMethodLinear (result) {

			return new LinearInterpolant(this.times, this.values, this.getValueSize(), result)

		}

		InterpolantFactoryMethodSmooth (result) {

			return new CubicInterpolant(this.times, this.values, this.getValueSize(), result)

		}

		setInterpolation (interpolation) {

			let factoryMethod

			switch (interpolation) {

				case InterpolateDiscrete:

					factoryMethod = this.InterpolantFactoryMethodDiscrete

					break

				case InterpolateLinear:

					factoryMethod = this.InterpolantFactoryMethodLinear

					break

				case InterpolateSmooth:

					factoryMethod = this.InterpolantFactoryMethodSmooth

					break

			}

			if (factoryMethod === undefined) {

				const message = 'unsupported interpolation for ' +
					this.ValueTypeName + ' keyframe track named ' + this.name

				if (this.createInterpolant === undefined) {

					// fall back to default, unless the default itself is messed up
					if (interpolation !== this.DefaultInterpolation) {

						this.setInterpolation(this.DefaultInterpolation)

					} else {

						throw new Error(message) // fatal, in this case

					}

				}

				console.warn('THREE.KeyframeTrack:', message)
				return this

			}

			this.createInterpolant = factoryMethod

			return this

		}

		getInterpolation () {

			switch (this.createInterpolant) {

				case this.InterpolantFactoryMethodDiscrete:

					return InterpolateDiscrete

				case this.InterpolantFactoryMethodLinear:

					return InterpolateLinear

				case this.InterpolantFactoryMethodSmooth:

					return InterpolateSmooth

			}

		}

		getValueSize () {

			return this.values.length / this.times.length

		}

		// move all keyframes either forwards or backwards in time
		shift (timeOffset) {

			if (timeOffset !== 0.0) {

				const times = this.times

				for (let i = 0, n = times.length; i !== n; ++i) {

					times[i] += timeOffset

				}

			}

			return this

		}

		// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
		scale (timeScale) {

			if (timeScale !== 1.0) {

				const times = this.times

				for (let i = 0, n = times.length; i !== n; ++i) {

					times[i] *= timeScale

				}

			}

			return this

		}

		// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
		trim (startTime, endTime) {

			const times = this.times,
				nKeys = times.length

			let from = 0,
				to = nKeys - 1

			while (from !== nKeys && times[from] < startTime) {

				++from

			}

			while (to !== - 1 && times[to] > endTime) {

				--to

			}

			++to // inclusive -> exclusive bound

			if (from !== 0 || to !== nKeys) {

				// empty tracks are forbidden, so keep at least one keyframe
				if (from >= to) {

					to = Math.max(to, 1)
					from = to - 1

				}

				const stride = this.getValueSize()
				this.times = AnimationUtils.arraySlice(times, from, to)
				this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride)

			}

			return this

		}

		// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
		validate () {

			let valid = true

			const valueSize = this.getValueSize()
			if (valueSize - Math.floor(valueSize) !== 0) {

				console.error('THREE.KeyframeTrack: Invalid value size in track.', this)
				valid = false

			}

			const times = this.times,
				values = this.values,

				nKeys = times.length

			if (nKeys === 0) {

				console.error('THREE.KeyframeTrack: Track is empty.', this)
				valid = false

			}

			let prevTime = null

			for (let i = 0; i !== nKeys; i++) {

				const currTime = times[i]

				if (typeof currTime === 'number' && isNaN(currTime)) {

					console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime)
					valid = false
					break

				}

				if (prevTime !== null && prevTime > currTime) {

					console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime)
					valid = false
					break

				}

				prevTime = currTime

			}

			if (values !== undefined) {

				if (AnimationUtils.isTypedArray(values)) {

					for (let i = 0, n = values.length; i !== n; ++i) {

						const value = values[i]

						if (isNaN(value)) {

							console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value)
							valid = false
							break

						}

					}

				}

			}

			return valid

		}

		// removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
		optimize () {

			// times or values may be shared with other tracks, so overwriting is unsafe
			const times = AnimationUtils.arraySlice(this.times),
				values = AnimationUtils.arraySlice(this.values),
				stride = this.getValueSize(),

				smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

				lastIndex = times.length - 1

			let writeIndex = 1

			for (let i = 1; i < lastIndex; ++i) {

				let keep = false

				const time = times[i]
				const timeNext = times[i + 1]

				// remove adjacent keyframes scheduled at the same time

				if (time !== timeNext && (i !== 1 || time !== times[0])) {

					if (!smoothInterpolation) {

						// remove unnecessary keyframes same as their neighbors

						const offset = i * stride,
							offsetP = offset - stride,
							offsetN = offset + stride

						for (let j = 0; j !== stride; ++j) {

							const value = values[offset + j]

							if (value !== values[offsetP + j] ||
								value !== values[offsetN + j]) {

								keep = true
								break

							}

						}

					} else {

						keep = true

					}

				}

				// in-place compaction

				if (keep) {

					if (i !== writeIndex) {

						times[writeIndex] = times[i]

						const readOffset = i * stride,
							writeOffset = writeIndex * stride

						for (let j = 0; j !== stride; ++j) {

							values[writeOffset + j] = values[readOffset + j]

						}

					}

					++writeIndex

				}

			}

			// flush last keyframe (compaction looks ahead)

			if (lastIndex > 0) {

				times[writeIndex] = times[lastIndex]

				for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {

					values[writeOffset + j] = values[readOffset + j]

				}

				++writeIndex

			}

			if (writeIndex !== times.length) {

				this.times = AnimationUtils.arraySlice(times, 0, writeIndex)
				this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride)

			} else {

				this.times = times
				this.values = values

			}

			return this

		}

		clone () {

			const times = AnimationUtils.arraySlice(this.times, 0)
			const values = AnimationUtils.arraySlice(this.values, 0)

			const TypedKeyframeTrack = this.constructor
			const track = new TypedKeyframeTrack(this.name, times, values)

			// Interpolant argument to constructor is not saved, so copy the factory method directly.
			track.createInterpolant = this.createInterpolant

			return track

		}

	}

	KeyframeTrack.prototype.TimeBufferType = Float32Array
	KeyframeTrack.prototype.ValueBufferType = Float32Array
	KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear

	/**
	 * A Track of Boolean keyframe values.
	 */
	class BooleanKeyframeTrack extends KeyframeTrack { }

	BooleanKeyframeTrack.prototype.ValueTypeName = 'bool'
	BooleanKeyframeTrack.prototype.ValueBufferType = Array
	BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete
	BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined
	BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined

	/**
	 * A Track of keyframe values that represent color.
	 */
	class ColorKeyframeTrack extends KeyframeTrack { }

	ColorKeyframeTrack.prototype.ValueTypeName = 'color'

	/**
	 * A Track of numeric keyframe values.
	 */
	class NumberKeyframeTrack extends KeyframeTrack { }

	NumberKeyframeTrack.prototype.ValueTypeName = 'number'

	/**
	 * Spherical linear unit quaternion interpolant.
	 */

	class QuaternionLinearInterpolant extends Interpolant {

		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {

			super(parameterPositions, sampleValues, sampleSize, resultBuffer)

		}

		interpolate_ (i1, t0, t, t1) {

			const result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				alpha = (t - t0) / (t1 - t0)

			let offset = i1 * stride

			for (let end = offset + stride; offset !== end; offset += 4) {

				Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha)

			}

			return result

		}

	}

	/**
	 * A Track of quaternion keyframe values.
	 */
	class QuaternionKeyframeTrack extends KeyframeTrack {

		InterpolantFactoryMethodLinear (result) {

			return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result)

		}

	}

	QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion'
	// ValueBufferType is inherited
	QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear
	QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined

	/**
	 * A Track that interpolates Strings
	 */
	class StringKeyframeTrack extends KeyframeTrack { }

	StringKeyframeTrack.prototype.ValueTypeName = 'string'
	StringKeyframeTrack.prototype.ValueBufferType = Array
	StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete
	StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined
	StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined

	/**
	 * A Track of vectored keyframe values.
	 */
	class VectorKeyframeTrack extends KeyframeTrack { }

	VectorKeyframeTrack.prototype.ValueTypeName = 'vector'

	class AnimationClip {

		constructor(name, duration = - 1, tracks, blendMode = NormalAnimationBlendMode) {

			this.name = name
			this.tracks = tracks
			this.duration = duration
			this.blendMode = blendMode

			this.uuid = generateUUID()

			// this means it should figure out its duration by scanning the tracks
			if (this.duration < 0) {

				this.resetDuration()

			}

		}


		static parse (json) {

			const tracks = [],
				jsonTracks = json.tracks,
				frameTime = 1.0 / (json.fps || 1.0)

			for (let i = 0, n = jsonTracks.length; i !== n; ++i) {

				tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime))

			}

			const clip = new this(json.name, json.duration, tracks, json.blendMode)
			clip.uuid = json.uuid

			return clip

		}

		static toJSON (clip) {

			const tracks = [],
				clipTracks = clip.tracks

			const json = {

				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks,
				'uuid': clip.uuid,
				'blendMode': clip.blendMode

			}

			for (let i = 0, n = clipTracks.length; i !== n; ++i) {

				tracks.push(KeyframeTrack.toJSON(clipTracks[i]))

			}

			return json

		}

		static CreateFromMorphTargetSequence (name, morphTargetSequence, fps, noLoop) {

			const numMorphTargets = morphTargetSequence.length
			const tracks = []

			for (let i = 0; i < numMorphTargets; i++) {

				let times = []
				let values = []

				times.push(
					(i + numMorphTargets - 1) % numMorphTargets,
					i,
					(i + 1) % numMorphTargets)

				values.push(0, 1, 0)

				const order = AnimationUtils.getKeyframeOrder(times)
				times = AnimationUtils.sortedArray(times, 1, order)
				values = AnimationUtils.sortedArray(values, 1, order)

				// if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.
				if (!noLoop && times[0] === 0) {

					times.push(numMorphTargets)
					values.push(values[0])

				}

				tracks.push(
					new NumberKeyframeTrack(
						'.morphTargetInfluences[' + morphTargetSequence[i].name + ']',
						times, values
					).scale(1.0 / fps))

			}

			return new this(name, - 1, tracks)

		}

		static findByName (objectOrClipArray, name) {

			let clipArray = objectOrClipArray

			if (!Array.isArray(objectOrClipArray)) {

				const o = objectOrClipArray
				clipArray = o.geometry && o.geometry.animations || o.animations

			}

			for (let i = 0; i < clipArray.length; i++) {

				if (clipArray[i].name === name) {

					return clipArray[i]

				}

			}

			return null

		}

		static CreateClipsFromMorphTargetSequences (morphTargets, fps, noLoop) {

			const animationToMorphTargets = {}

			// tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
			const pattern = /^([\w-]*?)([\d]+)$/

			// sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002
			for (let i = 0, il = morphTargets.length; i < il; i++) {

				const morphTarget = morphTargets[i]
				const parts = morphTarget.name.match(pattern)

				if (parts && parts.length > 1) {

					const name = parts[1]

					let animationMorphTargets = animationToMorphTargets[name]

					if (!animationMorphTargets) {

						animationToMorphTargets[name] = animationMorphTargets = []

					}

					animationMorphTargets.push(morphTarget)

				}

			}

			const clips = []

			for (const name in animationToMorphTargets) {

				clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop))

			}

			return clips

		}

		// parse the animation.hierarchy format
		static parseAnimation (animation, bones) {

			if (!animation) {

				console.error('THREE.AnimationClip: No animation in JSONLoader data.')
				return null

			}

			const addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {

				// only return track if there are actually keys.
				if (animationKeys.length !== 0) {

					const times = []
					const values = []

					AnimationUtils.flattenJSON(animationKeys, times, values, propertyName)

					// empty keys are filtered out, so check again
					if (times.length !== 0) {

						destTracks.push(new trackType(trackName, times, values))

					}

				}

			}

			const tracks = []

			const clipName = animation.name || 'default'
			const fps = animation.fps || 30
			const blendMode = animation.blendMode

			// automatic length determination in AnimationClip.
			let duration = animation.length || - 1

			const hierarchyTracks = animation.hierarchy || []

			for (let h = 0; h < hierarchyTracks.length; h++) {

				const animationKeys = hierarchyTracks[h].keys

				// skip empty tracks
				if (!animationKeys || animationKeys.length === 0) continue

				// process morph targets
				if (animationKeys[0].morphTargets) {

					// figure out all morph targets used in this track
					const morphTargetNames = {}

					let k

					for (k = 0; k < animationKeys.length; k++) {

						if (animationKeys[k].morphTargets) {

							for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {

								morphTargetNames[animationKeys[k].morphTargets[m]] = - 1

							}

						}

					}

					// create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.
					for (const morphTargetName in morphTargetNames) {

						const times = []
						const values = []

						for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {

							const animationKey = animationKeys[k]

							times.push(animationKey.time)
							values.push((animationKey.morphTarget === morphTargetName) ? 1 : 0)

						}

						tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values))

					}

					duration = morphTargetNames.length * (fps || 1.0)

				} else {

					// ...assume skeletal animation

					const boneName = '.bones[' + bones[h].name + ']'

					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.position',
						animationKeys, 'pos', tracks)

					addNonemptyTrack(
						QuaternionKeyframeTrack, boneName + '.quaternion',
						animationKeys, 'rot', tracks)

					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.scale',
						animationKeys, 'scl', tracks)

				}

			}

			if (tracks.length === 0) {

				return null

			}

			const clip = new this(clipName, duration, tracks, blendMode)

			return clip

		}

		resetDuration () {

			const tracks = this.tracks
			let duration = 0

			for (let i = 0, n = tracks.length; i !== n; ++i) {

				const track = this.tracks[i]

				duration = Math.max(duration, track.times[track.times.length - 1])

			}

			this.duration = duration

			return this

		}

		trim () {

			for (let i = 0; i < this.tracks.length; i++) {

				this.tracks[i].trim(0, this.duration)

			}

			return this

		}

		validate () {

			let valid = true

			for (let i = 0; i < this.tracks.length; i++) {

				valid = valid && this.tracks[i].validate()

			}

			return valid

		}

		optimize () {

			for (let i = 0; i < this.tracks.length; i++) {

				this.tracks[i].optimize()

			}

			return this

		}

		clone () {

			const tracks = []

			for (let i = 0; i < this.tracks.length; i++) {

				tracks.push(this.tracks[i].clone())

			}

			return new this.constructor(this.name, this.duration, tracks, this.blendMode)

		}

		toJSON () {

			return this.constructor.toJSON(this)

		}

	}

	function getTrackTypeForValueTypeName (typeName) {

		switch (typeName.toLowerCase()) {

			case 'scalar':
			case 'double':
			case 'float':
			case 'number':
			case 'integer':

				return NumberKeyframeTrack

			case 'vector':
			case 'vector2':
			case 'vector3':
			case 'vector4':

				return VectorKeyframeTrack

			case 'color':

				return ColorKeyframeTrack

			case 'quaternion':

				return QuaternionKeyframeTrack

			case 'bool':
			case 'boolean':

				return BooleanKeyframeTrack

			case 'string':

				return StringKeyframeTrack

		}

		throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName)

	}

	function parseKeyframeTrack (json) {

		if (json.type === undefined) {

			throw new Error('THREE.KeyframeTrack: track type undefined, can not parse')

		}

		const trackType = getTrackTypeForValueTypeName(json.type)

		if (json.times === undefined) {

			const times = [], values = []

			AnimationUtils.flattenJSON(json.keys, times, values, 'value')

			json.times = times
			json.values = values

		}

		// derived classes can define a static parse method
		if (trackType.parse !== undefined) {

			return trackType.parse(json)

		} else {

			// by default, we assume a constructor compatible with the base
			return new trackType(json.name, json.times, json.values, json.interpolation)

		}

	}

	const Cache = {

		enabled: false,

		files: {},

		add: function (key, file) {

			if (this.enabled === false) return

			// console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[key] = file

		},

		get: function (key) {

			if (this.enabled === false) return

			// console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[key]

		},

		remove: function (key) {

			delete this.files[key]

		},

		clear: function () {

			this.files = {}

		}

	}

	class LoadingManager {

		constructor(onLoad, onProgress, onError) {

			const scope = this

			let isLoading = false
			let itemsLoaded = 0
			let itemsTotal = 0
			let urlModifier = undefined
			const handlers = []

			// Refer to #5689 for the reason why we don't set .onStart
			// in the constructor

			this.onStart = undefined
			this.onLoad = onLoad
			this.onProgress = onProgress
			this.onError = onError

			this.itemStart = function (url) {

				itemsTotal++

				if (isLoading === false) {

					if (scope.onStart !== undefined) {

						scope.onStart(url, itemsLoaded, itemsTotal)

					}

				}

				isLoading = true

			}

			this.itemEnd = function (url) {

				itemsLoaded++

				if (scope.onProgress !== undefined) {

					scope.onProgress(url, itemsLoaded, itemsTotal)

				}

				if (itemsLoaded === itemsTotal) {

					isLoading = false

					if (scope.onLoad !== undefined) {

						scope.onLoad()

					}

				}

			}

			this.itemError = function (url) {

				if (scope.onError !== undefined) {

					scope.onError(url)

				}

			}

			this.resolveURL = function (url) {

				if (urlModifier) {

					return urlModifier(url)

				}

				return url

			}

			this.setURLModifier = function (transform) {

				urlModifier = transform

				return this

			}

			this.addHandler = function (regex, loader) {

				handlers.push(regex, loader)

				return this

			}

			this.removeHandler = function (regex) {

				const index = handlers.indexOf(regex)

				if (index !== - 1) {

					handlers.splice(index, 2)

				}

				return this

			}

			this.getHandler = function (file) {

				for (let i = 0, l = handlers.length; i < l; i += 2) {

					const regex = handlers[i]
					const loader = handlers[i + 1]

					if (regex.global) regex.lastIndex = 0 // see #17920

					if (regex.test(file)) {

						return loader

					}

				}

				return null

			}

		}

	}

	const DefaultLoadingManager = new LoadingManager()

	class Loader {

		constructor(manager) {

			this.manager = (manager !== undefined) ? manager : DefaultLoadingManager

			this.crossOrigin = 'anonymous'
			this.withCredentials = false
			this.path = ''
			this.resourcePath = ''
			this.requestHeader = {}

		}

		load ( /* url, onLoad, onProgress, onError */) { }

		loadAsync (url, onProgress) {

			const scope = this

			return new Promise(function (resolve, reject) {

				scope.load(url, resolve, onProgress, reject)

			})

		}

		parse ( /* data */) { }

		setCrossOrigin (crossOrigin) {

			this.crossOrigin = crossOrigin
			return this

		}

		setWithCredentials (value) {

			this.withCredentials = value
			return this

		}

		setPath (path) {

			this.path = path
			return this

		}

		setResourcePath (resourcePath) {

			this.resourcePath = resourcePath
			return this

		}

		setRequestHeader (requestHeader) {

			this.requestHeader = requestHeader
			return this

		}

	}

	const loading = {}

	class FileLoader extends Loader {

		constructor(manager) {

			super(manager)

		}

		load (url, onLoad, onProgress, onError) {

			if (url === undefined) url = ''

			if (this.path !== undefined) url = this.path + url

			url = this.manager.resolveURL(url)

			const scope = this

			const cached = Cache.get(url)

			if (cached !== undefined) {

				scope.manager.itemStart(url)

				setTimeout(function () {

					if (onLoad) onLoad(cached)

					scope.manager.itemEnd(url)

				}, 0)

				return cached

			}

			// Check if request is duplicate

			if (loading[url] !== undefined) {

				loading[url].push({

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				})

				return

			}

			// Check for data: URI
			const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/
			const dataUriRegexResult = url.match(dataUriRegex)
			let request

			// Safari can not handle Data URIs through XMLHttpRequest so process manually
			if (dataUriRegexResult) {

				const mimeType = dataUriRegexResult[1]
				const isBase64 = !!dataUriRegexResult[2]

				let data = dataUriRegexResult[3]
				data = decodeURIComponent(data)

				if (isBase64) data = atob(data)

				try {

					let response
					const responseType = (this.responseType || '').toLowerCase()

					switch (responseType) {

						case 'arraybuffer':
						case 'blob':

							const view = new Uint8Array(data.length)

							for (let i = 0; i < data.length; i++) {

								view[i] = data.charCodeAt(i)

							}

							if (responseType === 'blob') {

								response = new Blob([view.buffer], { type: mimeType })

							} else {

								response = view.buffer

							}

							break

						case 'document':

							const parser = new DOMParser()
							response = parser.parseFromString(data, mimeType)

							break

						case 'json':

							response = JSON.parse(data)

							break

						default: // 'text' or other

							response = data

							break

					}

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout(function () {

						if (onLoad) onLoad(response)

						scope.manager.itemEnd(url)

					}, 0)

				} catch (error) {

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout(function () {

						if (onError) onError(error)

						scope.manager.itemError(url)
						scope.manager.itemEnd(url)

					}, 0)

				}

			} else {

				// Initialise array for duplicate requests

				loading[url] = []

				loading[url].push({

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				})

				request = new XMLHttpRequest()

				request.open('GET', url, true)

				request.addEventListener('load', function (event) {

					const response = this.response

					const callbacks = loading[url]

					delete loading[url]

					if (this.status === 200 || this.status === 0) {

						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.

						if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.')

						// Add to cache only on HTTP success, so that we do not cache
						// error response bodies as proper responses to requests.
						Cache.add(url, response)

						for (let i = 0, il = callbacks.length; i < il; i++) {

							const callback = callbacks[i]
							if (callback.onLoad) callback.onLoad(response)

						}

						scope.manager.itemEnd(url)

					} else {

						for (let i = 0, il = callbacks.length; i < il; i++) {

							const callback = callbacks[i]
							if (callback.onError) callback.onError(event)

						}

						scope.manager.itemError(url)
						scope.manager.itemEnd(url)

					}

				}, false)

				request.addEventListener('progress', function (event) {

					const callbacks = loading[url]

					for (let i = 0, il = callbacks.length; i < il; i++) {

						const callback = callbacks[i]
						if (callback.onProgress) callback.onProgress(event)

					}

				}, false)

				request.addEventListener('error', function (event) {

					const callbacks = loading[url]

					delete loading[url]

					for (let i = 0, il = callbacks.length; i < il; i++) {

						const callback = callbacks[i]
						if (callback.onError) callback.onError(event)

					}

					scope.manager.itemError(url)
					scope.manager.itemEnd(url)

				}, false)

				request.addEventListener('abort', function (event) {

					const callbacks = loading[url]

					delete loading[url]

					for (let i = 0, il = callbacks.length; i < il; i++) {

						const callback = callbacks[i]
						if (callback.onError) callback.onError(event)

					}

					scope.manager.itemError(url)
					scope.manager.itemEnd(url)

				}, false)

				if (this.responseType !== undefined) request.responseType = this.responseType
				if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials

				if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain')

				for (const header in this.requestHeader) {

					request.setRequestHeader(header, this.requestHeader[header])

				}

				request.send(null)

			}

			scope.manager.itemStart(url)

			return request

		}

		setResponseType (value) {

			this.responseType = value
			return this

		}

		setMimeType (value) {

			this.mimeType = value
			return this

		}

	}

	class AnimationLoader extends Loader {

		constructor(manager) {

			super(manager)

		}

		load (url, onLoad, onProgress, onError) {

			const scope = this

			const loader = new FileLoader(this.manager)
			loader.setPath(this.path)
			loader.setRequestHeader(this.requestHeader)
			loader.setWithCredentials(this.withCredentials)
			loader.load(url, function (text) {

				try {

					onLoad(scope.parse(JSON.parse(text)))

				} catch (e) {

					if (onError) {

						onError(e)

					} else {

						console.error(e)

					}

					scope.manager.itemError(url)

				}

			}, onProgress, onError)

		}

		parse (json) {

			const animations = []

			for (let i = 0; i < json.length; i++) {

				const clip = AnimationClip.parse(json[i])

				animations.push(clip)

			}

			return animations

		}

	}

	/**
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */

	class CompressedTextureLoader extends Loader {

		constructor(manager) {

			super(manager)

		}

		load (url, onLoad, onProgress, onError) {

			const scope = this

			const images = []

			const texture = new CompressedTexture()

			const loader = new FileLoader(this.manager)
			loader.setPath(this.path)
			loader.setResponseType('arraybuffer')
			loader.setRequestHeader(this.requestHeader)
			loader.setWithCredentials(scope.withCredentials)

			let loaded = 0

			function loadTexture (i) {

				loader.load(url[i], function (buffer) {

					const texDatas = scope.parse(buffer, true)

					images[i] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					}

					loaded += 1

					if (loaded === 6) {

						if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter

						texture.image = images
						texture.format = texDatas.format
						texture.needsUpdate = true

						if (onLoad) onLoad(texture)

					}

				}, onProgress, onError)

			}

			if (Array.isArray(url)) {

				for (let i = 0, il = url.length; i < il; ++i) {

					loadTexture(i)

				}

			} else {

				// compressed cubemap texture stored in a single DDS file

				loader.load(url, function (buffer) {

					const texDatas = scope.parse(buffer, true)

					if (texDatas.isCubemap) {

						const faces = texDatas.mipmaps.length / texDatas.mipmapCount

						for (let f = 0; f < faces; f++) {

							images[f] = { mipmaps: [] }

							for (let i = 0; i < texDatas.mipmapCount; i++) {

								images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i])
								images[f].format = texDatas.format
								images[f].width = texDatas.width
								images[f].height = texDatas.height

							}

						}

						texture.image = images

					} else {

						texture.image.width = texDatas.width
						texture.image.height = texDatas.height
						texture.mipmaps = texDatas.mipmaps

					}

					if (texDatas.mipmapCount === 1) {

						texture.minFilter = LinearFilter

					}

					texture.format = texDatas.format
					texture.needsUpdate = true

					if (onLoad) onLoad(texture)

				}, onProgress, onError)

			}

			return texture

		}

	}

	class ImageLoader extends Loader {

		constructor(manager) {

			super(manager)

		}

		load (url, onLoad, onProgress, onError) {

			if (this.path !== undefined) url = this.path + url

			url = this.manager.resolveURL(url)

			const scope = this

			const cached = Cache.get(url)

			if (cached !== undefined) {

				scope.manager.itemStart(url)

				setTimeout(function () {

					if (onLoad) onLoad(cached)

					scope.manager.itemEnd(url)

				}, 0)

				return cached

			}

			const image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img')

			function onImageLoad () {

				image.removeEventListener('load', onImageLoad, false)
				image.removeEventListener('error', onImageError, false)

				Cache.add(url, this)

				if (onLoad) onLoad(this)

				scope.manager.itemEnd(url)

			}

			function onImageError (event) {

				image.removeEventListener('load', onImageLoad, false)
				image.removeEventListener('error', onImageError, false)

				if (onError) onError(event)

				scope.manager.itemError(url)
				scope.manager.itemEnd(url)

			}

			image.addEventListener('load', onImageLoad, false)
			image.addEventListener('error', onImageError, false)

			if (url.substr(0, 5) !== 'data:') {

				if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin

			}

			scope.manager.itemStart(url)

			image.src = url

			return image

		}

	}

	class CubeTextureLoader extends Loader {

		constructor(manager) {

			super(manager)

		}

		load (urls, onLoad, onProgress, onError) {

			const texture = new CubeTexture()

			const loader = new ImageLoader(this.manager)
			loader.setCrossOrigin(this.crossOrigin)
			loader.setPath(this.path)

			let loaded = 0

			function loadTexture (i) {

				loader.load(urls[i], function (image) {

					texture.images[i] = image

					loaded++

					if (loaded === 6) {

						texture.needsUpdate = true

						if (onLoad) onLoad(texture)

					}

				}, undefined, onError)

			}

			for (let i = 0; i < urls.length; ++i) {

				loadTexture(i)

			}

			return texture

		}

	}

	/**
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */

	class DataTextureLoader extends Loader {

		constructor(manager) {

			super(manager)

		}

		load (url, onLoad, onProgress, onError) {

			const scope = this

			const texture = new DataTexture()

			const loader = new FileLoader(this.manager)
			loader.setResponseType('arraybuffer')
			loader.setRequestHeader(this.requestHeader)
			loader.setPath(this.path)
			loader.setWithCredentials(scope.withCredentials)
			loader.load(url, function (buffer) {

				const texData = scope.parse(buffer)

				if (!texData) return

				if (texData.image !== undefined) {

					texture.image = texData.image

				} else if (texData.data !== undefined) {

					texture.image.width = texData.width
					texture.image.height = texData.height
					texture.image.data = texData.data

				}

				texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping
				texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping

				texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter
				texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter

				texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1

				if (texData.encoding !== undefined) {

					texture.encoding = texData.encoding

				}

				if (texData.flipY !== undefined) {

					texture.flipY = texData.flipY

				}

				if (texData.format !== undefined) {

					texture.format = texData.format

				}

				if (texData.type !== undefined) {

					texture.type = texData.type

				}

				if (texData.mipmaps !== undefined) {

					texture.mipmaps = texData.mipmaps
					texture.minFilter = LinearMipmapLinearFilter // presumably...

				}

				if (texData.mipmapCount === 1) {

					texture.minFilter = LinearFilter

				}

				if (texData.generateMipmaps !== undefined) {

					texture.generateMipmaps = texData.generateMipmaps

				}

				texture.needsUpdate = true

				if (onLoad) onLoad(texture, texData)

			}, onProgress, onError)


			return texture

		}

	}

	class TextureLoader extends Loader {

		constructor(manager) {

			super(manager)

		}

		load (url, onLoad, onProgress, onError) {

			const texture = new Texture()

			const loader = new ImageLoader(this.manager)
			loader.setCrossOrigin(this.crossOrigin)
			loader.setPath(this.path)

			loader.load(url, function (image) {

				texture.image = image

				// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
				const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0

				texture.format = isJPEG ? RGBFormat : RGBAFormat
				texture.needsUpdate = true

				if (onLoad !== undefined) {

					onLoad(texture)

				}

			}, onProgress, onError)

			return texture

		}

	}

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/

	class CurvePath extends Curve {

		constructor() {

			super()

			this.type = 'CurvePath'

			this.curves = []
			this.autoClose = false // Automatically closes the path

		}

		add (curve) {

			this.curves.push(curve)

		}

		closePath () {

			// Add a line curve if start and end of lines are not connected
			const startPoint = this.curves[0].getPoint(0)
			const endPoint = this.curves[this.curves.length - 1].getPoint(1)

			if (!startPoint.equals(endPoint)) {

				this.curves.push(new LineCurve(endPoint, startPoint))

			}

		}

		// To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:

		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')

		getPoint (t) {

			const d = t * this.getLength()
			const curveLengths = this.getCurveLengths()
			let i = 0

			// To think about boundaries points.

			while (i < curveLengths.length) {

				if (curveLengths[i] >= d) {

					const diff = curveLengths[i] - d
					const curve = this.curves[i]

					const segmentLength = curve.getLength()
					const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength

					return curve.getPointAt(u)

				}

				i++

			}

			return null

			// loop where sum != 0, sum > d , sum+1 <d

		}

		// We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength

		getLength () {

			const lens = this.getCurveLengths()
			return lens[lens.length - 1]

		}

		// cacheLengths must be recalculated.
		updateArcLengths () {

			this.needsUpdate = true
			this.cacheLengths = null
			this.getCurveLengths()

		}

		// Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.

		getCurveLengths () {

			// We use cache values if curves and cache array are same length

			if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {

				return this.cacheLengths

			}

			// Get length of sub-curve
			// Push sums into cached array

			const lengths = []
			let sums = 0

			for (let i = 0, l = this.curves.length; i < l; i++) {

				sums += this.curves[i].getLength()
				lengths.push(sums)

			}

			this.cacheLengths = lengths

			return lengths

		}

		getSpacedPoints (divisions = 40) {

			const points = []

			for (let i = 0; i <= divisions; i++) {

				points.push(this.getPoint(i / divisions))

			}

			if (this.autoClose) {

				points.push(points[0])

			}

			return points

		}

		getPoints (divisions = 12) {

			const points = []
			let last

			for (let i = 0, curves = this.curves; i < curves.length; i++) {

				const curve = curves[i]
				const resolution = (curve && curve.isEllipseCurve) ? divisions * 2
					: (curve && (curve.isLineCurve || curve.isLineCurve3)) ? 1
						: (curve && curve.isSplineCurve) ? divisions * curve.points.length
							: divisions

				const pts = curve.getPoints(resolution)

				for (let j = 0; j < pts.length; j++) {

					const point = pts[j]

					if (last && last.equals(point)) continue // ensures no consecutive points are duplicates

					points.push(point)
					last = point

				}

			}

			if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {

				points.push(points[0])

			}

			return points

		}

		copy (source) {

			super.copy(source)

			this.curves = []

			for (let i = 0, l = source.curves.length; i < l; i++) {

				const curve = source.curves[i]

				this.curves.push(curve.clone())

			}

			this.autoClose = source.autoClose

			return this

		}

		toJSON () {

			const data = super.toJSON()

			data.autoClose = this.autoClose
			data.curves = []

			for (let i = 0, l = this.curves.length; i < l; i++) {

				const curve = this.curves[i]
				data.curves.push(curve.toJSON())

			}

			return data

		}

		fromJSON (json) {

			super.fromJSON(json)

			this.autoClose = json.autoClose
			this.curves = []

			for (let i = 0, l = json.curves.length; i < l; i++) {

				const curve = json.curves[i]
				this.curves.push(new Curves[curve.type]().fromJSON(curve))

			}

			return this

		}

	}

	class Path extends CurvePath {

		constructor(points) {

			super()
			this.type = 'Path'

			this.currentPoint = new Vector2()

			if (points) {

				this.setFromPoints(points)

			}

		}

		setFromPoints (points) {

			this.moveTo(points[0].x, points[0].y)

			for (let i = 1, l = points.length; i < l; i++) {

				this.lineTo(points[i].x, points[i].y)

			}

			return this

		}

		moveTo (x, y) {

			this.currentPoint.set(x, y) // TODO consider referencing vectors instead of copying?

			return this

		}

		lineTo (x, y) {

			const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y))
			this.curves.push(curve)

			this.currentPoint.set(x, y)

			return this

		}

		quadraticCurveTo (aCPx, aCPy, aX, aY) {

			const curve = new QuadraticBezierCurve(
				this.currentPoint.clone(),
				new Vector2(aCPx, aCPy),
				new Vector2(aX, aY)
			)

			this.curves.push(curve)

			this.currentPoint.set(aX, aY)

			return this

		}

		bezierCurveTo (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {

			const curve = new CubicBezierCurve(
				this.currentPoint.clone(),
				new Vector2(aCP1x, aCP1y),
				new Vector2(aCP2x, aCP2y),
				new Vector2(aX, aY)
			)

			this.curves.push(curve)

			this.currentPoint.set(aX, aY)

			return this

		}

		splineThru (pts /*Array of Vector*/) {

			const npts = [this.currentPoint.clone()].concat(pts)

			const curve = new SplineCurve(npts)
			this.curves.push(curve)

			this.currentPoint.copy(pts[pts.length - 1])

			return this

		}

		arc (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {

			const x0 = this.currentPoint.x
			const y0 = this.currentPoint.y

			this.absarc(aX + x0, aY + y0, aRadius,
				aStartAngle, aEndAngle, aClockwise)

			return this

		}

		absarc (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {

			this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise)

			return this

		}

		ellipse (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {

			const x0 = this.currentPoint.x
			const y0 = this.currentPoint.y

			this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation)

			return this

		}

		absellipse (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {

			const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation)

			if (this.curves.length > 0) {

				// if a previous curve is present, attempt to join
				const firstPoint = curve.getPoint(0)

				if (!firstPoint.equals(this.currentPoint)) {

					this.lineTo(firstPoint.x, firstPoint.y)

				}

			}

			this.curves.push(curve)

			const lastPoint = curve.getPoint(1)
			this.currentPoint.copy(lastPoint)

			return this

		}

		copy (source) {

			super.copy(source)

			this.currentPoint.copy(source.currentPoint)

			return this

		}

		toJSON () {

			const data = super.toJSON()

			data.currentPoint = this.currentPoint.toArray()

			return data

		}

		fromJSON (json) {

			super.fromJSON(json)

			this.currentPoint.fromArray(json.currentPoint)

			return this

		}

	}

	class Shape extends Path {

		constructor(points) {

			super(points)

			this.uuid = generateUUID()

			this.type = 'Shape'

			this.holes = []

		}

		getPointsHoles (divisions) {

			const holesPts = []

			for (let i = 0, l = this.holes.length; i < l; i++) {

				holesPts[i] = this.holes[i].getPoints(divisions)

			}

			return holesPts

		}

		// get points of shape and holes (keypoints based on segments parameter)

		extractPoints (divisions) {

			return {

				shape: this.getPoints(divisions),
				holes: this.getPointsHoles(divisions)

			}

		}

		copy (source) {

			super.copy(source)

			this.holes = []

			for (let i = 0, l = source.holes.length; i < l; i++) {

				const hole = source.holes[i]

				this.holes.push(hole.clone())

			}

			return this

		}

		toJSON () {

			const data = super.toJSON()

			data.uuid = this.uuid
			data.holes = []

			for (let i = 0, l = this.holes.length; i < l; i++) {

				const hole = this.holes[i]
				data.holes.push(hole.toJSON())

			}

			return data

		}

		fromJSON (json) {

			super.fromJSON(json)

			this.uuid = json.uuid
			this.holes = []

			for (let i = 0, l = json.holes.length; i < l; i++) {

				const hole = json.holes[i]
				this.holes.push(new Path().fromJSON(hole))

			}

			return this

		}

	}

	class Light extends Object3D {

		constructor(color, intensity = 1) {

			super()

			this.type = 'Light'

			this.color = new Color(color)
			this.intensity = intensity

		}

		dispose () {

			// Empty here in base class; some subclasses override.

		}

		copy (source) {

			super.copy(source)

			this.color.copy(source.color)
			this.intensity = source.intensity

			return this

		}

		toJSON (meta) {

			const data = super.toJSON(meta)

			data.object.color = this.color.getHex()
			data.object.intensity = this.intensity

			if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex()

			if (this.distance !== undefined) data.object.distance = this.distance
			if (this.angle !== undefined) data.object.angle = this.angle
			if (this.decay !== undefined) data.object.decay = this.decay
			if (this.penumbra !== undefined) data.object.penumbra = this.penumbra

			if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON()

			return data

		}

	}

	Light.prototype.isLight = true

	class HemisphereLight extends Light {

		constructor(skyColor, groundColor, intensity) {

			super(skyColor, intensity)

			this.type = 'HemisphereLight'

			this.position.copy(Object3D.DefaultUp)
			this.updateMatrix()

			this.groundColor = new Color(groundColor)

		}

		copy (source) {

			Light.prototype.copy.call(this, source)

			this.groundColor.copy(source.groundColor)

			return this

		}

	}

	HemisphereLight.prototype.isHemisphereLight = true

	const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4()
	const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3()
	const _lookTarget$1 = /*@__PURE__*/ new Vector3()

	class LightShadow {

		constructor(camera) {

			this.camera = camera

			this.bias = 0
			this.normalBias = 0
			this.radius = 1

			this.mapSize = new Vector2(512, 512)

			this.map = null
			this.mapPass = null
			this.matrix = new Matrix4()

			this.autoUpdate = true
			this.needsUpdate = false

			this._frustum = new Frustum()
			this._frameExtents = new Vector2(1, 1)

			this._viewportCount = 1

			this._viewports = [

				new Vector4(0, 0, 1, 1)

			]

		}

		getViewportCount () {

			return this._viewportCount

		}

		getFrustum () {

			return this._frustum

		}

		updateMatrices (light) {

			const shadowCamera = this.camera
			const shadowMatrix = this.matrix

			_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld)
			shadowCamera.position.copy(_lightPositionWorld$1)

			_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld)
			shadowCamera.lookAt(_lookTarget$1)
			shadowCamera.updateMatrixWorld()

			_projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse)
			this._frustum.setFromProjectionMatrix(_projScreenMatrix$1)

			shadowMatrix.set(
				0.5, 0.0, 0.0, 0.5,
				0.0, 0.5, 0.0, 0.5,
				0.0, 0.0, 0.5, 0.5,
				0.0, 0.0, 0.0, 1.0
			)

			shadowMatrix.multiply(shadowCamera.projectionMatrix)
			shadowMatrix.multiply(shadowCamera.matrixWorldInverse)

		}

		getViewport (viewportIndex) {

			return this._viewports[viewportIndex]

		}

		getFrameExtents () {

			return this._frameExtents

		}

		dispose () {

			if (this.map) {

				this.map.dispose()

			}

			if (this.mapPass) {

				this.mapPass.dispose()

			}

		}

		copy (source) {

			this.camera = source.camera.clone()

			this.bias = source.bias
			this.radius = source.radius

			this.mapSize.copy(source.mapSize)

			return this

		}

		clone () {

			return new this.constructor().copy(this)

		}

		toJSON () {

			const object = {}

			if (this.bias !== 0) object.bias = this.bias
			if (this.normalBias !== 0) object.normalBias = this.normalBias
			if (this.radius !== 1) object.radius = this.radius
			if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray()

			object.camera = this.camera.toJSON(false).object
			delete object.camera.matrix

			return object

		}

	}

	class SpotLightShadow extends LightShadow {

		constructor() {

			super(new PerspectiveCamera(50, 1, 0.5, 500))

			this.focus = 1

		}

		updateMatrices (light) {

			const camera = this.camera

			const fov = RAD2DEG * 2 * light.angle * this.focus
			const aspect = this.mapSize.width / this.mapSize.height
			const far = light.distance || camera.far

			if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {

				camera.fov = fov
				camera.aspect = aspect
				camera.far = far
				camera.updateProjectionMatrix()

			}

			super.updateMatrices(light)

		}

		copy (source) {

			super.copy(source)

			this.focus = source.focus

			return this

		}

	}

	SpotLightShadow.prototype.isSpotLightShadow = true

	class SpotLight extends Light {

		constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {

			super(color, intensity)

			this.type = 'SpotLight'

			this.position.copy(Object3D.DefaultUp)
			this.updateMatrix()

			this.target = new Object3D()

			this.distance = distance
			this.angle = angle
			this.penumbra = penumbra
			this.decay = decay // for physically correct lights, should be 2.

			this.shadow = new SpotLightShadow()

		}

		get power () {

			// intensity = power per solid angle.
			// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			return this.intensity * Math.PI

		}

		set power (power) {

			// intensity = power per solid angle.
			// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			this.intensity = power / Math.PI

		}

		dispose () {

			this.shadow.dispose()

		}

		copy (source) {

			super.copy(source)

			this.distance = source.distance
			this.angle = source.angle
			this.penumbra = source.penumbra
			this.decay = source.decay

			this.target = source.target.clone()

			this.shadow = source.shadow.clone()

			return this

		}

	}

	SpotLight.prototype.isSpotLight = true

	const _projScreenMatrix = /*@__PURE__*/ new Matrix4()
	const _lightPositionWorld = /*@__PURE__*/ new Vector3()
	const _lookTarget = /*@__PURE__*/ new Vector3()

	class PointLightShadow extends LightShadow {

		constructor() {

			super(new PerspectiveCamera(90, 1, 0.5, 500))

			this._frameExtents = new Vector2(4, 2)

			this._viewportCount = 6

			this._viewports = [
				// These viewports map a cube-map onto a 2D texture with the
				// following orientation:
				//
				//  xzXZ
				//   y Y
				//
				// X - Positive x direction
				// x - Negative x direction
				// Y - Positive y direction
				// y - Negative y direction
				// Z - Positive z direction
				// z - Negative z direction

				// positive X
				new Vector4(2, 1, 1, 1),
				// negative X
				new Vector4(0, 1, 1, 1),
				// positive Z
				new Vector4(3, 1, 1, 1),
				// negative Z
				new Vector4(1, 1, 1, 1),
				// positive Y
				new Vector4(3, 0, 1, 1),
				// negative Y
				new Vector4(1, 0, 1, 1)
			]

			this._cubeDirections = [
				new Vector3(1, 0, 0), new Vector3(- 1, 0, 0), new Vector3(0, 0, 1),
				new Vector3(0, 0, - 1), new Vector3(0, 1, 0), new Vector3(0, - 1, 0)
			]

			this._cubeUps = [
				new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0),
				new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, - 1)
			]

		}

		updateMatrices (light, viewportIndex = 0) {

			const camera = this.camera
			const shadowMatrix = this.matrix

			const far = light.distance || camera.far

			if (far !== camera.far) {

				camera.far = far
				camera.updateProjectionMatrix()

			}

			_lightPositionWorld.setFromMatrixPosition(light.matrixWorld)
			camera.position.copy(_lightPositionWorld)

			_lookTarget.copy(camera.position)
			_lookTarget.add(this._cubeDirections[viewportIndex])
			camera.up.copy(this._cubeUps[viewportIndex])
			camera.lookAt(_lookTarget)
			camera.updateMatrixWorld()

			shadowMatrix.makeTranslation(- _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z)

			_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse)
			this._frustum.setFromProjectionMatrix(_projScreenMatrix)

		}

	}

	PointLightShadow.prototype.isPointLightShadow = true

	class PointLight extends Light {

		constructor(color, intensity, distance = 0, decay = 1) {

			super(color, intensity)

			this.type = 'PointLight'

			this.distance = distance
			this.decay = decay // for physically correct lights, should be 2.

			this.shadow = new PointLightShadow()

		}

		get power () {

			// intensity = power per solid angle.
			// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			return this.intensity * 4 * Math.PI

		}

		set power (power) {

			// intensity = power per solid angle.
			// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			this.intensity = power / (4 * Math.PI)

		}

		dispose () {

			this.shadow.dispose()

		}

		copy (source) {

			super.copy(source)

			this.distance = source.distance
			this.decay = source.decay

			this.shadow = source.shadow.clone()

			return this

		}

	}

	PointLight.prototype.isPointLight = true

	class DirectionalLightShadow extends LightShadow {

		constructor() {

			super(new OrthographicCamera(- 5, 5, 5, - 5, 0.5, 500))

		}

	}

	DirectionalLightShadow.prototype.isDirectionalLightShadow = true

	class DirectionalLight extends Light {

		constructor(color, intensity) {

			super(color, intensity)

			this.type = 'DirectionalLight'

			this.position.copy(Object3D.DefaultUp)
			this.updateMatrix()

			this.target = new Object3D()

			this.shadow = new DirectionalLightShadow()

		}

		dispose () {

			this.shadow.dispose()

		}

		copy (source) {

			super.copy(source)

			this.target = source.target.clone()
			this.shadow = source.shadow.clone()

			return this

		}

	}

	DirectionalLight.prototype.isDirectionalLight = true

	class AmbientLight extends Light {

		constructor(color, intensity) {

			super(color, intensity)

			this.type = 'AmbientLight'

		}

	}

	AmbientLight.prototype.isAmbientLight = true

	class RectAreaLight extends Light {

		constructor(color, intensity, width = 10, height = 10) {

			super(color, intensity)

			this.type = 'RectAreaLight'

			this.width = width
			this.height = height

		}

		copy (source) {

			super.copy(source)

			this.width = source.width
			this.height = source.height

			return this

		}

		toJSON (meta) {

			const data = super.toJSON(meta)

			data.object.width = this.width
			data.object.height = this.height

			return data

		}

	}

	RectAreaLight.prototype.isRectAreaLight = true

	/**
	 * Primary reference:
	 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
	 *
	 * Secondary reference:
	 *   https://www.ppsloan.org/publications/StupidSH36.pdf
	 */

	// 3-band SH defined by 9 coefficients

	class SphericalHarmonics3 {

		constructor() {

			this.coefficients = []

			for (let i = 0; i < 9; i++) {

				this.coefficients.push(new Vector3())

			}

		}

		set (coefficients) {

			for (let i = 0; i < 9; i++) {

				this.coefficients[i].copy(coefficients[i])

			}

			return this

		}

		zero () {

			for (let i = 0; i < 9; i++) {

				this.coefficients[i].set(0, 0, 0)

			}

			return this

		}

		// get the radiance in the direction of the normal
		// target is a Vector3
		getAt (normal, target) {

			// normal is assumed to be unit length

			const x = normal.x, y = normal.y, z = normal.z

			const coeff = this.coefficients

			// band 0
			target.copy(coeff[0]).multiplyScalar(0.282095)

			// band 1
			target.addScaledVector(coeff[1], 0.488603 * y)
			target.addScaledVector(coeff[2], 0.488603 * z)
			target.addScaledVector(coeff[3], 0.488603 * x)

			// band 2
			target.addScaledVector(coeff[4], 1.092548 * (x * y))
			target.addScaledVector(coeff[5], 1.092548 * (y * z))
			target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0))
			target.addScaledVector(coeff[7], 1.092548 * (x * z))
			target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y))

			return target

		}

		// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
		// target is a Vector3
		// https://graphics.stanford.edu/papers/envmap/envmap.pdf
		getIrradianceAt (normal, target) {

			// normal is assumed to be unit length

			const x = normal.x, y = normal.y, z = normal.z

			const coeff = this.coefficients

			// band 0
			target.copy(coeff[0]).multiplyScalar(0.886227) //  * 0.282095

			// band 1
			target.addScaledVector(coeff[1], 2.0 * 0.511664 * y) // ( 2 *  / 3 ) * 0.488603
			target.addScaledVector(coeff[2], 2.0 * 0.511664 * z)
			target.addScaledVector(coeff[3], 2.0 * 0.511664 * x)

			// band 2
			target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y) // (  / 4 ) * 1.092548
			target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z)
			target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708) // (  / 4 ) * 0.315392 * 3
			target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z)
			target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)) // (  / 4 ) * 0.546274

			return target

		}

		add (sh) {

			for (let i = 0; i < 9; i++) {

				this.coefficients[i].add(sh.coefficients[i])

			}

			return this

		}

		addScaledSH (sh, s) {

			for (let i = 0; i < 9; i++) {

				this.coefficients[i].addScaledVector(sh.coefficients[i], s)

			}

			return this

		}

		scale (s) {

			for (let i = 0; i < 9; i++) {

				this.coefficients[i].multiplyScalar(s)

			}

			return this

		}

		lerp (sh, alpha) {

			for (let i = 0; i < 9; i++) {

				this.coefficients[i].lerp(sh.coefficients[i], alpha)

			}

			return this

		}

		equals (sh) {

			for (let i = 0; i < 9; i++) {

				if (!this.coefficients[i].equals(sh.coefficients[i])) {

					return false

				}

			}

			return true

		}

		copy (sh) {

			return this.set(sh.coefficients)

		}

		clone () {

			return new this.constructor().copy(this)

		}

		fromArray (array, offset = 0) {

			const coefficients = this.coefficients

			for (let i = 0; i < 9; i++) {

				coefficients[i].fromArray(array, offset + (i * 3))

			}

			return this

		}

		toArray (array = [], offset = 0) {

			const coefficients = this.coefficients

			for (let i = 0; i < 9; i++) {

				coefficients[i].toArray(array, offset + (i * 3))

			}

			return array

		}

		// evaluate the basis functions
		// shBasis is an Array[ 9 ]
		static getBasisAt (normal, shBasis) {

			// normal is assumed to be unit length

			const x = normal.x, y = normal.y, z = normal.z

			// band 0
			shBasis[0] = 0.282095

			// band 1
			shBasis[1] = 0.488603 * y
			shBasis[2] = 0.488603 * z
			shBasis[3] = 0.488603 * x

			// band 2
			shBasis[4] = 1.092548 * x * y
			shBasis[5] = 1.092548 * y * z
			shBasis[6] = 0.315392 * (3 * z * z - 1)
			shBasis[7] = 1.092548 * x * z
			shBasis[8] = 0.546274 * (x * x - y * y)

		}

	}

	SphericalHarmonics3.prototype.isSphericalHarmonics3 = true

	class LightProbe extends Light {

		constructor(sh = new SphericalHarmonics3(), intensity = 1) {

			super(undefined, intensity)

			this.sh = sh

		}

		copy (source) {

			super.copy(source)

			this.sh.copy(source.sh)

			return this

		}

		fromJSON (json) {

			this.intensity = json.intensity // TODO: Move this bit to Light.fromJSON();
			this.sh.fromArray(json.sh)

			return this

		}

		toJSON (meta) {

			const data = super.toJSON(meta)

			data.object.sh = this.sh.toArray()

			return data

		}

	}

	LightProbe.prototype.isLightProbe = true

	class MaterialLoader extends Loader {

		constructor(manager) {

			super(manager)
			this.textures = {}

		}

		load (url, onLoad, onProgress, onError) {

			const scope = this

			const loader = new FileLoader(scope.manager)
			loader.setPath(scope.path)
			loader.setRequestHeader(scope.requestHeader)
			loader.setWithCredentials(scope.withCredentials)
			loader.load(url, function (text) {

				try {

					onLoad(scope.parse(JSON.parse(text)))

				} catch (e) {

					if (onError) {

						onError(e)

					} else {

						console.error(e)

					}

					scope.manager.itemError(url)

				}

			}, onProgress, onError)

		}

		parse (json) {

			const textures = this.textures

			function getTexture (name) {

				if (textures[name] === undefined) {

					console.warn('THREE.MaterialLoader: Undefined texture', name)

				}

				return textures[name]

			}

			const material = new Materials[json.type]()

			if (json.uuid !== undefined) material.uuid = json.uuid
			if (json.name !== undefined) material.name = json.name
			if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color)
			if (json.roughness !== undefined) material.roughness = json.roughness
			if (json.metalness !== undefined) material.metalness = json.metalness
			if (json.sheen !== undefined) material.sheen = new Color().setHex(json.sheen)
			if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive)
			if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular)
			if (json.specularIntensity !== undefined) material.specularIntensity = json.specularIntensity
			if (json.specularTint !== undefined && material.specularTint !== undefined) material.specularTint.setHex(json.specularTint)
			if (json.shininess !== undefined) material.shininess = json.shininess
			if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat
			if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness
			if (json.transmission !== undefined) material.transmission = json.transmission
			if (json.thickness !== undefined) material.thickness = json.thickness
			if (json.attenuationDistance !== undefined) material.attenuationDistance = json.attenuationDistance
			if (json.attenuationTint !== undefined && material.attenuationTint !== undefined) material.attenuationTint.setHex(json.attenuationTint)
			if (json.fog !== undefined) material.fog = json.fog
			if (json.flatShading !== undefined) material.flatShading = json.flatShading
			if (json.blending !== undefined) material.blending = json.blending
			if (json.combine !== undefined) material.combine = json.combine
			if (json.side !== undefined) material.side = json.side
			if (json.shadowSide !== undefined) material.shadowSide = json.shadowSide
			if (json.opacity !== undefined) material.opacity = json.opacity
			if (json.transparent !== undefined) material.transparent = json.transparent
			if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest
			if (json.depthTest !== undefined) material.depthTest = json.depthTest
			if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite
			if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite

			if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite
			if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask
			if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc
			if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef
			if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask
			if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail
			if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail
			if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass

			if (json.wireframe !== undefined) material.wireframe = json.wireframe
			if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth
			if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap
			if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin

			if (json.rotation !== undefined) material.rotation = json.rotation

			if (json.linewidth !== 1) material.linewidth = json.linewidth
			if (json.dashSize !== undefined) material.dashSize = json.dashSize
			if (json.gapSize !== undefined) material.gapSize = json.gapSize
			if (json.scale !== undefined) material.scale = json.scale

			if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset
			if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor
			if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits

			if (json.dithering !== undefined) material.dithering = json.dithering

			if (json.alphaToCoverage !== undefined) material.alphaToCoverage = json.alphaToCoverage
			if (json.premultipliedAlpha !== undefined) material.premultipliedAlpha = json.premultipliedAlpha

			if (json.visible !== undefined) material.visible = json.visible

			if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped

			if (json.userData !== undefined) material.userData = json.userData

			if (json.vertexColors !== undefined) {

				if (typeof json.vertexColors === 'number') {

					material.vertexColors = (json.vertexColors > 0) ? true : false

				} else {

					material.vertexColors = json.vertexColors

				}

			}

			// Shader Material

			if (json.uniforms !== undefined) {

				for (const name in json.uniforms) {

					const uniform = json.uniforms[name]

					material.uniforms[name] = {}

					switch (uniform.type) {

						case 't':
							material.uniforms[name].value = getTexture(uniform.value)
							break

						case 'c':
							material.uniforms[name].value = new Color().setHex(uniform.value)
							break

						case 'v2':
							material.uniforms[name].value = new Vector2().fromArray(uniform.value)
							break

						case 'v3':
							material.uniforms[name].value = new Vector3().fromArray(uniform.value)
							break

						case 'v4':
							material.uniforms[name].value = new Vector4().fromArray(uniform.value)
							break

						case 'm3':
							material.uniforms[name].value = new Matrix3().fromArray(uniform.value)
							break

						case 'm4':
							material.uniforms[name].value = new Matrix4().fromArray(uniform.value)
							break

						default:
							material.uniforms[name].value = uniform.value

					}

				}

			}

			if (json.defines !== undefined) material.defines = json.defines
			if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader
			if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader

			if (json.extensions !== undefined) {

				for (const key in json.extensions) {

					material.extensions[key] = json.extensions[key]

				}

			}

			// Deprecated

			if (json.shading !== undefined) material.flatShading = json.shading === 1 // THREE.FlatShading

			// for PointsMaterial

			if (json.size !== undefined) material.size = json.size
			if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation

			// maps

			if (json.map !== undefined) material.map = getTexture(json.map)
			if (json.matcap !== undefined) material.matcap = getTexture(json.matcap)

			if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap)

			if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap)
			if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale

			if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap)
			if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType
			if (json.normalScale !== undefined) {

				let normalScale = json.normalScale

				if (Array.isArray(normalScale) === false) {

					// Blender exporter used to export a scalar. See #7459

					normalScale = [normalScale, normalScale]

				}

				material.normalScale = new Vector2().fromArray(normalScale)

			}

			if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap)
			if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale
			if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias

			if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap)
			if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap)

			if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap)
			if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity

			if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap)
			if (json.specularIntensityMap !== undefined) material.specularIntensityMap = getTexture(json.specularIntensityMap)
			if (json.specularTintMap !== undefined) material.specularTintMap = getTexture(json.specularTintMap)

			if (json.envMap !== undefined) material.envMap = getTexture(json.envMap)
			if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity

			if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity
			if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio

			if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap)
			if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity

			if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap)
			if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity

			if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap)

			if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap)
			if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap)
			if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap)
			if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale)

			if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap)
			if (json.thicknessMap !== undefined) material.thicknessMap = getTexture(json.thicknessMap)

			return material

		}

		setTextures (value) {

			this.textures = value
			return this

		}

	}

	class LoaderUtils {

		static decodeText (array) {

			if (typeof TextDecoder !== 'undefined') {

				return new TextDecoder().decode(array)

			}

			// Avoid the String.fromCharCode.apply(null, array) shortcut, which
			// throws a "maximum call stack size exceeded" error for large arrays.

			let s = ''

			for (let i = 0, il = array.length; i < il; i++) {

				// Implicitly assumes little-endian.
				s += String.fromCharCode(array[i])

			}

			try {

				// merges multi-byte utf-8 characters.

				return decodeURIComponent(escape(s))

			} catch (e) { // see #16358

				return s

			}

		}

		static extractUrlBase (url) {

			const index = url.lastIndexOf('/')

			if (index === - 1) return './'

			return url.substr(0, index + 1)

		}

	}

	class InstancedBufferGeometry extends BufferGeometry {

		constructor() {

			super()

			this.type = 'InstancedBufferGeometry'
			this.instanceCount = Infinity

		}

		copy (source) {

			super.copy(source)

			this.instanceCount = source.instanceCount

			return this

		}

		clone () {

			return new this.constructor().copy(this)

		}

		toJSON () {

			const data = super.toJSON(this)

			data.instanceCount = this.instanceCount

			data.isInstancedBufferGeometry = true

			return data

		}

	}

	InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true

	class InstancedBufferAttribute extends BufferAttribute {

		constructor(array, itemSize, normalized, meshPerAttribute = 1) {

			if (typeof normalized === 'number') {

				meshPerAttribute = normalized

				normalized = false

				console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.')

			}

			super(array, itemSize, normalized)

			this.meshPerAttribute = meshPerAttribute

		}

		copy (source) {

			super.copy(source)

			this.meshPerAttribute = source.meshPerAttribute

			return this

		}

		toJSON () {

			const data = super.toJSON()

			data.meshPerAttribute = this.meshPerAttribute

			data.isInstancedBufferAttribute = true

			return data

		}

	}

	InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true

	class BufferGeometryLoader extends Loader {

		constructor(manager) {

			super(manager)

		}

		load (url, onLoad, onProgress, onError) {

			const scope = this

			const loader = new FileLoader(scope.manager)
			loader.setPath(scope.path)
			loader.setRequestHeader(scope.requestHeader)
			loader.setWithCredentials(scope.withCredentials)
			loader.load(url, function (text) {

				try {

					onLoad(scope.parse(JSON.parse(text)))

				} catch (e) {

					if (onError) {

						onError(e)

					} else {

						console.error(e)

					}

					scope.manager.itemError(url)

				}

			}, onProgress, onError)

		}

		parse (json) {

			const interleavedBufferMap = {}
			const arrayBufferMap = {}

			function getInterleavedBuffer (json, uuid) {

				if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid]

				const interleavedBuffers = json.interleavedBuffers
				const interleavedBuffer = interleavedBuffers[uuid]

				const buffer = getArrayBuffer(json, interleavedBuffer.buffer)

				const array = getTypedArray(interleavedBuffer.type, buffer)
				const ib = new InterleavedBuffer(array, interleavedBuffer.stride)
				ib.uuid = interleavedBuffer.uuid

				interleavedBufferMap[uuid] = ib

				return ib

			}

			function getArrayBuffer (json, uuid) {

				if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid]

				const arrayBuffers = json.arrayBuffers
				const arrayBuffer = arrayBuffers[uuid]

				const ab = new Uint32Array(arrayBuffer).buffer

				arrayBufferMap[uuid] = ab

				return ab

			}

			const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry()

			const index = json.data.index

			if (index !== undefined) {

				const typedArray = getTypedArray(index.type, index.array)
				geometry.setIndex(new BufferAttribute(typedArray, 1))

			}

			const attributes = json.data.attributes

			for (const key in attributes) {

				const attribute = attributes[key]
				let bufferAttribute

				if (attribute.isInterleavedBufferAttribute) {

					const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data)
					bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized)

				} else {

					const typedArray = getTypedArray(attribute.type, attribute.array)
					const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute
					bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized)

				}

				if (attribute.name !== undefined) bufferAttribute.name = attribute.name
				if (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage)

				if (attribute.updateRange !== undefined) {

					bufferAttribute.updateRange.offset = attribute.updateRange.offset
					bufferAttribute.updateRange.count = attribute.updateRange.count

				}

				geometry.setAttribute(key, bufferAttribute)

			}

			const morphAttributes = json.data.morphAttributes

			if (morphAttributes) {

				for (const key in morphAttributes) {

					const attributeArray = morphAttributes[key]

					const array = []

					for (let i = 0, il = attributeArray.length; i < il; i++) {

						const attribute = attributeArray[i]
						let bufferAttribute

						if (attribute.isInterleavedBufferAttribute) {

							const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data)
							bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized)

						} else {

							const typedArray = getTypedArray(attribute.type, attribute.array)
							bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized)

						}

						if (attribute.name !== undefined) bufferAttribute.name = attribute.name
						array.push(bufferAttribute)

					}

					geometry.morphAttributes[key] = array

				}

			}

			const morphTargetsRelative = json.data.morphTargetsRelative

			if (morphTargetsRelative) {

				geometry.morphTargetsRelative = true

			}

			const groups = json.data.groups || json.data.drawcalls || json.data.offsets

			if (groups !== undefined) {

				for (let i = 0, n = groups.length; i !== n; ++i) {

					const group = groups[i]

					geometry.addGroup(group.start, group.count, group.materialIndex)

				}

			}

			const boundingSphere = json.data.boundingSphere

			if (boundingSphere !== undefined) {

				const center = new Vector3()

				if (boundingSphere.center !== undefined) {

					center.fromArray(boundingSphere.center)

				}

				geometry.boundingSphere = new Sphere(center, boundingSphere.radius)

			}

			if (json.name) geometry.name = json.name
			if (json.userData) geometry.userData = json.userData

			return geometry

		}

	}

	class ObjectLoader extends Loader {

		constructor(manager) {

			super(manager)

		}

		load (url, onLoad, onProgress, onError) {

			const scope = this

			const path = (this.path === '') ? LoaderUtils.extractUrlBase(url) : this.path
			this.resourcePath = this.resourcePath || path

			const loader = new FileLoader(this.manager)
			loader.setPath(this.path)
			loader.setRequestHeader(this.requestHeader)
			loader.setWithCredentials(this.withCredentials)
			loader.load(url, function (text) {

				let json = null

				try {

					json = JSON.parse(text)

				} catch (error) {

					if (onError !== undefined) onError(error)

					console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message)

					return

				}

				const metadata = json.metadata

				if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {

					console.error('THREE.ObjectLoader: Can\'t load ' + url)
					return

				}

				scope.parse(json, onLoad)

			}, onProgress, onError)

		}

		async loadAsync (url, onProgress) {

			const scope = this

			const path = (this.path === '') ? LoaderUtils.extractUrlBase(url) : this.path
			this.resourcePath = this.resourcePath || path

			const loader = new FileLoader(this.manager)
			loader.setPath(this.path)
			loader.setRequestHeader(this.requestHeader)
			loader.setWithCredentials(this.withCredentials)

			const text = await loader.loadAsync(url, onProgress)

			const json = JSON.parse(text)

			const metadata = json.metadata

			if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {

				throw new Error('THREE.ObjectLoader: Can\'t load ' + url)

			}

			return await scope.parseAsync(json)

		}

		parse (json, onLoad) {

			const animations = this.parseAnimations(json.animations)
			const shapes = this.parseShapes(json.shapes)
			const geometries = this.parseGeometries(json.geometries, shapes)

			const images = this.parseImages(json.images, function () {

				if (onLoad !== undefined) onLoad(object)

			})

			const textures = this.parseTextures(json.textures, images)
			const materials = this.parseMaterials(json.materials, textures)

			const object = this.parseObject(json.object, geometries, materials, textures, animations)
			const skeletons = this.parseSkeletons(json.skeletons, object)

			this.bindSkeletons(object, skeletons)

			//

			if (onLoad !== undefined) {

				let hasImages = false

				for (const uuid in images) {

					if (images[uuid] instanceof HTMLImageElement) {

						hasImages = true
						break

					}

				}

				if (hasImages === false) onLoad(object)

			}

			return object

		}

		async parseAsync (json) {

			const animations = this.parseAnimations(json.animations)
			const shapes = this.parseShapes(json.shapes)
			const geometries = this.parseGeometries(json.geometries, shapes)

			const images = await this.parseImagesAsync(json.images)

			const textures = this.parseTextures(json.textures, images)
			const materials = this.parseMaterials(json.materials, textures)

			const object = this.parseObject(json.object, geometries, materials, textures, animations)
			const skeletons = this.parseSkeletons(json.skeletons, object)

			this.bindSkeletons(object, skeletons)

			return object

		}

		parseShapes (json) {

			const shapes = {}

			if (json !== undefined) {

				for (let i = 0, l = json.length; i < l; i++) {

					const shape = new Shape().fromJSON(json[i])

					shapes[shape.uuid] = shape

				}

			}

			return shapes

		}

		parseSkeletons (json, object) {

			const skeletons = {}
			const bones = {}

			// generate bone lookup table

			object.traverse(function (child) {

				if (child.isBone) bones[child.uuid] = child

			})

			// create skeletons

			if (json !== undefined) {

				for (let i = 0, l = json.length; i < l; i++) {

					const skeleton = new Skeleton().fromJSON(json[i], bones)

					skeletons[skeleton.uuid] = skeleton

				}

			}

			return skeletons

		}

		parseGeometries (json, shapes) {

			const geometries = {}

			if (json !== undefined) {

				const bufferGeometryLoader = new BufferGeometryLoader()

				for (let i = 0, l = json.length; i < l; i++) {

					let geometry
					const data = json[i]

					switch (data.type) {

						case 'BufferGeometry':
						case 'InstancedBufferGeometry':

							geometry = bufferGeometryLoader.parse(data)

							break

						case 'Geometry':

							console.error('THREE.ObjectLoader: The legacy Geometry type is no longer supported.')

							break

						default:

							if (data.type in Geometries) {

								geometry = Geometries[data.type].fromJSON(data, shapes)

							} else {

								console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`)

							}

					}

					geometry.uuid = data.uuid

					if (data.name !== undefined) geometry.name = data.name
					if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData

					geometries[data.uuid] = geometry

				}

			}

			return geometries

		}

		parseMaterials (json, textures) {

			const cache = {} // MultiMaterial
			const materials = {}

			if (json !== undefined) {

				const loader = new MaterialLoader()
				loader.setTextures(textures)

				for (let i = 0, l = json.length; i < l; i++) {

					const data = json[i]

					if (data.type === 'MultiMaterial') {

						// Deprecated

						const array = []

						for (let j = 0; j < data.materials.length; j++) {

							const material = data.materials[j]

							if (cache[material.uuid] === undefined) {

								cache[material.uuid] = loader.parse(material)

							}

							array.push(cache[material.uuid])

						}

						materials[data.uuid] = array

					} else {

						if (cache[data.uuid] === undefined) {

							cache[data.uuid] = loader.parse(data)

						}

						materials[data.uuid] = cache[data.uuid]

					}

				}

			}

			return materials

		}

		parseAnimations (json) {

			const animations = {}

			if (json !== undefined) {

				for (let i = 0; i < json.length; i++) {

					const data = json[i]

					const clip = AnimationClip.parse(data)

					animations[clip.uuid] = clip

				}

			}

			return animations

		}

		parseImages (json, onLoad) {

			const scope = this
			const images = {}

			let loader

			function loadImage (url) {

				scope.manager.itemStart(url)

				return loader.load(url, function () {

					scope.manager.itemEnd(url)

				}, undefined, function () {

					scope.manager.itemError(url)
					scope.manager.itemEnd(url)

				})

			}

			function deserializeImage (image) {

				if (typeof image === 'string') {

					const url = image

					const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url

					return loadImage(path)

				} else {

					if (image.data) {

						return {
							data: getTypedArray(image.type, image.data),
							width: image.width,
							height: image.height
						}

					} else {

						return null

					}

				}

			}

			if (json !== undefined && json.length > 0) {

				const manager = new LoadingManager(onLoad)

				loader = new ImageLoader(manager)
				loader.setCrossOrigin(this.crossOrigin)

				for (let i = 0, il = json.length; i < il; i++) {

					const image = json[i]
					const url = image.url

					if (Array.isArray(url)) {

						// load array of images e.g CubeTexture

						images[image.uuid] = []

						for (let j = 0, jl = url.length; j < jl; j++) {

							const currentUrl = url[j]

							const deserializedImage = deserializeImage(currentUrl)

							if (deserializedImage !== null) {

								if (deserializedImage instanceof HTMLImageElement) {

									images[image.uuid].push(deserializedImage)

								} else {

									// special case: handle array of data textures for cube textures

									images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height))

								}

							}

						}

					} else {

						// load single image

						const deserializedImage = deserializeImage(image.url)

						if (deserializedImage !== null) {

							images[image.uuid] = deserializedImage

						}

					}

				}

			}

			return images

		}

		async parseImagesAsync (json) {

			const scope = this
			const images = {}

			let loader

			async function deserializeImage (image) {

				if (typeof image === 'string') {

					const url = image

					const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url

					return await loader.loadAsync(path)

				} else {

					if (image.data) {

						return {
							data: getTypedArray(image.type, image.data),
							width: image.width,
							height: image.height
						}

					} else {

						return null

					}

				}

			}

			if (json !== undefined && json.length > 0) {

				loader = new ImageLoader(this.manager)
				loader.setCrossOrigin(this.crossOrigin)

				for (let i = 0, il = json.length; i < il; i++) {

					const image = json[i]
					const url = image.url

					if (Array.isArray(url)) {

						// load array of images e.g CubeTexture

						images[image.uuid] = []

						for (let j = 0, jl = url.length; j < jl; j++) {

							const currentUrl = url[j]

							const deserializedImage = await deserializeImage(currentUrl)

							if (deserializedImage !== null) {

								if (deserializedImage instanceof HTMLImageElement) {

									images[image.uuid].push(deserializedImage)

								} else {

									// special case: handle array of data textures for cube textures

									images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height))

								}

							}

						}

					} else {

						// load single image

						const deserializedImage = await deserializeImage(image.url)

						if (deserializedImage !== null) {

							images[image.uuid] = deserializedImage

						}

					}

				}

			}

			return images

		}

		parseTextures (json, images) {

			function parseConstant (value, type) {

				if (typeof value === 'number') return value

				console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value)

				return type[value]

			}

			const textures = {}

			if (json !== undefined) {

				for (let i = 0, l = json.length; i < l; i++) {

					const data = json[i]

					if (data.image === undefined) {

						console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid)

					}

					if (images[data.image] === undefined) {

						console.warn('THREE.ObjectLoader: Undefined image', data.image)

					}

					let texture
					const image = images[data.image]

					if (Array.isArray(image)) {

						texture = new CubeTexture(image)

						if (image.length === 6) texture.needsUpdate = true

					} else {

						if (image && image.data) {

							texture = new DataTexture(image.data, image.width, image.height)

						} else {

							texture = new Texture(image)

						}

						if (image) texture.needsUpdate = true // textures can have undefined image data

					}

					texture.uuid = data.uuid

					if (data.name !== undefined) texture.name = data.name

					if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING)

					if (data.offset !== undefined) texture.offset.fromArray(data.offset)
					if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat)
					if (data.center !== undefined) texture.center.fromArray(data.center)
					if (data.rotation !== undefined) texture.rotation = data.rotation

					if (data.wrap !== undefined) {

						texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING)
						texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING)

					}

					if (data.format !== undefined) texture.format = data.format
					if (data.type !== undefined) texture.type = data.type
					if (data.encoding !== undefined) texture.encoding = data.encoding

					if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER)
					if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER)
					if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy

					if (data.flipY !== undefined) texture.flipY = data.flipY

					if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha
					if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment

					textures[data.uuid] = texture

				}

			}

			return textures

		}

		parseObject (data, geometries, materials, textures, animations) {

			let object

			function getGeometry (name) {

				if (geometries[name] === undefined) {

					console.warn('THREE.ObjectLoader: Undefined geometry', name)

				}

				return geometries[name]

			}

			function getMaterial (name) {

				if (name === undefined) return undefined

				if (Array.isArray(name)) {

					const array = []

					for (let i = 0, l = name.length; i < l; i++) {

						const uuid = name[i]

						if (materials[uuid] === undefined) {

							console.warn('THREE.ObjectLoader: Undefined material', uuid)

						}

						array.push(materials[uuid])

					}

					return array

				}

				if (materials[name] === undefined) {

					console.warn('THREE.ObjectLoader: Undefined material', name)

				}

				return materials[name]

			}

			function getTexture (uuid) {

				if (textures[uuid] === undefined) {

					console.warn('THREE.ObjectLoader: Undefined texture', uuid)

				}

				return textures[uuid]

			}

			let geometry, material

			switch (data.type) {

				case 'Scene':

					object = new Scene()

					if (data.background !== undefined) {

						if (Number.isInteger(data.background)) {

							object.background = new Color(data.background)

						} else {

							object.background = getTexture(data.background)

						}

					}

					if (data.environment !== undefined) {

						object.environment = getTexture(data.environment)

					}

					if (data.fog !== undefined) {

						if (data.fog.type === 'Fog') {

							object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far)

						} else if (data.fog.type === 'FogExp2') {

							object.fog = new FogExp2(data.fog.color, data.fog.density)

						}

					}

					break

				case 'PerspectiveCamera':

					object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far)

					if (data.focus !== undefined) object.focus = data.focus
					if (data.zoom !== undefined) object.zoom = data.zoom
					if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge
					if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset
					if (data.view !== undefined) object.view = Object.assign({}, data.view)

					break

				case 'OrthographicCamera':

					object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far)

					if (data.zoom !== undefined) object.zoom = data.zoom
					if (data.view !== undefined) object.view = Object.assign({}, data.view)

					break

				case 'AmbientLight':

					object = new AmbientLight(data.color, data.intensity)

					break

				case 'DirectionalLight':

					object = new DirectionalLight(data.color, data.intensity)

					break

				case 'PointLight':

					object = new PointLight(data.color, data.intensity, data.distance, data.decay)

					break

				case 'RectAreaLight':

					object = new RectAreaLight(data.color, data.intensity, data.width, data.height)

					break

				case 'SpotLight':

					object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay)

					break

				case 'HemisphereLight':

					object = new HemisphereLight(data.color, data.groundColor, data.intensity)

					break

				case 'LightProbe':

					object = new LightProbe().fromJSON(data)

					break

				case 'SkinnedMesh':

					geometry = getGeometry(data.geometry)
					material = getMaterial(data.material)

					object = new SkinnedMesh(geometry, material)

					if (data.bindMode !== undefined) object.bindMode = data.bindMode
					if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix)
					if (data.skeleton !== undefined) object.skeleton = data.skeleton

					break

				case 'Mesh':

					geometry = getGeometry(data.geometry)
					material = getMaterial(data.material)

					object = new Mesh(geometry, material)

					break

				case 'InstancedMesh':

					geometry = getGeometry(data.geometry)
					material = getMaterial(data.material)
					const count = data.count
					const instanceMatrix = data.instanceMatrix
					const instanceColor = data.instanceColor

					object = new InstancedMesh(geometry, material, count)
					object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16)
					if (instanceColor !== undefined) object.instanceColor = new BufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize)

					break

				case 'LOD':

					object = new LOD()

					break

				case 'Line':

					object = new Line(getGeometry(data.geometry), getMaterial(data.material))

					break

				case 'LineLoop':

					object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material))

					break

				case 'LineSegments':

					object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material))

					break

				case 'PointCloud':
				case 'Points':

					object = new Points(getGeometry(data.geometry), getMaterial(data.material))

					break

				case 'Sprite':

					object = new Sprite(getMaterial(data.material))

					break

				case 'Group':

					object = new Group$1()

					break

				case 'Bone':

					object = new Bone()

					break

				default:

					object = new Object3D()

			}

			object.uuid = data.uuid

			if (data.name !== undefined) object.name = data.name

			if (data.matrix !== undefined) {

				object.matrix.fromArray(data.matrix)

				if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate
				if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale)

			} else {

				if (data.position !== undefined) object.position.fromArray(data.position)
				if (data.rotation !== undefined) object.rotation.fromArray(data.rotation)
				if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion)
				if (data.scale !== undefined) object.scale.fromArray(data.scale)

			}

			if (data.castShadow !== undefined) object.castShadow = data.castShadow
			if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow

			if (data.shadow) {

				if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias
				if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias
				if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius
				if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize)
				if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera)

			}

			if (data.visible !== undefined) object.visible = data.visible
			if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled
			if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder
			if (data.userData !== undefined) object.userData = data.userData
			if (data.layers !== undefined) object.layers.mask = data.layers

			if (data.children !== undefined) {

				const children = data.children

				for (let i = 0; i < children.length; i++) {

					object.add(this.parseObject(children[i], geometries, materials, textures, animations))

				}

			}

			if (data.animations !== undefined) {

				const objectAnimations = data.animations

				for (let i = 0; i < objectAnimations.length; i++) {

					const uuid = objectAnimations[i]

					object.animations.push(animations[uuid])

				}

			}

			if (data.type === 'LOD') {

				if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate

				const levels = data.levels

				for (let l = 0; l < levels.length; l++) {

					const level = levels[l]
					const child = object.getObjectByProperty('uuid', level.object)

					if (child !== undefined) {

						object.addLevel(child, level.distance)

					}

				}

			}

			return object

		}

		bindSkeletons (object, skeletons) {

			if (Object.keys(skeletons).length === 0) return

			object.traverse(function (child) {

				if (child.isSkinnedMesh === true && child.skeleton !== undefined) {

					const skeleton = skeletons[child.skeleton]

					if (skeleton === undefined) {

						console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton)

					} else {

						child.bind(skeleton, child.bindMatrix)

					}

				}

			})

		}

		/* DEPRECATED */

		setTexturePath (value) {

			console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().')
			return this.setResourcePath(value)

		}

	}

	const TEXTURE_MAPPING = {
		UVMapping: UVMapping,
		CubeReflectionMapping: CubeReflectionMapping,
		CubeRefractionMapping: CubeRefractionMapping,
		EquirectangularReflectionMapping: EquirectangularReflectionMapping,
		EquirectangularRefractionMapping: EquirectangularRefractionMapping,
		CubeUVReflectionMapping: CubeUVReflectionMapping,
		CubeUVRefractionMapping: CubeUVRefractionMapping
	}

	const TEXTURE_WRAPPING = {
		RepeatWrapping: RepeatWrapping,
		ClampToEdgeWrapping: ClampToEdgeWrapping,
		MirroredRepeatWrapping: MirroredRepeatWrapping
	}

	const TEXTURE_FILTER = {
		NearestFilter: NearestFilter,
		NearestMipmapNearestFilter: NearestMipmapNearestFilter,
		NearestMipmapLinearFilter: NearestMipmapLinearFilter,
		LinearFilter: LinearFilter,
		LinearMipmapNearestFilter: LinearMipmapNearestFilter,
		LinearMipmapLinearFilter: LinearMipmapLinearFilter
	}

	class ImageBitmapLoader extends Loader {

		constructor(manager) {

			super(manager)

			if (typeof createImageBitmap === 'undefined') {

				console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.')

			}

			if (typeof fetch === 'undefined') {

				console.warn('THREE.ImageBitmapLoader: fetch() not supported.')

			}

			this.options = { premultiplyAlpha: 'none' }

		}

		setOptions (options) {

			this.options = options

			return this

		}

		load (url, onLoad, onProgress, onError) {

			if (url === undefined) url = ''

			if (this.path !== undefined) url = this.path + url

			url = this.manager.resolveURL(url)

			const scope = this

			const cached = Cache.get(url)

			if (cached !== undefined) {

				scope.manager.itemStart(url)

				setTimeout(function () {

					if (onLoad) onLoad(cached)

					scope.manager.itemEnd(url)

				}, 0)

				return cached

			}

			const fetchOptions = {}
			fetchOptions.credentials = (this.crossOrigin === 'anonymous') ? 'same-origin' : 'include'
			fetchOptions.headers = this.requestHeader

			fetch(url, fetchOptions).then(function (res) {

				return res.blob()

			}).then(function (blob) {

				return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: 'none' }))

			}).then(function (imageBitmap) {

				Cache.add(url, imageBitmap)

				if (onLoad) onLoad(imageBitmap)

				scope.manager.itemEnd(url)

			}).catch(function (e) {

				if (onError) onError(e)

				scope.manager.itemError(url)
				scope.manager.itemEnd(url)

			})

			scope.manager.itemStart(url)

		}

	}

	ImageBitmapLoader.prototype.isImageBitmapLoader = true

	class ShapePath {

		constructor() {

			this.type = 'ShapePath'

			this.color = new Color()

			this.subPaths = []
			this.currentPath = null

		}

		moveTo (x, y) {

			this.currentPath = new Path()
			this.subPaths.push(this.currentPath)
			this.currentPath.moveTo(x, y)

			return this

		}

		lineTo (x, y) {

			this.currentPath.lineTo(x, y)

			return this

		}

		quadraticCurveTo (aCPx, aCPy, aX, aY) {

			this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY)

			return this

		}

		bezierCurveTo (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {

			this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY)

			return this

		}

		splineThru (pts) {

			this.currentPath.splineThru(pts)

			return this

		}

		toShapes (isCCW, noHoles) {

			function toShapesNoHoles (inSubpaths) {

				const shapes = []

				for (let i = 0, l = inSubpaths.length; i < l; i++) {

					const tmpPath = inSubpaths[i]

					const tmpShape = new Shape()
					tmpShape.curves = tmpPath.curves

					shapes.push(tmpShape)

				}

				return shapes

			}

			function isPointInsidePolygon (inPt, inPolygon) {

				const polyLen = inPolygon.length

				// inPt on polygon contour => immediate success    or
				// toggling of inside/outside at every single! intersection point of an edge
				//  with the horizontal line through inPt, left of inPt
				//  not counting lowerY endpoints of edges and whole edges on that line
				let inside = false
				for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {

					let edgeLowPt = inPolygon[p]
					let edgeHighPt = inPolygon[q]

					let edgeDx = edgeHighPt.x - edgeLowPt.x
					let edgeDy = edgeHighPt.y - edgeLowPt.y

					if (Math.abs(edgeDy) > Number.EPSILON) {

						// not parallel
						if (edgeDy < 0) {

							edgeLowPt = inPolygon[q]; edgeDx = - edgeDx
							edgeHighPt = inPolygon[p]; edgeDy = - edgeDy

						}

						if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y)) continue

						if (inPt.y === edgeLowPt.y) {

							if (inPt.x === edgeLowPt.x) return true		// inPt is on contour ?
							// continue;				// no intersection or edgeLowPt => doesn't count !!!

						} else {

							const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y)
							if (perpEdge === 0) return true		// inPt is on contour ?
							if (perpEdge < 0) continue
							inside = !inside		// true intersection left of inPt

						}

					} else {

						// parallel or collinear
						if (inPt.y !== edgeLowPt.y) continue			// parallel
						// edge lies on the same horizontal line as inPt
						if (((edgeHighPt.x <= inPt.x) && (inPt.x <= edgeLowPt.x)) ||
							((edgeLowPt.x <= inPt.x) && (inPt.x <= edgeHighPt.x))) return true	// inPt: Point on contour !
						// continue;

					}

				}

				return inside

			}

			const isClockWise = ShapeUtils.isClockWise

			const subPaths = this.subPaths
			if (subPaths.length === 0) return []

			if (noHoles === true) return toShapesNoHoles(subPaths)


			let solid, tmpPath, tmpShape
			const shapes = []

			if (subPaths.length === 1) {

				tmpPath = subPaths[0]
				tmpShape = new Shape()
				tmpShape.curves = tmpPath.curves
				shapes.push(tmpShape)
				return shapes

			}

			let holesFirst = !isClockWise(subPaths[0].getPoints())
			holesFirst = isCCW ? !holesFirst : holesFirst

			// console.log("Holes first", holesFirst);

			const betterShapeHoles = []
			const newShapes = []
			let newShapeHoles = []
			let mainIdx = 0
			let tmpPoints

			newShapes[mainIdx] = undefined
			newShapeHoles[mainIdx] = []

			for (let i = 0, l = subPaths.length; i < l; i++) {

				tmpPath = subPaths[i]
				tmpPoints = tmpPath.getPoints()
				solid = isClockWise(tmpPoints)
				solid = isCCW ? !solid : solid

				if (solid) {

					if ((!holesFirst) && (newShapes[mainIdx])) mainIdx++

					newShapes[mainIdx] = { s: new Shape(), p: tmpPoints }
					newShapes[mainIdx].s.curves = tmpPath.curves

					if (holesFirst) mainIdx++
					newShapeHoles[mainIdx] = []

					//console.log('cw', i);

				} else {

					newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] })

					//console.log('ccw', i);

				}

			}

			// only Holes? -> probably all Shapes with wrong orientation
			if (!newShapes[0]) return toShapesNoHoles(subPaths)


			if (newShapes.length > 1) {

				let ambiguous = false
				const toChange = []

				for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {

					betterShapeHoles[sIdx] = []

				}

				for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {

					const sho = newShapeHoles[sIdx]

					for (let hIdx = 0; hIdx < sho.length; hIdx++) {

						const ho = sho[hIdx]
						let hole_unassigned = true

						for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {

							if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {

								if (sIdx !== s2Idx) toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx })
								if (hole_unassigned) {

									hole_unassigned = false
									betterShapeHoles[s2Idx].push(ho)

								} else {

									ambiguous = true

								}

							}

						}

						if (hole_unassigned) {

							betterShapeHoles[sIdx].push(ho)

						}

					}

				}
				// console.log("ambiguous: ", ambiguous);

				if (toChange.length > 0) {

					// console.log("to change: ", toChange);
					if (!ambiguous) newShapeHoles = betterShapeHoles

				}

			}

			let tmpHoles

			for (let i = 0, il = newShapes.length; i < il; i++) {

				tmpShape = newShapes[i].s
				shapes.push(tmpShape)
				tmpHoles = newShapeHoles[i]

				for (let j = 0, jl = tmpHoles.length; j < jl; j++) {

					tmpShape.holes.push(tmpHoles[j].h)

				}

			}

			//console.log("shape", shapes);

			return shapes

		}

	}

	class Font {

		constructor(data) {

			this.type = 'Font'

			this.data = data

		}

		generateShapes (text, size = 100) {

			const shapes = []
			const paths = createPaths(text, size, this.data)

			for (let p = 0, pl = paths.length; p < pl; p++) {

				Array.prototype.push.apply(shapes, paths[p].toShapes())

			}

			return shapes

		}

	}

	function createPaths (text, size, data) {

		const chars = Array.from(text)
		const scale = size / data.resolution
		const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale

		const paths = []

		let offsetX = 0, offsetY = 0

		for (let i = 0; i < chars.length; i++) {

			const char = chars[i]

			if (char === '\n') {

				offsetX = 0
				offsetY -= line_height

			} else {

				const ret = createPath(char, scale, offsetX, offsetY, data)
				offsetX += ret.offsetX
				paths.push(ret.path)

			}

		}

		return paths

	}

	function createPath (char, scale, offsetX, offsetY, data) {

		const glyph = data.glyphs[char] || data.glyphs['?']

		if (!glyph) {

			console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.')

			return

		}

		const path = new ShapePath()

		let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2

		if (glyph.o) {

			const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '))

			for (let i = 0, l = outline.length; i < l;) {

				const action = outline[i++]

				switch (action) {

					case 'm': // moveTo

						x = outline[i++] * scale + offsetX
						y = outline[i++] * scale + offsetY

						path.moveTo(x, y)

						break

					case 'l': // lineTo

						x = outline[i++] * scale + offsetX
						y = outline[i++] * scale + offsetY

						path.lineTo(x, y)

						break

					case 'q': // quadraticCurveTo

						cpx = outline[i++] * scale + offsetX
						cpy = outline[i++] * scale + offsetY
						cpx1 = outline[i++] * scale + offsetX
						cpy1 = outline[i++] * scale + offsetY

						path.quadraticCurveTo(cpx1, cpy1, cpx, cpy)

						break

					case 'b': // bezierCurveTo

						cpx = outline[i++] * scale + offsetX
						cpy = outline[i++] * scale + offsetY
						cpx1 = outline[i++] * scale + offsetX
						cpy1 = outline[i++] * scale + offsetY
						cpx2 = outline[i++] * scale + offsetX
						cpy2 = outline[i++] * scale + offsetY

						path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy)

						break

				}

			}

		}

		return { offsetX: glyph.ha * scale, path: path }

	}

	Font.prototype.isFont = true

	class FontLoader extends Loader {

		constructor(manager) {

			super(manager)

		}

		load (url, onLoad, onProgress, onError) {

			const scope = this

			const loader = new FileLoader(this.manager)
			loader.setPath(this.path)
			loader.setRequestHeader(this.requestHeader)
			loader.setWithCredentials(scope.withCredentials)
			loader.load(url, function (text) {

				let json

				try {

					json = JSON.parse(text)

				} catch (e) {

					console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.')
					json = JSON.parse(text.substring(65, text.length - 2))

				}

				const font = scope.parse(json)

				if (onLoad) onLoad(font)

			}, onProgress, onError)

		}

		parse (json) {

			return new Font(json)

		}

	}

	let _context

	const AudioContext = {

		getContext: function () {

			if (_context === undefined) {

				_context = new (window.AudioContext || window.webkitAudioContext)()

			}

			return _context

		},

		setContext: function (value) {

			_context = value

		}

	}

	class AudioLoader extends Loader {

		constructor(manager) {

			super(manager)

		}

		load (url, onLoad, onProgress, onError) {

			const scope = this

			const loader = new FileLoader(this.manager)
			loader.setResponseType('arraybuffer')
			loader.setPath(this.path)
			loader.setRequestHeader(this.requestHeader)
			loader.setWithCredentials(this.withCredentials)
			loader.load(url, function (buffer) {

				try {

					// Create a copy of the buffer. The `decodeAudioData` method
					// detaches the buffer when complete, preventing reuse.
					const bufferCopy = buffer.slice(0)

					const context = AudioContext.getContext()
					context.decodeAudioData(bufferCopy, function (audioBuffer) {

						onLoad(audioBuffer)

					})

				} catch (e) {

					if (onError) {

						onError(e)

					} else {

						console.error(e)

					}

					scope.manager.itemError(url)

				}

			}, onProgress, onError)

		}

	}

	class HemisphereLightProbe extends LightProbe {

		constructor(skyColor, groundColor, intensity = 1) {

			super(undefined, intensity)

			const color1 = new Color().set(skyColor)
			const color2 = new Color().set(groundColor)

			const sky = new Vector3(color1.r, color1.g, color1.b)
			const ground = new Vector3(color2.r, color2.g, color2.b)

			// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
			const c0 = Math.sqrt(Math.PI)
			const c1 = c0 * Math.sqrt(0.75)

			this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0)
			this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1)

		}

	}

	HemisphereLightProbe.prototype.isHemisphereLightProbe = true

	class AmbientLightProbe extends LightProbe {

		constructor(color, intensity = 1) {

			super(undefined, intensity)

			const color1 = new Color().set(color)

			// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
			this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI))

		}

	}

	AmbientLightProbe.prototype.isAmbientLightProbe = true

	const _eyeRight = /*@__PURE__*/ new Matrix4()
	const _eyeLeft = /*@__PURE__*/ new Matrix4()

	class StereoCamera {

		constructor() {

			this.type = 'StereoCamera'

			this.aspect = 1

			this.eyeSep = 0.064

			this.cameraL = new PerspectiveCamera()
			this.cameraL.layers.enable(1)
			this.cameraL.matrixAutoUpdate = false

			this.cameraR = new PerspectiveCamera()
			this.cameraR.layers.enable(2)
			this.cameraR.matrixAutoUpdate = false

			this._cache = {
				focus: null,
				fov: null,
				aspect: null,
				near: null,
				far: null,
				zoom: null,
				eyeSep: null
			}

		}

		update (camera) {

			const cache = this._cache

			const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
				cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
				cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep

			if (needsUpdate) {

				cache.focus = camera.focus
				cache.fov = camera.fov
				cache.aspect = camera.aspect * this.aspect
				cache.near = camera.near
				cache.far = camera.far
				cache.zoom = camera.zoom
				cache.eyeSep = this.eyeSep

				// Off-axis stereoscopic effect based on
				// http://paulbourke.net/stereographics/stereorender/

				const projectionMatrix = camera.projectionMatrix.clone()
				const eyeSepHalf = cache.eyeSep / 2
				const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus
				const ymax = (cache.near * Math.tan(DEG2RAD * cache.fov * 0.5)) / cache.zoom
				let xmin, xmax

				// translate xOffset

				_eyeLeft.elements[12] = - eyeSepHalf
				_eyeRight.elements[12] = eyeSepHalf

				// for left eye

				xmin = - ymax * cache.aspect + eyeSepOnProjection
				xmax = ymax * cache.aspect + eyeSepOnProjection

				projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin)
				projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin)

				this.cameraL.projectionMatrix.copy(projectionMatrix)

				// for right eye

				xmin = - ymax * cache.aspect - eyeSepOnProjection
				xmax = ymax * cache.aspect - eyeSepOnProjection

				projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin)
				projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin)

				this.cameraR.projectionMatrix.copy(projectionMatrix)

			}

			this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft)
			this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight)

		}

	}

	class Clock {

		constructor(autoStart = true) {

			this.autoStart = autoStart

			this.startTime = 0
			this.oldTime = 0
			this.elapsedTime = 0

			this.running = false

		}

		start () {

			this.startTime = now$2()

			this.oldTime = this.startTime
			this.elapsedTime = 0
			this.running = true

		}

		stop () {

			this.getElapsedTime()
			this.running = false
			this.autoStart = false

		}

		getElapsedTime () {

			this.getDelta()
			return this.elapsedTime

		}

		getDelta () {

			let diff = 0

			if (this.autoStart && !this.running) {

				this.start()
				return 0

			}

			if (this.running) {

				const newTime = now$2()

				diff = (newTime - this.oldTime) / 1000
				this.oldTime = newTime

				this.elapsedTime += diff

			}

			return diff

		}

	}

	function now$2 () {

		return (typeof performance === 'undefined' ? Date : performance).now() // see #10732

	}

	const _position$1 = /*@__PURE__*/ new Vector3()
	const _quaternion$1 = /*@__PURE__*/ new Quaternion()
	const _scale$1 = /*@__PURE__*/ new Vector3()
	const _orientation$1 = /*@__PURE__*/ new Vector3()

	class AudioListener extends Object3D {

		constructor() {

			super()

			this.type = 'AudioListener'

			this.context = AudioContext.getContext()

			this.gain = this.context.createGain()
			this.gain.connect(this.context.destination)

			this.filter = null

			this.timeDelta = 0

			// private

			this._clock = new Clock()

		}

		getInput () {

			return this.gain

		}

		removeFilter () {

			if (this.filter !== null) {

				this.gain.disconnect(this.filter)
				this.filter.disconnect(this.context.destination)
				this.gain.connect(this.context.destination)
				this.filter = null

			}

			return this

		}

		getFilter () {

			return this.filter

		}

		setFilter (value) {

			if (this.filter !== null) {

				this.gain.disconnect(this.filter)
				this.filter.disconnect(this.context.destination)

			} else {

				this.gain.disconnect(this.context.destination)

			}

			this.filter = value
			this.gain.connect(this.filter)
			this.filter.connect(this.context.destination)

			return this

		}

		getMasterVolume () {

			return this.gain.gain.value

		}

		setMasterVolume (value) {

			this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01)

			return this

		}

		updateMatrixWorld (force) {

			super.updateMatrixWorld(force)

			const listener = this.context.listener
			const up = this.up

			this.timeDelta = this._clock.getDelta()

			this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1)

			_orientation$1.set(0, 0, - 1).applyQuaternion(_quaternion$1)

			if (listener.positionX) {

				// code path for Chrome (see #14393)

				const endTime = this.context.currentTime + this.timeDelta

				listener.positionX.linearRampToValueAtTime(_position$1.x, endTime)
				listener.positionY.linearRampToValueAtTime(_position$1.y, endTime)
				listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime)
				listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime)
				listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime)
				listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime)
				listener.upX.linearRampToValueAtTime(up.x, endTime)
				listener.upY.linearRampToValueAtTime(up.y, endTime)
				listener.upZ.linearRampToValueAtTime(up.z, endTime)

			} else {

				listener.setPosition(_position$1.x, _position$1.y, _position$1.z)
				listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z)

			}

		}

	}

	class Audio extends Object3D {

		constructor(listener) {

			super()

			this.type = 'Audio'

			this.listener = listener
			this.context = listener.context

			this.gain = this.context.createGain()
			this.gain.connect(listener.getInput())

			this.autoplay = false

			this.buffer = null
			this.detune = 0
			this.loop = false
			this.loopStart = 0
			this.loopEnd = 0
			this.offset = 0
			this.duration = undefined
			this.playbackRate = 1
			this.isPlaying = false
			this.hasPlaybackControl = true
			this.source = null
			this.sourceType = 'empty'

			this._startedAt = 0
			this._progress = 0
			this._connected = false

			this.filters = []

		}

		getOutput () {

			return this.gain

		}

		setNodeSource (audioNode) {

			this.hasPlaybackControl = false
			this.sourceType = 'audioNode'
			this.source = audioNode
			this.connect()

			return this

		}

		setMediaElementSource (mediaElement) {

			this.hasPlaybackControl = false
			this.sourceType = 'mediaNode'
			this.source = this.context.createMediaElementSource(mediaElement)
			this.connect()

			return this

		}

		setMediaStreamSource (mediaStream) {

			this.hasPlaybackControl = false
			this.sourceType = 'mediaStreamNode'
			this.source = this.context.createMediaStreamSource(mediaStream)
			this.connect()

			return this

		}

		setBuffer (audioBuffer) {

			this.buffer = audioBuffer
			this.sourceType = 'buffer'

			if (this.autoplay) this.play()

			return this

		}

		play (delay = 0) {

			if (this.isPlaying === true) {

				console.warn('THREE.Audio: Audio is already playing.')
				return

			}

			if (this.hasPlaybackControl === false) {

				console.warn('THREE.Audio: this Audio has no playback control.')
				return

			}

			this._startedAt = this.context.currentTime + delay

			const source = this.context.createBufferSource()
			source.buffer = this.buffer
			source.loop = this.loop
			source.loopStart = this.loopStart
			source.loopEnd = this.loopEnd
			source.onended = this.onEnded.bind(this)
			source.start(this._startedAt, this._progress + this.offset, this.duration)

			this.isPlaying = true

			this.source = source

			this.setDetune(this.detune)
			this.setPlaybackRate(this.playbackRate)

			return this.connect()

		}

		pause () {

			if (this.hasPlaybackControl === false) {

				console.warn('THREE.Audio: this Audio has no playback control.')
				return

			}

			if (this.isPlaying === true) {

				// update current progress

				this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate

				if (this.loop === true) {

					// ensure _progress does not exceed duration with looped audios

					this._progress = this._progress % (this.duration || this.buffer.duration)

				}

				this.source.stop()
				this.source.onended = null

				this.isPlaying = false

			}

			return this

		}

		stop () {

			if (this.hasPlaybackControl === false) {

				console.warn('THREE.Audio: this Audio has no playback control.')
				return

			}

			this._progress = 0

			this.source.stop()
			this.source.onended = null
			this.isPlaying = false

			return this

		}

		connect () {

			if (this.filters.length > 0) {

				this.source.connect(this.filters[0])

				for (let i = 1, l = this.filters.length; i < l; i++) {

					this.filters[i - 1].connect(this.filters[i])

				}

				this.filters[this.filters.length - 1].connect(this.getOutput())

			} else {

				this.source.connect(this.getOutput())

			}

			this._connected = true

			return this

		}

		disconnect () {

			if (this.filters.length > 0) {

				this.source.disconnect(this.filters[0])

				for (let i = 1, l = this.filters.length; i < l; i++) {

					this.filters[i - 1].disconnect(this.filters[i])

				}

				this.filters[this.filters.length - 1].disconnect(this.getOutput())

			} else {

				this.source.disconnect(this.getOutput())

			}

			this._connected = false

			return this

		}

		getFilters () {

			return this.filters

		}

		setFilters (value) {

			if (!value) value = []

			if (this._connected === true) {

				this.disconnect()
				this.filters = value.slice()
				this.connect()

			} else {

				this.filters = value.slice()

			}

			return this

		}

		setDetune (value) {

			this.detune = value

			if (this.source.detune === undefined) return // only set detune when available

			if (this.isPlaying === true) {

				this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01)

			}

			return this

		}

		getDetune () {

			return this.detune

		}

		getFilter () {

			return this.getFilters()[0]

		}

		setFilter (filter) {

			return this.setFilters(filter ? [filter] : [])

		}

		setPlaybackRate (value) {

			if (this.hasPlaybackControl === false) {

				console.warn('THREE.Audio: this Audio has no playback control.')
				return

			}

			this.playbackRate = value

			if (this.isPlaying === true) {

				this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01)

			}

			return this

		}

		getPlaybackRate () {

			return this.playbackRate

		}

		onEnded () {

			this.isPlaying = false

		}

		getLoop () {

			if (this.hasPlaybackControl === false) {

				console.warn('THREE.Audio: this Audio has no playback control.')
				return false

			}

			return this.loop

		}

		setLoop (value) {

			if (this.hasPlaybackControl === false) {

				console.warn('THREE.Audio: this Audio has no playback control.')
				return

			}

			this.loop = value

			if (this.isPlaying === true) {

				this.source.loop = this.loop

			}

			return this

		}

		setLoopStart (value) {

			this.loopStart = value

			return this

		}

		setLoopEnd (value) {

			this.loopEnd = value

			return this

		}

		getVolume () {

			return this.gain.gain.value

		}

		setVolume (value) {

			this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01)

			return this

		}

	}

	const _position = /*@__PURE__*/ new Vector3()
	const _quaternion = /*@__PURE__*/ new Quaternion()
	const _scale = /*@__PURE__*/ new Vector3()
	const _orientation = /*@__PURE__*/ new Vector3()

	class PositionalAudio extends Audio {

		constructor(listener) {

			super(listener)

			this.panner = this.context.createPanner()
			this.panner.panningModel = 'HRTF'
			this.panner.connect(this.gain)

		}

		getOutput () {

			return this.panner

		}

		getRefDistance () {

			return this.panner.refDistance

		}

		setRefDistance (value) {

			this.panner.refDistance = value

			return this

		}

		getRolloffFactor () {

			return this.panner.rolloffFactor

		}

		setRolloffFactor (value) {

			this.panner.rolloffFactor = value

			return this

		}

		getDistanceModel () {

			return this.panner.distanceModel

		}

		setDistanceModel (value) {

			this.panner.distanceModel = value

			return this

		}

		getMaxDistance () {

			return this.panner.maxDistance

		}

		setMaxDistance (value) {

			this.panner.maxDistance = value

			return this

		}

		setDirectionalCone (coneInnerAngle, coneOuterAngle, coneOuterGain) {

			this.panner.coneInnerAngle = coneInnerAngle
			this.panner.coneOuterAngle = coneOuterAngle
			this.panner.coneOuterGain = coneOuterGain

			return this

		}

		updateMatrixWorld (force) {

			super.updateMatrixWorld(force)

			if (this.hasPlaybackControl === true && this.isPlaying === false) return

			this.matrixWorld.decompose(_position, _quaternion, _scale)

			_orientation.set(0, 0, 1).applyQuaternion(_quaternion)

			const panner = this.panner

			if (panner.positionX) {

				// code path for Chrome and Firefox (see #14393)

				const endTime = this.context.currentTime + this.listener.timeDelta

				panner.positionX.linearRampToValueAtTime(_position.x, endTime)
				panner.positionY.linearRampToValueAtTime(_position.y, endTime)
				panner.positionZ.linearRampToValueAtTime(_position.z, endTime)
				panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime)
				panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime)
				panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime)

			} else {

				panner.setPosition(_position.x, _position.y, _position.z)
				panner.setOrientation(_orientation.x, _orientation.y, _orientation.z)

			}

		}

	}

	class AudioAnalyser {

		constructor(audio, fftSize = 2048) {

			this.analyser = audio.context.createAnalyser()
			this.analyser.fftSize = fftSize

			this.data = new Uint8Array(this.analyser.frequencyBinCount)

			audio.getOutput().connect(this.analyser)

		}


		getFrequencyData () {

			this.analyser.getByteFrequencyData(this.data)

			return this.data

		}

		getAverageFrequency () {

			let value = 0
			const data = this.getFrequencyData()

			for (let i = 0; i < data.length; i++) {

				value += data[i]

			}

			return value / data.length

		}

	}

	class PropertyMixer {

		constructor(binding, typeName, valueSize) {

			this.binding = binding
			this.valueSize = valueSize

			let mixFunction,
				mixFunctionAdditive,
				setIdentity

			// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
			//
			// interpolators can use .buffer as their .result
			// the data then goes to 'incoming'
			//
			// 'accu0' and 'accu1' are used frame-interleaved for
			// the cumulative result and are compared to detect
			// changes
			//
			// 'orig' stores the original state of the property
			//
			// 'add' is used for additive cumulative results
			//
			// 'work' is optional and is only present for quaternion types. It is used
			// to store intermediate quaternion multiplication results

			switch (typeName) {

				case 'quaternion':
					mixFunction = this._slerp
					mixFunctionAdditive = this._slerpAdditive
					setIdentity = this._setAdditiveIdentityQuaternion

					this.buffer = new Float64Array(valueSize * 6)
					this._workIndex = 5
					break

				case 'string':
				case 'bool':
					mixFunction = this._select

					// Use the regular mix function and for additive on these types,
					// additive is not relevant for non-numeric types
					mixFunctionAdditive = this._select

					setIdentity = this._setAdditiveIdentityOther

					this.buffer = new Array(valueSize * 5)
					break

				default:
					mixFunction = this._lerp
					mixFunctionAdditive = this._lerpAdditive
					setIdentity = this._setAdditiveIdentityNumeric

					this.buffer = new Float64Array(valueSize * 5)

			}

			this._mixBufferRegion = mixFunction
			this._mixBufferRegionAdditive = mixFunctionAdditive
			this._setIdentity = setIdentity
			this._origIndex = 3
			this._addIndex = 4

			this.cumulativeWeight = 0
			this.cumulativeWeightAdditive = 0

			this.useCount = 0
			this.referenceCount = 0

		}

		// accumulate data in the 'incoming' region into 'accu<i>'
		accumulate (accuIndex, weight) {

			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place

			const buffer = this.buffer,
				stride = this.valueSize,
				offset = accuIndex * stride + stride

			let currentWeight = this.cumulativeWeight

			if (currentWeight === 0) {

				// accuN := incoming * weight

				for (let i = 0; i !== stride; ++i) {

					buffer[offset + i] = buffer[i]

				}

				currentWeight = weight

			} else {

				// accuN := accuN + incoming * weight

				currentWeight += weight
				const mix = weight / currentWeight
				this._mixBufferRegion(buffer, offset, 0, mix, stride)

			}

			this.cumulativeWeight = currentWeight

		}

		// accumulate data in the 'incoming' region into 'add'
		accumulateAdditive (weight) {

			const buffer = this.buffer,
				stride = this.valueSize,
				offset = stride * this._addIndex

			if (this.cumulativeWeightAdditive === 0) {

				// add = identity

				this._setIdentity()

			}

			// add := add + incoming * weight

			this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride)
			this.cumulativeWeightAdditive += weight

		}

		// apply the state of 'accu<i>' to the binding when accus differ
		apply (accuIndex) {

			const stride = this.valueSize,
				buffer = this.buffer,
				offset = accuIndex * stride + stride,

				weight = this.cumulativeWeight,
				weightAdditive = this.cumulativeWeightAdditive,

				binding = this.binding

			this.cumulativeWeight = 0
			this.cumulativeWeightAdditive = 0

			if (weight < 1) {

				// accuN := accuN + original * ( 1 - cumulativeWeight )

				const originalValueOffset = stride * this._origIndex

				this._mixBufferRegion(
					buffer, offset, originalValueOffset, 1 - weight, stride)

			}

			if (weightAdditive > 0) {

				// accuN := accuN + additive accuN

				this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride)

			}

			for (let i = stride, e = stride + stride; i !== e; ++i) {

				if (buffer[i] !== buffer[i + stride]) {

					// value has changed -> update scene graph

					binding.setValue(buffer, offset)
					break

				}

			}

		}

		// remember the state of the bound property and copy it to both accus
		saveOriginalState () {

			const binding = this.binding

			const buffer = this.buffer,
				stride = this.valueSize,

				originalValueOffset = stride * this._origIndex

			binding.getValue(buffer, originalValueOffset)

			// accu[0..1] := orig -- initially detect changes against the original
			for (let i = stride, e = originalValueOffset; i !== e; ++i) {

				buffer[i] = buffer[originalValueOffset + (i % stride)]

			}

			// Add to identity for additive
			this._setIdentity()

			this.cumulativeWeight = 0
			this.cumulativeWeightAdditive = 0

		}

		// apply the state previously taken via 'saveOriginalState' to the binding
		restoreOriginalState () {

			const originalValueOffset = this.valueSize * 3
			this.binding.setValue(this.buffer, originalValueOffset)

		}

		_setAdditiveIdentityNumeric () {

			const startIndex = this._addIndex * this.valueSize
			const endIndex = startIndex + this.valueSize

			for (let i = startIndex; i < endIndex; i++) {

				this.buffer[i] = 0

			}

		}

		_setAdditiveIdentityQuaternion () {

			this._setAdditiveIdentityNumeric()
			this.buffer[this._addIndex * this.valueSize + 3] = 1

		}

		_setAdditiveIdentityOther () {

			const startIndex = this._origIndex * this.valueSize
			const targetIndex = this._addIndex * this.valueSize

			for (let i = 0; i < this.valueSize; i++) {

				this.buffer[targetIndex + i] = this.buffer[startIndex + i]

			}

		}


		// mix functions

		_select (buffer, dstOffset, srcOffset, t, stride) {

			if (t >= 0.5) {

				for (let i = 0; i !== stride; ++i) {

					buffer[dstOffset + i] = buffer[srcOffset + i]

				}

			}

		}

		_slerp (buffer, dstOffset, srcOffset, t) {

			Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t)

		}

		_slerpAdditive (buffer, dstOffset, srcOffset, t, stride) {

			const workOffset = this._workIndex * stride

			// Store result in intermediate buffer offset
			Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset)

			// Slerp to the intermediate result
			Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t)

		}

		_lerp (buffer, dstOffset, srcOffset, t, stride) {

			const s = 1 - t

			for (let i = 0; i !== stride; ++i) {

				const j = dstOffset + i

				buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t

			}

		}

		_lerpAdditive (buffer, dstOffset, srcOffset, t, stride) {

			for (let i = 0; i !== stride; ++i) {

				const j = dstOffset + i

				buffer[j] = buffer[j] + buffer[srcOffset + i] * t

			}

		}

	}

	// Characters [].:/ are reserved for track binding syntax.
	const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/'
	const _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g')

	// Attempts to allow node names from any language. ES5's `\w` regexp matches
	// only latin characters, and the unicode \p{L} is not yet supported. So
	// instead, we exclude reserved characters and match everything else.
	const _wordChar = '[^' + _RESERVED_CHARS_RE + ']'
	const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']'

	// Parent directories, delimited by '/' or ':'. Currently unused, but must
	// be matched to parse the rest of the track name.
	const _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar)

	// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
	const _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot)

	// Object on target node, and accessor. May not contain reserved
	// characters. Accessor may contain any character except closing bracket.
	const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar)

	// Property and accessor. May not contain reserved characters. Accessor may
	// contain any non-bracket characters.
	const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar)

	const _trackRe = new RegExp(''
		+ '^'
		+ _directoryRe
		+ _nodeRe
		+ _objectRe
		+ _propertyRe
		+ '$'
	)

	const _supportedObjectNames = ['material', 'materials', 'bones']

	class Composite {

		constructor(targetGroup, path, optionalParsedPath) {

			const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path)

			this._targetGroup = targetGroup
			this._bindings = targetGroup.subscribe_(path, parsedPath)

		}

		getValue (array, offset) {

			this.bind() // bind all binding

			const firstValidIndex = this._targetGroup.nCachedObjects_,
				binding = this._bindings[firstValidIndex]

			// and only call .getValue on the first
			if (binding !== undefined) binding.getValue(array, offset)

		}

		setValue (array, offset) {

			const bindings = this._bindings

			for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {

				bindings[i].setValue(array, offset)

			}

		}

		bind () {

			const bindings = this._bindings

			for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {

				bindings[i].bind()

			}

		}

		unbind () {

			const bindings = this._bindings

			for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {

				bindings[i].unbind()

			}

		}

	}

	// Note: This class uses a State pattern on a per-method basis:
	// 'bind' sets 'this.getValue' / 'setValue' and shadows the
	// prototype version of these methods with one that represents
	// the bound state. When the property is not found, the methods
	// become no-ops.
	class PropertyBinding {

		constructor(rootNode, path, parsedPath) {

			this.path = path
			this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path)

			this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode

			this.rootNode = rootNode

			// initial state of these methods that calls 'bind'
			this.getValue = this._getValue_unbound
			this.setValue = this._setValue_unbound

		}


		static create (root, path, parsedPath) {

			if (!(root && root.isAnimationObjectGroup)) {

				return new PropertyBinding(root, path, parsedPath)

			} else {

				return new PropertyBinding.Composite(root, path, parsedPath)

			}

		}

		/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param {string} name Node name to be sanitized.
		 * @return {string}
		 */
		static sanitizeNodeName (name) {

			return name.replace(/\s/g, '_').replace(_reservedRe, '')

		}

		static parseTrackName (trackName) {

			const matches = _trackRe.exec(trackName)

			if (!matches) {

				throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName)

			}

			const results = {
				// directoryName: matches[ 1 ], // (tschw) currently unused
				nodeName: matches[2],
				objectName: matches[3],
				objectIndex: matches[4],
				propertyName: matches[5], // required
				propertyIndex: matches[6]
			}

			const lastDot = results.nodeName && results.nodeName.lastIndexOf('.')

			if (lastDot !== undefined && lastDot !== - 1) {

				const objectName = results.nodeName.substring(lastDot + 1)

				// Object names must be checked against an allowlist. Otherwise, there
				// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
				// 'bar' could be the objectName, or part of a nodeName (which can
				// include '.' characters).
				if (_supportedObjectNames.indexOf(objectName) !== - 1) {

					results.nodeName = results.nodeName.substring(0, lastDot)
					results.objectName = objectName

				}

			}

			if (results.propertyName === null || results.propertyName.length === 0) {

				throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName)

			}

			return results

		}

		static findNode (root, nodeName) {

			if (!nodeName || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid) {

				return root

			}

			// search into skeleton bones.
			if (root.skeleton) {

				const bone = root.skeleton.getBoneByName(nodeName)

				if (bone !== undefined) {

					return bone

				}

			}

			// search into node subtree.
			if (root.children) {

				const searchNodeSubtree = function (children) {

					for (let i = 0; i < children.length; i++) {

						const childNode = children[i]

						if (childNode.name === nodeName || childNode.uuid === nodeName) {

							return childNode

						}

						const result = searchNodeSubtree(childNode.children)

						if (result) return result

					}

					return null

				}

				const subTreeNode = searchNodeSubtree(root.children)

				if (subTreeNode) {

					return subTreeNode

				}

			}

			return null

		}

		// these are used to "bind" a nonexistent property
		_getValue_unavailable () { }
		_setValue_unavailable () { }

		// Getters

		_getValue_direct (buffer, offset) {

			buffer[offset] = this.node[this.propertyName]

		}

		_getValue_array (buffer, offset) {

			const source = this.resolvedProperty

			for (let i = 0, n = source.length; i !== n; ++i) {

				buffer[offset++] = source[i]

			}

		}

		_getValue_arrayElement (buffer, offset) {

			buffer[offset] = this.resolvedProperty[this.propertyIndex]

		}

		_getValue_toArray (buffer, offset) {

			this.resolvedProperty.toArray(buffer, offset)

		}

		// Direct

		_setValue_direct (buffer, offset) {

			this.targetObject[this.propertyName] = buffer[offset]

		}

		_setValue_direct_setNeedsUpdate (buffer, offset) {

			this.targetObject[this.propertyName] = buffer[offset]
			this.targetObject.needsUpdate = true

		}

		_setValue_direct_setMatrixWorldNeedsUpdate (buffer, offset) {

			this.targetObject[this.propertyName] = buffer[offset]
			this.targetObject.matrixWorldNeedsUpdate = true

		}

		// EntireArray

		_setValue_array (buffer, offset) {

			const dest = this.resolvedProperty

			for (let i = 0, n = dest.length; i !== n; ++i) {

				dest[i] = buffer[offset++]

			}

		}

		_setValue_array_setNeedsUpdate (buffer, offset) {

			const dest = this.resolvedProperty

			for (let i = 0, n = dest.length; i !== n; ++i) {

				dest[i] = buffer[offset++]

			}

			this.targetObject.needsUpdate = true

		}

		_setValue_array_setMatrixWorldNeedsUpdate (buffer, offset) {

			const dest = this.resolvedProperty

			for (let i = 0, n = dest.length; i !== n; ++i) {

				dest[i] = buffer[offset++]

			}

			this.targetObject.matrixWorldNeedsUpdate = true

		}

		// ArrayElement

		_setValue_arrayElement (buffer, offset) {

			this.resolvedProperty[this.propertyIndex] = buffer[offset]

		}

		_setValue_arrayElement_setNeedsUpdate (buffer, offset) {

			this.resolvedProperty[this.propertyIndex] = buffer[offset]
			this.targetObject.needsUpdate = true

		}

		_setValue_arrayElement_setMatrixWorldNeedsUpdate (buffer, offset) {

			this.resolvedProperty[this.propertyIndex] = buffer[offset]
			this.targetObject.matrixWorldNeedsUpdate = true

		}

		// HasToFromArray

		_setValue_fromArray (buffer, offset) {

			this.resolvedProperty.fromArray(buffer, offset)

		}

		_setValue_fromArray_setNeedsUpdate (buffer, offset) {

			this.resolvedProperty.fromArray(buffer, offset)
			this.targetObject.needsUpdate = true

		}

		_setValue_fromArray_setMatrixWorldNeedsUpdate (buffer, offset) {

			this.resolvedProperty.fromArray(buffer, offset)
			this.targetObject.matrixWorldNeedsUpdate = true

		}

		_getValue_unbound (targetArray, offset) {

			this.bind()
			this.getValue(targetArray, offset)

		}

		_setValue_unbound (sourceArray, offset) {

			this.bind()
			this.setValue(sourceArray, offset)

		}

		// create getter / setter pair for a property in the scene graph
		bind () {

			let targetObject = this.node
			const parsedPath = this.parsedPath

			const objectName = parsedPath.objectName
			const propertyName = parsedPath.propertyName
			let propertyIndex = parsedPath.propertyIndex

			if (!targetObject) {

				targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode

				this.node = targetObject

			}

			// set fail state so we can just 'return' on error
			this.getValue = this._getValue_unavailable
			this.setValue = this._setValue_unavailable

			// ensure there is a value node
			if (!targetObject) {

				console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.')
				return

			}

			if (objectName) {

				let objectIndex = parsedPath.objectIndex

				// special cases were we need to reach deeper into the hierarchy to get the face materials....
				switch (objectName) {

					case 'materials':

						if (!targetObject.material) {

							console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this)
							return

						}

						if (!targetObject.material.materials) {

							console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this)
							return

						}

						targetObject = targetObject.material.materials

						break

					case 'bones':

						if (!targetObject.skeleton) {

							console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this)
							return

						}

						// potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.

						targetObject = targetObject.skeleton.bones

						// support resolving morphTarget names into indices.
						for (let i = 0; i < targetObject.length; i++) {

							if (targetObject[i].name === objectIndex) {

								objectIndex = i
								break

							}

						}

						break

					default:

						if (targetObject[objectName] === undefined) {

							console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this)
							return

						}

						targetObject = targetObject[objectName]

				}


				if (objectIndex !== undefined) {

					if (targetObject[objectIndex] === undefined) {

						console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject)
						return

					}

					targetObject = targetObject[objectIndex]

				}

			}

			// resolve property
			const nodeProperty = targetObject[propertyName]

			if (nodeProperty === undefined) {

				const nodeName = parsedPath.nodeName

				console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
					'.' + propertyName + ' but it wasn\'t found.', targetObject)
				return

			}

			// determine versioning scheme
			let versioning = this.Versioning.None

			this.targetObject = targetObject

			if (targetObject.needsUpdate !== undefined) { // material

				versioning = this.Versioning.NeedsUpdate

			} else if (targetObject.matrixWorldNeedsUpdate !== undefined) { // node transform

				versioning = this.Versioning.MatrixWorldNeedsUpdate

			}

			// determine how the property gets bound
			let bindingType = this.BindingType.Direct

			if (propertyIndex !== undefined) {

				// access a sub element of the property array (only primitives are supported right now)

				if (propertyName === 'morphTargetInfluences') {

					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

					// support resolving morphTarget names into indices.
					if (!targetObject.geometry) {

						console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this)
						return

					}

					if (targetObject.geometry.isBufferGeometry) {

						if (!targetObject.geometry.morphAttributes) {

							console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this)
							return

						}

						if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {

							propertyIndex = targetObject.morphTargetDictionary[propertyIndex]

						}


					} else {

						console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this)
						return

					}

				}

				bindingType = this.BindingType.ArrayElement

				this.resolvedProperty = nodeProperty
				this.propertyIndex = propertyIndex

			} else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {

				// must use copy for Object3D.Euler/Quaternion

				bindingType = this.BindingType.HasFromToArray

				this.resolvedProperty = nodeProperty

			} else if (Array.isArray(nodeProperty)) {

				bindingType = this.BindingType.EntireArray

				this.resolvedProperty = nodeProperty

			} else {

				this.propertyName = propertyName

			}

			// select getter / setter
			this.getValue = this.GetterByBindingType[bindingType]
			this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning]

		}

		unbind () {

			this.node = null

			// back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'
			this.getValue = this._getValue_unbound
			this.setValue = this._setValue_unbound

		}

	}

	PropertyBinding.Composite = Composite

	PropertyBinding.prototype.BindingType = {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	}

	PropertyBinding.prototype.Versioning = {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	}

	PropertyBinding.prototype.GetterByBindingType = [

		PropertyBinding.prototype._getValue_direct,
		PropertyBinding.prototype._getValue_array,
		PropertyBinding.prototype._getValue_arrayElement,
		PropertyBinding.prototype._getValue_toArray,

	]

	PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [

		[
			// Direct
			PropertyBinding.prototype._setValue_direct,
			PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
			PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,

		], [

			// EntireArray

			PropertyBinding.prototype._setValue_array,
			PropertyBinding.prototype._setValue_array_setNeedsUpdate,
			PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,

		], [

			// ArrayElement
			PropertyBinding.prototype._setValue_arrayElement,
			PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
			PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,

		], [

			// HasToFromArray
			PropertyBinding.prototype._setValue_fromArray,
			PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
			PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,

		]

	]

	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 *  - Add objects you would otherwise pass as 'root' to the
	 *    constructor or the .clipAction method of AnimationMixer.
	 *
	 *  - Instead pass this object as 'root'.
	 *
	 *  - You can also add and remove objects later when the mixer
	 *    is running.
	 *
	 * Note:
	 *
	 *    Objects of this class appear as one object to the mixer,
	 *    so cache control of the individual objects must be done
	 *    on the group.
	 *
	 * Limitation:
	 *
	 *  - The animated properties must be compatible among the
	 *    all objects in the group.
	 *
	 *  - A single property can either be controlled through a
	 *    target group or directly, but not both.
	 */

	class AnimationObjectGroup {

		constructor() {

			this.uuid = generateUUID()

			// cached objects followed by the active ones
			this._objects = Array.prototype.slice.call(arguments)

			this.nCachedObjects_ = 0 // threshold
			// note: read by PropertyBinding.Composite

			const indices = {}
			this._indicesByUUID = indices // for bookkeeping

			for (let i = 0, n = arguments.length; i !== n; ++i) {

				indices[arguments[i].uuid] = i

			}

			this._paths = [] // inside: string
			this._parsedPaths = [] // inside: { we don't care, here }
			this._bindings = [] // inside: Array< PropertyBinding >
			this._bindingsIndicesByPath = {} // inside: indices in these arrays

			const scope = this

			this.stats = {

				objects: {
					get total () {

						return scope._objects.length

					},
					get inUse () {

						return this.total - scope.nCachedObjects_

					}
				},
				get bindingsPerObject () {

					return scope._bindings.length

				}

			}

		}

		add () {

			const objects = this._objects,
				indicesByUUID = this._indicesByUUID,
				paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				nBindings = bindings.length

			let knownObject = undefined,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_

			for (let i = 0, n = arguments.length; i !== n; ++i) {

				const object = arguments[i],
					uuid = object.uuid
				let index = indicesByUUID[uuid]

				if (index === undefined) {

					// unknown object -> add it to the ACTIVE region

					index = nObjects++
					indicesByUUID[uuid] = index
					objects.push(object)

					// accounting is done, now do the same for all bindings

					for (let j = 0, m = nBindings; j !== m; ++j) {

						bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]))

					}

				} else if (index < nCachedObjects) {

					knownObject = objects[index]

					// move existing object to the ACTIVE region

					const firstActiveIndex = --nCachedObjects,
						lastCachedObject = objects[firstActiveIndex]

					indicesByUUID[lastCachedObject.uuid] = index
					objects[index] = lastCachedObject

					indicesByUUID[uuid] = firstActiveIndex
					objects[firstActiveIndex] = object

					// accounting is done, now do the same for all bindings

					for (let j = 0, m = nBindings; j !== m; ++j) {

						const bindingsForPath = bindings[j],
							lastCached = bindingsForPath[firstActiveIndex]

						let binding = bindingsForPath[index]

						bindingsForPath[index] = lastCached

						if (binding === undefined) {

							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist

							binding = new PropertyBinding(object, paths[j], parsedPaths[j])

						}

						bindingsForPath[firstActiveIndex] = binding

					}

				} else if (objects[index] !== knownObject) {

					console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' +
						'detected. Clean the caches or recreate your infrastructure when reloading scenes.')

				} // else the object is already where we want it to be

			} // for arguments

			this.nCachedObjects_ = nCachedObjects

		}

		remove () {

			const objects = this._objects,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length

			let nCachedObjects = this.nCachedObjects_

			for (let i = 0, n = arguments.length; i !== n; ++i) {

				const object = arguments[i],
					uuid = object.uuid,
					index = indicesByUUID[uuid]

				if (index !== undefined && index >= nCachedObjects) {

					// move existing object into the CACHED region

					const lastCachedIndex = nCachedObjects++,
						firstActiveObject = objects[lastCachedIndex]

					indicesByUUID[firstActiveObject.uuid] = index
					objects[index] = firstActiveObject

					indicesByUUID[uuid] = lastCachedIndex
					objects[lastCachedIndex] = object

					// accounting is done, now do the same for all bindings

					for (let j = 0, m = nBindings; j !== m; ++j) {

						const bindingsForPath = bindings[j],
							firstActive = bindingsForPath[lastCachedIndex],
							binding = bindingsForPath[index]

						bindingsForPath[index] = firstActive
						bindingsForPath[lastCachedIndex] = binding

					}

				}

			} // for arguments

			this.nCachedObjects_ = nCachedObjects

		}

		// remove & forget
		uncache () {

			const objects = this._objects,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length

			let nCachedObjects = this.nCachedObjects_,
				nObjects = objects.length

			for (let i = 0, n = arguments.length; i !== n; ++i) {

				const object = arguments[i],
					uuid = object.uuid,
					index = indicesByUUID[uuid]

				if (index !== undefined) {

					delete indicesByUUID[uuid]

					if (index < nCachedObjects) {

						// object is cached, shrink the CACHED region

						const firstActiveIndex = --nCachedObjects,
							lastCachedObject = objects[firstActiveIndex],
							lastIndex = --nObjects,
							lastObject = objects[lastIndex]

						// last cached object takes this object's place
						indicesByUUID[lastCachedObject.uuid] = index
						objects[index] = lastCachedObject

						// last object goes to the activated slot and pop
						indicesByUUID[lastObject.uuid] = firstActiveIndex
						objects[firstActiveIndex] = lastObject
						objects.pop()

						// accounting is done, now do the same for all bindings

						for (let j = 0, m = nBindings; j !== m; ++j) {

							const bindingsForPath = bindings[j],
								lastCached = bindingsForPath[firstActiveIndex],
								last = bindingsForPath[lastIndex]

							bindingsForPath[index] = lastCached
							bindingsForPath[firstActiveIndex] = last
							bindingsForPath.pop()

						}

					} else {

						// object is active, just swap with the last and pop

						const lastIndex = --nObjects,
							lastObject = objects[lastIndex]

						if (lastIndex > 0) {

							indicesByUUID[lastObject.uuid] = index

						}

						objects[index] = lastObject
						objects.pop()

						// accounting is done, now do the same for all bindings

						for (let j = 0, m = nBindings; j !== m; ++j) {

							const bindingsForPath = bindings[j]

							bindingsForPath[index] = bindingsForPath[lastIndex]
							bindingsForPath.pop()

						}

					} // cached or active

				} // if object is known

			} // for arguments

			this.nCachedObjects_ = nCachedObjects

		}

		// Internal interface used by befriended PropertyBinding.Composite:

		subscribe_ (path, parsedPath) {

			// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group

			const indicesByPath = this._bindingsIndicesByPath
			let index = indicesByPath[path]
			const bindings = this._bindings

			if (index !== undefined) return bindings[index]

			const paths = this._paths,
				parsedPaths = this._parsedPaths,
				objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				bindingsForPath = new Array(nObjects)

			index = bindings.length

			indicesByPath[path] = index

			paths.push(path)
			parsedPaths.push(parsedPath)
			bindings.push(bindingsForPath)

			for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {

				const object = objects[i]
				bindingsForPath[i] = new PropertyBinding(object, path, parsedPath)

			}

			return bindingsForPath

		}

		unsubscribe_ (path) {

			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'

			const indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[path]

			if (index !== undefined) {

				const paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					lastBindingsIndex = bindings.length - 1,
					lastBindings = bindings[lastBindingsIndex],
					lastBindingsPath = path[lastBindingsIndex]

				indicesByPath[lastBindingsPath] = index

				bindings[index] = lastBindings
				bindings.pop()

				parsedPaths[index] = parsedPaths[lastBindingsIndex]
				parsedPaths.pop()

				paths[index] = paths[lastBindingsIndex]
				paths.pop()

			}

		}

	}

	AnimationObjectGroup.prototype.isAnimationObjectGroup = true

	class AnimationAction {

		constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {

			this._mixer = mixer
			this._clip = clip
			this._localRoot = localRoot
			this.blendMode = blendMode

			const tracks = clip.tracks,
				nTracks = tracks.length,
				interpolants = new Array(nTracks)

			const interpolantSettings = {
				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding
			}

			for (let i = 0; i !== nTracks; ++i) {

				const interpolant = tracks[i].createInterpolant(null)
				interpolants[i] = interpolant
				interpolant.settings = interpolantSettings

			}

			this._interpolantSettings = interpolantSettings

			this._interpolants = interpolants // bound by the mixer

			// inside: PropertyMixer (managed by the mixer)
			this._propertyBindings = new Array(nTracks)

			this._cacheIndex = null // for the memory manager
			this._byClipCacheIndex = null // for the memory manager

			this._timeScaleInterpolant = null
			this._weightInterpolant = null

			this.loop = LoopRepeat
			this._loopCount = - 1

			// global mixer time when the action is to be started
			// it's set back to 'null' upon start of the action
			this._startTime = null

			// scaled local time of the action
			// gets clamped or wrapped to 0..clip.duration according to loop
			this.time = 0

			this.timeScale = 1
			this._effectiveTimeScale = 1

			this.weight = 1
			this._effectiveWeight = 1

			this.repetitions = Infinity // no. of repetitions when looping

			this.paused = false // true -> zero effective time scale
			this.enabled = true // false -> zero effective weight

			this.clampWhenFinished = false// keep feeding the last frame?

			this.zeroSlopeAtStart = true// for smooth interpolation w/o separate
			this.zeroSlopeAtEnd = true// clips for start, loop and end

		}

		// State & Scheduling

		play () {

			this._mixer._activateAction(this)

			return this

		}

		stop () {

			this._mixer._deactivateAction(this)

			return this.reset()

		}

		reset () {

			this.paused = false
			this.enabled = true

			this.time = 0 // restart clip
			this._loopCount = - 1// forget previous loops
			this._startTime = null// forget scheduling

			return this.stopFading().stopWarping()

		}

		isRunning () {

			return this.enabled && !this.paused && this.timeScale !== 0 &&
				this._startTime === null && this._mixer._isActiveAction(this)

		}

		// return true when play has been called
		isScheduled () {

			return this._mixer._isActiveAction(this)

		}

		startAt (time) {

			this._startTime = time

			return this

		}

		setLoop (mode, repetitions) {

			this.loop = mode
			this.repetitions = repetitions

			return this

		}

		// Weight

		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing
		setEffectiveWeight (weight) {

			this.weight = weight

			// note: same logic as when updated at runtime
			this._effectiveWeight = this.enabled ? weight : 0

			return this.stopFading()

		}

		// return the weight considering fading and .enabled
		getEffectiveWeight () {

			return this._effectiveWeight

		}

		fadeIn (duration) {

			return this._scheduleFading(duration, 0, 1)

		}

		fadeOut (duration) {

			return this._scheduleFading(duration, 1, 0)

		}

		crossFadeFrom (fadeOutAction, duration, warp) {

			fadeOutAction.fadeOut(duration)
			this.fadeIn(duration)

			if (warp) {

				const fadeInDuration = this._clip.duration,
					fadeOutDuration = fadeOutAction._clip.duration,

					startEndRatio = fadeOutDuration / fadeInDuration,
					endStartRatio = fadeInDuration / fadeOutDuration

				fadeOutAction.warp(1.0, startEndRatio, duration)
				this.warp(endStartRatio, 1.0, duration)

			}

			return this

		}

		crossFadeTo (fadeInAction, duration, warp) {

			return fadeInAction.crossFadeFrom(this, duration, warp)

		}

		stopFading () {

			const weightInterpolant = this._weightInterpolant

			if (weightInterpolant !== null) {

				this._weightInterpolant = null
				this._mixer._takeBackControlInterpolant(weightInterpolant)

			}

			return this

		}

		// Time Scale Control

		// set the time scale stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing
		setEffectiveTimeScale (timeScale) {

			this.timeScale = timeScale
			this._effectiveTimeScale = this.paused ? 0 : timeScale

			return this.stopWarping()

		}

		// return the time scale considering warping and .paused
		getEffectiveTimeScale () {

			return this._effectiveTimeScale

		}

		setDuration (duration) {

			this.timeScale = this._clip.duration / duration

			return this.stopWarping()

		}

		syncWith (action) {

			this.time = action.time
			this.timeScale = action.timeScale

			return this.stopWarping()

		}

		halt (duration) {

			return this.warp(this._effectiveTimeScale, 0, duration)

		}

		warp (startTimeScale, endTimeScale, duration) {

			const mixer = this._mixer,
				now = mixer.time,
				timeScale = this.timeScale

			let interpolant = this._timeScaleInterpolant

			if (interpolant === null) {

				interpolant = mixer._lendControlInterpolant()
				this._timeScaleInterpolant = interpolant

			}

			const times = interpolant.parameterPositions,
				values = interpolant.sampleValues

			times[0] = now
			times[1] = now + duration

			values[0] = startTimeScale / timeScale
			values[1] = endTimeScale / timeScale

			return this

		}

		stopWarping () {

			const timeScaleInterpolant = this._timeScaleInterpolant

			if (timeScaleInterpolant !== null) {

				this._timeScaleInterpolant = null
				this._mixer._takeBackControlInterpolant(timeScaleInterpolant)

			}

			return this

		}

		// Object Accessors

		getMixer () {

			return this._mixer

		}

		getClip () {

			return this._clip

		}

		getRoot () {

			return this._localRoot || this._mixer._root

		}

		// Interna

		_update (time, deltaTime, timeDirection, accuIndex) {

			// called by the mixer

			if (!this.enabled) {

				// call ._updateWeight() to update ._effectiveWeight

				this._updateWeight(time)
				return

			}

			const startTime = this._startTime

			if (startTime !== null) {

				// check for scheduled start of action

				const timeRunning = (time - startTime) * timeDirection
				if (timeRunning < 0 || timeDirection === 0) {

					return // yet to come / don't decide when delta = 0

				}

				// start

				this._startTime = null // unschedule
				deltaTime = timeDirection * timeRunning

			}

			// apply time scale and advance time

			deltaTime *= this._updateTimeScale(time)
			const clipTime = this._updateTime(deltaTime)

			// note: _updateTime may disable the action resulting in
			// an effective weight of 0

			const weight = this._updateWeight(time)

			if (weight > 0) {

				const interpolants = this._interpolants
				const propertyMixers = this._propertyBindings

				switch (this.blendMode) {

					case AdditiveAnimationBlendMode:

						for (let j = 0, m = interpolants.length; j !== m; ++j) {

							interpolants[j].evaluate(clipTime)
							propertyMixers[j].accumulateAdditive(weight)

						}

						break

					case NormalAnimationBlendMode:
					default:

						for (let j = 0, m = interpolants.length; j !== m; ++j) {

							interpolants[j].evaluate(clipTime)
							propertyMixers[j].accumulate(accuIndex, weight)

						}

				}

			}

		}

		_updateWeight (time) {

			let weight = 0

			if (this.enabled) {

				weight = this.weight
				const interpolant = this._weightInterpolant

				if (interpolant !== null) {

					const interpolantValue = interpolant.evaluate(time)[0]

					weight *= interpolantValue

					if (time > interpolant.parameterPositions[1]) {

						this.stopFading()

						if (interpolantValue === 0) {

							// faded out, disable
							this.enabled = false

						}

					}

				}

			}

			this._effectiveWeight = weight
			return weight

		}

		_updateTimeScale (time) {

			let timeScale = 0

			if (!this.paused) {

				timeScale = this.timeScale

				const interpolant = this._timeScaleInterpolant

				if (interpolant !== null) {

					const interpolantValue = interpolant.evaluate(time)[0]

					timeScale *= interpolantValue

					if (time > interpolant.parameterPositions[1]) {

						this.stopWarping()

						if (timeScale === 0) {

							// motion has halted, pause
							this.paused = true

						} else {

							// warp done - apply final time scale
							this.timeScale = timeScale

						}

					}

				}

			}

			this._effectiveTimeScale = timeScale
			return timeScale

		}

		_updateTime (deltaTime) {

			const duration = this._clip.duration
			const loop = this.loop

			let time = this.time + deltaTime
			let loopCount = this._loopCount

			const pingPong = (loop === LoopPingPong)

			if (deltaTime === 0) {

				if (loopCount === - 1) return time

				return (pingPong && (loopCount & 1) === 1) ? duration - time : time

			}

			if (loop === LoopOnce) {

				if (loopCount === - 1) {

					// just started

					this._loopCount = 0
					this._setEndings(true, true, false)

				}

				handle_stop: {

					if (time >= duration) {

						time = duration

					} else if (time < 0) {

						time = 0

					} else {

						this.time = time

						break handle_stop

					}

					if (this.clampWhenFinished) this.paused = true
					else this.enabled = false

					this.time = time

					this._mixer.dispatchEvent({
						type: 'finished', action: this,
						direction: deltaTime < 0 ? - 1 : 1
					})

				}

			} else { // repetitive Repeat or PingPong

				if (loopCount === - 1) {

					// just started

					if (deltaTime >= 0) {

						loopCount = 0

						this._setEndings(true, this.repetitions === 0, pingPong)

					} else {

						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1

						this._setEndings(this.repetitions === 0, true, pingPong)

					}

				}

				if (time >= duration || time < 0) {

					// wrap around

					const loopDelta = Math.floor(time / duration) // signed
					time -= duration * loopDelta

					loopCount += Math.abs(loopDelta)

					const pending = this.repetitions - loopCount

					if (pending <= 0) {

						// have to stop (switch state, clamp time, fire event)

						if (this.clampWhenFinished) this.paused = true
						else this.enabled = false

						time = deltaTime > 0 ? duration : 0

						this.time = time

						this._mixer.dispatchEvent({
							type: 'finished', action: this,
							direction: deltaTime > 0 ? 1 : - 1
						})

					} else {

						// keep running

						if (pending === 1) {

							// entering the last round

							const atStart = deltaTime < 0
							this._setEndings(atStart, !atStart, pingPong)

						} else {

							this._setEndings(false, false, pingPong)

						}

						this._loopCount = loopCount

						this.time = time

						this._mixer.dispatchEvent({
							type: 'loop', action: this, loopDelta: loopDelta
						})

					}

				} else {

					this.time = time

				}

				if (pingPong && (loopCount & 1) === 1) {

					// invert time for the "pong round"

					return duration - time

				}

			}

			return time

		}

		_setEndings (atStart, atEnd, pingPong) {

			const settings = this._interpolantSettings

			if (pingPong) {

				settings.endingStart = ZeroSlopeEnding
				settings.endingEnd = ZeroSlopeEnding

			} else {

				// assuming for LoopOnce atStart == atEnd == true

				if (atStart) {

					settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding

				} else {

					settings.endingStart = WrapAroundEnding

				}

				if (atEnd) {

					settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding

				} else {

					settings.endingEnd = WrapAroundEnding

				}

			}

		}

		_scheduleFading (duration, weightNow, weightThen) {

			const mixer = this._mixer, now = mixer.time
			let interpolant = this._weightInterpolant

			if (interpolant === null) {

				interpolant = mixer._lendControlInterpolant()
				this._weightInterpolant = interpolant

			}

			const times = interpolant.parameterPositions,
				values = interpolant.sampleValues

			times[0] = now
			values[0] = weightNow
			times[1] = now + duration
			values[1] = weightThen

			return this

		}

	}

	class AnimationMixer extends EventDispatcher {

		constructor(root) {

			super()

			this._root = root
			this._initMemoryManager()
			this._accuIndex = 0
			this.time = 0
			this.timeScale = 1.0

		}

		_bindAction (action, prototypeAction) {

			const root = action._localRoot || this._root,
				tracks = action._clip.tracks,
				nTracks = tracks.length,
				bindings = action._propertyBindings,
				interpolants = action._interpolants,
				rootUuid = root.uuid,
				bindingsByRoot = this._bindingsByRootAndName

			let bindingsByName = bindingsByRoot[rootUuid]

			if (bindingsByName === undefined) {

				bindingsByName = {}
				bindingsByRoot[rootUuid] = bindingsByName

			}

			for (let i = 0; i !== nTracks; ++i) {

				const track = tracks[i],
					trackName = track.name

				let binding = bindingsByName[trackName]

				if (binding !== undefined) {

					bindings[i] = binding

				} else {

					binding = bindings[i]

					if (binding !== undefined) {

						// existing binding, make sure the cache knows

						if (binding._cacheIndex === null) {

							++binding.referenceCount
							this._addInactiveBinding(binding, rootUuid, trackName)

						}

						continue

					}

					const path = prototypeAction && prototypeAction.
						_propertyBindings[i].binding.parsedPath

					binding = new PropertyMixer(
						PropertyBinding.create(root, trackName, path),
						track.ValueTypeName, track.getValueSize())

					++binding.referenceCount
					this._addInactiveBinding(binding, rootUuid, trackName)

					bindings[i] = binding

				}

				interpolants[i].resultBuffer = binding.buffer

			}

		}

		_activateAction (action) {

			if (!this._isActiveAction(action)) {

				if (action._cacheIndex === null) {

					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind

					const rootUuid = (action._localRoot || this._root).uuid,
						clipUuid = action._clip.uuid,
						actionsForClip = this._actionsByClip[clipUuid]

					this._bindAction(action,
						actionsForClip && actionsForClip.knownActions[0])

					this._addInactiveAction(action, clipUuid, rootUuid)

				}

				const bindings = action._propertyBindings

				// increment reference counts / sort out state
				for (let i = 0, n = bindings.length; i !== n; ++i) {

					const binding = bindings[i]

					if (binding.useCount++ === 0) {

						this._lendBinding(binding)
						binding.saveOriginalState()

					}

				}

				this._lendAction(action)

			}

		}

		_deactivateAction (action) {

			if (this._isActiveAction(action)) {

				const bindings = action._propertyBindings

				// decrement reference counts / sort out state
				for (let i = 0, n = bindings.length; i !== n; ++i) {

					const binding = bindings[i]

					if (--binding.useCount === 0) {

						binding.restoreOriginalState()
						this._takeBackBinding(binding)

					}

				}

				this._takeBackAction(action)

			}

		}

		// Memory manager

		_initMemoryManager () {

			this._actions = [] // 'nActiveActions' followed by inactive ones
			this._nActiveActions = 0

			this._actionsByClip = {}
			// inside:
			// {
			// 	knownActions: Array< AnimationAction > - used as prototypes
			// 	actionByRoot: AnimationAction - lookup
			// }


			this._bindings = [] // 'nActiveBindings' followed by inactive ones
			this._nActiveBindings = 0

			this._bindingsByRootAndName = {} // inside: Map< name, PropertyMixer >


			this._controlInterpolants = [] // same game as above
			this._nActiveControlInterpolants = 0

			const scope = this

			this.stats = {

				actions: {
					get total () {

						return scope._actions.length

					},
					get inUse () {

						return scope._nActiveActions

					}
				},
				bindings: {
					get total () {

						return scope._bindings.length

					},
					get inUse () {

						return scope._nActiveBindings

					}
				},
				controlInterpolants: {
					get total () {

						return scope._controlInterpolants.length

					},
					get inUse () {

						return scope._nActiveControlInterpolants

					}
				}

			}

		}

		// Memory management for AnimationAction objects

		_isActiveAction (action) {

			const index = action._cacheIndex
			return index !== null && index < this._nActiveActions

		}

		_addInactiveAction (action, clipUuid, rootUuid) {

			const actions = this._actions,
				actionsByClip = this._actionsByClip

			let actionsForClip = actionsByClip[clipUuid]

			if (actionsForClip === undefined) {

				actionsForClip = {

					knownActions: [action],
					actionByRoot: {}

				}

				action._byClipCacheIndex = 0

				actionsByClip[clipUuid] = actionsForClip

			} else {

				const knownActions = actionsForClip.knownActions

				action._byClipCacheIndex = knownActions.length
				knownActions.push(action)

			}

			action._cacheIndex = actions.length
			actions.push(action)

			actionsForClip.actionByRoot[rootUuid] = action

		}

		_removeInactiveAction (action) {

			const actions = this._actions,
				lastInactiveAction = actions[actions.length - 1],
				cacheIndex = action._cacheIndex

			lastInactiveAction._cacheIndex = cacheIndex
			actions[cacheIndex] = lastInactiveAction
			actions.pop()

			action._cacheIndex = null


			const clipUuid = action._clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[clipUuid],
				knownActionsForClip = actionsForClip.knownActions,

				lastKnownAction =
					knownActionsForClip[knownActionsForClip.length - 1],

				byClipCacheIndex = action._byClipCacheIndex

			lastKnownAction._byClipCacheIndex = byClipCacheIndex
			knownActionsForClip[byClipCacheIndex] = lastKnownAction
			knownActionsForClip.pop()

			action._byClipCacheIndex = null


			const actionByRoot = actionsForClip.actionByRoot,
				rootUuid = (action._localRoot || this._root).uuid

			delete actionByRoot[rootUuid]

			if (knownActionsForClip.length === 0) {

				delete actionsByClip[clipUuid]

			}

			this._removeInactiveBindingsForAction(action)

		}

		_removeInactiveBindingsForAction (action) {

			const bindings = action._propertyBindings

			for (let i = 0, n = bindings.length; i !== n; ++i) {

				const binding = bindings[i]

				if (--binding.referenceCount === 0) {

					this._removeInactiveBinding(binding)

				}

			}

		}

		_lendAction (action) {

			// [ active actions |  inactive actions  ]
			// [  active actions >| inactive actions ]
			//                 s        a
			//                  <-swap->
			//                 a        s

			const actions = this._actions,
				prevIndex = action._cacheIndex,

				lastActiveIndex = this._nActiveActions++,

				firstInactiveAction = actions[lastActiveIndex]

			action._cacheIndex = lastActiveIndex
			actions[lastActiveIndex] = action

			firstInactiveAction._cacheIndex = prevIndex
			actions[prevIndex] = firstInactiveAction

		}

		_takeBackAction (action) {

			// [  active actions  | inactive actions ]
			// [ active actions |< inactive actions  ]
			//        a        s
			//         <-swap->
			//        s        a

			const actions = this._actions,
				prevIndex = action._cacheIndex,

				firstInactiveIndex = --this._nActiveActions,

				lastActiveAction = actions[firstInactiveIndex]

			action._cacheIndex = firstInactiveIndex
			actions[firstInactiveIndex] = action

			lastActiveAction._cacheIndex = prevIndex
			actions[prevIndex] = lastActiveAction

		}

		// Memory management for PropertyMixer objects

		_addInactiveBinding (binding, rootUuid, trackName) {

			const bindingsByRoot = this._bindingsByRootAndName,
				bindings = this._bindings

			let bindingByName = bindingsByRoot[rootUuid]

			if (bindingByName === undefined) {

				bindingByName = {}
				bindingsByRoot[rootUuid] = bindingByName

			}

			bindingByName[trackName] = binding

			binding._cacheIndex = bindings.length
			bindings.push(binding)

		}

		_removeInactiveBinding (binding) {

			const bindings = this._bindings,
				propBinding = binding.binding,
				rootUuid = propBinding.rootNode.uuid,
				trackName = propBinding.path,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[rootUuid],

				lastInactiveBinding = bindings[bindings.length - 1],
				cacheIndex = binding._cacheIndex

			lastInactiveBinding._cacheIndex = cacheIndex
			bindings[cacheIndex] = lastInactiveBinding
			bindings.pop()

			delete bindingByName[trackName]

			if (Object.keys(bindingByName).length === 0) {

				delete bindingsByRoot[rootUuid]

			}

		}

		_lendBinding (binding) {

			const bindings = this._bindings,
				prevIndex = binding._cacheIndex,

				lastActiveIndex = this._nActiveBindings++,

				firstInactiveBinding = bindings[lastActiveIndex]

			binding._cacheIndex = lastActiveIndex
			bindings[lastActiveIndex] = binding

			firstInactiveBinding._cacheIndex = prevIndex
			bindings[prevIndex] = firstInactiveBinding

		}

		_takeBackBinding (binding) {

			const bindings = this._bindings,
				prevIndex = binding._cacheIndex,

				firstInactiveIndex = --this._nActiveBindings,

				lastActiveBinding = bindings[firstInactiveIndex]

			binding._cacheIndex = firstInactiveIndex
			bindings[firstInactiveIndex] = binding

			lastActiveBinding._cacheIndex = prevIndex
			bindings[prevIndex] = lastActiveBinding

		}


		// Memory management of Interpolants for weight and time scale

		_lendControlInterpolant () {

			const interpolants = this._controlInterpolants,
				lastActiveIndex = this._nActiveControlInterpolants++

			let interpolant = interpolants[lastActiveIndex]

			if (interpolant === undefined) {

				interpolant = new LinearInterpolant(
					new Float32Array(2), new Float32Array(2),
					1, this._controlInterpolantsResultBuffer)

				interpolant.__cacheIndex = lastActiveIndex
				interpolants[lastActiveIndex] = interpolant

			}

			return interpolant

		}

		_takeBackControlInterpolant (interpolant) {

			const interpolants = this._controlInterpolants,
				prevIndex = interpolant.__cacheIndex,

				firstInactiveIndex = --this._nActiveControlInterpolants,

				lastActiveInterpolant = interpolants[firstInactiveIndex]

			interpolant.__cacheIndex = firstInactiveIndex
			interpolants[firstInactiveIndex] = interpolant

			lastActiveInterpolant.__cacheIndex = prevIndex
			interpolants[prevIndex] = lastActiveInterpolant

		}

		// return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)
		clipAction (clip, optionalRoot, blendMode) {

			const root = optionalRoot || this._root,
				rootUuid = root.uuid

			let clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip

			const clipUuid = clipObject !== null ? clipObject.uuid : clip

			const actionsForClip = this._actionsByClip[clipUuid]
			let prototypeAction = null

			if (blendMode === undefined) {

				if (clipObject !== null) {

					blendMode = clipObject.blendMode

				} else {

					blendMode = NormalAnimationBlendMode

				}

			}

			if (actionsForClip !== undefined) {

				const existingAction = actionsForClip.actionByRoot[rootUuid]

				if (existingAction !== undefined && existingAction.blendMode === blendMode) {

					return existingAction

				}

				// we know the clip, so we don't have to parse all
				// the bindings again but can just copy
				prototypeAction = actionsForClip.knownActions[0]

				// also, take the clip from the prototype action
				if (clipObject === null)
					clipObject = prototypeAction._clip

			}

			// clip must be known when specified via string
			if (clipObject === null) return null

			// allocate all resources required to run it
			const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode)

			this._bindAction(newAction, prototypeAction)

			// and make the action known to the memory manager
			this._addInactiveAction(newAction, clipUuid, rootUuid)

			return newAction

		}

		// get an existing action
		existingAction (clip, optionalRoot) {

			const root = optionalRoot || this._root,
				rootUuid = root.uuid,

				clipObject = typeof clip === 'string' ?
					AnimationClip.findByName(root, clip) : clip,

				clipUuid = clipObject ? clipObject.uuid : clip,

				actionsForClip = this._actionsByClip[clipUuid]

			if (actionsForClip !== undefined) {

				return actionsForClip.actionByRoot[rootUuid] || null

			}

			return null

		}

		// deactivates all previously scheduled actions
		stopAllAction () {

			const actions = this._actions,
				nActions = this._nActiveActions

			for (let i = nActions - 1; i >= 0; --i) {

				actions[i].stop()

			}

			return this

		}

		// advance the time and update apply the animation
		update (deltaTime) {

			deltaTime *= this.timeScale

			const actions = this._actions,
				nActions = this._nActiveActions,

				time = this.time += deltaTime,
				timeDirection = Math.sign(deltaTime),

				accuIndex = this._accuIndex ^= 1

			// run active actions

			for (let i = 0; i !== nActions; ++i) {

				const action = actions[i]

				action._update(time, deltaTime, timeDirection, accuIndex)

			}

			// update scene graph

			const bindings = this._bindings,
				nBindings = this._nActiveBindings

			for (let i = 0; i !== nBindings; ++i) {

				bindings[i].apply(accuIndex)

			}

			return this

		}

		// Allows you to seek to a specific time in an animation.
		setTime (timeInSeconds) {

			this.time = 0 // Zero out time attribute for AnimationMixer object;
			for (let i = 0; i < this._actions.length; i++) {

				this._actions[i].time = 0 // Zero out time attribute for all associated AnimationAction objects.

			}

			return this.update(timeInSeconds) // Update used to set exact time. Returns "this" AnimationMixer object.

		}

		// return this mixer's root target object
		getRoot () {

			return this._root

		}

		// free all resources specific to a particular clip
		uncacheClip (clip) {

			const actions = this._actions,
				clipUuid = clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[clipUuid]

			if (actionsForClip !== undefined) {

				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away

				const actionsToRemove = actionsForClip.knownActions

				for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {

					const action = actionsToRemove[i]

					this._deactivateAction(action)

					const cacheIndex = action._cacheIndex,
						lastInactiveAction = actions[actions.length - 1]

					action._cacheIndex = null
					action._byClipCacheIndex = null

					lastInactiveAction._cacheIndex = cacheIndex
					actions[cacheIndex] = lastInactiveAction
					actions.pop()

					this._removeInactiveBindingsForAction(action)

				}

				delete actionsByClip[clipUuid]

			}

		}

		// free all resources specific to a particular root target object
		uncacheRoot (root) {

			const rootUuid = root.uuid,
				actionsByClip = this._actionsByClip

			for (const clipUuid in actionsByClip) {

				const actionByRoot = actionsByClip[clipUuid].actionByRoot,
					action = actionByRoot[rootUuid]

				if (action !== undefined) {

					this._deactivateAction(action)
					this._removeInactiveAction(action)

				}

			}

			const bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[rootUuid]

			if (bindingByName !== undefined) {

				for (const trackName in bindingByName) {

					const binding = bindingByName[trackName]
					binding.restoreOriginalState()
					this._removeInactiveBinding(binding)

				}

			}

		}

		// remove a targeted clip from the cache
		uncacheAction (clip, optionalRoot) {

			const action = this.existingAction(clip, optionalRoot)

			if (action !== null) {

				this._deactivateAction(action)
				this._removeInactiveAction(action)

			}

		}

	}

	AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1)

	class Uniform {

		constructor(value) {

			if (typeof value === 'string') {

				console.warn('THREE.Uniform: Type parameter is no longer needed.')
				value = arguments[1]

			}

			this.value = value

		}

		clone () {

			return new Uniform(this.value.clone === undefined ? this.value : this.value.clone())

		}

	}

	class InstancedInterleavedBuffer extends InterleavedBuffer {

		constructor(array, stride, meshPerAttribute = 1) {

			super(array, stride)

			this.meshPerAttribute = meshPerAttribute

		}

		copy (source) {

			super.copy(source)

			this.meshPerAttribute = source.meshPerAttribute

			return this

		}

		clone (data) {

			const ib = super.clone(data)

			ib.meshPerAttribute = this.meshPerAttribute

			return ib

		}

		toJSON (data) {

			const json = super.toJSON(data)

			json.isInstancedInterleavedBuffer = true
			json.meshPerAttribute = this.meshPerAttribute

			return json

		}

	}

	InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true

	class GLBufferAttribute {

		constructor(buffer, type, itemSize, elementSize, count) {

			this.buffer = buffer
			this.type = type
			this.itemSize = itemSize
			this.elementSize = elementSize
			this.count = count

			this.version = 0

		}

		set needsUpdate (value) {

			if (value === true) this.version++

		}

		setBuffer (buffer) {

			this.buffer = buffer

			return this

		}

		setType (type, elementSize) {

			this.type = type
			this.elementSize = elementSize

			return this

		}

		setItemSize (itemSize) {

			this.itemSize = itemSize

			return this

		}

		setCount (count) {

			this.count = count

			return this

		}

	}

	GLBufferAttribute.prototype.isGLBufferAttribute = true

	class Raycaster {

		constructor(origin, direction, near = 0, far = Infinity) {

			this.ray = new Ray(origin, direction)
			// direction is assumed to be normalized (for accurate distance calculations)

			this.near = near
			this.far = far
			this.camera = null
			this.layers = new Layers()

			this.params = {
				Mesh: {},
				Line: { threshold: 1 },
				LOD: {},
				Points: { threshold: 1 },
				Sprite: {}
			}

		}

		set (origin, direction) {

			// direction is assumed to be normalized (for accurate distance calculations)

			this.ray.set(origin, direction)

		}

		setFromCamera (coords, camera) {

			if (camera && camera.isPerspectiveCamera) {

				this.ray.origin.setFromMatrixPosition(camera.matrixWorld)
				this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize()
				this.camera = camera

			} else if (camera && camera.isOrthographicCamera) {

				this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera) // set origin in plane of camera
				this.ray.direction.set(0, 0, - 1).transformDirection(camera.matrixWorld)
				this.camera = camera

			} else {

				console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type)

			}

		}

		intersectObject (object, recursive = false, intersects = []) {

			intersectObject(object, this, intersects, recursive)

			intersects.sort(ascSort)

			return intersects

		}

		intersectObjects (objects, recursive = false, intersects = []) {

			for (let i = 0, l = objects.length; i < l; i++) {

				intersectObject(objects[i], this, intersects, recursive)

			}

			intersects.sort(ascSort)

			return intersects

		}

	}

	function ascSort (a, b) {

		return a.distance - b.distance

	}

	function intersectObject (object, raycaster, intersects, recursive) {

		if (object.layers.test(raycaster.layers)) {

			object.raycast(raycaster, intersects)

		}

		if (recursive === true) {

			const children = object.children

			for (let i = 0, l = children.length; i < l; i++) {

				intersectObject(children[i], raycaster, intersects, true)

			}

		}

	}

	/**
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
	 * The azimuthal angle (theta) is measured from the positive z-axis.
	 */

	class Spherical {

		constructor(radius = 1, phi = 0, theta = 0) {

			this.radius = radius
			this.phi = phi // polar angle
			this.theta = theta // azimuthal angle

			return this

		}

		set (radius, phi, theta) {

			this.radius = radius
			this.phi = phi
			this.theta = theta

			return this

		}

		copy (other) {

			this.radius = other.radius
			this.phi = other.phi
			this.theta = other.theta

			return this

		}

		// restrict phi to be betwee EPS and PI-EPS
		makeSafe () {

			const EPS = 0.000001
			this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi))

			return this

		}

		setFromVector3 (v) {

			return this.setFromCartesianCoords(v.x, v.y, v.z)

		}

		setFromCartesianCoords (x, y, z) {

			this.radius = Math.sqrt(x * x + y * y + z * z)

			if (this.radius === 0) {

				this.theta = 0
				this.phi = 0

			} else {

				this.theta = Math.atan2(x, z)
				this.phi = Math.acos(clamp(y / this.radius, - 1, 1))

			}

			return this

		}

		clone () {

			return new this.constructor().copy(this)

		}

	}

	/**
	 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
	 */

	class Cylindrical {

		constructor(radius = 1, theta = 0, y = 0) {

			this.radius = radius // distance from the origin to a point in the x-z plane
			this.theta = theta // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
			this.y = y // height above the x-z plane

			return this

		}

		set (radius, theta, y) {

			this.radius = radius
			this.theta = theta
			this.y = y

			return this

		}

		copy (other) {

			this.radius = other.radius
			this.theta = other.theta
			this.y = other.y

			return this

		}

		setFromVector3 (v) {

			return this.setFromCartesianCoords(v.x, v.y, v.z)

		}

		setFromCartesianCoords (x, y, z) {

			this.radius = Math.sqrt(x * x + z * z)
			this.theta = Math.atan2(x, z)
			this.y = y

			return this

		}

		clone () {

			return new this.constructor().copy(this)

		}

	}

	const _vector$4 = /*@__PURE__*/ new Vector2()

	class Box2 {

		constructor(min = new Vector2(+ Infinity, + Infinity), max = new Vector2(- Infinity, - Infinity)) {

			this.min = min
			this.max = max

		}

		set (min, max) {

			this.min.copy(min)
			this.max.copy(max)

			return this

		}

		setFromPoints (points) {

			this.makeEmpty()

			for (let i = 0, il = points.length; i < il; i++) {

				this.expandByPoint(points[i])

			}

			return this

		}

		setFromCenterAndSize (center, size) {

			const halfSize = _vector$4.copy(size).multiplyScalar(0.5)
			this.min.copy(center).sub(halfSize)
			this.max.copy(center).add(halfSize)

			return this

		}

		clone () {

			return new this.constructor().copy(this)

		}

		copy (box) {

			this.min.copy(box.min)
			this.max.copy(box.max)

			return this

		}

		makeEmpty () {

			this.min.x = this.min.y = + Infinity
			this.max.x = this.max.y = - Infinity

			return this

		}

		isEmpty () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return (this.max.x < this.min.x) || (this.max.y < this.min.y)

		}

		getCenter (target) {

			return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5)

		}

		getSize (target) {

			return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min)

		}

		expandByPoint (point) {

			this.min.min(point)
			this.max.max(point)

			return this

		}

		expandByVector (vector) {

			this.min.sub(vector)
			this.max.add(vector)

			return this

		}

		expandByScalar (scalar) {

			this.min.addScalar(- scalar)
			this.max.addScalar(scalar)

			return this

		}

		containsPoint (point) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ? false : true

		}

		containsBox (box) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y

		}

		getParameter (point, target) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			return target.set(
				(point.x - this.min.x) / (this.max.x - this.min.x),
				(point.y - this.min.y) / (this.max.y - this.min.y)
			)

		}

		intersectsBox (box) {

			// using 4 splitting planes to rule out intersections

			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ? false : true

		}

		clampPoint (point, target) {

			return target.copy(point).clamp(this.min, this.max)

		}

		distanceToPoint (point) {

			const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max)
			return clampedPoint.sub(point).length()

		}

		intersect (box) {

			this.min.max(box.min)
			this.max.min(box.max)

			return this

		}

		union (box) {

			this.min.min(box.min)
			this.max.max(box.max)

			return this

		}

		translate (offset) {

			this.min.add(offset)
			this.max.add(offset)

			return this

		}

		equals (box) {

			return box.min.equals(this.min) && box.max.equals(this.max)

		}

	}

	Box2.prototype.isBox2 = true

	const _startP = /*@__PURE__*/ new Vector3()
	const _startEnd = /*@__PURE__*/ new Vector3()

	class Line3 {

		constructor(start = new Vector3(), end = new Vector3()) {

			this.start = start
			this.end = end

		}

		set (start, end) {

			this.start.copy(start)
			this.end.copy(end)

			return this

		}

		copy (line) {

			this.start.copy(line.start)
			this.end.copy(line.end)

			return this

		}

		getCenter (target) {

			return target.addVectors(this.start, this.end).multiplyScalar(0.5)

		}

		delta (target) {

			return target.subVectors(this.end, this.start)

		}

		distanceSq () {

			return this.start.distanceToSquared(this.end)

		}

		distance () {

			return this.start.distanceTo(this.end)

		}

		at (t, target) {

			return this.delta(target).multiplyScalar(t).add(this.start)

		}

		closestPointToPointParameter (point, clampToLine) {

			_startP.subVectors(point, this.start)
			_startEnd.subVectors(this.end, this.start)

			const startEnd2 = _startEnd.dot(_startEnd)
			const startEnd_startP = _startEnd.dot(_startP)

			let t = startEnd_startP / startEnd2

			if (clampToLine) {

				t = clamp(t, 0, 1)

			}

			return t

		}

		closestPointToPoint (point, clampToLine, target) {

			const t = this.closestPointToPointParameter(point, clampToLine)

			return this.delta(target).multiplyScalar(t).add(this.start)

		}

		applyMatrix4 (matrix) {

			this.start.applyMatrix4(matrix)
			this.end.applyMatrix4(matrix)

			return this

		}

		equals (line) {

			return line.start.equals(this.start) && line.end.equals(this.end)

		}

		clone () {

			return new this.constructor().copy(this)

		}

	}

	class ImmediateRenderObject extends Object3D {

		constructor(material) {

			super()

			this.material = material
			this.render = function ( /* renderCallback */) { }

			this.hasPositions = false
			this.hasNormals = false
			this.hasColors = false
			this.hasUvs = false

			this.positionArray = null
			this.normalArray = null
			this.colorArray = null
			this.uvArray = null

			this.count = 0

		}

	}

	ImmediateRenderObject.prototype.isImmediateRenderObject = true

	const _vector$3 = /*@__PURE__*/ new Vector3()

	class SpotLightHelper extends Object3D {

		constructor(light, color) {

			super()
			this.light = light
			this.light.updateMatrixWorld()

			this.matrix = light.matrixWorld
			this.matrixAutoUpdate = false

			this.color = color

			const geometry = new BufferGeometry()

			const positions = [
				0, 0, 0, 0, 0, 1,
				0, 0, 0, 1, 0, 1,
				0, 0, 0, - 1, 0, 1,
				0, 0, 0, 0, 1, 1,
				0, 0, 0, 0, - 1, 1
			]

			for (let i = 0, j = 1, l = 32; i < l; i++, j++) {

				const p1 = (i / l) * Math.PI * 2
				const p2 = (j / l) * Math.PI * 2

				positions.push(
					Math.cos(p1), Math.sin(p1), 1,
					Math.cos(p2), Math.sin(p2), 1
				)

			}

			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3))

			const material = new LineBasicMaterial({ fog: false, toneMapped: false })

			this.cone = new LineSegments(geometry, material)
			this.add(this.cone)

			this.update()

		}

		dispose () {

			this.cone.geometry.dispose()
			this.cone.material.dispose()

		}

		update () {

			this.light.updateMatrixWorld()

			const coneLength = this.light.distance ? this.light.distance : 1000
			const coneWidth = coneLength * Math.tan(this.light.angle)

			this.cone.scale.set(coneWidth, coneWidth, coneLength)

			_vector$3.setFromMatrixPosition(this.light.target.matrixWorld)

			this.cone.lookAt(_vector$3)

			if (this.color !== undefined) {

				this.cone.material.color.set(this.color)

			} else {

				this.cone.material.color.copy(this.light.color)

			}

		}

	}

	const _vector$2 = /*@__PURE__*/ new Vector3()
	const _boneMatrix = /*@__PURE__*/ new Matrix4()
	const _matrixWorldInv = /*@__PURE__*/ new Matrix4()


	class SkeletonHelper extends LineSegments {

		constructor(object) {

			const bones = getBoneList(object)

			const geometry = new BufferGeometry()

			const vertices = []
			const colors = []

			const color1 = new Color(0, 0, 1)
			const color2 = new Color(0, 1, 0)

			for (let i = 0; i < bones.length; i++) {

				const bone = bones[i]

				if (bone.parent && bone.parent.isBone) {

					vertices.push(0, 0, 0)
					vertices.push(0, 0, 0)
					colors.push(color1.r, color1.g, color1.b)
					colors.push(color2.r, color2.g, color2.b)

				}

			}

			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3))

			const material = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true })

			super(geometry, material)

			this.type = 'SkeletonHelper'
			this.isSkeletonHelper = true

			this.root = object
			this.bones = bones

			this.matrix = object.matrixWorld
			this.matrixAutoUpdate = false

		}

		updateMatrixWorld (force) {

			const bones = this.bones

			const geometry = this.geometry
			const position = geometry.getAttribute('position')

			_matrixWorldInv.copy(this.root.matrixWorld).invert()

			for (let i = 0, j = 0; i < bones.length; i++) {

				const bone = bones[i]

				if (bone.parent && bone.parent.isBone) {

					_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld)
					_vector$2.setFromMatrixPosition(_boneMatrix)
					position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z)

					_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld)
					_vector$2.setFromMatrixPosition(_boneMatrix)
					position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z)

					j += 2

				}

			}

			geometry.getAttribute('position').needsUpdate = true

			super.updateMatrixWorld(force)

		}

	}


	function getBoneList (object) {

		const boneList = []

		if (object && object.isBone) {

			boneList.push(object)

		}

		for (let i = 0; i < object.children.length; i++) {

			boneList.push.apply(boneList, getBoneList(object.children[i]))

		}

		return boneList

	}

	class PointLightHelper extends Mesh {

		constructor(light, sphereSize, color) {

			const geometry = new SphereGeometry(sphereSize, 4, 2)
			const material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false })

			super(geometry, material)

			this.light = light
			this.light.updateMatrixWorld()

			this.color = color

			this.type = 'PointLightHelper'

			this.matrix = this.light.matrixWorld
			this.matrixAutoUpdate = false

			this.update()


			/*
		// TODO: delete this comment?
		const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
		const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

		const d = light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.scale.set( d, d, d );

		}

		this.add( this.lightDistance );
		*/

		}

		dispose () {

			this.geometry.dispose()
			this.material.dispose()

		}

		update () {

			if (this.color !== undefined) {

				this.material.color.set(this.color)

			} else {

				this.material.color.copy(this.light.color)

			}

			/*
			const d = this.light.distance;

			if ( d === 0.0 ) {

				this.lightDistance.visible = false;

			} else {

				this.lightDistance.visible = true;
				this.lightDistance.scale.set( d, d, d );

			}
			*/

		}

	}

	const _vector$1$1 = /*@__PURE__*/ new Vector3()
	const _color1 = /*@__PURE__*/ new Color()
	const _color2 = /*@__PURE__*/ new Color()

	class HemisphereLightHelper extends Object3D {

		constructor(light, size, color) {

			super()
			this.light = light
			this.light.updateMatrixWorld()

			this.matrix = light.matrixWorld
			this.matrixAutoUpdate = false

			this.color = color

			const geometry = new OctahedronGeometry(size)
			geometry.rotateY(Math.PI * 0.5)

			this.material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false })
			if (this.color === undefined) this.material.vertexColors = true

			const position = geometry.getAttribute('position')
			const colors = new Float32Array(position.count * 3)

			geometry.setAttribute('color', new BufferAttribute(colors, 3))

			this.add(new Mesh(geometry, this.material))

			this.update()

		}

		dispose () {

			this.children[0].geometry.dispose()
			this.children[0].material.dispose()

		}

		update () {

			const mesh = this.children[0]

			if (this.color !== undefined) {

				this.material.color.set(this.color)

			} else {

				const colors = mesh.geometry.getAttribute('color')

				_color1.copy(this.light.color)
				_color2.copy(this.light.groundColor)

				for (let i = 0, l = colors.count; i < l; i++) {

					const color = (i < (l / 2)) ? _color1 : _color2

					colors.setXYZ(i, color.r, color.g, color.b)

				}

				colors.needsUpdate = true

			}

			mesh.lookAt(_vector$1$1.setFromMatrixPosition(this.light.matrixWorld).negate())

		}

	}

	class GridHelper extends LineSegments {

		constructor(size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888) {

			color1 = new Color(color1)
			color2 = new Color(color2)

			const center = divisions / 2
			const step = size / divisions
			const halfSize = size / 2

			const vertices = [], colors = []

			for (let i = 0, j = 0, k = - halfSize; i <= divisions; i++, k += step) {

				vertices.push(- halfSize, 0, k, halfSize, 0, k)
				vertices.push(k, 0, - halfSize, k, 0, halfSize)

				const color = i === center ? color1 : color2

				color.toArray(colors, j); j += 3
				color.toArray(colors, j); j += 3
				color.toArray(colors, j); j += 3
				color.toArray(colors, j); j += 3

			}

			const geometry = new BufferGeometry()
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3))

			const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false })

			super(geometry, material)

			this.type = 'GridHelper'

		}

	}

	class PolarGridHelper extends LineSegments {

		constructor(radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888) {

			color1 = new Color(color1)
			color2 = new Color(color2)

			const vertices = []
			const colors = []

			// create the radials

			for (let i = 0; i <= radials; i++) {

				const v = (i / radials) * (Math.PI * 2)

				const x = Math.sin(v) * radius
				const z = Math.cos(v) * radius

				vertices.push(0, 0, 0)
				vertices.push(x, 0, z)

				const color = (i & 1) ? color1 : color2

				colors.push(color.r, color.g, color.b)
				colors.push(color.r, color.g, color.b)

			}

			// create the circles

			for (let i = 0; i <= circles; i++) {

				const color = (i & 1) ? color1 : color2

				const r = radius - (radius / circles * i)

				for (let j = 0; j < divisions; j++) {

					// first vertex

					let v = (j / divisions) * (Math.PI * 2)

					let x = Math.sin(v) * r
					let z = Math.cos(v) * r

					vertices.push(x, 0, z)
					colors.push(color.r, color.g, color.b)

					// second vertex

					v = ((j + 1) / divisions) * (Math.PI * 2)

					x = Math.sin(v) * r
					z = Math.cos(v) * r

					vertices.push(x, 0, z)
					colors.push(color.r, color.g, color.b)

				}

			}

			const geometry = new BufferGeometry()
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3))

			const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false })

			super(geometry, material)

			this.type = 'PolarGridHelper'

		}

	}

	const _v1$8 = /*@__PURE__*/ new Vector3()
	const _v2$4 = /*@__PURE__*/ new Vector3()
	const _v3$2 = /*@__PURE__*/ new Vector3()

	class DirectionalLightHelper extends Object3D {

		constructor(light, size, color) {

			super()
			this.light = light
			this.light.updateMatrixWorld()

			this.matrix = light.matrixWorld
			this.matrixAutoUpdate = false

			this.color = color

			if (size === undefined) size = 1

			let geometry = new BufferGeometry()
			geometry.setAttribute('position', new Float32BufferAttribute([
				- size, size, 0,
				size, size, 0,
				size, - size, 0,
				- size, - size, 0,
				- size, size, 0
			], 3))

			const material = new LineBasicMaterial({ fog: false, toneMapped: false })

			this.lightPlane = new Line(geometry, material)
			this.add(this.lightPlane)

			geometry = new BufferGeometry()
			geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3))

			this.targetLine = new Line(geometry, material)
			this.add(this.targetLine)

			this.update()

		}

		dispose () {

			this.lightPlane.geometry.dispose()
			this.lightPlane.material.dispose()
			this.targetLine.geometry.dispose()
			this.targetLine.material.dispose()

		}

		update () {

			_v1$8.setFromMatrixPosition(this.light.matrixWorld)
			_v2$4.setFromMatrixPosition(this.light.target.matrixWorld)
			_v3$2.subVectors(_v2$4, _v1$8)

			this.lightPlane.lookAt(_v2$4)

			if (this.color !== undefined) {

				this.lightPlane.material.color.set(this.color)
				this.targetLine.material.color.set(this.color)

			} else {

				this.lightPlane.material.color.copy(this.light.color)
				this.targetLine.material.color.copy(this.light.color)

			}

			this.targetLine.lookAt(_v2$4)
			this.targetLine.scale.z = _v3$2.length()

		}

	}

	const _vector$d = /*@__PURE__*/ new Vector3()
	const _camera$2 = /*@__PURE__*/ new Camera()

	/**
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */

	class CameraHelper extends LineSegments {

		constructor(camera) {

			const geometry = new BufferGeometry()
			const material = new LineBasicMaterial({ color: 0xffffff, vertexColors: true, toneMapped: false })

			const vertices = []
			const colors = []

			const pointMap = {}

			// colors

			const colorFrustum = new Color(0xffaa00)
			const colorCone = new Color(0xff0000)
			const colorUp = new Color(0x00aaff)
			const colorTarget = new Color(0xffffff)
			const colorCross = new Color(0x333333)

			// near

			addLine('n1', 'n2', colorFrustum)
			addLine('n2', 'n4', colorFrustum)
			addLine('n4', 'n3', colorFrustum)
			addLine('n3', 'n1', colorFrustum)

			// far

			addLine('f1', 'f2', colorFrustum)
			addLine('f2', 'f4', colorFrustum)
			addLine('f4', 'f3', colorFrustum)
			addLine('f3', 'f1', colorFrustum)

			// sides

			addLine('n1', 'f1', colorFrustum)
			addLine('n2', 'f2', colorFrustum)
			addLine('n3', 'f3', colorFrustum)
			addLine('n4', 'f4', colorFrustum)

			// cone

			addLine('p', 'n1', colorCone)
			addLine('p', 'n2', colorCone)
			addLine('p', 'n3', colorCone)
			addLine('p', 'n4', colorCone)

			// up

			addLine('u1', 'u2', colorUp)
			addLine('u2', 'u3', colorUp)
			addLine('u3', 'u1', colorUp)

			// target

			addLine('c', 't', colorTarget)
			addLine('p', 'c', colorCross)

			// cross

			addLine('cn1', 'cn2', colorCross)
			addLine('cn3', 'cn4', colorCross)

			addLine('cf1', 'cf2', colorCross)
			addLine('cf3', 'cf4', colorCross)

			function addLine (a, b, color) {

				addPoint(a, color)
				addPoint(b, color)

			}

			function addPoint (id, color) {

				vertices.push(0, 0, 0)
				colors.push(color.r, color.g, color.b)

				if (pointMap[id] === undefined) {

					pointMap[id] = []

				}

				pointMap[id].push((vertices.length / 3) - 1)

			}

			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3))

			super(geometry, material)

			this.type = 'CameraHelper'

			this.camera = camera
			if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix()

			this.matrix = camera.matrixWorld
			this.matrixAutoUpdate = false

			this.pointMap = pointMap

			this.update()

		}

		update () {

			const geometry = this.geometry
			const pointMap = this.pointMap

			const w = 1, h = 1

			// we need just camera projection matrix inverse
			// world matrix must be identity

			_camera$2.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse)

			// center / target

			setPoint('c', pointMap, geometry, _camera$2, 0, 0, - 1)
			setPoint('t', pointMap, geometry, _camera$2, 0, 0, 1)

			// near

			setPoint('n1', pointMap, geometry, _camera$2, - w, - h, - 1)
			setPoint('n2', pointMap, geometry, _camera$2, w, - h, - 1)
			setPoint('n3', pointMap, geometry, _camera$2, - w, h, - 1)
			setPoint('n4', pointMap, geometry, _camera$2, w, h, - 1)

			// far

			setPoint('f1', pointMap, geometry, _camera$2, - w, - h, 1)
			setPoint('f2', pointMap, geometry, _camera$2, w, - h, 1)
			setPoint('f3', pointMap, geometry, _camera$2, - w, h, 1)
			setPoint('f4', pointMap, geometry, _camera$2, w, h, 1)

			// up

			setPoint('u1', pointMap, geometry, _camera$2, w * 0.7, h * 1.1, - 1)
			setPoint('u2', pointMap, geometry, _camera$2, - w * 0.7, h * 1.1, - 1)
			setPoint('u3', pointMap, geometry, _camera$2, 0, h * 2, - 1)

			// cross

			setPoint('cf1', pointMap, geometry, _camera$2, - w, 0, 1)
			setPoint('cf2', pointMap, geometry, _camera$2, w, 0, 1)
			setPoint('cf3', pointMap, geometry, _camera$2, 0, - h, 1)
			setPoint('cf4', pointMap, geometry, _camera$2, 0, h, 1)

			setPoint('cn1', pointMap, geometry, _camera$2, - w, 0, - 1)
			setPoint('cn2', pointMap, geometry, _camera$2, w, 0, - 1)
			setPoint('cn3', pointMap, geometry, _camera$2, 0, - h, - 1)
			setPoint('cn4', pointMap, geometry, _camera$2, 0, h, - 1)

			geometry.getAttribute('position').needsUpdate = true

		}

		dispose () {

			this.geometry.dispose()
			this.material.dispose()

		}

	}


	function setPoint (point, pointMap, geometry, camera, x, y, z) {

		_vector$d.set(x, y, z).unproject(camera)

		const points = pointMap[point]

		if (points !== undefined) {

			const position = geometry.getAttribute('position')

			for (let i = 0, l = points.length; i < l; i++) {

				position.setXYZ(points[i], _vector$d.x, _vector$d.y, _vector$d.z)

			}

		}

	}

	const _box$4 = /*@__PURE__*/ new Box3()

	class BoxHelper extends LineSegments {

		constructor(object, color = 0xffff00) {

			const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
			const positions = new Float32Array(8 * 3)

			const geometry = new BufferGeometry()
			geometry.setIndex(new BufferAttribute(indices, 1))
			geometry.setAttribute('position', new BufferAttribute(positions, 3))

			super(geometry, new LineBasicMaterial({ color: color, toneMapped: false }))

			this.object = object
			this.type = 'BoxHelper'

			this.matrixAutoUpdate = false

			this.update()

		}

		update (object) {

			if (object !== undefined) {

				console.warn('THREE.BoxHelper: .update() has no longer arguments.')

			}

			if (this.object !== undefined) {

				_box$4.setFromObject(this.object)

			}

			if (_box$4.isEmpty()) return

			const min = _box$4.min
			const max = _box$4.max

			/*
				5____4
			1/___0/|
			| 6__|_7
			2/___3/

			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/

			const position = this.geometry.attributes.position
			const array = position.array

			array[0] = max.x; array[1] = max.y; array[2] = max.z
			array[3] = min.x; array[4] = max.y; array[5] = max.z
			array[6] = min.x; array[7] = min.y; array[8] = max.z
			array[9] = max.x; array[10] = min.y; array[11] = max.z
			array[12] = max.x; array[13] = max.y; array[14] = min.z
			array[15] = min.x; array[16] = max.y; array[17] = min.z
			array[18] = min.x; array[19] = min.y; array[20] = min.z
			array[21] = max.x; array[22] = min.y; array[23] = min.z

			position.needsUpdate = true

			this.geometry.computeBoundingSphere()


		}

		setFromObject (object) {

			this.object = object
			this.update()

			return this

		}

		copy (source) {

			LineSegments.prototype.copy.call(this, source)

			this.object = source.object

			return this

		}

	}

	class Box3Helper extends LineSegments {

		constructor(box, color = 0xffff00) {

			const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])

			const positions = [1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1]

			const geometry = new BufferGeometry()

			geometry.setIndex(new BufferAttribute(indices, 1))

			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3))

			super(geometry, new LineBasicMaterial({ color: color, toneMapped: false }))

			this.box = box

			this.type = 'Box3Helper'

			this.geometry.computeBoundingSphere()

		}

		updateMatrixWorld (force) {

			const box = this.box

			if (box.isEmpty()) return

			box.getCenter(this.position)

			box.getSize(this.scale)

			this.scale.multiplyScalar(0.5)

			super.updateMatrixWorld(force)

		}

	}

	class PlaneHelper extends Line {

		constructor(plane, size = 1, hex = 0xffff00) {

			const color = hex

			const positions = [1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0]

			const geometry = new BufferGeometry()
			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3))
			geometry.computeBoundingSphere()

			super(geometry, new LineBasicMaterial({ color: color, toneMapped: false }))

			this.type = 'PlaneHelper'

			this.plane = plane

			this.size = size

			const positions2 = [1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1]

			const geometry2 = new BufferGeometry()
			geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3))
			geometry2.computeBoundingSphere()

			this.add(new Mesh(geometry2, new MeshBasicMaterial({ color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false })))

		}

		updateMatrixWorld (force) {

			let scale = - this.plane.constant

			if (Math.abs(scale) < 1e-8) scale = 1e-8 // sign does not matter

			this.scale.set(0.5 * this.size, 0.5 * this.size, scale)

			this.children[0].material.side = (scale < 0) ? BackSide : FrontSide // renderer flips side when determinant < 0; flipping not wanted here

			this.lookAt(this.plane.normal)

			super.updateMatrixWorld(force)

		}

	}

	const _axis = /*@__PURE__*/ new Vector3()
	let _lineGeometry, _coneGeometry

	class ArrowHelper extends Object3D {

		// dir is assumed to be normalized

		constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2) {

			super()

			this.type = 'ArrowHelper'

			if (_lineGeometry === undefined) {

				_lineGeometry = new BufferGeometry()
				_lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3))

				_coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1)
				_coneGeometry.translate(0, - 0.5, 0)

			}

			this.position.copy(origin)

			this.line = new Line(_lineGeometry, new LineBasicMaterial({ color: color, toneMapped: false }))
			this.line.matrixAutoUpdate = false
			this.add(this.line)

			this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({ color: color, toneMapped: false }))
			this.cone.matrixAutoUpdate = false
			this.add(this.cone)

			this.setDirection(dir)
			this.setLength(length, headLength, headWidth)

		}

		setDirection (dir) {

			// dir is assumed to be normalized

			if (dir.y > 0.99999) {

				this.quaternion.set(0, 0, 0, 1)

			} else if (dir.y < - 0.99999) {

				this.quaternion.set(1, 0, 0, 0)

			} else {

				_axis.set(dir.z, 0, - dir.x).normalize()

				const radians = Math.acos(dir.y)

				this.quaternion.setFromAxisAngle(_axis, radians)

			}

		}

		setLength (length, headLength = length * 0.2, headWidth = headLength * 0.2) {

			this.line.scale.set(1, Math.max(0.0001, length - headLength), 1) // see #17458
			this.line.updateMatrix()

			this.cone.scale.set(headWidth, headLength, headWidth)
			this.cone.position.y = length
			this.cone.updateMatrix()

		}

		setColor (color) {

			this.line.material.color.set(color)
			this.cone.material.color.set(color)

		}

		copy (source) {

			super.copy(source, false)

			this.line.copy(source.line)
			this.cone.copy(source.cone)

			return this

		}

	}

	class AxesHelper extends LineSegments {

		constructor(size = 1) {

			const vertices = [
				0, 0, 0, size, 0, 0,
				0, 0, 0, 0, size, 0,
				0, 0, 0, 0, 0, size
			]

			const colors = [
				1, 0, 0, 1, 0.6, 0,
				0, 1, 0, 0.6, 1, 0,
				0, 0, 1, 0, 0.6, 1
			]

			const geometry = new BufferGeometry()
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3))

			const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false })

			super(geometry, material)

			this.type = 'AxesHelper'

		}

		setColors (xAxisColor, yAxisColor, zAxisColor) {

			const color = new Color()
			const array = this.geometry.attributes.color.array

			color.set(xAxisColor)
			color.toArray(array, 0)
			color.toArray(array, 3)

			color.set(yAxisColor)
			color.toArray(array, 6)
			color.toArray(array, 9)

			color.set(zAxisColor)
			color.toArray(array, 12)
			color.toArray(array, 15)

			this.geometry.attributes.color.needsUpdate = true

			return this

		}

		dispose () {

			this.geometry.dispose()
			this.material.dispose()

		}

	}

	const _floatView = new Float32Array(1)
	const _int32View = new Int32Array(_floatView.buffer)

	class DataUtils {

		// Converts float32 to float16 (stored as uint16 value).

		static toHalfFloat (val) {

			// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410

			/* This method is faster than the OpenEXR implementation (very often
			* used, eg. in Ogre), with the additional benefit of rounding, inspired
			* by James Tursa?s half-precision code. */

			_floatView[0] = val
			const x = _int32View[0]

			let bits = (x >> 16) & 0x8000 /* Get the sign */
			let m = (x >> 12) & 0x07ff /* Keep one extra bit for rounding */
			const e = (x >> 23) & 0xff /* Using int is faster here */

			/* If zero, or denormal, or exponent underflows too much for a denormal
				* half, return signed zero. */
			if (e < 103) return bits

			/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
			if (e > 142) {

				bits |= 0x7c00
				/* If exponent was 0xff and one mantissa bit was set, it means NaN,
							* not Inf, so make sure we set one mantissa bit too. */
				bits |= ((e == 255) ? 0 : 1) && (x & 0x007fffff)
				return bits

			}

			/* If exponent underflows but not too much, return a denormal */
			if (e < 113) {

				m |= 0x0800
				/* Extra rounding may overflow and set mantissa to 0 and exponent
					* to 1, which is OK. */
				bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1)
				return bits

			}

			bits |= ((e - 112) << 10) | (m >> 1)
			/* Extra rounding. An overflow will set mantissa to 0 and increment
				* the exponent, which is OK. */
			bits += m & 1
			return bits

		}

	}

	const LineStrip = 0
	const LinePieces = 1
	const NoColors = 0
	const FaceColors = 1
	const VertexColors = 2

	function MeshFaceMaterial (materials) {

		console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.')
		return materials

	}

	function MultiMaterial (materials = []) {

		console.warn('THREE.MultiMaterial has been removed. Use an Array instead.')
		materials.isMultiMaterial = true
		materials.materials = materials
		materials.clone = function () {

			return materials.slice()

		}

		return materials

	}

	function PointCloud (geometry, material) {

		console.warn('THREE.PointCloud has been renamed to THREE.Points.')
		return new Points(geometry, material)

	}

	function Particle (material) {

		console.warn('THREE.Particle has been renamed to THREE.Sprite.')
		return new Sprite(material)

	}

	function ParticleSystem (geometry, material) {

		console.warn('THREE.ParticleSystem has been renamed to THREE.Points.')
		return new Points(geometry, material)

	}

	function PointCloudMaterial (parameters) {

		console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.')
		return new PointsMaterial(parameters)

	}

	function ParticleBasicMaterial (parameters) {

		console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.')
		return new PointsMaterial(parameters)

	}

	function ParticleSystemMaterial (parameters) {

		console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.')
		return new PointsMaterial(parameters)

	}

	function Vertex (x, y, z) {

		console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.')
		return new Vector3(x, y, z)

	}

	//

	function DynamicBufferAttribute (array, itemSize) {

		console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.')
		return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage)

	}

	function Int8Attribute (array, itemSize) {

		console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.')
		return new Int8BufferAttribute(array, itemSize)

	}

	function Uint8Attribute (array, itemSize) {

		console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.')
		return new Uint8BufferAttribute(array, itemSize)

	}

	function Uint8ClampedAttribute (array, itemSize) {

		console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.')
		return new Uint8ClampedBufferAttribute(array, itemSize)

	}

	function Int16Attribute (array, itemSize) {

		console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.')
		return new Int16BufferAttribute(array, itemSize)

	}

	function Uint16Attribute (array, itemSize) {

		console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.')
		return new Uint16BufferAttribute(array, itemSize)

	}

	function Int32Attribute (array, itemSize) {

		console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.')
		return new Int32BufferAttribute(array, itemSize)

	}

	function Uint32Attribute (array, itemSize) {

		console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.')
		return new Uint32BufferAttribute(array, itemSize)

	}

	function Float32Attribute (array, itemSize) {

		console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.')
		return new Float32BufferAttribute(array, itemSize)

	}

	function Float64Attribute (array, itemSize) {

		console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.')
		return new Float64BufferAttribute(array, itemSize)

	}

	//

	Curve.create = function (construct, getPoint) {

		console.log('THREE.Curve.create() has been deprecated')

		construct.prototype = Object.create(Curve.prototype)
		construct.prototype.constructor = construct
		construct.prototype.getPoint = getPoint

		return construct

	}

	//

	Path.prototype.fromPoints = function (points) {

		console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().')
		return this.setFromPoints(points)

	}

	//

	function AxisHelper (size) {

		console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.')
		return new AxesHelper(size)

	}

	function BoundingBoxHelper (object, color) {

		console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.')
		return new BoxHelper(object, color)

	}

	function EdgesHelper (object, hex) {

		console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.')
		return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({ color: hex !== undefined ? hex : 0xffffff }))

	}

	GridHelper.prototype.setColors = function () {

		console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.')

	}

	SkeletonHelper.prototype.update = function () {

		console.error('THREE.SkeletonHelper: update() no longer needs to be called.')

	}

	function WireframeHelper (object, hex) {

		console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.')
		return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({ color: hex !== undefined ? hex : 0xffffff }))

	}

	//

	Loader.prototype.extractUrlBase = function (url) {

		console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.')
		return LoaderUtils.extractUrlBase(url)

	}

	Loader.Handlers = {

		add: function ( /* regex, loader */) {

			console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.')

		},

		get: function ( /* file */) {

			console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.')

		}

	}

	function XHRLoader (manager) {

		console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.')
		return new FileLoader(manager)

	}

	function BinaryTextureLoader (manager) {

		console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.')
		return new DataTextureLoader(manager)

	}

	//

	Box2.prototype.center = function (optionalTarget) {

		console.warn('THREE.Box2: .center() has been renamed to .getCenter().')
		return this.getCenter(optionalTarget)

	}

	Box2.prototype.empty = function () {

		console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().')
		return this.isEmpty()

	}

	Box2.prototype.isIntersectionBox = function (box) {

		console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().')
		return this.intersectsBox(box)

	}

	Box2.prototype.size = function (optionalTarget) {

		console.warn('THREE.Box2: .size() has been renamed to .getSize().')
		return this.getSize(optionalTarget)

	}

	//

	Box3.prototype.center = function (optionalTarget) {

		console.warn('THREE.Box3: .center() has been renamed to .getCenter().')
		return this.getCenter(optionalTarget)

	}

	Box3.prototype.empty = function () {

		console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().')
		return this.isEmpty()

	}

	Box3.prototype.isIntersectionBox = function (box) {

		console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().')
		return this.intersectsBox(box)

	}

	Box3.prototype.isIntersectionSphere = function (sphere) {

		console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().')
		return this.intersectsSphere(sphere)

	}

	Box3.prototype.size = function (optionalTarget) {

		console.warn('THREE.Box3: .size() has been renamed to .getSize().')
		return this.getSize(optionalTarget)

	}

	//

	Sphere.prototype.empty = function () {

		console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().')
		return this.isEmpty()

	}

	//

	Frustum.prototype.setFromMatrix = function (m) {

		console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().')
		return this.setFromProjectionMatrix(m)

	}

	//

	Line3.prototype.center = function (optionalTarget) {

		console.warn('THREE.Line3: .center() has been renamed to .getCenter().')
		return this.getCenter(optionalTarget)

	}

	//

	Matrix3.prototype.flattenToArrayOffset = function (array, offset) {

		console.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.')
		return this.toArray(array, offset)

	}

	Matrix3.prototype.multiplyVector3 = function (vector) {

		console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.')
		return vector.applyMatrix3(this)

	}

	Matrix3.prototype.multiplyVector3Array = function ( /* a */) {

		console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.')

	}

	Matrix3.prototype.applyToBufferAttribute = function (attribute) {

		console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.')
		return attribute.applyMatrix3(this)

	}

	Matrix3.prototype.applyToVector3Array = function ( /* array, offset, length */) {

		console.error('THREE.Matrix3: .applyToVector3Array() has been removed.')

	}

	Matrix3.prototype.getInverse = function (matrix) {

		console.warn('THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.')
		return this.copy(matrix).invert()

	}

	//

	Matrix4.prototype.extractPosition = function (m) {

		console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().')
		return this.copyPosition(m)

	}

	Matrix4.prototype.flattenToArrayOffset = function (array, offset) {

		console.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.')
		return this.toArray(array, offset)

	}

	Matrix4.prototype.getPosition = function () {

		console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.')
		return new Vector3().setFromMatrixColumn(this, 3)

	}

	Matrix4.prototype.setRotationFromQuaternion = function (q) {

		console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().')
		return this.makeRotationFromQuaternion(q)

	}

	Matrix4.prototype.multiplyToArray = function () {

		console.warn('THREE.Matrix4: .multiplyToArray() has been removed.')

	}

	Matrix4.prototype.multiplyVector3 = function (vector) {

		console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.')
		return vector.applyMatrix4(this)

	}

	Matrix4.prototype.multiplyVector4 = function (vector) {

		console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.')
		return vector.applyMatrix4(this)

	}

	Matrix4.prototype.multiplyVector3Array = function ( /* a */) {

		console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.')

	}

	Matrix4.prototype.rotateAxis = function (v) {

		console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.')
		v.transformDirection(this)

	}

	Matrix4.prototype.crossVector = function (vector) {

		console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.')
		return vector.applyMatrix4(this)

	}

	Matrix4.prototype.translate = function () {

		console.error('THREE.Matrix4: .translate() has been removed.')

	}

	Matrix4.prototype.rotateX = function () {

		console.error('THREE.Matrix4: .rotateX() has been removed.')

	}

	Matrix4.prototype.rotateY = function () {

		console.error('THREE.Matrix4: .rotateY() has been removed.')

	}

	Matrix4.prototype.rotateZ = function () {

		console.error('THREE.Matrix4: .rotateZ() has been removed.')

	}

	Matrix4.prototype.rotateByAxis = function () {

		console.error('THREE.Matrix4: .rotateByAxis() has been removed.')

	}

	Matrix4.prototype.applyToBufferAttribute = function (attribute) {

		console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.')
		return attribute.applyMatrix4(this)

	}

	Matrix4.prototype.applyToVector3Array = function ( /* array, offset, length */) {

		console.error('THREE.Matrix4: .applyToVector3Array() has been removed.')

	}

	Matrix4.prototype.makeFrustum = function (left, right, bottom, top, near, far) {

		console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.')
		return this.makePerspective(left, right, top, bottom, near, far)

	}

	Matrix4.prototype.getInverse = function (matrix) {

		console.warn('THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.')
		return this.copy(matrix).invert()

	}

	//

	Plane.prototype.isIntersectionLine = function (line) {

		console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().')
		return this.intersectsLine(line)

	}

	//

	Quaternion.prototype.multiplyVector3 = function (vector) {

		console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.')
		return vector.applyQuaternion(this)

	}

	Quaternion.prototype.inverse = function () {

		console.warn('THREE.Quaternion: .inverse() has been renamed to invert().')
		return this.invert()

	}

	//

	Ray.prototype.isIntersectionBox = function (box) {

		console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().')
		return this.intersectsBox(box)

	}

	Ray.prototype.isIntersectionPlane = function (plane) {

		console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().')
		return this.intersectsPlane(plane)

	}

	Ray.prototype.isIntersectionSphere = function (sphere) {

		console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().')
		return this.intersectsSphere(sphere)

	}

	//

	Triangle.prototype.area = function () {

		console.warn('THREE.Triangle: .area() has been renamed to .getArea().')
		return this.getArea()

	}

	Triangle.prototype.barycoordFromPoint = function (point, target) {

		console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().')
		return this.getBarycoord(point, target)

	}

	Triangle.prototype.midpoint = function (target) {

		console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().')
		return this.getMidpoint(target)

	}

	Triangle.prototypenormal = function (target) {

		console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().')
		return this.getNormal(target)

	}

	Triangle.prototype.plane = function (target) {

		console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().')
		return this.getPlane(target)

	}

	Triangle.barycoordFromPoint = function (point, a, b, c, target) {

		console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().')
		return Triangle.getBarycoord(point, a, b, c, target)

	}

	Triangle.normal = function (a, b, c, target) {

		console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().')
		return Triangle.getNormal(a, b, c, target)

	}

	//

	Shape.prototype.extractAllPoints = function (divisions) {

		console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.')
		return this.extractPoints(divisions)

	}

	Shape.prototype.extrude = function (options) {

		console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.')
		return new ExtrudeGeometry(this, options)

	}

	Shape.prototype.makeGeometry = function (options) {

		console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.')
		return new ShapeGeometry(this, options)

	}

	//

	Vector2.prototype.fromAttribute = function (attribute, index, offset) {

		console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().')
		return this.fromBufferAttribute(attribute, index, offset)

	}

	Vector2.prototype.distanceToManhattan = function (v) {

		console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().')
		return this.manhattanDistanceTo(v)

	}

	Vector2.prototype.lengthManhattan = function () {

		console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().')
		return this.manhattanLength()

	}

	//

	Vector3.prototype.setEulerFromRotationMatrix = function () {

		console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.')

	}

	Vector3.prototype.setEulerFromQuaternion = function () {

		console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.')

	}

	Vector3.prototype.getPositionFromMatrix = function (m) {

		console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().')
		return this.setFromMatrixPosition(m)

	}

	Vector3.prototype.getScaleFromMatrix = function (m) {

		console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().')
		return this.setFromMatrixScale(m)

	}

	Vector3.prototype.getColumnFromMatrix = function (index, matrix) {

		console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().')
		return this.setFromMatrixColumn(matrix, index)

	}

	Vector3.prototype.applyProjection = function (m) {

		console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.')
		return this.applyMatrix4(m)

	}

	Vector3.prototype.fromAttribute = function (attribute, index, offset) {

		console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().')
		return this.fromBufferAttribute(attribute, index, offset)

	}

	Vector3.prototype.distanceToManhattan = function (v) {

		console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().')
		return this.manhattanDistanceTo(v)

	}

	Vector3.prototype.lengthManhattan = function () {

		console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().')
		return this.manhattanLength()

	}

	//

	Vector4.prototype.fromAttribute = function (attribute, index, offset) {

		console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().')
		return this.fromBufferAttribute(attribute, index, offset)

	}

	Vector4.prototype.lengthManhattan = function () {

		console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().')
		return this.manhattanLength()

	}

	//

	Object3D.prototype.getChildByName = function (name) {

		console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().')
		return this.getObjectByName(name)

	}

	Object3D.prototype.renderDepth = function () {

		console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.')

	}

	Object3D.prototype.translate = function (distance, axis) {

		console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.')
		return this.translateOnAxis(axis, distance)

	}

	Object3D.prototype.getWorldRotation = function () {

		console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.')

	}

	Object3D.prototype.applyMatrix = function (matrix) {

		console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().')
		return this.applyMatrix4(matrix)

	}

	Object.defineProperties(Object3D.prototype, {

		eulerOrder: {
			get: function () {

				console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.')
				return this.rotation.order

			},
			set: function (value) {

				console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.')
				this.rotation.order = value

			}
		},
		useQuaternion: {
			get: function () {

				console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.')

			},
			set: function () {

				console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.')

			}
		}

	})

	Mesh.prototype.setDrawMode = function () {

		console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.')

	}

	Object.defineProperties(Mesh.prototype, {

		drawMode: {
			get: function () {

				console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.')
				return TrianglesDrawMode

			},
			set: function () {

				console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.')

			}
		}

	})

	SkinnedMesh.prototype.initBones = function () {

		console.error('THREE.SkinnedMesh: initBones() has been removed.')

	}

	//

	PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {

		console.warn('THREE.PerspectiveCamera.setLens is deprecated. ' +
			'Use .setFocalLength and .filmGauge for a photographic setup.')

		if (filmGauge !== undefined) this.filmGauge = filmGauge
		this.setFocalLength(focalLength)

	}

	//

	Object.defineProperties(Light.prototype, {
		onlyShadow: {
			set: function () {

				console.warn('THREE.Light: .onlyShadow has been removed.')

			}
		},
		shadowCameraFov: {
			set: function (value) {

				console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.')
				this.shadow.camera.fov = value

			}
		},
		shadowCameraLeft: {
			set: function (value) {

				console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.')
				this.shadow.camera.left = value

			}
		},
		shadowCameraRight: {
			set: function (value) {

				console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.')
				this.shadow.camera.right = value

			}
		},
		shadowCameraTop: {
			set: function (value) {

				console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.')
				this.shadow.camera.top = value

			}
		},
		shadowCameraBottom: {
			set: function (value) {

				console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.')
				this.shadow.camera.bottom = value

			}
		},
		shadowCameraNear: {
			set: function (value) {

				console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.')
				this.shadow.camera.near = value

			}
		},
		shadowCameraFar: {
			set: function (value) {

				console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.')
				this.shadow.camera.far = value

			}
		},
		shadowCameraVisible: {
			set: function () {

				console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.')

			}
		},
		shadowBias: {
			set: function (value) {

				console.warn('THREE.Light: .shadowBias is now .shadow.bias.')
				this.shadow.bias = value

			}
		},
		shadowDarkness: {
			set: function () {

				console.warn('THREE.Light: .shadowDarkness has been removed.')

			}
		},
		shadowMapWidth: {
			set: function (value) {

				console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.')
				this.shadow.mapSize.width = value

			}
		},
		shadowMapHeight: {
			set: function (value) {

				console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.')
				this.shadow.mapSize.height = value

			}
		}
	})

	//

	Object.defineProperties(BufferAttribute.prototype, {

		length: {
			get: function () {

				console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.')
				return this.array.length

			}
		},
		dynamic: {
			get: function () {

				console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.')
				return this.usage === DynamicDrawUsage

			},
			set: function ( /* value */) {

				console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.')
				this.setUsage(DynamicDrawUsage)

			}
		}

	})

	BufferAttribute.prototype.setDynamic = function (value) {

		console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.')
		this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage)
		return this

	}

	BufferAttribute.prototype.copyIndicesArray = function ( /* indices */) {

		console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.')

	},

		BufferAttribute.prototype.setArray = function ( /* array */) {

			console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers')

		}

	//

	BufferGeometry.prototype.addIndex = function (index) {

		console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().')
		this.setIndex(index)

	}

	BufferGeometry.prototype.addAttribute = function (name, attribute) {

		console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().')

		if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {

			console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).')

			return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]))

		}

		if (name === 'index') {

			console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.')
			this.setIndex(attribute)

			return this

		}

		return this.setAttribute(name, attribute)

	}

	BufferGeometry.prototype.addDrawCall = function (start, count, indexOffset) {

		if (indexOffset !== undefined) {

			console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.')

		}

		console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().')
		this.addGroup(start, count)

	}

	BufferGeometry.prototype.clearDrawCalls = function () {

		console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().')
		this.clearGroups()

	}

	BufferGeometry.prototype.computeOffsets = function () {

		console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.')

	}

	BufferGeometry.prototype.removeAttribute = function (name) {

		console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().')

		return this.deleteAttribute(name)

	}

	BufferGeometry.prototype.applyMatrix = function (matrix) {

		console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().')
		return this.applyMatrix4(matrix)

	}

	Object.defineProperties(BufferGeometry.prototype, {

		drawcalls: {
			get: function () {

				console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.')
				return this.groups

			}
		},
		offsets: {
			get: function () {

				console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.')
				return this.groups

			}
		}

	})

	InterleavedBuffer.prototype.setDynamic = function (value) {

		console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.')
		this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage)
		return this

	}

	InterleavedBuffer.prototype.setArray = function ( /* array */) {

		console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers')

	}

	//

	ExtrudeGeometry.prototype.getArrays = function () {

		console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.')

	}

	ExtrudeGeometry.prototype.addShapeList = function () {

		console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.')

	}

	ExtrudeGeometry.prototype.addShape = function () {

		console.error('THREE.ExtrudeGeometry: .addShape() has been removed.')

	}

	//

	Scene.prototype.dispose = function () {

		console.error('THREE.Scene: .dispose() has been removed.')

	}

	//

	Uniform.prototype.onUpdate = function () {

		console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.')
		return this

	}

	//

	Object.defineProperties(Material.prototype, {

		wrapAround: {
			get: function () {

				console.warn('THREE.Material: .wrapAround has been removed.')

			},
			set: function () {

				console.warn('THREE.Material: .wrapAround has been removed.')

			}
		},

		overdraw: {
			get: function () {

				console.warn('THREE.Material: .overdraw has been removed.')

			},
			set: function () {

				console.warn('THREE.Material: .overdraw has been removed.')

			}
		},

		wrapRGB: {
			get: function () {

				console.warn('THREE.Material: .wrapRGB has been removed.')
				return new Color()

			}
		},

		shading: {
			get: function () {

				console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.')

			},
			set: function (value) {

				console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.')
				this.flatShading = (value === FlatShading)

			}
		},

		stencilMask: {
			get: function () {

				console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.')
				return this.stencilFuncMask

			},
			set: function (value) {

				console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.')
				this.stencilFuncMask = value

			}
		},

		vertexTangents: {
			get: function () {

				console.warn('THREE.' + this.type + ': .vertexTangents has been removed.')

			},
			set: function () {

				console.warn('THREE.' + this.type + ': .vertexTangents has been removed.')

			}
		},

	})

	Object.defineProperties(ShaderMaterial.prototype, {

		derivatives: {
			get: function () {

				console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.')
				return this.extensions.derivatives

			},
			set: function (value) {

				console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.')
				this.extensions.derivatives = value

			}
		}

	})

	//

	WebGLRenderer$1.prototype.clearTarget = function (renderTarget, color, depth, stencil) {

		console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.')
		this.setRenderTarget(renderTarget)
		this.clear(color, depth, stencil)

	}

	WebGLRenderer$1.prototype.animate = function (callback) {

		console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().')
		this.setAnimationLoop(callback)

	}

	WebGLRenderer$1.prototype.getCurrentRenderTarget = function () {

		console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().')
		return this.getRenderTarget()

	}

	WebGLRenderer$1.prototype.getMaxAnisotropy = function () {

		console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().')
		return this.capabilities.getMaxAnisotropy()

	}

	WebGLRenderer$1.prototype.getPrecision = function () {

		console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.')
		return this.capabilities.precision

	}

	WebGLRenderer$1.prototype.resetGLState = function () {

		console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().')
		return this.state.reset()

	}

	WebGLRenderer$1.prototype.supportsFloatTextures = function () {

		console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).')
		return this.extensions.get('OES_texture_float')

	}

	WebGLRenderer$1.prototype.supportsHalfFloatTextures = function () {

		console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).')
		return this.extensions.get('OES_texture_half_float')

	}

	WebGLRenderer$1.prototype.supportsStandardDerivatives = function () {

		console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).')
		return this.extensions.get('OES_standard_derivatives')

	}

	WebGLRenderer$1.prototype.supportsCompressedTextureS3TC = function () {

		console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).')
		return this.extensions.get('WEBGL_compressed_texture_s3tc')

	}

	WebGLRenderer$1.prototype.supportsCompressedTexturePVRTC = function () {

		console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).')
		return this.extensions.get('WEBGL_compressed_texture_pvrtc')

	}

	WebGLRenderer$1.prototype.supportsBlendMinMax = function () {

		console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).')
		return this.extensions.get('EXT_blend_minmax')

	}

	WebGLRenderer$1.prototype.supportsVertexTextures = function () {

		console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.')
		return this.capabilities.vertexTextures

	}

	WebGLRenderer$1.prototype.supportsInstancedArrays = function () {

		console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).')
		return this.extensions.get('ANGLE_instanced_arrays')

	}

	WebGLRenderer$1.prototype.enableScissorTest = function (boolean) {

		console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().')
		this.setScissorTest(boolean)

	}

	WebGLRenderer$1.prototype.initMaterial = function () {

		console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.')

	}

	WebGLRenderer$1.prototype.addPrePlugin = function () {

		console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.')

	}

	WebGLRenderer$1.prototype.addPostPlugin = function () {

		console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.')

	}

	WebGLRenderer$1.prototype.updateShadowMap = function () {

		console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.')

	}

	WebGLRenderer$1.prototype.setFaceCulling = function () {

		console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.')

	}

	WebGLRenderer$1.prototype.allocTextureUnit = function () {

		console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.')

	}

	WebGLRenderer$1.prototype.setTexture = function () {

		console.warn('THREE.WebGLRenderer: .setTexture() has been removed.')

	}

	WebGLRenderer$1.prototype.setTexture2D = function () {

		console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.')

	}

	WebGLRenderer$1.prototype.setTextureCube = function () {

		console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.')

	}

	WebGLRenderer$1.prototype.getActiveMipMapLevel = function () {

		console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().')
		return this.getActiveMipmapLevel()

	}

	Object.defineProperties(WebGLRenderer$1.prototype, {

		shadowMapEnabled: {
			get: function () {

				return this.shadowMap.enabled

			},
			set: function (value) {

				console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.')
				this.shadowMap.enabled = value

			}
		},
		shadowMapType: {
			get: function () {

				return this.shadowMap.type

			},
			set: function (value) {

				console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.')
				this.shadowMap.type = value

			}
		},
		shadowMapCullFace: {
			get: function () {

				console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.')
				return undefined

			},
			set: function ( /* value */) {

				console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.')

			}
		},
		context: {
			get: function () {

				console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.')
				return this.getContext()

			}
		},
		vr: {
			get: function () {

				console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr')
				return this.xr

			}
		},
		gammaInput: {
			get: function () {

				console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.')
				return false

			},
			set: function () {

				console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.')

			}
		},
		gammaOutput: {
			get: function () {

				console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.')
				return false

			},
			set: function (value) {

				console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.')
				this.outputEncoding = (value === true) ? sRGBEncoding : LinearEncoding

			}
		},
		toneMappingWhitePoint: {
			get: function () {

				console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.')
				return 1.0

			},
			set: function () {

				console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.')

			}
		},

	})

	Object.defineProperties(WebGLShadowMap$1.prototype, {

		cullFace: {
			get: function () {

				console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.')
				return undefined

			},
			set: function ( /* cullFace */) {

				console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.')

			}
		},
		renderReverseSided: {
			get: function () {

				console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.')
				return undefined

			},
			set: function () {

				console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.')

			}
		},
		renderSingleSided: {
			get: function () {

				console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.')
				return undefined

			},
			set: function () {

				console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.')

			}
		}

	})

	function WebGLRenderTargetCube (width, height, options) {

		console.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).')
		return new WebGLCubeRenderTarget(width, options)

	}

	//

	Object.defineProperties(WebGLRenderTarget.prototype, {

		wrapS: {
			get: function () {

				console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.')
				return this.texture.wrapS

			},
			set: function (value) {

				console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.')
				this.texture.wrapS = value

			}
		},
		wrapT: {
			get: function () {

				console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.')
				return this.texture.wrapT

			},
			set: function (value) {

				console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.')
				this.texture.wrapT = value

			}
		},
		magFilter: {
			get: function () {

				console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.')
				return this.texture.magFilter

			},
			set: function (value) {

				console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.')
				this.texture.magFilter = value

			}
		},
		minFilter: {
			get: function () {

				console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.')
				return this.texture.minFilter

			},
			set: function (value) {

				console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.')
				this.texture.minFilter = value

			}
		},
		anisotropy: {
			get: function () {

				console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.')
				return this.texture.anisotropy

			},
			set: function (value) {

				console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.')
				this.texture.anisotropy = value

			}
		},
		offset: {
			get: function () {

				console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.')
				return this.texture.offset

			},
			set: function (value) {

				console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.')
				this.texture.offset = value

			}
		},
		repeat: {
			get: function () {

				console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.')
				return this.texture.repeat

			},
			set: function (value) {

				console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.')
				this.texture.repeat = value

			}
		},
		format: {
			get: function () {

				console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.')
				return this.texture.format

			},
			set: function (value) {

				console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.')
				this.texture.format = value

			}
		},
		type: {
			get: function () {

				console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.')
				return this.texture.type

			},
			set: function (value) {

				console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.')
				this.texture.type = value

			}
		},
		generateMipmaps: {
			get: function () {

				console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.')
				return this.texture.generateMipmaps

			},
			set: function (value) {

				console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.')
				this.texture.generateMipmaps = value

			}
		}

	})

	//

	Audio.prototype.load = function (file) {

		console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.')
		const scope = this
		const audioLoader = new AudioLoader()
		audioLoader.load(file, function (buffer) {

			scope.setBuffer(buffer)

		})
		return this

	}


	AudioAnalyser.prototype.getData = function () {

		console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().')
		return this.getFrequencyData()

	}

	//

	CubeCamera.prototype.updateCubeMap = function (renderer, scene) {

		console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().')
		return this.update(renderer, scene)

	}

	CubeCamera.prototype.clear = function (renderer, color, depth, stencil) {

		console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().')
		return this.renderTarget.clear(renderer, color, depth, stencil)

	}

	ImageUtils.crossOrigin = undefined

	ImageUtils.loadTexture = function (url, mapping, onLoad, onError) {

		console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.')

		const loader = new TextureLoader()
		loader.setCrossOrigin(this.crossOrigin)

		const texture = loader.load(url, onLoad, undefined, onError)

		if (mapping) texture.mapping = mapping

		return texture

	}

	ImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {

		console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.')

		const loader = new CubeTextureLoader()
		loader.setCrossOrigin(this.crossOrigin)

		const texture = loader.load(urls, onLoad, undefined, onError)

		if (mapping) texture.mapping = mapping

		return texture

	}

	ImageUtils.loadCompressedTexture = function () {

		console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.')

	}

	ImageUtils.loadCompressedTextureCube = function () {

		console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.')

	}

	//

	function CanvasRenderer () {

		console.error('THREE.CanvasRenderer has been removed')

	}

	//

	function JSONLoader () {

		console.error('THREE.JSONLoader has been removed.')

	}

	//

	const SceneUtils = {

		createMultiMaterialObject: function ( /* geometry, materials */) {

			console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js')

		},

		detach: function ( /* child, parent, scene */) {

			console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js')

		},

		attach: function ( /* child, scene, parent */) {

			console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js')

		}

	}

	//

	function LensFlare () {

		console.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js')

	}

	if (typeof __THREE_DEVTOOLS__ !== 'undefined') {

		/* eslint-disable no-undef */
		__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
			detail: {
				revision: REVISION,
			}
		}))
		/* eslint-enable no-undef */

	}

	if (typeof window !== 'undefined') {

		if (window.__THREE__) {

			console.warn('WARNING: Multiple instances of Three.js being imported.')

		} else {

			window.__THREE__ = REVISION

		}

	}

	function WebGLAnimation () {

		let context = null
		let isAnimating = false
		let animationLoop = null
		let requestId = null

		function onAnimationFrame (time, frame) {

			animationLoop(time, frame)

			requestId = context.requestAnimationFrame(onAnimationFrame)

		}

		return {

			start: function () {

				if (isAnimating === true) return
				if (animationLoop === null) return

				requestId = context.requestAnimationFrame(onAnimationFrame)

				isAnimating = true

			},

			stop: function () {

				context.cancelAnimationFrame(requestId)

				isAnimating = false

			},

			setAnimationLoop: function (callback) {

				animationLoop = callback

			},

			setContext: function (value) {

				context = value

			}

		}

	}

	function WebGLAttributes (gl, capabilities) {

		const isWebGL2 = capabilities.isWebGL2

		const buffers = new WeakMap()

		function createBuffer (attribute, bufferType) {

			const array = attribute.array
			const usage = attribute.usage

			const buffer = gl.createBuffer()

			gl.bindBuffer(bufferType, buffer)
			gl.bufferData(bufferType, array, usage)

			attribute.onUploadCallback()

			let type = gl.FLOAT

			if (array instanceof Float32Array) {

				type = gl.FLOAT

			} else if (array instanceof Float64Array) {

				console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.')

			} else if (array instanceof Uint16Array) {

				if (attribute.isFloat16BufferAttribute) {

					if (isWebGL2) {

						type = gl.HALF_FLOAT

					} else {

						console.warn('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.')

					}

				} else {

					type = gl.UNSIGNED_SHORT

				}

			} else if (array instanceof Int16Array) {

				type = gl.SHORT

			} else if (array instanceof Uint32Array) {

				type = gl.UNSIGNED_INT

			} else if (array instanceof Int32Array) {

				type = gl.INT

			} else if (array instanceof Int8Array) {

				type = gl.BYTE

			} else if (array instanceof Uint8Array) {

				type = gl.UNSIGNED_BYTE

			} else if (array instanceof Uint8ClampedArray) {

				type = gl.UNSIGNED_BYTE

			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			}

		}

		function updateBuffer (buffer, attribute, bufferType) {

			const array = attribute.array
			const updateRange = attribute.updateRange

			gl.bindBuffer(bufferType, buffer)

			if (updateRange.count === - 1) {

				// Not using update ranges

				gl.bufferSubData(bufferType, 0, array)

			} else {

				if (isWebGL2) {

					gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array, updateRange.offset, updateRange.count)

				} else {

					gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array.subarray(updateRange.offset, updateRange.offset + updateRange.count))

				}

				updateRange.count = - 1 // reset range

			}

		}

		//

		function get (attribute) {

			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data

			return buffers.get(attribute)

		}

		function remove (attribute) {

			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data

			const data = buffers.get(attribute)

			if (data) {

				gl.deleteBuffer(data.buffer)

				buffers.delete(attribute)

			}

		}

		function update (attribute, bufferType) {

			if (attribute.isGLBufferAttribute) {

				const cached = buffers.get(attribute)

				if (!cached || cached.version < attribute.version) {

					buffers.set(attribute, {
						buffer: attribute.buffer,
						type: attribute.type,
						bytesPerElement: attribute.elementSize,
						version: attribute.version
					})

				}

				return

			}

			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data

			const data = buffers.get(attribute)

			if (data === undefined) {

				buffers.set(attribute, createBuffer(attribute, bufferType))

			} else if (data.version < attribute.version) {

				updateBuffer(data.buffer, attribute, bufferType)

				data.version = attribute.version

			}

		}

		return {

			get: get,
			remove: remove,
			update: update

		}

	}

	var alphamap_fragment = /* glsl */`
#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, vUv ).g;

#endif
`

	var alphamap_pars_fragment = /* glsl */`
#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`

	var alphatest_fragment = /* glsl */`
#ifdef ALPHATEST

	if ( diffuseColor.a < ALPHATEST ) discard;

#endif
`

	var aomap_fragment = /* glsl */`
#ifdef USE_AOMAP

	// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;

	reflectedLight.indirectDiffuse *= ambientOcclusion;

	#if defined( USE_ENVMAP ) && defined( STANDARD )

		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );

		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );

	#endif

#endif
`

	var aomap_pars_fragment = /* glsl */`
#ifdef USE_AOMAP

	uniform sampler2D aoMap;
	uniform float aoMapIntensity;

#endif
`

	var begin_vertex = /* glsl */`
vec3 transformed = vec3( position );
`

	var beginnormal_vertex = /* glsl */`
vec3 objectNormal = vec3( normal );

#ifdef USE_TANGENT

	vec3 objectTangent = vec3( tangent.xyz );

#endif
`

	var bsdfs = /* glsl */`

// Analytical approximation of the DFG LUT, one half of the
// split-sum approximation used in indirect specular lighting.
// via 'environmentBRDF' from "Physically Based Shading on Mobile"
// https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile
vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );

	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );

	vec4 r = roughness * c0 + c1;

	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;

	return vec2( -1.04, 1.04 ) * a004 + r.zw;

}

float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {

#if defined ( PHYSICALLY_CORRECT_LIGHTS )

	// based upon Frostbite 3 Moving to Physically-based Rendering
	// page 32, equation 26: E[window1]
	// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
	// this is intended to be used on spot and point lights who are represented as luminous intensity
	// but who must be converted to luminous irradiance for surface lighting calculation
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );

	if( cutoffDistance > 0.0 ) {

		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );

	}

	return distanceFalloff;

#else

	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {

		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

	}

	return 1.0;

#endif

}

vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {

	return RECIPROCAL_PI * diffuseColor;

} // validated

vec3 F_Schlick( const in vec3 f0, const in vec3 f90, const in float dotVH ) {

	// Original approximation by Christophe Schlick '94
	// float fresnel = pow( 1.0 - dotVH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH '13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	float fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );

	return ( f90 - f0 ) * fresnel + f0;

} // validated

vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {

	// See F_Schlick
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;

	return Fr * fresnel + F0;

}


// Microfacet Models for Refraction through Rough Surfaces - equation (34)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disneys reparameterization
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {

	// geometry term (normalized) = G(l)G(v) / 4(nl)(nv)
	// also see #12151

	float a2 = pow2( alpha );

	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );

	return 1.0 / ( gl * gv );

} // validated

// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {

	float a2 = pow2( alpha );

	// dotNL and dotNV are explicitly swapped. This is not a mistake.
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );

	return 0.5 / max( gv + gl, EPSILON );

}

// Microfacet Models for Refraction through Rough Surfaces - equation (33)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disneys reparameterization
float D_GGX( const in float alpha, const in float dotNH ) {

	float a2 = pow2( alpha );

	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1

	return RECIPROCAL_PI * a2 / pow2( denom );

}

// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in vec3 f90, const in float roughness ) {

	float alpha = pow2( roughness ); // UE4's roughness

	vec3 halfDir = normalize( incidentLight.direction + viewDir );

	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );

	vec3 F = F_Schlick( f0, f90, dotLH );

	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );

	float D = D_GGX( alpha, dotNH );

	return F * ( G * D );

} // validated

// Rect Area Light

// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
// code: https://github.com/selfshadow/ltc_code/

vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {

	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;

	float dotNV = saturate( dot( N, V ) );

	// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );

	uv = uv * LUT_SCALE + LUT_BIAS;

	return uv;

}

float LTC_ClippedSphereFormFactor( const in vec3 f ) {

	// Real-Time Area Lighting: a Journey from Research to Production (p.102)
	// An approximation of the form factor of a horizon-clipped rectangle.

	float l = length( f );

	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );

}

vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {

	float x = dot( v1, v2 );

	float y = abs( x );

	// rational polynomial approximation to theta / sin( theta ) / 2PI
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;

	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;

	return cross( v1, v2 ) * theta_sintheta;

}

vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {

	// bail if point is on back side of plane of light
	// assumes ccw winding order of light vertices
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );

	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );

	// construct orthonormal basis around N
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system

	// compute transform
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );

	// transform rect
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );

	// project rect onto sphere
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );

	// calculate vector form factor
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );

	// adjust for horizon clipping
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );

/*
	// alternate method of adjusting for horizon clipping (see referece)
	// refactoring required
	float len = length( vectorFormFactor );
	float z = vectorFormFactor.z / len;

	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;

	// tabulated horizon-clipped sphere, apparently...
	vec2 uv = vec2( z * 0.5 + 0.5, len );
	uv = uv * LUT_SCALE + LUT_BIAS;

	float scale = texture2D( ltc_2, uv ).w;

	float result = len * scale;
*/

	return vec3( result );

}

// End Rect Area Light

// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {

	float dotNV = saturate( dot( normal, viewDir ) );

	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );

	return specularColor * brdf.x + brdf.y;

} // validated

// Fdez-Agera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
// Approximates multiscattering in order to preserve energy.
// http://www.jcgt.org/published/0008/01/03/
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {

	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );

	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;

	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;

	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619; // 1/21
	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );

	singleScatter += FssEss;
	multiScatter += Fms * Ems;

}

float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {

	// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)
	return 0.25;

}

float D_BlinnPhong( const in float shininess, const in float dotNH ) {

	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {

	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );

	//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );
	//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );

	vec3 F = F_Schlick( specularColor, vec3( 1.0 ), dotLH );

	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

	float D = D_BlinnPhong( shininess, dotNH );

	return F * ( G * D );

} // validated

// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}

float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}

#if defined( USE_SHEEN )

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L94
float D_Charlie(float roughness, float NoH) {
	// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125); // 2^(-14/2), so sin2h^2 > 0 in fp16
	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L136
float V_Neubelt(float NoV, float NoL) {
	// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}

vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {

	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;

	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );

	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );

}

#endif
`

	var bumpmap_pars_fragment = /* glsl */`
#ifdef USE_BUMPMAP

	uniform sampler2D bumpMap;
	uniform float bumpScale;

	// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
	// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf

	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

	vec2 dHdxy_fwd() {

		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );

		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;

		return vec2( dBx, dBy );

	}

	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {

		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;		// normalized

		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );

		float fDet = dot( vSigmaX, R1 ) * faceDirection;

		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );

	}

#endif
`

	var clipping_planes_fragment = /* glsl */`
#if NUM_CLIPPING_PLANES > 0

	vec4 plane;

	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {

		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;

	}
	#pragma unroll_loop_end

	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES

		bool clipped = true;

		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {

			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;

		}
		#pragma unroll_loop_end

		if ( clipped ) discard;

	#endif

#endif
`

	var clipping_planes_pars_fragment = /* glsl */`
#if NUM_CLIPPING_PLANES > 0

	varying vec3 vClipPosition;

	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];

#endif
`

	var clipping_planes_pars_vertex = /* glsl */`
#if NUM_CLIPPING_PLANES > 0

	varying vec3 vClipPosition;

#endif
`

	var clipping_planes_vertex = /* glsl */`
#if NUM_CLIPPING_PLANES > 0

	vClipPosition = - mvPosition.xyz;

#endif
`

	var color_fragment = /* glsl */`
#if defined( USE_COLOR_ALPHA )

	diffuseColor *= vColor;

#elif defined( USE_COLOR )

	diffuseColor.rgb *= vColor;

#endif
`

	var color_pars_fragment = /* glsl */`
#if defined( USE_COLOR_ALPHA )

	varying vec4 vColor;

#elif defined( USE_COLOR )

	varying vec3 vColor;

#endif
`

	var color_pars_vertex = /* glsl */`
#if defined( USE_COLOR_ALPHA )

	varying vec4 vColor;

#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )

	varying vec3 vColor;

#endif
`

	var color_vertex = /* glsl */`
#if defined( USE_COLOR_ALPHA )

	vColor = vec4( 1.0 );

#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )

	vColor = vec3( 1.0 );

#endif

#ifdef USE_COLOR

	vColor *= color;

#endif

#ifdef USE_INSTANCING_COLOR

	vColor.xyz *= instanceColor.xyz;

#endif
`

	var common = /* glsl */`
#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6

#ifndef saturate
// <tonemapping_pars_fragment> may have defined saturate() already
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )

float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.
// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}

#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif

struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};

struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};

struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};

vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

}

vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {

	// dir can be either a direction vector or a normal vector
	// upper-left 3x3 of matrix is assumed to be orthogonal

	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

	float distance = dot( planeNormal, point - pointOnPlane );

	return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

	return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

mat3 transposeMat3( const in mat3 m ) {

	mat3 tmp;

	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );

	return tmp;

}

// https://en.wikipedia.org/wiki/Relative_luminance
float linearToRelativeLuminance( const in vec3 color ) {

	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );

	return dot( weights, color.rgb );

}

bool isPerspectiveMatrix( mat4 m ) {

	return m[ 2 ][ 3 ] == - 1.0;

}

vec2 equirectUv( in vec3 dir ) {

	// dir is assumed to be unit length

	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;

	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;

	return vec2( u, v );

}
`

	var cube_uv_reflection_fragment = /* glsl */`
#ifdef ENVMAP_TYPE_CUBE_UV

	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0

	// These shader functions convert between the UV coordinates of a single face of
	// a cubemap, the 0-5 integer index of a cube face, and the direction vector for
	// sampling a textureCube (not generally normalized ).

	float getFace( vec3 direction ) {

		vec3 absDirection = abs( direction );

		float face = - 1.0;

		if ( absDirection.x > absDirection.z ) {

			if ( absDirection.x > absDirection.y )

				face = direction.x > 0.0 ? 0.0 : 3.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		} else {

			if ( absDirection.z > absDirection.y )

				face = direction.z > 0.0 ? 2.0 : 5.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		}

		return face;

	}

	// RH coordinate system; PMREM face-indexing convention
	vec2 getUV( vec3 direction, float face ) {

		vec2 uv;

		if ( face == 0.0 ) {

			uv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x

		} else if ( face == 1.0 ) {

			uv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y

		} else if ( face == 2.0 ) {

			uv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z

		} else if ( face == 3.0 ) {

			uv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x

		} else if ( face == 4.0 ) {

			uv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y

		} else {

			uv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z

		}

		return 0.5 * ( uv + 1.0 );

	}

	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {

		float face = getFace( direction );

		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );

		mipInt = max( mipInt, cubeUV_minMipLevel );

		float faceSize = exp2( mipInt );

		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );

		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );

		vec2 f = fract( uv );

		uv += 0.5 - f;

		if ( face > 2.0 ) {

			uv.y += faceSize;

			face -= 3.0;

		}

		uv.x += face * faceSize;

		if ( mipInt < cubeUV_maxMipLevel ) {

			uv.y += 2.0 * cubeUV_maxTileSize;

		}

		uv.y += filterInt * 2.0 * cubeUV_minTileSize;

		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );

		uv *= texelSize;

		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		uv.x += texelSize;

		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		uv.y += texelSize;

		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		uv.x -= texelSize;

		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		vec3 tm = mix( tl, tr, f.x );

		vec3 bm = mix( bl, br, f.x );

		return mix( tm, bm, f.y );

	}

	// These defines must match with PMREMGenerator

	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0

	float roughnessToMip( float roughness ) {

		float mip = 0.0;

		if ( roughness >= r1 ) {

			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;

		} else if ( roughness >= r4 ) {

			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;

		} else if ( roughness >= r5 ) {

			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;

		} else if ( roughness >= r6 ) {

			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;

		} else {

			mip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25
		}

		return mip;

	}

	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {

		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );

		float mipF = fract( mip );

		float mipInt = floor( mip );

		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );

		if ( mipF == 0.0 ) {

			return vec4( color0, 1.0 );

		} else {

			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );

			return vec4( mix( color0, color1, mipF ), 1.0 );

		}

	}

#endif
`

	var defaultnormal_vertex = /* glsl */`
vec3 transformedNormal = objectNormal;

#ifdef USE_INSTANCING

	// this is in lieu of a per-instance normal-matrix
	// shear transforms in the instance matrix are not supported

	mat3 m = mat3( instanceMatrix );

	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );

	transformedNormal = m * transformedNormal;

#endif

transformedNormal = normalMatrix * transformedNormal;

#ifdef FLIP_SIDED

	transformedNormal = - transformedNormal;

#endif

#ifdef USE_TANGENT

	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;

	#ifdef FLIP_SIDED

		transformedTangent = - transformedTangent;

	#endif

#endif
`

	var displacementmap_pars_vertex = /* glsl */`
#ifdef USE_DISPLACEMENTMAP

	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;

#endif
`

	var displacementmap_vertex = /* glsl */`
#ifdef USE_DISPLACEMENTMAP

	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );

#endif
`

	var emissivemap_fragment = /* glsl */`
#ifdef USE_EMISSIVEMAP

	vec4 emissiveColor = texture2D( emissiveMap, vUv );

	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;

	totalEmissiveRadiance *= emissiveColor.rgb;

#endif
`

	var emissivemap_pars_fragment = /* glsl */`
#ifdef USE_EMISSIVEMAP

	uniform sampler2D emissiveMap;

#endif
`

	var encodings_fragment = /* glsl */`
gl_FragColor = linearToOutputTexel( gl_FragColor );
`

	var encodings_pars_fragment = /* glsl */`
// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/

vec4 LinearToLinear( in vec4 value ) {
	return value;
}

vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}

vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}

vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}

vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}

vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}

vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
	// return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );
}

// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}

vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}

// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}

vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	// NOTE: The implementation with min causes the shader to not compile on
	// a common Alcatel A502DL in Chrome 78/Android 8.1. Some research suggests 
	// that the chipset is Mediatek MT6739 w/ IMG PowerVR GE8100 GPU.
	// D = min( floor( D ) / 255.0, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}

// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html

// M matrix, for encoding
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}

// Inverse M matrix, for decoding
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}
`

	var envmap_fragment = /* glsl */`
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vec3 cameraToFrag;

		if ( isOrthographic ) {

			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToFrag = normalize( vWorldPosition - cameraPosition );

		}

		// Transforming Normal Vectors with the Inverse Transformation
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vec3 reflectVec = reflect( cameraToFrag, worldNormal );

		#else

			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );

		#endif

	#else

		vec3 reflectVec = vReflect;

	#endif

	#ifdef ENVMAP_TYPE_CUBE

		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );

	#elif defined( ENVMAP_TYPE_CUBE_UV )

		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );

	#else

		vec4 envColor = vec4( 0.0 );

	#endif

	#ifndef ENVMAP_TYPE_CUBE_UV

		envColor = envMapTexelToLinear( envColor );

	#endif

	#ifdef ENVMAP_BLENDING_MULTIPLY

		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_MIX )

		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_ADD )

		outgoingLight += envColor.xyz * specularStrength * reflectivity;

	#endif

#endif
`

	var envmap_common_pars_fragment = /* glsl */`
#ifdef USE_ENVMAP

	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;

	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif
`

	var envmap_pars_fragment = /* glsl */`
#ifdef USE_ENVMAP

	uniform float reflectivity;

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS

		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif

#endif
`

	var envmap_pars_vertex = /* glsl */`
#ifdef USE_ENVMAP

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;

	#else

		varying vec3 vReflect;
		uniform float refractionRatio;

	#endif

#endif
`

	var envmap_vertex = /* glsl */`
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vWorldPosition = worldPosition.xyz;

	#else

		vec3 cameraToVertex;

		if ( isOrthographic ) {

			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );

		}

		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vReflect = reflect( cameraToVertex, worldNormal );

		#else

			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );

		#endif

	#endif

#endif
`

	var fog_vertex = /* glsl */`
#ifdef USE_FOG

	fogDepth = - mvPosition.z;

#endif
`

	var fog_pars_vertex = /* glsl */`
#ifdef USE_FOG

	varying float fogDepth;

#endif
`

	var fog_fragment = /* glsl */`
#ifdef USE_FOG

	#ifdef FOG_EXP2

		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );

	#else

		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );

	#endif

	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );

#endif
`

	var fog_pars_fragment = /* glsl */`
#ifdef USE_FOG

	uniform vec3 fogColor;
	varying float fogDepth;

	#ifdef FOG_EXP2

		uniform float fogDensity;

	#else

		uniform float fogNear;
		uniform float fogFar;

	#endif

#endif
`

	var gradientmap_pars_fragment = /* glsl */`

#ifdef USE_GRADIENTMAP

	uniform sampler2D gradientMap;

#endif

vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {

	// dotNL will be from -1.0 to 1.0
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );

	#ifdef USE_GRADIENTMAP

		return texture2D( gradientMap, coord ).rgb;

	#else

		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );

	#endif

}
`

	var lightmap_fragment = /* glsl */`
#ifdef USE_LIGHTMAP

	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage

#endif
`

	var lightmap_pars_fragment = /* glsl */`
#ifdef USE_LIGHTMAP

	uniform sampler2D lightMap;
	uniform float lightMapIntensity;

#endif
`

	var lights_lambert_vertex = /* glsl */`
vec3 diffuse = vec3( 1.0 );

GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );

GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;

vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif

IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;

vIndirectFront += getAmbientLightIrradiance( ambientLightColor );

vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );

#ifdef DOUBLE_SIDED

	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );

	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );

#endif

#if NUM_POINT_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif

	}
	#pragma unroll_loop_end

#endif

#if NUM_SPOT_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif
	}
	#pragma unroll_loop_end

#endif

/*
#if NUM_RECT_AREA_LIGHTS > 0

	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		// TODO (abelnation): implement

	}

#endif
*/

#if NUM_DIR_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif

	}
	#pragma unroll_loop_end

#endif

#if NUM_HEMI_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		#ifdef DOUBLE_SIDED

			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );

		#endif

	}
	#pragma unroll_loop_end

#endif
`

	var lights_pars_begin = /* glsl */`
uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];

// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere
// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {

	// normal is assumed to have unit length

	float x = normal.x, y = normal.y, z = normal.z;

	// band 0
	vec3 result = shCoefficients[ 0 ] * 0.886227;

	// band 1
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;

	// band 2
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );

	return result;

}

vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {

	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );

	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );

	return irradiance;

}

vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {

	vec3 irradiance = ambientLightColor;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI;

	#endif

	return irradiance;

}

#if NUM_DIR_LIGHTS > 0

	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};

	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];

	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {

		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;

	}

#endif


#if NUM_POINT_LIGHTS > 0

	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};

	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];

	// directLight is an out parameter as having it as a return value caused compiler errors on some devices
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {

		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );

		float lightDistance = length( lVector );

		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );

	}

#endif


#if NUM_SPOT_LIGHTS > 0

	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};

	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];

	// directLight is an out parameter as having it as a return value caused compiler errors on some devices
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {

		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );

		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );

		if ( angleCos > spotLight.coneCos ) {

			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );

			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;

		} else {

			directLight.color = vec3( 0.0 );
			directLight.visible = false;

		}
	}

#endif


#if NUM_RECT_AREA_LIGHTS > 0

	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};

	// Pre-computed values of LinearTransformedCosine approximation of BRDF
	// BRDF approximation Texture is 64x64
	uniform sampler2D ltc_1; // RGBA Float
	uniform sampler2D ltc_2; // RGBA Float

	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];

#endif


#if NUM_HEMI_LIGHTS > 0

	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};

	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];

	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {

		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;

		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			irradiance *= PI;

		#endif

		return irradiance;

	}

#endif
`

	var envmap_physical_pars_fragment = /* glsl */ `
#if defined( USE_ENVMAP )

	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif

	vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {

		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );

		#ifdef ENVMAP_TYPE_CUBE

			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );

			// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level
			// of a specular cubemap, or just the default level of a specially created irradiance cubemap.

			#ifdef TEXTURE_LOD_EXT

				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );

			#else

				// force the bias high to get the last LOD level as it is the most blurred.
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );

			#endif

			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

		#elif defined( ENVMAP_TYPE_CUBE_UV )

			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );

		#else

			vec4 envMapColor = vec4( 0.0 );

		#endif

		return PI * envMapColor.rgb * envMapIntensity;

	}

	// Trowbridge-Reitz distribution to Mip level, following the logic of http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {

		float maxMIPLevelScalar = float( maxMIPLevel );

		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );

		// clamp to allowable LOD ranges.
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );

	}

	vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {

		#ifdef ENVMAP_MODE_REFLECTION

			vec3 reflectVec = reflect( -viewDir, normal );

			// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );

		#else

			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );

		#endif

		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );

		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );

		#ifdef ENVMAP_TYPE_CUBE

			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );

			#ifdef TEXTURE_LOD_EXT

				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );

			#else

				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );

			#endif

			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

		#elif defined( ENVMAP_TYPE_CUBE_UV )

			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );

		#endif

		return envMapColor.rgb * envMapIntensity;

	}

#endif
`

	var lights_toon_fragment = /* glsl */`
ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;
`

	var lights_toon_pars_fragment = /* glsl */`
varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif


struct ToonMaterial {

	vec3 diffuseColor;

};

void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon

#define Material_LightProbeLOD( material )	(0)
`

	var lights_phong_fragment = /* glsl */`
BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;
`

	var lights_phong_pars_fragment = /* glsl */`
varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif


struct BlinnPhongMaterial {

	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;

};

void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;

}

void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong

#define Material_LightProbeLOD( material )	(0)
`

	var lights_physical_fragment = /* glsl */`
PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );

vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );

material.specularRoughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.
material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );

#ifdef REFLECTIVITY

	#ifdef SPECULAR

		vec3 specularIntensityFactor = vec3( specularIntensity );
		vec3 specularTintFactor = specularTint;

		#ifdef USE_SPECULARINTENSITYMAP

			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;

		#endif

		#ifdef USE_SPECULARTINTMAP

			specularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;

		#endif

		material.specularColorF90 = mix( specularIntensityFactor, vec3( 1.0 ), metalnessFactor );

	#else

		vec3 specularIntensityFactor = vec3( 1.0 );
		vec3 specularTintFactor = vec3( 1.0 );
		material.specularColorF90 = vec3( 1.0 );

	#endif

	material.specularColor = mix( min( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );

#else

	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
	material.specularColorF90 = vec3( 1.0 );

#endif

#ifdef CLEARCOAT

	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;

	#ifdef USE_CLEARCOATMAP

		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;

	#endif

	#ifdef USE_CLEARCOAT_ROUGHNESSMAP

		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;

	#endif

	material.clearcoat = saturate( material.clearcoat ); // Burley clearcoat model
	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );

#endif

#ifdef USE_SHEEN

	material.sheenColor = sheen;

#endif
`

	var lights_physical_pars_fragment = /* glsl */`
struct PhysicalMaterial {

	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
	vec3 specularColorF90;

#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif

};

#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04

// Clear coat directional hemishperical reflectance (this approximation should be improved)
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {

	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );

}

#if NUM_RECT_AREA_LIGHTS > 0

	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;

		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction
		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;

		vec2 uv = LTC_Uv( normal, viewDir, roughness );

		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );

		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);

		// LTC Fresnel Approximation by Stephen Hill
		// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );

		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );

		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );

	}

#endif

void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );

	vec3 irradiance = dotNL * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	#ifdef CLEARCOAT

		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );

		vec3 ccIrradiance = ccDotNL * directLight.color;

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			ccIrradiance *= PI; // punctual light

		#endif

		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );

		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), vec3( 1.0 ), material.clearcoatRoughness );

	#else

		float clearcoatDHR = 0.0;

	#endif

	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularColorF90, material.specularRoughness);
	#endif

	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}

void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {

	#ifdef CLEARCOAT

		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );

		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );

		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );

	#else

		float clearcoatDHR = 0.0;

	#endif

	float clearcoatInv = 1.0 - clearcoatDHR;

	// Both indirect specular and indirect diffuse light accumulate here

	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;

	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );

	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );

	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;

	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;

}

#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical

// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {

	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );

}
`

	var lights_fragment_begin = /* glsl */`
/**
 * This is a template that can be used to light a material, it uses pluggable
 * RenderEquations (RE)for specific lighting scenarios.
 *
 * Instructions for use:
 * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined
 * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???
 * - Create a material parameter that is to be passed as the third parameter to your lighting functions.
 *
 * TODO:
 * - Add area light support.
 * - Add sphere light support.
 * - Add diffuse light probe (irradiance cubemap) support.
 */

GeometricContext geometry;

geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

#ifdef CLEARCOAT

	geometry.clearcoatNormal = clearcoatNormal;

#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointDirectLightIrradiance( pointLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotDirectLightIrradiance( spotLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	irradiance += getLightProbeIrradiance( lightProbe, geometry );

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`

	var lights_fragment_maps = /* glsl */`
#if defined( RE_IndirectDiffuse )

	#ifdef USE_LIGHTMAP

		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage

		#endif

		irradiance += lightMapIrradiance;

	#endif

	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )

		iblIrradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, maxMipLevel );

	#endif

#endif

#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )

	radiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );

	#ifdef CLEARCOAT

		clearcoatRadiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );

	#endif

#endif
`

	var lights_fragment_end = /* glsl */`
#if defined( RE_IndirectDiffuse )

	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );

#endif

#if defined( RE_IndirectSpecular )

	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );

#endif
`

	var logdepthbuf_fragment = /* glsl */`
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	// Doing a strict comparison with == 1.0 can cause noise artifacts
	// on some platforms. See issue #17623.
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;

#endif
`

	var logdepthbuf_pars_fragment = /* glsl */`
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;

#endif
`

	var logdepthbuf_pars_vertex = /* glsl */`
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		varying float vFragDepth;
		varying float vIsPerspective;

	#else

		uniform float logDepthBufFC;

	#endif

#endif
`

	var logdepthbuf_vertex = /* glsl */`
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );

	#else

		if ( isPerspectiveMatrix( projectionMatrix ) ) {

			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;

			gl_Position.z *= gl_Position.w;

		}

	#endif

#endif
`

	var map_fragment = /* glsl */`
#ifdef USE_MAP

	vec4 texelColor = texture2D( map, vUv );

	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;

#endif
`

	var map_pars_fragment = /* glsl */`
#ifdef USE_MAP

	uniform sampler2D map;

#endif
`

	var map_particle_fragment = /* glsl */`
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;

#endif

#ifdef USE_MAP

	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );

#endif

#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, uv ).g;

#endif
`

	var map_particle_pars_fragment = /* glsl */`
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	uniform mat3 uvTransform;

#endif

#ifdef USE_MAP

	uniform sampler2D map;

#endif

#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`

	var metalnessmap_fragment = /* glsl */`
float metalnessFactor = metalness;

#ifdef USE_METALNESSMAP

	vec4 texelMetalness = texture2D( metalnessMap, vUv );

	// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	metalnessFactor *= texelMetalness.b;

#endif
`

	var metalnessmap_pars_fragment = /* glsl */`
#ifdef USE_METALNESSMAP

	uniform sampler2D metalnessMap;

#endif
`

	var morphnormal_vertex = /* glsl */`
#ifdef USE_MORPHNORMALS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];

#endif
`

	var morphtarget_pars_vertex = /* glsl */`
#ifdef USE_MORPHTARGETS

	uniform float morphTargetBaseInfluence;

	#ifndef USE_MORPHNORMALS

		uniform float morphTargetInfluences[ 8 ];

	#else

		uniform float morphTargetInfluences[ 4 ];

	#endif

#endif
`

	var morphtarget_vertex = /* glsl */`
#ifdef USE_MORPHTARGETS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];

	#ifndef USE_MORPHNORMALS

		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];

	#endif

#endif
`

	var normal_fragment_begin = /* glsl */`
float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;

#ifdef FLAT_SHADED

	// Workaround for Adreno GPUs not able to do dFdx( vViewPosition )

	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );

#else

	vec3 normal = normalize( vNormal );

	#ifdef DOUBLE_SIDED

		normal = normal * faceDirection;

	#endif

	#ifdef USE_TANGENT

		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );

		#ifdef DOUBLE_SIDED

			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;

		#endif

		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )

			mat3 vTBN = mat3( tangent, bitangent, normal );

		#endif

	#endif

#endif

// non perturbed normal for clearcoat among others

vec3 geometryNormal = normal;

`

	var normal_fragment_maps = /* glsl */`

#ifdef OBJECTSPACE_NORMALMAP

	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

	#ifdef FLIP_SIDED

		normal = - normal;

	#endif

	#ifdef DOUBLE_SIDED

		normal = normal * faceDirection;

	#endif

	normal = normalize( normalMatrix * normal );

#elif defined( TANGENTSPACE_NORMALMAP )

	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;

	#ifdef USE_TANGENT

		normal = normalize( vTBN * mapN );

	#else

		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );

	#endif

#elif defined( USE_BUMPMAP )

	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );

#endif
`

	var normalmap_pars_fragment = /* glsl */`
#ifdef USE_NORMALMAP

	uniform sampler2D normalMap;
	uniform vec2 normalScale;

#endif

#ifdef OBJECTSPACE_NORMALMAP

	uniform mat3 normalMatrix;

#endif

#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )

	// Normal Mapping Without Precomputed Tangents
	// http://www.thetenthplanet.de/archives/1180

	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {

		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );

		vec3 N = surf_norm; // normalized

		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );

		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;

		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );

		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );

	}

#endif
`

	var clearcoat_normal_fragment_begin = /* glsl */`
#ifdef CLEARCOAT

	vec3 clearcoatNormal = geometryNormal;

#endif
`

	var clearcoat_normal_fragment_maps = /* glsl */`
#ifdef USE_CLEARCOAT_NORMALMAP

	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;

	#ifdef USE_TANGENT

		clearcoatNormal = normalize( vTBN * clearcoatMapN );

	#else

		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );

	#endif

#endif
`

	var clearcoat_pars_fragment = /* glsl */`

#ifdef USE_CLEARCOATMAP

	uniform sampler2D clearcoatMap;

#endif

#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	uniform sampler2D clearcoatRoughnessMap;

#endif

#ifdef USE_CLEARCOAT_NORMALMAP

	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;

#endif
`

	var packing = /* glsl */`
vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}

vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}

const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)
const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)

const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );

const float ShiftRight8 = 1. / 256.;

vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8; // tidy overflow
	return r * PackUpscale;
}

float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}

vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}

// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions

float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}

// NOTE: https://twitter.com/gonnavis/status/1377183786949959682

float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}
`

	var premultiplied_alpha_fragment = /* glsl */`
#ifdef PREMULTIPLIED_ALPHA

	// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.
	gl_FragColor.rgb *= gl_FragColor.a;

#endif
`

	var project_vertex = /* glsl */`
vec4 mvPosition = vec4( transformed, 1.0 );

#ifdef USE_INSTANCING

	mvPosition = instanceMatrix * mvPosition;

#endif

mvPosition = modelViewMatrix * mvPosition;

gl_Position = projectionMatrix * mvPosition;
`

	var dithering_fragment = /* glsl */`
#ifdef DITHERING

	gl_FragColor.rgb = dithering( gl_FragColor.rgb );

#endif
`

	var dithering_pars_fragment = /* glsl */`
#ifdef DITHERING

	// based on https://www.shadertoy.com/view/MslGR8
	vec3 dithering( vec3 color ) {
		//Calculate grid position
		float grid_position = rand( gl_FragCoord.xy );

		//Shift the individual colors differently, thus making it even harder to see the dithering pattern
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );

		//modify shift acording to grid position.
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );

		//shift the color by dither_shift
		return color + dither_shift_RGB;
	}

#endif
`

	var roughnessmap_fragment = /* glsl */`
float roughnessFactor = roughness;

#ifdef USE_ROUGHNESSMAP

	vec4 texelRoughness = texture2D( roughnessMap, vUv );

	// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	roughnessFactor *= texelRoughness.g;

#endif
`

	var roughnessmap_pars_fragment = /* glsl */`
#ifdef USE_ROUGHNESSMAP

	uniform sampler2D roughnessMap;

#endif
`

	var shadowmap_pars_fragment = /* glsl */`
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];

		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): create uniforms for area light shadows

	#endif
	*/

	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {

		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );

	}

	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {

		return unpackRGBATo2Half( texture2D( shadow, uv ) );

	}

	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){

		float occlusion = 1.0;

		vec2 distribution = texture2DDistribution( shadow, uv );

		float hard_shadow = step( compare , distribution.x ); // Hard Shadow

		if (hard_shadow != 1.0 ) {

			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality
			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed
			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );

		}
		return occlusion;

	}

	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {

		float shadow = 1.0;

		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;

		// if ( something && something ) breaks ATI OpenGL shader compiler
		// if ( all( something, something ) ) using this instead

		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );

		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );

		bool frustumTest = all( frustumTestVec );

		if ( frustumTest ) {

		#if defined( SHADOWMAP_TYPE_PCF )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;

			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;

			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );

		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;

			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;

			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );

		#elif defined( SHADOWMAP_TYPE_VSM )

			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );

		#else // no percentage-closer filtering:

			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );

		#endif

		}

		return shadow;

	}

	// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
	// vector suitable for 2D texture mapping. This code uses the following layout for the
	// 2D texture:
	//
	// xzXZ
	//  y Y
	//
	// Y - Positive y direction
	// y - Negative y direction
	// X - Positive x direction
	// x - Negative x direction
	// Z - Positive z direction
	// z - Negative z direction
	//
	// Source and test bed:
	// https://gist.github.com/tschw/da10c43c467ce8afd0c4

	vec2 cubeToUV( vec3 v, float texelSizeY ) {

		// Number of texels to avoid at the edge of each square

		vec3 absV = abs( v );

		// Intersect unit cube

		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;

		// Apply scale to avoid seams

		// two texels less per square (one texel will do for NEAREST)
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

		// Unwrap

		// space: -1 ... 1 range for each square
		//
		// #X##		dim    := ( 4 , 2 )
		//  # #		center := ( 1 , 1 )

		vec2 planar = v.xy;

		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;

		if ( absV.z >= almostOne ) {

			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;

		} else if ( absV.x >= almostOne ) {

			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;

		} else if ( absV.y >= almostOne ) {

			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;

		}

		// Transform to UV space

		// scale := 0.5 / dim
		// translate := ( center + 0.5 ) / dim
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

	}

	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );

		// for point lights, the uniform @vShadowCoord is re-purposed to hold
		// the vector from the light to the world-space position of the fragment.
		vec3 lightToPosition = shadowCoord.xyz;

		// dp = normalized distance from light to fragment position
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
		dp += shadowBias;

		// bd3D = base direction 3D
		vec3 bd3D = normalize( lightToPosition );

		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )

			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;

			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );

		#else // no percentage-closer filtering

			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );

		#endif

	}

#endif
`

	var shadowmap_pars_vertex = /* glsl */`
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];

		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): uniforms for area light shadows

	#endif
	*/

#endif
`

	var shadowmap_vertex = /* glsl */`
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0

		// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;

	#endif

	#if NUM_DIR_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update vAreaShadowCoord with area light info

	#endif
	*/

#endif
`

	var shadowmask_pars_fragment = /* glsl */`
float getShadowMask() {

	float shadow = 1.0;

	#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

	DirectionalLightShadow directionalLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

	SpotLightShadow spotLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {

		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

	PointLightShadow pointLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update shadow for Area light

	#endif
	*/

	#endif

	return shadow;

}
`

	var skinbase_vertex = /* glsl */`
#ifdef USE_SKINNING

	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );

#endif
`

	var skinning_pars_vertex = /* glsl */`
#ifdef USE_SKINNING

	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;

	#ifdef BONE_TEXTURE

		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;

		mat4 getBoneMatrix( const in float i ) {

			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );

			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );

			y = dy * ( y + 0.5 );

			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

			mat4 bone = mat4( v1, v2, v3, v4 );

			return bone;

		}

	#else

		uniform mat4 boneMatrices[ MAX_BONES ];

		mat4 getBoneMatrix( const in float i ) {

			mat4 bone = boneMatrices[ int(i) ];
			return bone;

		}

	#endif

#endif
`

	var skinning_vertex = /* glsl */`
#ifdef USE_SKINNING

	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );

	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;

	transformed = ( bindMatrixInverse * skinned ).xyz;

#endif
`

	var skinnormal_vertex = /* glsl */`
#ifdef USE_SKINNING

	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;

	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;

	#ifdef USE_TANGENT

		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;

	#endif

#endif
`

	var specularmap_fragment = /* glsl */`
float specularStrength;

#ifdef USE_SPECULARMAP

	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;

#else

	specularStrength = 1.0;

#endif
`

	var specularmap_pars_fragment = /* glsl */`
#ifdef USE_SPECULARMAP

	uniform sampler2D specularMap;

#endif
`

	var tonemapping_fragment = /* glsl */`
#if defined( TONE_MAPPING )

	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );

#endif
`

	var tonemapping_pars_fragment = /* glsl */`
#ifndef saturate
// <common> may have defined saturate() already
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif

uniform float toneMappingExposure;

// exposure only
vec3 LinearToneMapping( vec3 color ) {

	return toneMappingExposure * color;

}

// source: https://www.cs.utah.edu/~reinhard/cdrom/
vec3 ReinhardToneMapping( vec3 color ) {

	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );

}

// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/
vec3 OptimizedCineonToneMapping( vec3 color ) {

	// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );

}

// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs
vec3 RRTAndODTFit( vec3 v ) {

	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;

}

// this implementation of ACES is modified to accommodate a brighter viewing environment.
// the scale factor of 1/0.6 is subjective. see discussion in #19621.

vec3 ACESFilmicToneMapping( vec3 color ) {

	// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ), // transposed from source
		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);

	// ODT_SAT => XYZ => D60_2_D65 => sRGB
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ), // transposed from source
		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);

	color *= toneMappingExposure / 0.6;

	color = ACESInputMat * color;

	// Apply RRT and ODT
	color = RRTAndODTFit( color );

	color = ACESOutputMat * color;

	// Clamp to [0, 1]
	return saturate( color );

}

vec3 CustomToneMapping( vec3 color ) { return color; }
`

	var transmission_fragment = /* glsl */`
#ifdef USE_TRANSMISSION

	float transmissionFactor = transmission;
	float thicknessFactor = thickness;

	#ifdef USE_TRANSMISSIONMAP

		transmissionFactor *= texture2D( transmissionMap, vUv ).r;

	#endif

	#ifdef USE_THICKNESSMAP

		thicknessFactor *= texture2D( thicknessMap, vUv ).g;

	#endif

	vec3 pos = vWorldPosition.xyz / vWorldPosition.w;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	float ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );

	vec3 transmission = transmissionFactor * getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationTint, attenuationDistance );

	totalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );
#endif
`

	var transmission_pars_fragment = /* glsl */`
#ifdef USE_TRANSMISSION

	// Transmission code is based on glTF-Sampler-Viewer
	// https://github.com/KhronosGroup/glTF-Sample-Viewer

	#ifdef USE_TRANSMISSIONMAP

		uniform sampler2D transmissionMap;

	#endif

	#ifdef USE_THICKNESSMAP

		uniform sampler2D thicknessMap;

	#endif

	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;

	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;

	varying vec4 vWorldPosition;

	vec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {
		// Direction of refracted light.
		vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);

		// Compute rotation-independant scaling of the model matrix.
		vec3 modelScale;
		modelScale.x = length(vec3(modelMatrix[0].xyz));
		modelScale.y = length(vec3(modelMatrix[1].xyz));
		modelScale.z = length(vec3(modelMatrix[2].xyz));

		// The thickness is specified in local space.
		return normalize(refractionVector) * thickness * modelScale;
	}

	float applyIorToRoughness(float roughness, float ior) {
		// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
		// an IOR of 1.5 results in the default amount of microfacet refraction.
		return roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);
	}

	vec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {
		float framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);
		return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;
	}

	vec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {
		if (attenuationDistance == 0.0) {
			// Attenuation distance is + (which we indicate by zero), i.e. the transmitted color is not attenuated at all.
			return radiance;
		} else {
			// Compute light attenuation using Beer's law.
			vec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;
			vec3 transmittance = exp(-attenuationCoefficient * transmissionDistance); // Beer's law
			return transmittance * radiance;
		}
	}

	vec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,
		vec3 attenuationColor, float attenuationDistance) {
		vec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);
		vec3 refractedRayExit = position + transmissionRay;

		// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
		vec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;

		// Sample framebuffer to get pixel the refracted ray hits.
		vec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);

		vec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);

		return (1.0 - specularColor) * attenuatedColor * baseColor;
	}
#endif
`

	var uv_pars_fragment = /* glsl */`
#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )

	varying vec2 vUv;

#endif
`

	var uv_pars_vertex = /* glsl */`
#ifdef USE_UV

	#ifdef UVS_VERTEX_ONLY

		vec2 vUv;

	#else

		varying vec2 vUv;

	#endif

	uniform mat3 uvTransform;

#endif
`

	var uv_vertex = /* glsl */`
#ifdef USE_UV

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

#endif
`

	var uv2_pars_fragment = /* glsl */`
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	varying vec2 vUv2;

#endif
`

	var uv2_pars_vertex = /* glsl */`
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	attribute vec2 uv2;
	varying vec2 vUv2;

	uniform mat3 uv2Transform;

#endif
`

	var uv2_vertex = /* glsl */`
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;

#endif
`

	var worldpos_vertex = /* glsl */`
#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )

	vec4 worldPosition = vec4( transformed, 1.0 );

	#ifdef USE_INSTANCING

		worldPosition = instanceMatrix * worldPosition;

	#endif

	worldPosition = modelMatrix * worldPosition;

#endif
`

	var background_frag = /* glsl */`
uniform sampler2D t2D;

varying vec2 vUv;

void main() {

	vec4 texColor = texture2D( t2D, vUv );

	gl_FragColor = mapTexelToLinear( texColor );

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`

	var background_vert = /* glsl */`
varying vec2 vUv;
uniform mat3 uvTransform;

void main() {

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

	gl_Position = vec4( position.xy, 1.0, 1.0 );

}
`

	var cube_frag = /* glsl */`
#include <envmap_common_pars_fragment>
uniform float opacity;

varying vec3 vWorldDirection;

#include <cube_uv_reflection_fragment>

void main() {

	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>

	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`

	var cube_vert = /* glsl */`
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

	gl_Position.z = gl_Position.w; // set z to camera.far

}
`

	var depth_frag = /* glsl */`
#if DEPTH_PACKING == 3200

	uniform float opacity;

#endif

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

varying vec2 vHighPrecisionZW;

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( 1.0 );

	#if DEPTH_PACKING == 3200

		diffuseColor.a = opacity;

	#endif

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	#include <logdepthbuf_fragment>

	// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;

	#if DEPTH_PACKING == 3200

		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );

	#elif DEPTH_PACKING == 3201

		gl_FragColor = packDepthToRGBA( fragCoordZ );

	#endif

}
`

	var depth_vert = /* glsl */`
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.
// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for
// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.
varying vec2 vHighPrecisionZW;

void main() {

	#include <uv_vertex>

	#include <skinbase_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vHighPrecisionZW = gl_Position.zw;

}
`

	var distanceRGBA_frag = /* glsl */`
#define DISTANCE

uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>

void main () {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( 1.0 );

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist ); // clamp to [ 0, 1 ]

	gl_FragColor = packDepthToRGBA( dist );

}
`

	var distanceRGBA_vert = /* glsl */`
#define DISTANCE

varying vec3 vWorldPosition;

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <skinbase_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>

	vWorldPosition = worldPosition.xyz;

}
`

	var equirect_frag = /* glsl */`
uniform sampler2D tEquirect;

varying vec3 vWorldDirection;

#include <common>

void main() {

	vec3 direction = normalize( vWorldDirection );

	vec2 sampleUV = equirectUv( direction );

	vec4 texColor = texture2D( tEquirect, sampleUV );

	gl_FragColor = mapTexelToLinear( texColor );

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`

	var equirect_vert = /* glsl */`
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

}
`

	var linedashed_frag = /* glsl */`
uniform vec3 diffuse;
uniform float opacity;

uniform float dashSize;
uniform float totalSize;

varying float vLineDistance;

#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	if ( mod( vLineDistance, totalSize ) > dashSize ) {

		discard;

	}

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <color_fragment>

	outgoingLight = diffuseColor.rgb; // simple shader

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`

	var linedashed_vert = /* glsl */`
uniform float scale;
attribute float lineDistance;

varying float vLineDistance;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	vLineDistance = scale * lineDistance;

	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`

	var meshbasic_frag = /* glsl */`
uniform vec3 diffuse;
uniform float opacity;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );

	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;

	#else

		reflectedLight.indirectDiffuse += vec3( 1.0 );

	#endif

	// modulation
	#include <aomap_fragment>

	reflectedLight.indirectDiffuse *= diffuseColor.rgb;

	vec3 outgoingLight = reflectedLight.indirectDiffuse;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`

	var meshbasic_vert = /* glsl */`
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>

}
`

	var meshlambert_frag = /* glsl */`
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

varying vec3 vLightFront;
varying vec3 vIndirectFront;

#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif


#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>

	// accumulation

	#ifdef DOUBLE_SIDED

		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;

	#else

		reflectedLight.indirectDiffuse += vIndirectFront;

	#endif

	#include <lightmap_fragment>

	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );

	#ifdef DOUBLE_SIDED

		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;

	#else

		reflectedLight.directDiffuse = vLightFront;

	#endif

	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();

	// modulation

	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`

	var meshlambert_vert = /* glsl */`
#define LAMBERT

varying vec3 vLightFront;
varying vec3 vIndirectFront;

#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`

	var meshmatcap_frag = /* glsl */`
#define MATCAP

uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>

#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks

	#ifdef USE_MATCAP

		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );

	#else

		vec4 matcapColor = vec4( 1.0 );

	#endif

	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`

	var meshmatcap_vert = /* glsl */`
#define MATCAP

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>

#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

		vNormal = normalize( transformedNormal );

		#ifdef USE_TANGENT

			vTangent = normalize( transformedTangent );
			vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );

		#endif

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

	vViewPosition = - mvPosition.xyz;

}
`

	var meshtoon_frag = /* glsl */`
#define TOON

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`

	var meshtoon_vert = /* glsl */`
#define TOON

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`

	var meshphong_frag = /* glsl */`
#define PHONG

uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`

	var meshphong_vert = /* glsl */`
#define PHONG

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`

	var meshphysical_frag = /* glsl */`
#define STANDARD

#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define SPECULAR
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationTint;
#endif

#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif

#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularTint;

	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif

	#ifdef USE_SPECULARTINTMAP
		uniform sampler2D specularTintMap;
	#endif
#endif

#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif

#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <transmission_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;

	#include <transmission_fragment>

	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`

	var meshphysical_vert = /* glsl */`
#define STANDARD

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#ifdef USE_TRANSMISSION

	varying vec4 vWorldPosition;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

	#ifdef USE_TANGENT

		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );

	#endif

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

#ifdef USE_TRANSMISSION

	vWorldPosition = worldPosition;

#endif
}
`

	var normal_frag = /* glsl */`
#define NORMAL

uniform float opacity;

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	varying vec3 vViewPosition;

#endif

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );

}
`

	var normal_vert = /* glsl */`
#define NORMAL

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	varying vec3 vViewPosition;

#endif

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

	#ifdef USE_TANGENT

		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );

	#endif

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	vViewPosition = - mvPosition.xyz;

#endif

}
`

	var points_frag = /* glsl */`
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`

	var points_vert = /* glsl */`
uniform float size;
uniform float scale;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>

	gl_PointSize = size;

	#ifdef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );

	#endif

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>

}
`

	var shadow_frag = /* glsl */`
uniform vec3 color;
uniform float opacity;

#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>

void main() {

	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`

	var shadow_vert = /* glsl */`
#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>

void main() {

	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`

	var sprite_frag = /* glsl */ `
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	if(diffuseColor.a == 0.0){
		discard;
	}else{
		gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	}

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`

	var sprite_vert = /* glsl */`
uniform float rotation;
uniform vec2 center;

#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	#ifndef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) scale *= - mvPosition.z;

	#endif

	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`

	const ShaderChunk = {
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		encodings_fragment: encodings_fragment,
		encodings_pars_fragment: encodings_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_common_pars_fragment: envmap_common_pars_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_vertex: lights_lambert_vertex,
		lights_pars_begin: lights_pars_begin,
		lights_toon_fragment: lights_toon_fragment,
		lights_toon_pars_fragment: lights_toon_pars_fragment,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normalmap_pars_fragment: normalmap_pars_fragment,
		clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
		clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
		clearcoat_pars_fragment: clearcoat_pars_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		transmission_fragment: transmission_fragment,
		transmission_pars_fragment: transmission_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		uv2_pars_fragment: uv2_pars_fragment,
		uv2_pars_vertex: uv2_pars_vertex,
		uv2_vertex: uv2_vertex,
		worldpos_vertex: worldpos_vertex,

		background_frag: background_frag,
		background_vert: background_vert,
		cube_frag: cube_frag,
		cube_vert: cube_vert,
		depth_frag: depth_frag,
		depth_vert: depth_vert,
		distanceRGBA_frag: distanceRGBA_frag,
		distanceRGBA_vert: distanceRGBA_vert,
		equirect_frag: equirect_frag,
		equirect_vert: equirect_vert,
		linedashed_frag: linedashed_frag,
		linedashed_vert: linedashed_vert,
		meshbasic_frag: meshbasic_frag,
		meshbasic_vert: meshbasic_vert,
		meshlambert_frag: meshlambert_frag,
		meshlambert_vert: meshlambert_vert,
		meshmatcap_frag: meshmatcap_frag,
		meshmatcap_vert: meshmatcap_vert,
		meshtoon_frag: meshtoon_frag,
		meshtoon_vert: meshtoon_vert,
		meshphong_frag: meshphong_frag,
		meshphong_vert: meshphong_vert,
		meshphysical_frag: meshphysical_frag,
		meshphysical_vert: meshphysical_vert,
		normal_frag: normal_frag,
		normal_vert: normal_vert,
		points_frag: points_frag,
		points_vert: points_vert,
		shadow_frag: shadow_frag,
		shadow_vert: shadow_vert,
		sprite_frag: sprite_frag,
		sprite_vert: sprite_vert
	}

	/**
	 * Uniform Utilities
	 */

	function cloneUniforms (src) {
		const dst = {}

		for (const u in src) {
			dst[u] = {}

			for (const p in src[u]) {
				const property = src[u][p]

				if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
					dst[u][p] = property.clone()
				} else if (Array.isArray(property)) {
					dst[u][p] = property.slice()
				} else {
					dst[u][p] = property
				}
			}
		}

		return dst
	}

	function mergeUniforms (uniforms) {
		const merged = {}

		for (let u = 0; u < uniforms.length; u++) {
			const tmp = cloneUniforms(uniforms[u])

			for (const p in tmp) {
				merged[p] = tmp[p]
			}
		}

		return merged
	}

	// Legacy

	const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms }

	/**
	 * Uniforms library for shared webgl shaders
	 */

	const UniformsLib = {
		common: {
			diffuse: { value: new Color(0xffffff) },
			opacity: { value: 1.0 },

			map: { value: null },
			uvTransform: { value: new Matrix3() },
			uv2Transform: { value: new Matrix3() },

			alphaMap: { value: null }
		},

		specularmap: {
			specularMap: { value: null }
		},

		envmap: {
			envMap: { value: null },
			flipEnvMap: { value: -1 },
			reflectivity: { value: 1.0 },
			refractionRatio: { value: 0.98 },
			maxMipLevel: { value: 0 }
		},

		aomap: {
			aoMap: { value: null },
			aoMapIntensity: { value: 1 }
		},

		lightmap: {
			lightMap: { value: null },
			lightMapIntensity: { value: 1 }
		},

		emissivemap: {
			emissiveMap: { value: null }
		},

		bumpmap: {
			bumpMap: { value: null },
			bumpScale: { value: 1 }
		},

		normalmap: {
			normalMap: { value: null },
			normalScale: { value: new Vector2(1, 1) }
		},

		displacementmap: {
			displacementMap: { value: null },
			displacementScale: { value: 1 },
			displacementBias: { value: 0 }
		},

		roughnessmap: {
			roughnessMap: { value: null }
		},

		metalnessmap: {
			metalnessMap: { value: null }
		},

		gradientmap: {
			gradientMap: { value: null }
		},

		fog: {
			fogDensity: { value: 0.00025 },
			fogNear: { value: 1 },
			fogFar: { value: 2000 },
			fogColor: { value: new Color(0xffffff) }
		},

		lights: {
			ambientLightColor: { value: [] },

			lightProbe: { value: [] },

			directionalLights: {
				value: [],
				properties: {
					direction: {},
					color: {}
				}
			},

			directionalLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},

			directionalShadowMap: { value: [] },
			directionalShadowMatrix: { value: [] },

			spotLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {}
				}
			},

			spotLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},

			spotShadowMap: { value: [] },
			spotShadowMatrix: { value: [] },

			pointLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					decay: {},
					distance: {}
				}
			},

			pointLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {},
					shadowCameraNear: {},
					shadowCameraFar: {}
				}
			},

			pointShadowMap: { value: [] },
			pointShadowMatrix: { value: [] },

			hemisphereLights: {
				value: [],
				properties: {
					direction: {},
					skyColor: {},
					groundColor: {}
				}
			},

			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					width: {},
					height: {}
				}
			},

			ltc_1: { value: null },
			ltc_2: { value: null }
		},

		points: {
			diffuse: { value: new Color(0xffffff) },
			opacity: { value: 1.0 },
			size: { value: 1.0 },
			scale: { value: 1.0 },
			map: { value: null },
			alphaMap: { value: null },
			uvTransform: { value: new Matrix3() }
		},

		sprite: {
			diffuse: { value: new Color(0xffffff) },
			opacity: { value: 1.0 },
			center: { value: new Vector2(0.5, 0.5) },
			rotation: { value: 0.0 },
			map: { value: null },
			alphaMap: { value: null },
			uvTransform: { value: new Matrix3() }
		}
	}

	const ShaderLib = {
		basic: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),

			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag
		},

		lambert: {
			uniforms: mergeUniforms([
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color(0x000000) }
				}
			]),

			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag
		},

		phong: {
			uniforms: mergeUniforms([
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color(0x000000) },
					specular: { value: new Color(0x111111) },
					shininess: { value: 30 }
				}
			]),

			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag
		},

		standard: {
			uniforms: mergeUniforms([
				UniformsLib.common,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.roughnessmap,
				UniformsLib.metalnessmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color(0x000000) },
					roughness: { value: 1.0 },
					metalness: { value: 0.0 },
					envMapIntensity: { value: 1 } // temporary
				}
			]),

			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag
		},

		toon: {
			uniforms: mergeUniforms([
				UniformsLib.common,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.gradientmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color(0x000000) }
				}
			]),

			vertexShader: ShaderChunk.meshtoon_vert,
			fragmentShader: ShaderChunk.meshtoon_frag
		},

		matcap: {
			uniforms: mergeUniforms([
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				{
					matcap: { value: null }
				}
			]),

			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag
		},

		points: {
			uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),

			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag
		},

		dashed: {
			uniforms: mergeUniforms([
				UniformsLib.common,
				UniformsLib.fog,
				{
					scale: { value: 1 },
					dashSize: { value: 1 },
					totalSize: { value: 2 }
				}
			]),

			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag
		},

		depth: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),

			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag
		},

		normal: {
			uniforms: mergeUniforms([
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				{
					opacity: { value: 1.0 }
				}
			]),

			vertexShader: ShaderChunk.normal_vert,
			fragmentShader: ShaderChunk.normal_frag
		},

		sprite: {
			uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),

			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag
		},

		background: {
			uniforms: {
				uvTransform: { value: new Matrix3() },
				t2D: { value: null }
			},

			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag
		},
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		cube: {
			uniforms: mergeUniforms([
				UniformsLib.envmap,
				{
					opacity: { value: 1.0 }
				}
			]),

			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag
		},

		equirect: {
			uniforms: {
				tEquirect: { value: null }
			},

			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag
		},

		distanceRGBA: {
			uniforms: mergeUniforms([
				UniformsLib.common,
				UniformsLib.displacementmap,
				{
					referencePosition: { value: new Vector3() },
					nearDistance: { value: 1 },
					farDistance: { value: 1000 }
				}
			]),

			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag
		},

		shadow: {
			uniforms: mergeUniforms([
				UniformsLib.lights,
				UniformsLib.fog,
				{
					color: { value: new Color(0x00000) },
					opacity: { value: 1.0 }
				}
			]),

			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag
		}
	}

	ShaderLib.physical = {
		uniforms: mergeUniforms([
			ShaderLib.standard.uniforms,
			{
				clearcoat: { value: 0 },
				clearcoatMap: { value: null },
				clearcoatRoughness: { value: 0 },
				clearcoatRoughnessMap: { value: null },
				clearcoatNormalScale: { value: new Vector2(1, 1) },
				clearcoatNormalMap: { value: null },
				sheen: { value: new Color(0x000000) },
				transmission: { value: 0 },
				transmissionMap: { value: null },
				transmissionSamplerSize: { value: new Vector2() },
				transmissionSamplerMap: { value: null },
				thickness: { value: 0 },
				thicknessMap: { value: null },
				attenuationDistance: { value: 0 },
				attenuationTint: { value: new Color(0x000000) },
				specularIntensity: { value: 0 },
				specularIntensityMap: { value: null },
				specularTint: { value: new Color(1, 1, 1) },
				specularTintMap: { value: null }
			}
		]),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag
	}

	function WebGLBackground (renderer, cubemaps, state, objects, premultipliedAlpha) {
		const clearColor = new Color(0x000000)
		let clearAlpha = 0

		let planeMesh
		let boxMesh

		let currentBackground = null
		let currentBackgroundVersion = 0
		let currentTonemapping = null

		function render (renderList, scene) {
			let forceClear = false
			let background = scene.isScene === true ? scene.background : null

			if (background && background.isTexture) {
				background = cubemaps.get(background)
			}

			// Ignore background in AR
			// TODO: Reconsider this.

			const xr = renderer.xr
			const session = xr.getSession && xr.getSession()

			if (session && session.environmentBlendMode === 'additive') {
				background = null
			}

			if (background === null) {
				setClear(clearColor, clearAlpha)
			} else if (background && background.isColor) {
				setClear(background, 1)
				forceClear = true
			}

			if (renderer.autoClear || forceClear) {
				renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil)
			}

			if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
				if (boxMesh === undefined) {
					boxMesh = new Mesh(
						new BoxGeometry(1, 1, 1),
						new ShaderMaterial({
							name: 'BackgroundCubeMaterial',
							uniforms: cloneUniforms(ShaderLib.cube.uniforms),
							vertexShader: ShaderLib.cube.vertexShader,
							fragmentShader: ShaderLib.cube.fragmentShader,
							side: BackSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						})
					)

					boxMesh.geometry.deleteAttribute('normal')
					boxMesh.geometry.deleteAttribute('uv')

					boxMesh.onBeforeRender = function (renderer, scene, camera) {
						this.matrixWorld.copyPosition(camera.matrixWorld)
					}

					// enable code injection for non-built-in material
					Object.defineProperty(boxMesh.material, 'envMap', {
						get: function () {
							return this.uniforms.envMap.value
						}
					})

					objects.update(boxMesh)
				}

				boxMesh.material.uniforms.envMap.value = background
				boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1

				if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
					boxMesh.material.needsUpdate = true

					currentBackground = background
					currentBackgroundVersion = background.version
					currentTonemapping = renderer.toneMapping
				}

				// push to the pre-sorted opaque render list
				renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null)
			} else if (background && background.isTexture) {
				if (planeMesh === undefined) {
					planeMesh = new Mesh(
						new PlaneGeometry(2, 2),
						new ShaderMaterial({
							name: 'BackgroundMaterial',
							uniforms: cloneUniforms(ShaderLib.background.uniforms),
							vertexShader: ShaderLib.background.vertexShader,
							fragmentShader: ShaderLib.background.fragmentShader,
							side: FrontSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						})
					)

					planeMesh.geometry.deleteAttribute('normal')

					// enable code injection for non-built-in material
					Object.defineProperty(planeMesh.material, 'map', {
						get: function () {
							return this.uniforms.t2D.value
						}
					})

					objects.update(planeMesh)
				}

				planeMesh.material.uniforms.t2D.value = background

				if (background.matrixAutoUpdate === true) {
					background.updateMatrix()
				}

				planeMesh.material.uniforms.uvTransform.value.copy(background.matrix)

				if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
					planeMesh.material.needsUpdate = true

					currentBackground = background
					currentBackgroundVersion = background.version
					currentTonemapping = renderer.toneMapping
				}

				// push to the pre-sorted opaque render list
				renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null)
			}
		}

		function setClear (color, alpha) {
			state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha)
		}

		return {
			getClearColor: function () {
				return clearColor
			},
			setClearColor: function (color, alpha = 1) {
				clearColor.set(color)
				clearAlpha = alpha
				setClear(clearColor, clearAlpha)
			},
			getClearAlpha: function () {
				return clearAlpha
			},
			setClearAlpha: function (alpha) {
				clearAlpha = alpha
				setClear(clearColor, clearAlpha)
			},
			render: render
		}
	}

	function WebGLBindingStates (gl, extensions, attributes, capabilities) {

		const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS)

		const extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object')
		const vaoAvailable = capabilities.isWebGL2 || extension !== null

		const bindingStates = {}

		const defaultState = createBindingState(null)
		let currentState = defaultState

		function setup (object, material, program, geometry, index) {

			let updateBuffers = false

			if (vaoAvailable) {

				const state = getBindingState(geometry, program, material)

				if (currentState !== state) {

					currentState = state
					bindVertexArrayObject(currentState.object)

				}

				updateBuffers = needsUpdate(geometry, index)

				if (updateBuffers) saveCache(geometry, index)

			} else {

				const wireframe = (material.wireframe === true)

				if (currentState.geometry !== geometry.id ||
					currentState.program !== program.id ||
					currentState.wireframe !== wireframe) {

					currentState.geometry = geometry.id
					currentState.program = program.id
					currentState.wireframe = wireframe

					updateBuffers = true

				}

			}

			if (object.isInstancedMesh === true) {

				updateBuffers = true

			}

			if (index !== null) {

				attributes.update(index, gl.ELEMENT_ARRAY_BUFFER)

			}

			if (updateBuffers) {

				setupVertexAttributes(object, material, program, geometry)

				if (index !== null) {

					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer)

				}

			}

		}

		function createVertexArrayObject () {

			if (capabilities.isWebGL2) return gl.createVertexArray()

			return extension.createVertexArrayOES()

		}

		function bindVertexArrayObject (vao) {

			if (capabilities.isWebGL2) return gl.bindVertexArray(vao)

			return extension.bindVertexArrayOES(vao)

		}

		function deleteVertexArrayObject (vao) {

			if (capabilities.isWebGL2) return gl.deleteVertexArray(vao)

			return extension.deleteVertexArrayOES(vao)

		}

		function getBindingState (geometry, program, material) {

			const wireframe = (material.wireframe === true)

			let programMap = bindingStates[geometry.id]

			if (programMap === undefined) {

				programMap = {}
				bindingStates[geometry.id] = programMap

			}

			let stateMap = programMap[program.id]

			if (stateMap === undefined) {

				stateMap = {}
				programMap[program.id] = stateMap

			}

			let state = stateMap[wireframe]

			if (state === undefined) {

				state = createBindingState(createVertexArrayObject())
				stateMap[wireframe] = state

			}

			return state

		}

		function createBindingState (vao) {

			const newAttributes = []
			const enabledAttributes = []
			const attributeDivisors = []

			for (let i = 0; i < maxVertexAttributes; i++) {

				newAttributes[i] = 0
				enabledAttributes[i] = 0
				attributeDivisors[i] = 0

			}

			return {

				// for backward compatibility on non-VAO support browser
				geometry: null,
				program: null,
				wireframe: false,

				newAttributes: newAttributes,
				enabledAttributes: enabledAttributes,
				attributeDivisors: attributeDivisors,
				object: vao,
				attributes: {},
				index: null

			}

		}

		function needsUpdate (geometry, index) {

			const cachedAttributes = currentState.attributes
			const geometryAttributes = geometry.attributes

			let attributesNum = 0

			for (const key in geometryAttributes) {

				const cachedAttribute = cachedAttributes[key]
				const geometryAttribute = geometryAttributes[key]

				if (cachedAttribute === undefined) return true

				if (cachedAttribute.attribute !== geometryAttribute) return true

				if (cachedAttribute.data !== geometryAttribute.data) return true

				attributesNum++

			}

			if (currentState.attributesNum !== attributesNum) return true

			if (currentState.index !== index) return true

			return false

		}

		function saveCache (geometry, index) {

			const cache = {}
			const attributes = geometry.attributes
			let attributesNum = 0

			for (const key in attributes) {

				const attribute = attributes[key]

				const data = {}
				data.attribute = attribute

				if (attribute.data) {

					data.data = attribute.data

				}

				cache[key] = data

				attributesNum++

			}

			currentState.attributes = cache
			currentState.attributesNum = attributesNum

			currentState.index = index

		}

		function initAttributes () {

			const newAttributes = currentState.newAttributes

			for (let i = 0, il = newAttributes.length; i < il; i++) {

				newAttributes[i] = 0

			}

		}

		function enableAttribute (attribute) {

			enableAttributeAndDivisor(attribute, 0)

		}

		function enableAttributeAndDivisor (attribute, meshPerAttribute) {

			const newAttributes = currentState.newAttributes
			const enabledAttributes = currentState.enabledAttributes
			const attributeDivisors = currentState.attributeDivisors

			newAttributes[attribute] = 1

			if (enabledAttributes[attribute] === 0) {

				gl.enableVertexAttribArray(attribute)
				enabledAttributes[attribute] = 1

			}

			if (attributeDivisors[attribute] !== meshPerAttribute) {

				const extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays')

				extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute)
				attributeDivisors[attribute] = meshPerAttribute

			}

		}

		function disableUnusedAttributes () {

			const newAttributes = currentState.newAttributes
			const enabledAttributes = currentState.enabledAttributes

			for (let i = 0, il = enabledAttributes.length; i < il; i++) {

				if (enabledAttributes[i] !== newAttributes[i]) {

					gl.disableVertexAttribArray(i)
					enabledAttributes[i] = 0

				}

			}

		}

		function vertexAttribPointer (index, size, type, normalized, stride, offset) {

			if (capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT)) {

				gl.vertexAttribIPointer(index, size, type, stride, offset)

			} else {

				gl.vertexAttribPointer(index, size, type, normalized, stride, offset)

			}

		}

		function setupVertexAttributes (object, material, program, geometry) {

			if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {

				if (extensions.get('ANGLE_instanced_arrays') === null) return

			}

			initAttributes()

			const geometryAttributes = geometry.attributes

			const programAttributes = program.getAttributes()

			const materialDefaultAttributeValues = material.defaultAttributeValues

			for (const name in programAttributes) {

				const programAttribute = programAttributes[name]

				if (programAttribute >= 0) {

					const geometryAttribute = geometryAttributes[name]

					if (geometryAttribute !== undefined) {

						const normalized = geometryAttribute.normalized
						const size = geometryAttribute.itemSize

						const attribute = attributes.get(geometryAttribute)

						// TODO Attribute may not be available on context restore

						if (attribute === undefined) continue

						const buffer = attribute.buffer
						const type = attribute.type
						const bytesPerElement = attribute.bytesPerElement

						if (geometryAttribute.isInterleavedBufferAttribute) {

							const data = geometryAttribute.data
							const stride = data.stride
							const offset = geometryAttribute.offset

							if (data && data.isInstancedInterleavedBuffer) {

								enableAttributeAndDivisor(programAttribute, data.meshPerAttribute)

								if (geometry._maxInstanceCount === undefined) {

									geometry._maxInstanceCount = data.meshPerAttribute * data.count

								}

							} else {

								enableAttribute(programAttribute)

							}

							gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
							vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement)

						} else {

							if (geometryAttribute.isInstancedBufferAttribute) {

								enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute)

								if (geometry._maxInstanceCount === undefined) {

									geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count

								}

							} else {

								enableAttribute(programAttribute)

							}

							gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
							vertexAttribPointer(programAttribute, size, type, normalized, 0, 0)

						}

					} else if (name === 'instanceMatrix') {

						const attribute = attributes.get(object.instanceMatrix)

						// TODO Attribute may not be available on context restore

						if (attribute === undefined) continue

						const buffer = attribute.buffer
						const type = attribute.type

						enableAttributeAndDivisor(programAttribute + 0, 1)
						enableAttributeAndDivisor(programAttribute + 1, 1)
						enableAttributeAndDivisor(programAttribute + 2, 1)
						enableAttributeAndDivisor(programAttribute + 3, 1)

						gl.bindBuffer(gl.ARRAY_BUFFER, buffer)

						gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0)
						gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16)
						gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32)
						gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48)

					} else if (name === 'instanceColor') {

						const attribute = attributes.get(object.instanceColor)

						// TODO Attribute may not be available on context restore

						if (attribute === undefined) continue

						const buffer = attribute.buffer
						const type = attribute.type

						enableAttributeAndDivisor(programAttribute, 1)

						gl.bindBuffer(gl.ARRAY_BUFFER, buffer)

						gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0)

					} else if (materialDefaultAttributeValues !== undefined) {

						const value = materialDefaultAttributeValues[name]

						if (value !== undefined) {

							switch (value.length) {

								case 2:
									gl.vertexAttrib2fv(programAttribute, value)
									break

								case 3:
									gl.vertexAttrib3fv(programAttribute, value)
									break

								case 4:
									gl.vertexAttrib4fv(programAttribute, value)
									break

								default:
									gl.vertexAttrib1fv(programAttribute, value)

							}

						}

					}

				}

			}

			disableUnusedAttributes()

		}

		function dispose () {

			reset()

			for (const geometryId in bindingStates) {

				const programMap = bindingStates[geometryId]

				for (const programId in programMap) {

					const stateMap = programMap[programId]

					for (const wireframe in stateMap) {

						deleteVertexArrayObject(stateMap[wireframe].object)

						delete stateMap[wireframe]

					}

					delete programMap[programId]

				}

				delete bindingStates[geometryId]

			}

		}

		function releaseStatesOfGeometry (geometry) {

			if (bindingStates[geometry.id] === undefined) return

			const programMap = bindingStates[geometry.id]

			for (const programId in programMap) {

				const stateMap = programMap[programId]

				for (const wireframe in stateMap) {

					deleteVertexArrayObject(stateMap[wireframe].object)

					delete stateMap[wireframe]

				}

				delete programMap[programId]

			}

			delete bindingStates[geometry.id]

		}

		function releaseStatesOfProgram (program) {

			for (const geometryId in bindingStates) {

				const programMap = bindingStates[geometryId]

				if (programMap[program.id] === undefined) continue

				const stateMap = programMap[program.id]

				for (const wireframe in stateMap) {

					deleteVertexArrayObject(stateMap[wireframe].object)

					delete stateMap[wireframe]

				}

				delete programMap[program.id]

			}

		}

		function reset () {

			resetDefaultState()

			if (currentState === defaultState) return

			currentState = defaultState
			bindVertexArrayObject(currentState.object)

		}

		// for backward-compatilibity

		function resetDefaultState () {

			defaultState.geometry = null
			defaultState.program = null
			defaultState.wireframe = false

		}

		return {

			setup: setup,
			reset: reset,
			resetDefaultState: resetDefaultState,
			dispose: dispose,
			releaseStatesOfGeometry: releaseStatesOfGeometry,
			releaseStatesOfProgram: releaseStatesOfProgram,

			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			disableUnusedAttributes: disableUnusedAttributes

		}

	}

	function WebGLBufferRenderer (gl, extensions, info, capabilities) {

		const isWebGL2 = capabilities.isWebGL2

		let mode

		function setMode (value) {

			mode = value

		}

		function render (start, count) {

			gl.drawArrays(mode, start, count)

			info.update(count, mode, 1)

		}

		function renderInstances (start, count, primcount) {

			if (primcount === 0) return

			let extension, methodName

			if (isWebGL2) {

				extension = gl
				methodName = 'drawArraysInstanced'

			} else {

				extension = extensions.get('ANGLE_instanced_arrays')
				methodName = 'drawArraysInstancedANGLE'

				if (extension === null) {

					console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.')
					return

				}

			}

			extension[methodName](mode, start, count, primcount)

			info.update(count, mode, primcount)

		}

		//

		this.setMode = setMode
		this.render = render
		this.renderInstances = renderInstances

	}

	function WebGLCapabilities (gl, extensions, parameters) {

		let maxAnisotropy

		function getMaxAnisotropy () {

			if (maxAnisotropy !== undefined) return maxAnisotropy

			if (extensions.has('EXT_texture_filter_anisotropic') === true) {

				const extension = extensions.get('EXT_texture_filter_anisotropic')

				maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT)

			} else {

				maxAnisotropy = 0

			}

			return maxAnisotropy

		}

		function getMaxPrecision (precision) {

			if (precision === 'highp') {

				if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 &&
					gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {

					return 'highp'

				}

				precision = 'mediump'

			}

			if (precision === 'mediump') {

				if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 &&
					gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {

					return 'mediump'

				}

			}

			return 'lowp'

		}

		/* eslint-disable no-undef */
		const isWebGL2 = (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) ||
			(typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext)
		/* eslint-enable no-undef */

		let precision = parameters.precision !== undefined ? parameters.precision : 'highp'
		const maxPrecision = getMaxPrecision(precision)

		if (maxPrecision !== precision) {

			console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.')
			precision = maxPrecision

		}

		const drawBuffers = isWebGL2 || extensions.has('WEBGL_draw_buffers')

		const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true

		const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)
		const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
		const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE)
		const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE)

		const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS)
		const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS)
		const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS)
		const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS)

		const vertexTextures = maxVertexTextures > 0
		const floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float')
		const floatVertexTextures = vertexTextures && floatFragmentTextures

		const maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0

		return {

			isWebGL2: isWebGL2,

			drawBuffers: drawBuffers,

			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,

			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,

			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,

			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures,

			maxSamples: maxSamples

		}

	}

	function WebGLClipping (properties) {
		const scope = this

		let globalState = null,
			numGlobalPlanes = 0,
			localClippingEnabled = false,
			renderingShadows = false

		const plane = new Plane(),
			viewNormalMatrix = new Matrix3(),
			uniform = { value: null, needsUpdate: false }

		this.uniform = uniform
		this.numPlanes = 0
		this.numIntersection = 0

		this.init = function (planes, enableLocalClipping, camera) {
			const enabled =
				planes.length !== 0 ||
				enableLocalClipping ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				numGlobalPlanes !== 0 ||
				localClippingEnabled

			localClippingEnabled = enableLocalClipping

			globalState = projectPlanes(planes, camera, 0)
			numGlobalPlanes = planes.length

			return enabled
		}

		this.beginShadows = function () {
			renderingShadows = true
			projectPlanes(null)
		}

		this.endShadows = function () {
			renderingShadows = false
			resetGlobalState()
		}

		this.setState = function (material, camera, useCache) {
			const planes = material.clippingPlanes,
				clipIntersection = material.clipIntersection,
				clipShadows = material.clipShadows

			const materialProperties = properties.get(material)

			if (!localClippingEnabled || planes === null || planes.length === 0 || (renderingShadows && !clipShadows)) {
				// there's no local clipping

				if (renderingShadows) {
					// there's no global clipping

					projectPlanes(null)
				} else {
					resetGlobalState()
				}
			} else {
				const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
					lGlobal = nGlobal * 4

				let dstArray = materialProperties.clippingState || null

				uniform.value = dstArray // ensure unique state

				dstArray = projectPlanes(planes, camera, lGlobal, useCache)

				for (let i = 0; i !== lGlobal; ++i) {
					dstArray[i] = globalState[i]
				}

				materialProperties.clippingState = dstArray
				this.numIntersection = clipIntersection ? this.numPlanes : 0
				this.numPlanes += nGlobal
			}
		}

		function resetGlobalState () {
			if (uniform.value !== globalState) {
				uniform.value = globalState
				uniform.needsUpdate = numGlobalPlanes > 0
			}

			scope.numPlanes = numGlobalPlanes
			scope.numIntersection = 0
		}

		function projectPlanes (planes, camera, dstOffset, skipTransform) {
			const nPlanes = planes !== null ? planes.length : 0
			let dstArray = null

			if (nPlanes !== 0) {
				dstArray = uniform.value

				if (skipTransform !== true || dstArray === null) {
					const flatSize = dstOffset + nPlanes * 4,
						viewMatrix = camera.matrixWorldInverse

					viewNormalMatrix.getNormalMatrix(viewMatrix)

					if (dstArray === null || dstArray.length < flatSize) {
						dstArray = new Float32Array(flatSize)
					}

					for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
						plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix)

						plane.normal.toArray(dstArray, i4)
						dstArray[i4 + 3] = plane.constant
					}
				}

				uniform.value = dstArray
				uniform.needsUpdate = true
			}

			scope.numPlanes = nPlanes
			scope.numIntersection = 0

			return dstArray
		}
	}

	function WebGLCubeMaps (renderer) {
		let cubemaps = new WeakMap()

		function mapTextureMapping (texture, mapping) {
			if (mapping === EquirectangularReflectionMapping) {
				texture.mapping = CubeReflectionMapping
			} else if (mapping === EquirectangularRefractionMapping) {
				texture.mapping = CubeRefractionMapping
			}

			return texture
		}

		function get (texture) {
			if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
				const mapping = texture.mapping

				if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
					if (cubemaps.has(texture)) {
						const cubemap = cubemaps.get(texture).texture
						return mapTextureMapping(cubemap, texture.mapping)
					} else {
						const image = texture.image

						if (image && image.height > 0) {
							const currentRenderTarget = renderer.getRenderTarget()

							const renderTarget = new WebGLCubeRenderTarget(image.height / 2)
							renderTarget.fromEquirectangularTexture(renderer, texture)
							cubemaps.set(texture, renderTarget)

							renderer.setRenderTarget(currentRenderTarget)

							texture.addEventListener('dispose', onTextureDispose)

							return mapTextureMapping(renderTarget.texture, texture.mapping)
						} else {
							// image not yet ready. try the conversion next frame

							return null
						}
					}
				}
			}

			return texture
		}

		function onTextureDispose (event) {
			const texture = event.target

			texture.removeEventListener('dispose', onTextureDispose)

			const cubemap = cubemaps.get(texture)

			if (cubemap !== undefined) {
				cubemaps.delete(texture)
				cubemap.dispose()
			}
		}

		function dispose () {
			cubemaps = new WeakMap()
		}

		return {
			get: get,
			dispose: dispose
		}
	}

	function WebGLCubeUVMaps (renderer) {
		let cubeUVmaps = new WeakMap()

		let pmremGenerator = null

		function get (texture) {
			if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
				const mapping = texture.mapping

				const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping
				const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping

				if (isEquirectMap || isCubeMap) {
					// equirect/cube map to cubeUV conversion

					if (cubeUVmaps.has(texture)) {
						return cubeUVmaps.get(texture).texture
					} else {
						const image = texture.image

						if ((isEquirectMap && image && image.height > 0) || (isCubeMap && image && isCubeTextureComplete(image))) {
							const currentRenderTarget = renderer.getRenderTarget()

							if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer)

							const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture)
							cubeUVmaps.set(texture, renderTarget)

							renderer.setRenderTarget(currentRenderTarget)

							texture.addEventListener('dispose', onTextureDispose)

							return renderTarget.texture
						} else {
							// image not yet ready. try the conversion next frame

							return null
						}
					}
				}
			}

			return texture
		}

		function isCubeTextureComplete (image) {
			let count = 0
			const length = 6

			for (let i = 0; i < length; i++) {
				if (image[i] !== undefined) count++
			}

			return count === length
		}

		function onTextureDispose (event) {
			const texture = event.target

			texture.removeEventListener('dispose', onTextureDispose)

			const cubemapUV = cubeUVmaps.get(texture)

			if (cubemapUV !== undefined) {
				cubemapUV.delete(texture)
				cubemapUV.dispose()
			}
		}

		function dispose () {
			cubeUVmaps = new WeakMap()

			if (pmremGenerator !== null) {
				pmremGenerator.dispose()
				pmremGenerator = null
			}
		}

		return {
			get: get,
			dispose: dispose
		}
	}

	function WebGLExtensions (gl) {

		const extensions = {}

		function getExtension (name) {

			if (extensions[name] !== undefined) {

				return extensions[name]

			}

			let extension

			switch (name) {

				case 'WEBGL_depth_texture':
					extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture')
					break

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic')
					break

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc')
					break

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc')
					break

				default:
					extension = gl.getExtension(name)

			}

			extensions[name] = extension

			return extension

		}

		return {

			has: function (name) {

				return getExtension(name) !== null

			},

			init: function (capabilities) {

				if (capabilities.isWebGL2) {

					getExtension('EXT_color_buffer_float')

				} else {

					getExtension('WEBGL_depth_texture')
					getExtension('OES_texture_float')
					getExtension('OES_texture_half_float')
					getExtension('OES_texture_half_float_linear')
					getExtension('OES_standard_derivatives')
					getExtension('OES_element_index_uint')
					getExtension('OES_vertex_array_object')
					getExtension('ANGLE_instanced_arrays')

				}

				getExtension('OES_texture_float_linear')
				getExtension('EXT_color_buffer_half_float')

			},

			get: function (name) {

				const extension = getExtension(name)

				if (extension === null) {

					console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.')

				}

				return extension

			}

		}

	}

	function arrayMax (array) {

		if (array.length === 0) return - Infinity

		let max = array[0]

		for (let i = 1, l = array.length; i < l; ++i) {

			if (array[i] > max) max = array[i]

		}

		return max

	}

	function WebGLGeometries (gl, attributes, info, bindingStates) {
		const geometries = {}
		const wireframeAttributes = new WeakMap()

		function onGeometryDispose (event) {
			const geometry = event.target

			if (geometry.index !== null) {
				attributes.remove(geometry.index)
			}

			for (const name in geometry.attributes) {
				attributes.remove(geometry.attributes[name])
			}

			geometry.removeEventListener('dispose', onGeometryDispose)

			delete geometries[geometry.id]

			const attribute = wireframeAttributes.get(geometry)

			if (attribute) {
				attributes.remove(attribute)
				wireframeAttributes.delete(geometry)
			}

			bindingStates.releaseStatesOfGeometry(geometry)

			if (geometry.isInstancedBufferGeometry === true) {
				delete geometry._maxInstanceCount
			}

			//

			info.memory.geometries--
		}

		function get (object, geometry) {
			if (geometries[geometry.id] === true) return geometry

			geometry.addEventListener('dispose', onGeometryDispose)

			geometries[geometry.id] = true

			info.memory.geometries++

			return geometry
		}

		function update (geometry) {
			const geometryAttributes = geometry.attributes

			// Updating index buffer in VAO now. See WebGLBindingStates.

			for (const name in geometryAttributes) {
				attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER)
			}

			// morph targets

			const morphAttributes = geometry.morphAttributes

			for (const name in morphAttributes) {
				const array = morphAttributes[name]

				for (let i = 0, l = array.length; i < l; i++) {
					attributes.update(array[i], gl.ARRAY_BUFFER)
				}
			}
		}

		function updateWireframeAttribute (geometry) {
			const indices = []

			const geometryIndex = geometry.index
			const geometryPosition = geometry.attributes.position
			let version = 0

			if (geometryIndex !== null) {
				const array = geometryIndex.array
				version = geometryIndex.version

				for (let i = 0, l = array.length; i < l; i += 3) {
					const a = array[i + 0]
					const b = array[i + 1]
					const c = array[i + 2]

					indices.push(a, b, b, c, c, a)
				}
			} else {
				const array = geometryPosition.array
				version = geometryPosition.version

				for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
					const a = i + 0
					const b = i + 1
					const c = i + 2

					indices.push(a, b, b, c, c, a)
				}
			}

			const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1)
			attribute.version = version

			// Updating index buffer in VAO now. See WebGLBindingStates

			//

			const previousAttribute = wireframeAttributes.get(geometry)

			if (previousAttribute) attributes.remove(previousAttribute)

			//

			wireframeAttributes.set(geometry, attribute)
		}

		function getWireframeAttribute (geometry) {
			const currentAttribute = wireframeAttributes.get(geometry)

			if (currentAttribute) {
				const geometryIndex = geometry.index

				if (geometryIndex !== null) {
					// if the attribute is obsolete, create a new one

					if (currentAttribute.version < geometryIndex.version) {
						updateWireframeAttribute(geometry)
					}
				}
			} else {
				updateWireframeAttribute(geometry)
			}

			return wireframeAttributes.get(geometry)
		}

		return {
			get: get,
			update: update,

			getWireframeAttribute: getWireframeAttribute
		}
	}

	function WebGLIndexedBufferRenderer (gl, extensions, info, capabilities) {

		const isWebGL2 = capabilities.isWebGL2

		let mode

		function setMode (value) {

			mode = value

		}

		let type, bytesPerElement

		function setIndex (value) {

			type = value.type
			bytesPerElement = value.bytesPerElement

		}

		function render (start, count) {

			gl.drawElements(mode, count, type, start * bytesPerElement)

			info.update(count, mode, 1)

		}

		function renderInstances (start, count, primcount) {

			if (primcount === 0) return

			let extension, methodName

			if (isWebGL2) {

				extension = gl
				methodName = 'drawElementsInstanced'

			} else {

				extension = extensions.get('ANGLE_instanced_arrays')
				methodName = 'drawElementsInstancedANGLE'

				if (extension === null) {

					console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.')
					return

				}

			}

			extension[methodName](mode, count, type, start * bytesPerElement, primcount)

			info.update(count, mode, primcount)

		}

		//

		this.setMode = setMode
		this.setIndex = setIndex
		this.render = render
		this.renderInstances = renderInstances

	}

	function WebGLInfo (gl) {

		const memory = {
			geometries: 0,
			textures: 0
		}

		const render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		}

		function update (count, mode, instanceCount) {

			render.calls++

			switch (mode) {

				case gl.TRIANGLES:
					render.triangles += instanceCount * (count / 3)
					break

				case gl.LINES:
					render.lines += instanceCount * (count / 2)
					break

				case gl.LINE_STRIP:
					render.lines += instanceCount * (count - 1)
					break

				case gl.LINE_LOOP:
					render.lines += instanceCount * count
					break

				case gl.POINTS:
					render.points += instanceCount * count
					break

				default:
					console.error('THREE.WebGLInfo: Unknown draw mode:', mode)
					break

			}

		}

		function reset () {

			render.frame++
			render.calls = 0
			render.triangles = 0
			render.points = 0
			render.lines = 0

		}

		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		}

	}

	function numericalSort (a, b) {

		return a[0] - b[0]

	}

	function absNumericalSort (a, b) {

		return Math.abs(b[1]) - Math.abs(a[1])

	}

	function WebGLMorphtargets (gl) {

		const influencesList = {}
		const morphInfluences = new Float32Array(8)

		const workInfluences = []

		for (let i = 0; i < 8; i++) {

			workInfluences[i] = [i, 0]

		}

		function update (object, geometry, material, program) {

			const objectInfluences = object.morphTargetInfluences

			// When object doesn't have morph target influences defined, we treat it as a 0-length array
			// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

			const length = objectInfluences === undefined ? 0 : objectInfluences.length

			let influences = influencesList[geometry.id]

			if (influences === undefined || influences.length !== length) {

				// initialise list

				influences = []

				for (let i = 0; i < length; i++) {

					influences[i] = [i, 0]

				}

				influencesList[geometry.id] = influences

			}

			// Collect influences

			for (let i = 0; i < length; i++) {

				const influence = influences[i]

				influence[0] = i
				influence[1] = objectInfluences[i]

			}

			influences.sort(absNumericalSort)

			for (let i = 0; i < 8; i++) {

				if (i < length && influences[i][1]) {

					workInfluences[i][0] = influences[i][0]
					workInfluences[i][1] = influences[i][1]

				} else {

					workInfluences[i][0] = Number.MAX_SAFE_INTEGER
					workInfluences[i][1] = 0

				}

			}

			workInfluences.sort(numericalSort)

			const morphTargets = geometry.morphAttributes.position
			const morphNormals = geometry.morphAttributes.normal

			let morphInfluencesSum = 0

			for (let i = 0; i < 8; i++) {

				const influence = workInfluences[i]
				const index = influence[0]
				const value = influence[1]

				if (index !== Number.MAX_SAFE_INTEGER && value) {

					if (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {

						geometry.setAttribute('morphTarget' + i, morphTargets[index])

					}

					if (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {

						geometry.setAttribute('morphNormal' + i, morphNormals[index])

					}

					morphInfluences[i] = value
					morphInfluencesSum += value

				} else {

					if (morphTargets && geometry.hasAttribute('morphTarget' + i) === true) {

						geometry.deleteAttribute('morphTarget' + i)

					}

					if (morphNormals && geometry.hasAttribute('morphNormal' + i) === true) {

						geometry.deleteAttribute('morphNormal' + i)

					}

					morphInfluences[i] = 0

				}

			}

			// GLSL shader uses formula baseinfluence * base + sum(target * influence)
			// This allows us to switch between absolute morphs and relative morphs without changing shader code
			// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum

			program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence)
			program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences)

		}

		return {

			update: update

		}

	}

	function WebGLObjects (gl, geometries, attributes, info) {

		let updateMap = new WeakMap()

		function update (object) {

			const frame = info.render.frame

			const geometry = object.geometry
			const buffergeometry = geometries.get(object, geometry)

			// Update once per frame

			if (updateMap.get(buffergeometry) !== frame) {

				geometries.update(buffergeometry)

				updateMap.set(buffergeometry, frame)

			}

			if (object.isInstancedMesh) {

				if (object.hasEventListener('dispose', onInstancedMeshDispose) === false) {

					object.addEventListener('dispose', onInstancedMeshDispose)

				}

				attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER)

				if (object.instanceColor !== null) {

					attributes.update(object.instanceColor, gl.ARRAY_BUFFER)

				}

			}

			return buffergeometry

		}

		function dispose () {

			updateMap = new WeakMap()

		}

		function onInstancedMeshDispose (event) {

			const instancedMesh = event.target

			instancedMesh.removeEventListener('dispose', onInstancedMeshDispose)

			attributes.remove(instancedMesh.instanceMatrix)

			if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor)

		}

		return {

			update: update,
			dispose: dispose

		}

	}

	/**
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */

	const emptyTexture = new Texture()
	const emptyTexture2dArray = new DataTexture2DArray()
	const emptyTexture3d = new DataTexture3D()
	const emptyCubeTexture = new CubeTexture()

	// --- Utilities ---

	// Array Caches (provide typed arrays for temporary by size)

	const arrayCacheF32 = []
	const arrayCacheI32 = []

	// Float32Array caches used for uploading Matrix uniforms

	const mat4array = new Float32Array(16)
	const mat3array = new Float32Array(9)
	const mat2array = new Float32Array(4)

	// Flattening for arrays of vectors and matrices

	function flatten (array, nBlocks, blockSize) {
		const firstElem = array[0]

		if (firstElem <= 0 || firstElem > 0) return array
		// unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		const n = nBlocks * blockSize
		let r = arrayCacheF32[n]

		if (r === undefined) {
			r = new Float32Array(n)
			arrayCacheF32[n] = r
		}

		if (nBlocks !== 0) {
			firstElem.toArray(r, 0)

			for (let i = 1, offset = 0; i !== nBlocks; ++i) {
				offset += blockSize
				array[i].toArray(r, offset)
			}
		}

		return r
	}

	function arraysEqual (a, b) {
		if (a.length !== b.length) return false

		for (let i = 0, l = a.length; i < l; i++) {
			if (a[i] !== b[i]) return false
		}

		return true
	}

	function copyArray (a, b) {
		for (let i = 0, l = b.length; i < l; i++) {
			a[i] = b[i]
		}
	}

	// Texture unit allocation

	function allocTexUnits (textures, n) {
		let r = arrayCacheI32[n]

		if (r === undefined) {
			r = new Int32Array(n)
			arrayCacheI32[n] = r
		}

		for (let i = 0; i !== n; ++i) {
			r[i] = textures.allocateTextureUnit()
		}

		return r
	}

	// --- Setters ---

	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.

	// Single scalar

	function setValueV1f (gl, v) {
		const cache = this.cache

		if (cache[0] === v) return

		gl.uniform1f(this.addr, v)

		cache[0] = v
	}

	// Single float vector (from flat array or THREE.VectorN)

	function setValueV2f (gl, v) {
		const cache = this.cache

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y) {
				gl.uniform2f(this.addr, v.x, v.y)

				cache[0] = v.x
				cache[1] = v.y
			}
		} else {
			if (arraysEqual(cache, v)) return

			gl.uniform2fv(this.addr, v)

			copyArray(cache, v)
		}
	}

	function setValueV3f (gl, v) {
		const cache = this.cache

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
				gl.uniform3f(this.addr, v.x, v.y, v.z)

				cache[0] = v.x
				cache[1] = v.y
				cache[2] = v.z
			}
		} else if (v.r !== undefined) {
			if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
				gl.uniform3f(this.addr, v.r, v.g, v.b)

				cache[0] = v.r
				cache[1] = v.g
				cache[2] = v.b
			}
		} else {
			if (arraysEqual(cache, v)) return

			gl.uniform3fv(this.addr, v)

			copyArray(cache, v)
		}
	}

	function setValueV4f (gl, v) {
		const cache = this.cache

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
				gl.uniform4f(this.addr, v.x, v.y, v.z, v.w)

				cache[0] = v.x
				cache[1] = v.y
				cache[2] = v.z
				cache[3] = v.w
			}
		} else {
			if (arraysEqual(cache, v)) return

			gl.uniform4fv(this.addr, v)

			copyArray(cache, v)
		}
	}

	// Single matrix (from flat array or THREE.MatrixN)

	function setValueM2 (gl, v) {
		const cache = this.cache
		const elements = v.elements

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return

			gl.uniformMatrix2fv(this.addr, false, v)

			copyArray(cache, v)
		} else {
			if (arraysEqual(cache, elements)) return

			mat2array.set(elements)

			gl.uniformMatrix2fv(this.addr, false, mat2array)

			copyArray(cache, elements)
		}
	}

	function setValueM3 (gl, v) {
		const cache = this.cache
		const elements = v.elements

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return

			gl.uniformMatrix3fv(this.addr, false, v)

			copyArray(cache, v)
		} else {
			if (arraysEqual(cache, elements)) return

			mat3array.set(elements)

			gl.uniformMatrix3fv(this.addr, false, mat3array)

			copyArray(cache, elements)
		}
	}

	function setValueM4 (gl, v) {
		const cache = this.cache
		const elements = v.elements

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return

			gl.uniformMatrix4fv(this.addr, false, v)

			copyArray(cache, v)
		} else {
			if (arraysEqual(cache, elements)) return

			mat4array.set(elements)

			gl.uniformMatrix4fv(this.addr, false, mat4array)

			copyArray(cache, elements)
		}
	}

	// Single integer / boolean

	function setValueV1i (gl, v) {
		const cache = this.cache

		if (cache[0] === v) return

		gl.uniform1i(this.addr, v)

		cache[0] = v
	}

	// Single integer / boolean vector (from flat array)

	function setValueV2i (gl, v) {
		const cache = this.cache

		if (arraysEqual(cache, v)) return

		gl.uniform2iv(this.addr, v)

		copyArray(cache, v)
	}

	function setValueV3i (gl, v) {
		const cache = this.cache

		if (arraysEqual(cache, v)) return

		gl.uniform3iv(this.addr, v)

		copyArray(cache, v)
	}

	function setValueV4i (gl, v) {
		const cache = this.cache

		if (arraysEqual(cache, v)) return

		gl.uniform4iv(this.addr, v)

		copyArray(cache, v)
	}

	// Single unsigned integer

	function setValueV1ui (gl, v) {
		const cache = this.cache

		if (cache[0] === v) return

		gl.uniform1ui(this.addr, v)

		cache[0] = v
	}

	// Single unsigned integer vector (from flat array)

	function setValueV2ui (gl, v) {
		const cache = this.cache

		if (arraysEqual(cache, v)) return

		gl.uniform2uiv(this.addr, v)

		copyArray(cache, v)
	}

	function setValueV3ui (gl, v) {
		const cache = this.cache

		if (arraysEqual(cache, v)) return

		gl.uniform3uiv(this.addr, v)

		copyArray(cache, v)
	}

	function setValueV4ui (gl, v) {
		const cache = this.cache

		if (arraysEqual(cache, v)) return

		gl.uniform4uiv(this.addr, v)

		copyArray(cache, v)
	}

	// Single texture (2D / Cube)

	function setValueT1 (gl, v, textures) {
		const cache = this.cache
		const unit = textures.allocateTextureUnit()

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit)
			cache[0] = unit
		}

		textures.safeSetTexture2D(v || emptyTexture, unit)
	}

	function setValueT3D1 (gl, v, textures) {
		const cache = this.cache
		const unit = textures.allocateTextureUnit()

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit)
			cache[0] = unit
		}

		textures.setTexture3D(v || emptyTexture3d, unit)
	}

	function setValueT6 (gl, v, textures) {
		const cache = this.cache
		const unit = textures.allocateTextureUnit()

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit)
			cache[0] = unit
		}

		textures.safeSetTextureCube(v || emptyCubeTexture, unit)
	}

	function setValueT2DArray1 (gl, v, textures) {
		const cache = this.cache
		const unit = textures.allocateTextureUnit()

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit)
			cache[0] = unit
		}

		textures.setTexture2DArray(v || emptyTexture2dArray, unit)
	}

	// Helper to pick the right setter for the singular case

	function getSingularSetter (type) {
		switch (type) {
			case 0x1406:
				return setValueV1f // FLOAT
			case 0x8b50:
				return setValueV2f // _VEC2
			case 0x8b51:
				return setValueV3f // _VEC3
			case 0x8b52:
				return setValueV4f // _VEC4

			case 0x8b5a:
				return setValueM2 // _MAT2
			case 0x8b5b:
				return setValueM3 // _MAT3
			case 0x8b5c:
				return setValueM4 // _MAT4

			case 0x1404:
			case 0x8b56:
				return setValueV1i // INT, BOOL
			case 0x8b53:
			case 0x8b57:
				return setValueV2i // _VEC2
			case 0x8b54:
			case 0x8b58:
				return setValueV3i // _VEC3
			case 0x8b55:
			case 0x8b59:
				return setValueV4i // _VEC4

			case 0x1405:
				return setValueV1ui // UINT
			case 0x8dc6:
				return setValueV2ui // _VEC2
			case 0x8dc7:
				return setValueV3ui // _VEC3
			case 0x8dc8:
				return setValueV4ui // _VEC4

			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1

			case 0x8b5f: // SAMPLER_3D
			case 0x8dcb: // INT_SAMPLER_3D
			case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
				return setValueT3D1

			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6

			case 0x8dc1: // SAMPLER_2D_ARRAY
			case 0x8dcf: // INT_SAMPLER_2D_ARRAY
			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
			case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArray1
		}
	}

	// Array of scalars

	function setValueV1fArray (gl, v) {
		gl.uniform1fv(this.addr, v)
	}

	// Array of vectors (from flat array or array of THREE.VectorN)

	function setValueV2fArray (gl, v) {
		const data = flatten(v, this.size, 2)

		gl.uniform2fv(this.addr, data)
	}

	function setValueV3fArray (gl, v) {
		const data = flatten(v, this.size, 3)

		gl.uniform3fv(this.addr, data)
	}

	function setValueV4fArray (gl, v) {
		const data = flatten(v, this.size, 4)

		gl.uniform4fv(this.addr, data)
	}

	// Array of matrices (from flat array or array of THREE.MatrixN)

	function setValueM2Array (gl, v) {
		const data = flatten(v, this.size, 4)

		gl.uniformMatrix2fv(this.addr, false, data)
	}

	function setValueM3Array (gl, v) {
		const data = flatten(v, this.size, 9)

		gl.uniformMatrix3fv(this.addr, false, data)
	}

	function setValueM4Array (gl, v) {
		const data = flatten(v, this.size, 16)

		gl.uniformMatrix4fv(this.addr, false, data)
	}

	// Array of integer / boolean

	function setValueV1iArray (gl, v) {
		gl.uniform1iv(this.addr, v)
	}

	// Array of integer / boolean vectors (from flat array)

	function setValueV2iArray (gl, v) {
		gl.uniform2iv(this.addr, v)
	}

	function setValueV3iArray (gl, v) {
		gl.uniform3iv(this.addr, v)
	}

	function setValueV4iArray (gl, v) {
		gl.uniform4iv(this.addr, v)
	}

	// Array of unsigned integer

	function setValueV1uiArray (gl, v) {
		gl.uniform1uiv(this.addr, v)
	}

	// Array of unsigned integer vectors (from flat array)

	function setValueV2uiArray (gl, v) {
		gl.uniform2uiv(this.addr, v)
	}

	function setValueV3uiArray (gl, v) {
		gl.uniform3uiv(this.addr, v)
	}

	function setValueV4uiArray (gl, v) {
		gl.uniform4uiv(this.addr, v)
	}

	// Array of textures (2D / Cube)

	function setValueT1Array (gl, v, textures) {
		const n = v.length

		const units = allocTexUnits(textures, n)

		gl.uniform1iv(this.addr, units)

		for (let i = 0; i !== n; ++i) {
			textures.safeSetTexture2D(v[i] || emptyTexture, units[i])
		}
	}

	function setValueT6Array (gl, v, textures) {
		const n = v.length

		const units = allocTexUnits(textures, n)

		gl.uniform1iv(this.addr, units)

		for (let i = 0; i !== n; ++i) {
			textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i])
		}
	}

	// Helper to pick the right setter for a pure (bottom-level) array

	function getPureArraySetter (type) {
		switch (type) {
			case 0x1406:
				return setValueV1fArray // FLOAT
			case 0x8b50:
				return setValueV2fArray // _VEC2
			case 0x8b51:
				return setValueV3fArray // _VEC3
			case 0x8b52:
				return setValueV4fArray // _VEC4

			case 0x8b5a:
				return setValueM2Array // _MAT2
			case 0x8b5b:
				return setValueM3Array // _MAT3
			case 0x8b5c:
				return setValueM4Array // _MAT4

			case 0x1404:
			case 0x8b56:
				return setValueV1iArray // INT, BOOL
			case 0x8b53:
			case 0x8b57:
				return setValueV2iArray // _VEC2
			case 0x8b54:
			case 0x8b58:
				return setValueV3iArray // _VEC3
			case 0x8b55:
			case 0x8b59:
				return setValueV4iArray // _VEC4

			case 0x1405:
				return setValueV1uiArray // UINT
			case 0x8dc6:
				return setValueV2uiArray // _VEC2
			case 0x8dc7:
				return setValueV3uiArray // _VEC3
			case 0x8dc8:
				return setValueV4uiArray // _VEC4

			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1Array

			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6Array
		}
	}

	// --- Uniform Classes ---

	function SingleUniform (id, activeInfo, addr) {
		this.id = id
		this.addr = addr
		this.cache = []
		this.setValue = getSingularSetter(activeInfo.type)

		// this.path = activeInfo.name; // DEBUG
	}

	function PureArrayUniform (id, activeInfo, addr) {
		this.id = id
		this.addr = addr
		this.cache = []
		this.size = activeInfo.size
		this.setValue = getPureArraySetter(activeInfo.type)

		// this.path = activeInfo.name; // DEBUG
	}

	PureArrayUniform.prototype.updateCache = function (data) {
		const cache = this.cache

		if (data instanceof Float32Array && cache.length !== data.length) {
			this.cache = new Float32Array(data.length)
		}

		copyArray(cache, data)
	}

	function StructuredUniform (id) {
		this.id = id

		this.seq = []
		this.map = {}
	}

	StructuredUniform.prototype.setValue = function (gl, value, textures) {
		const seq = this.seq

		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i]
			u.setValue(gl, value[u.id], textures)
		}
	}

	// --- Top-level ---

	// Parser - builds up the property tree from the path strings

	const RePathPart = /(\w+)(\])?(\[|\.)?/g

	// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform (container, uniformObject) {
		container.seq.push(uniformObject)
		container.map[uniformObject.id] = uniformObject
	}

	function parseUniform (activeInfo, addr, container) {
		const path = activeInfo.name,
			pathLength = path.length

		// reset RegExp object, because of the early exit of a previous run
		RePathPart.lastIndex = 0

		while (true) {
			const match = RePathPart.exec(path),
				matchEnd = RePathPart.lastIndex

			let id = match[1]
			const idIsIndex = match[2] === ']',
				subscript = match[3]

			if (idIsIndex) id = id | 0 // convert to integer

			if (subscript === undefined || (subscript === '[' && matchEnd + 2 === pathLength)) {
				// bare name or "pure" bottom-level array "[0]" suffix

				addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr))

				break
			} else {
				// step into inner node / create it in case it doesn't exist

				const map = container.map
				let next = map[id]

				if (next === undefined) {
					next = new StructuredUniform(id)
					addUniform(container, next)
				}

				container = next
			}
		}
	}

	// Root Container

	function WebGLUniforms (gl, program) {
		this.seq = []
		this.map = {}

		const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS)

		for (let i = 0; i < n; ++i) {
			const info = gl.getActiveUniform(program, i),
				addr = gl.getUniformLocation(program, info.name)

			parseUniform(info, addr, this)
		}
	}

	WebGLUniforms.prototype.setValue = function (gl, name, value, textures) {
		const u = this.map[name]

		if (u !== undefined) u.setValue(gl, value, textures)
	}

	WebGLUniforms.prototype.setOptional = function (gl, object, name) {
		const v = object[name]

		if (v !== undefined) this.setValue(gl, name, v)
	}

	// Static interface

	WebGLUniforms.upload = function (gl, seq, values, textures) {
		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i],
				v = values[u.id]

			if (v.needsUpdate !== false) {
				// note: always updating when .needsUpdate is undefined
				u.setValue(gl, v.value, textures)
			}
		}
	}

	WebGLUniforms.seqWithValue = function (seq, values) {
		const r = []

		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i]
			if (u.id in values) r.push(u)
		}

		return r
	}

	function WebGLShader (gl, type, string) {

		const shader = gl.createShader(type)

		gl.shaderSource(shader, string)
		gl.compileShader(shader)

		return shader

	}

	let programIdCount = 0

	function addLineNumbers (string) {
		const lines = string.split('\n')

		for (let i = 0; i < lines.length; i++) {
			lines[i] = i + 1 + ': ' + lines[i]
		}

		return lines.join('\n')
	}

	function getEncodingComponents (encoding) {
		switch (encoding) {
			case LinearEncoding:
				return ['Linear', '( value )']
			case sRGBEncoding:
				return ['sRGB', '( value )']
			case RGBEEncoding:
				return ['RGBE', '( value )']
			case RGBM7Encoding:
				return ['RGBM', '( value, 7.0 )']
			case RGBM16Encoding:
				return ['RGBM', '( value, 16.0 )']
			case RGBDEncoding:
				return ['RGBD', '( value, 256.0 )']
			case GammaEncoding:
				return ['Gamma', '( value, float( GAMMA_FACTOR ) )']
			case LogLuvEncoding:
				return ['LogLuv', '( value )']
			default:
				console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding)
				return ['Linear', '( value )']
		}
	}

	function getShaderErrors (gl, shader, type) {
		const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS)
		const log = gl.getShaderInfoLog(shader).trim()

		if (status && log === '') return ''

		// --enable-privileged-webgl-extension
		// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		const source = gl.getShaderSource(shader)

		return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers(source)
	}

	function getTexelDecodingFunction (functionName, encoding) {
		const components = getEncodingComponents(encoding)
		return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }'
	}

	function getTexelEncodingFunction (functionName, encoding) {
		const components = getEncodingComponents(encoding)
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }'
	}

	function getToneMappingFunction (functionName, toneMapping) {
		let toneMappingName

		switch (toneMapping) {
			case LinearToneMapping:
				toneMappingName = 'Linear'
				break

			case ReinhardToneMapping:
				toneMappingName = 'Reinhard'
				break

			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon'
				break

			case ACESFilmicToneMapping:
				toneMappingName = 'ACESFilmic'
				break

			case CustomToneMapping:
				toneMappingName = 'Custom'
				break

			default:
				console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping)
				toneMappingName = 'Linear'
		}

		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }'
	}

	function generateExtensions (parameters) {
		const chunks = [
			parameters.extensionDerivatives ||
				parameters.envMapCubeUV ||
				parameters.bumpMap ||
				parameters.tangentSpaceNormalMap ||
				parameters.clearcoatNormalMap ||
				parameters.flatShading ||
				parameters.shaderID === 'physical'
				? '#extension GL_OES_standard_derivatives : enable'
				: '',
			(parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
			parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '',
			(parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission > 0.0) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
		]

		return chunks.filter(filterEmptyLine).join('\n')
	}

	function generateDefines (defines) {
		const chunks = []

		for (const name in defines) {
			const value = defines[name]

			if (value === false) continue

			chunks.push('#define ' + name + ' ' + value)
		}

		return chunks.join('\n')
	}

	function fetchAttributeLocations (gl, program) {
		const attributes = {}

		const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES)

		for (let i = 0; i < n; i++) {
			const info = gl.getActiveAttrib(program, i)
			const name = info.name

			// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[name] = gl.getAttribLocation(program, name)
		}

		return attributes
	}

	function filterEmptyLine (string) {
		return string !== ''
	}

	function replaceLightNums (string, parameters) {
		return string
			.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights)
			.replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights)
			.replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights)
			.replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights)
			.replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights)
			.replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows)
			.replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows)
			.replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows)
	}

	function replaceClippingPlaneNums (string, parameters) {
		return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection)
	}

	// Resolve Includes

	const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm

	function resolveIncludes (string) {
		return string.replace(includePattern, includeReplacer)
	}

	function includeReplacer (match, include) {
		const string = ShaderChunk[include]

		if (string === undefined) {
			throw new Error('Can not resolve #include <' + include + '>')
		}

		return resolveIncludes(string)
	}

	// Unroll Loops

	const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g
	const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g

	function unrollLoops (string) {
		return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer)
	}

	function deprecatedLoopReplacer (match, start, end, snippet) {
		console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.')
		return loopReplacer(match, start, end, snippet)
	}

	function loopReplacer (match, start, end, snippet) {
		let string = ''

		for (let i = parseInt(start); i < parseInt(end); i++) {
			string += snippet.replace(/\[\s*i\s*\]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i)
		}

		return string
	}

	//

	function generatePrecision (parameters) {
		let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;'

		if (parameters.precision === 'highp') {
			precisionstring += '\n#define HIGH_PRECISION'
		} else if (parameters.precision === 'mediump') {
			precisionstring += '\n#define MEDIUM_PRECISION'
		} else if (parameters.precision === 'lowp') {
			precisionstring += '\n#define LOW_PRECISION'
		}

		return precisionstring
	}

	function generateShadowMapTypeDefine (parameters) {
		let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC'

		if (parameters.shadowMapType === PCFShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF'
		} else if (parameters.shadowMapType === PCFSoftShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT'
		} else if (parameters.shadowMapType === VSMShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM'
		}

		return shadowMapTypeDefine
	}

	function generateEnvMapTypeDefine (parameters) {
		let envMapTypeDefine = 'ENVMAP_TYPE_CUBE'

		if (parameters.envMap) {
			switch (parameters.envMapMode) {
				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE'
					break

				case CubeUVReflectionMapping:
				case CubeUVRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV'
					break
			}
		}

		return envMapTypeDefine
	}

	function generateEnvMapModeDefine (parameters) {
		let envMapModeDefine = 'ENVMAP_MODE_REFLECTION'

		if (parameters.envMap) {
			switch (parameters.envMapMode) {
				case CubeRefractionMapping:
				case CubeUVRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION'
					break
			}
		}

		return envMapModeDefine
	}

	function generateEnvMapBlendingDefine (parameters) {
		let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE'

		if (parameters.envMap) {
			switch (parameters.combine) {
				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY'
					break

				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX'
					break

				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD'
					break
			}
		}

		return envMapBlendingDefine
	}

	function WebGLProgram (renderer, cacheKey, parameters, bindingStates) {
		const gl = renderer.getContext()

		const defines = parameters.defines

		let vertexShader = parameters.vertexShader
		let fragmentShader = parameters.fragmentShader

		const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters)
		const envMapTypeDefine = generateEnvMapTypeDefine(parameters)
		const envMapModeDefine = generateEnvMapModeDefine(parameters)
		const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters)

		const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0

		const customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters)

		const customDefines = generateDefines(defines)

		const program = gl.createProgram()

		let prefixVertex, prefixFragment
		let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : ''

		if (parameters.isRawShaderMaterial) {
			prefixVertex = [customDefines].filter(filterEmptyLine).join('\n')

			if (prefixVertex.length > 0) {
				prefixVertex += '\n'
			}

			prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n')

			if (prefixFragment.length > 0) {
				prefixFragment += '\n'
			}
		} else {
			prefixVertex = [
				generatePrecision(parameters),

				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines,

				parameters.instancing ? '#define USE_INSTANCING' : '',
				parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',

				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				'#define MAX_BONES ' + parameters.maxBones,
				parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
				parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
				parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',

				parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
				parameters.specularTintMap ? '#define USE_SPECULARTINTMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.transmission ? '#define USE_TRANSMISSION' : '',
				parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
				parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

				parameters.vertexTangents ? '#define USE_TANGENT' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',
				parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
				parameters.vertexUvs ? '#define USE_UV' : '',
				parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',
				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',

				'#ifdef USE_INSTANCING',

				'	attribute mat4 instanceMatrix;',

				'#endif',

				'#ifdef USE_INSTANCING_COLOR',

				'	attribute vec3 instanceColor;',

				'#endif',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',

				'#ifdef USE_TANGENT',

				'	attribute vec4 tangent;',

				'#endif',

				'#if defined( USE_COLOR_ALPHA )',

				'	attribute vec4 color;',

				'#elif defined( USE_COLOR )',

				'	attribute vec3 color;',

				'#endif',

				'#ifdef USE_MORPHTARGETS',

				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',

				'	#ifdef USE_MORPHNORMALS',

				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',

				'	#else',

				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',

				'	#endif',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				'\n'
			]
				.filter(filterEmptyLine)
				.join('\n')

			prefixFragment = [
				customExtensions,

				generatePrecision(parameters),

				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines,

				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '', // add '.0' if integer

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
				parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.matcap ? '#define USE_MATCAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
				parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
				parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
				parameters.specularTintMap ? '#define USE_SPECULARTINTMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

				parameters.sheen ? '#define USE_SHEEN' : '',
				parameters.transmission ? '#define USE_TRANSMISSION' : '',
				parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
				parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

				parameters.vertexTangents ? '#define USE_TANGENT' : '',
				parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
				parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
				parameters.vertexUvs ? '#define USE_UV' : '',
				parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

				parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

				parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',

				(parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',

				parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '',
				parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below
				parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '',

				parameters.dithering ? '#define DITHERING' : '',

				ShaderChunk['encodings_pars_fragment'], // this code is required here because it is used by the various encoding/decoding function defined below
				parameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '',
				parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '',
				parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '',
				parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '',
				parameters.specularTintMap ? getTexelDecodingFunction('specularTintMapTexelToLinear', parameters.specularTintMapEncoding) : '',
				parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '',
				getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding),

				parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

				'\n'
			]
				.filter(filterEmptyLine)
				.join('\n')
		}

		vertexShader = resolveIncludes(vertexShader)
		vertexShader = replaceLightNums(vertexShader, parameters)
		vertexShader = replaceClippingPlaneNums(vertexShader, parameters)

		fragmentShader = resolveIncludes(fragmentShader)
		fragmentShader = replaceLightNums(fragmentShader, parameters)
		fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters)

		vertexShader = unrollLoops(vertexShader)
		fragmentShader = unrollLoops(fragmentShader)

		if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
			// GLSL 3.0 conversion for built-in materials and ShaderMaterial

			versionString = '#version 300 es\n'

			prefixVertex = ['#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex

			prefixFragment =
				[
					'#define varying in',
					parameters.glslVersion === GLSL3 ? '' : 'out highp vec4 pc_fragColor;',
					parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor',
					'#define gl_FragDepthEXT gl_FragDepth',
					'#define texture2D texture',
					'#define textureCube texture',
					'#define texture2DProj textureProj',
					'#define texture2DLodEXT textureLod',
					'#define texture2DProjLodEXT textureProjLod',
					'#define textureCubeLodEXT textureLod',
					'#define texture2DGradEXT textureGrad',
					'#define texture2DProjGradEXT textureProjGrad',
					'#define textureCubeGradEXT textureGrad'
				].join('\n') +
				'\n' +
				prefixFragment
		}

		const vertexGlsl = versionString + prefixVertex + vertexShader
		const fragmentGlsl = versionString + prefixFragment + fragmentShader

		// console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl)
		const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl)

		gl.attachShader(program, glVertexShader)
		gl.attachShader(program, glFragmentShader)

		// Force a particular attribute to index 0.

		if (parameters.index0AttributeName !== undefined) {
			gl.bindAttribLocation(program, 0, parameters.index0AttributeName)
		} else if (parameters.morphTargets === true) {
			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation(program, 0, 'position')
		}

		gl.linkProgram(program)

		// check for link errors
		if (renderer.debug.checkShaderErrors) {
			const programLog = gl.getProgramInfoLog(program).trim()
			const vertexLog = gl.getShaderInfoLog(glVertexShader).trim()
			const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim()

			let runnable = true
			let haveDiagnostics = true

			if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
				runnable = false

				const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex')
				const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment')

				console.error(
					'THREE.WebGLProgram: shader error: ',
					gl.getError(),
					'gl.VALIDATE_STATUS',
					gl.getProgramParameter(program, gl.VALIDATE_STATUS),
					'gl.getProgramInfoLog',
					programLog,
					vertexErrors,
					fragmentErrors
				)
			} else if (programLog !== '') {
				console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog)
			} else if (vertexLog === '' || fragmentLog === '') {
				haveDiagnostics = false
			}

			if (haveDiagnostics) {
				this.diagnostics = {
					runnable: runnable,

					programLog: programLog,

					vertexShader: {
						log: vertexLog,
						prefix: prefixVertex
					},

					fragmentShader: {
						log: fragmentLog,
						prefix: prefixFragment
					}
				}
			}
		}

		// Clean up

		// Crashes in iOS9 and iOS10. #18402
		// gl.detachShader( program, glVertexShader );
		// gl.detachShader( program, glFragmentShader );

		gl.deleteShader(glVertexShader)
		gl.deleteShader(glFragmentShader)

		// set up caching for uniform locations

		let cachedUniforms

		this.getUniforms = function () {
			if (cachedUniforms === undefined) {
				cachedUniforms = new WebGLUniforms(gl, program)
			}

			return cachedUniforms
		}

		// set up caching for attribute locations

		let cachedAttributes

		this.getAttributes = function () {
			if (cachedAttributes === undefined) {
				cachedAttributes = fetchAttributeLocations(gl, program)
			}

			return cachedAttributes
		}

		// free resource

		this.destroy = function () {
			bindingStates.releaseStatesOfProgram(this)

			gl.deleteProgram(program)
			this.program = undefined
		}

		//

		this.name = parameters.shaderName
		this.id = programIdCount++
		this.cacheKey = cacheKey
		this.usedTimes = 1
		this.program = program
		this.vertexShader = glVertexShader
		this.fragmentShader = glFragmentShader

		return this
	}

	function WebGLPrograms (renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
		const programs = []

		const isWebGL2 = capabilities.isWebGL2
		const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer
		const floatVertexTextures = capabilities.floatVertexTextures
		const maxVertexUniforms = capabilities.maxVertexUniforms
		const vertexTextures = capabilities.vertexTextures

		let precision = capabilities.precision

		const shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'toon',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		}

		const parameterNames = [
			'precision',
			'isWebGL2',
			'supportsVertexTextures',
			'outputEncoding',
			'instancing',
			'instancingColor',
			'map',
			'mapEncoding',
			'matcap',
			'matcapEncoding',
			'envMap',
			'envMapMode',
			'envMapEncoding',
			'envMapCubeUV',
			'lightMap',
			'lightMapEncoding',
			'aoMap',
			'emissiveMap',
			'emissiveMapEncoding',
			'bumpMap',
			'normalMap',
			'objectSpaceNormalMap',
			'tangentSpaceNormalMap',
			'clearcoatMap',
			'clearcoatRoughnessMap',
			'clearcoatNormalMap',
			'displacementMap',
			'specularMap',
			'specularIntensityMap',
			'specularTintMap',
			'specularTintMapEncoding',
			'roughnessMap',
			'metalnessMap',
			'gradientMap',
			'alphaMap',
			'combine',
			'vertexColors',
			'vertexAlphas',
			'vertexTangents',
			'vertexUvs',
			'uvsVertexOnly',
			'fog',
			'useFog',
			'fogExp2',
			'flatShading',
			'sizeAttenuation',
			'logarithmicDepthBuffer',
			'skinning',
			'maxBones',
			'useVertexTexture',
			'morphTargets',
			'morphNormals',
			'premultipliedAlpha',
			'numDirLights',
			'numPointLights',
			'numSpotLights',
			'numHemiLights',
			'numRectAreaLights',
			'numDirLightShadows',
			'numPointLightShadows',
			'numSpotLightShadows',
			'shadowMapEnabled',
			'shadowMapType',
			'toneMapping',
			'physicallyCorrectLights',
			'alphaTest',
			'doubleSided',
			'flipSided',
			'numClippingPlanes',
			'numClipIntersection',
			'depthPacking',
			'dithering',
			'sheen',
			'transmission',
			'transmissionMap',
			'thicknessMap'
		]

		function getMaxBones (object) {
			const skeleton = object.skeleton
			const bones = skeleton.bones

			if (floatVertexTextures) {
				return 1024
			} else {
				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)

				const nVertexUniforms = maxVertexUniforms
				const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4)

				const maxBones = Math.min(nVertexMatrices, bones.length)

				if (maxBones < bones.length) {
					console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.')
					return 0
				}

				return maxBones
			}
		}

		function getTextureEncodingFromMap (map) {
			let encoding

			if (map && map.isTexture) {
				encoding = map.encoding
			} else if (map && map.isWebGLRenderTarget) {
				console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.")
				encoding = map.texture.encoding
			} else {
				encoding = LinearEncoding
			}

			return encoding
		}

		function getParameters (material, lights, shadows, scene, object) {
			const fog = scene.fog
			const environment = material.isMeshStandardMaterial ? scene.environment : null

			const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment)

			const shaderID = shaderIDs[material.type]

			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0

			if (material.precision !== null) {
				precision = capabilities.getMaxPrecision(material.precision)

				if (precision !== material.precision) {
					console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.')
				}
			}

			let vertexShader, fragmentShader

			if (shaderID) {
				const shader = ShaderLib[shaderID]

				vertexShader = shader.vertexShader
				fragmentShader = shader.fragmentShader
			} else {
				vertexShader = material.vertexShader
				fragmentShader = material.fragmentShader
			}

			const currentRenderTarget = renderer.getRenderTarget()

			const parameters = {
				isWebGL2: isWebGL2,

				shaderID: shaderID,
				shaderName: material.type,

				vertexShader: vertexShader,
				fragmentShader: fragmentShader,
				defines: material.defines,

				isRawShaderMaterial: material.isRawShaderMaterial === true,
				glslVersion: material.glslVersion,

				precision: precision,

				instancing: object.isInstancedMesh === true,
				instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,

				supportsVertexTextures: vertexTextures,
				outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
				map: !!material.map,
				mapEncoding: getTextureEncodingFromMap(material.map),
				matcap: !!material.matcap,
				matcapEncoding: getTextureEncodingFromMap(material.matcap),
				envMap: !!envMap,
				envMapMode: envMap && envMap.mapping,
				envMapEncoding: getTextureEncodingFromMap(envMap),
				envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
				lightMap: !!material.lightMap,
				lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
				aoMap: !!material.aoMap,
				emissiveMap: !!material.emissiveMap,
				emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
				bumpMap: !!material.bumpMap,
				normalMap: !!material.normalMap,
				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
				tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
				clearcoatMap: !!material.clearcoatMap,
				clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
				clearcoatNormalMap: !!material.clearcoatNormalMap,
				displacementMap: !!material.displacementMap,
				roughnessMap: !!material.roughnessMap,
				metalnessMap: !!material.metalnessMap,
				specularMap: !!material.specularMap,
				specularIntensityMap: !!material.specularIntensityMap,
				specularTintMap: !!material.specularTintMap,
				specularTintMapEncoding: getTextureEncodingFromMap(material.specularTintMap),
				alphaMap: !!material.alphaMap,

				gradientMap: !!material.gradientMap,

				sheen: !!material.sheen,

				transmission: !!material.transmission,
				transmissionMap: !!material.transmissionMap,
				thicknessMap: !!material.thicknessMap,

				combine: material.combine,

				vertexTangents: !!material.normalMap && !!object.geometry && !!object.geometry.attributes.tangent,
				vertexColors: material.vertexColors,
				vertexAlphas: material.vertexColors === true && !!object.geometry && !!object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
				vertexUvs:
					!!material.map ||
					!!material.bumpMap ||
					!!material.normalMap ||
					!!material.specularMap ||
					!!material.alphaMap ||
					!!material.emissiveMap ||
					!!material.roughnessMap ||
					!!material.metalnessMap ||
					!!material.clearcoatMap ||
					!!material.clearcoatRoughnessMap ||
					!!material.clearcoatNormalMap ||
					!!material.displacementMap ||
					!!material.transmissionMap ||
					!!material.thicknessMap ||
					!!material.specularIntensityMap ||
					!!material.specularTintMap,
				uvsVertexOnly:
					!(
						!!material.map ||
						!!material.bumpMap ||
						!!material.normalMap ||
						!!material.specularMap ||
						!!material.alphaMap ||
						!!material.emissiveMap ||
						!!material.roughnessMap ||
						!!material.metalnessMap ||
						!!material.clearcoatNormalMap ||
						!!material.transmission ||
						!!material.transmissionMap ||
						!!material.thicknessMap ||
						!!material.specularIntensityMap ||
						!!material.specularTintMap
					) && !!material.displacementMap,

				fog: !!fog,
				useFog: material.fog,
				fogExp2: fog && fog.isFogExp2,

				flatShading: !!material.flatShading,

				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: logarithmicDepthBuffer,

				skinning: object.isSkinnedMesh === true && maxBones > 0,
				maxBones: maxBones,
				useVertexTexture: floatVertexTextures,

				morphTargets: !!object.geometry && !!object.geometry.morphAttributes.position,
				morphNormals: !!object.geometry && !!object.geometry.morphAttributes.normal,

				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,

				numDirLightShadows: lights.directionalShadowMap.length,
				numPointLightShadows: lights.pointShadowMap.length,
				numSpotLightShadows: lights.spotShadowMap.length,

				numClippingPlanes: clipping.numPlanes,
				numClipIntersection: clipping.numIntersection,

				dithering: material.dithering,

				shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,

				toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,

				premultipliedAlpha: material.premultipliedAlpha,

				alphaTest: material.alphaTest,
				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,

				depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,

				index0AttributeName: material.index0AttributeName,

				extensionDerivatives: material.extensions && material.extensions.derivatives,
				extensionFragDepth: material.extensions && material.extensions.fragDepth,
				extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
				extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

				rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
				rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),
				rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),

				customProgramCacheKey: material.customProgramCacheKey()
			}

			return parameters
		}

		function getProgramCacheKey (parameters) {
			const array = []

			if (parameters.shaderID) {
				array.push(parameters.shaderID)
			} else {
				array.push(parameters.fragmentShader)
				array.push(parameters.vertexShader)
			}

			if (parameters.defines !== undefined) {
				for (const name in parameters.defines) {
					array.push(name)
					array.push(parameters.defines[name])
				}
			}

			if (parameters.isRawShaderMaterial === false) {
				for (let i = 0; i < parameterNames.length; i++) {
					array.push(parameters[parameterNames[i]])
				}

				array.push(renderer.outputEncoding)
				array.push(renderer.gammaFactor)
			}

			array.push(parameters.customProgramCacheKey)

			return array.join()
		}

		function getUniforms (material) {
			const shaderID = shaderIDs[material.type]
			let uniforms

			if (shaderID) {
				const shader = ShaderLib[shaderID]
				uniforms = UniformsUtils.clone(shader.uniforms)
			} else {
				uniforms = material.uniforms
			}

			return uniforms
		}

		function acquireProgram (parameters, cacheKey) {
			let program

			// Check if code has been already compiled
			for (let p = 0, pl = programs.length; p < pl; p++) {
				const preexistingProgram = programs[p]

				if (preexistingProgram.cacheKey === cacheKey) {
					program = preexistingProgram
					++program.usedTimes

					break
				}
			}

			if (program === undefined) {
				program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates)
				programs.push(program)
			}

			return program
		}

		function releaseProgram (program) {
			if (--program.usedTimes === 0) {
				// Remove from unordered set
				const i = programs.indexOf(program)
				programs[i] = programs[programs.length - 1]
				programs.pop()

				// Free WebGL resources
				program.destroy()
			}
		}

		return {
			getParameters: getParameters,
			getProgramCacheKey: getProgramCacheKey,
			getUniforms: getUniforms,
			acquireProgram: acquireProgram,
			releaseProgram: releaseProgram,
			// Exposed for resource monitoring & error feedback via renderer.info:
			programs: programs
		}
	}

	function WebGLProperties () {

		let properties = new WeakMap()

		function get (object) {

			let map = properties.get(object)

			if (map === undefined) {

				map = {}
				properties.set(object, map)

			}

			return map

		}

		function remove (object) {

			properties.delete(object)

		}

		function update (object, key, value) {

			properties.get(object)[key] = value

		}

		function dispose () {

			properties = new WeakMap()

		}

		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		}

	}

	function painterSortStable (a, b) {

		if (a.groupOrder !== b.groupOrder) {

			return a.groupOrder - b.groupOrder

		} else if (a.renderOrder !== b.renderOrder) {

			return a.renderOrder - b.renderOrder

		} else if (a.program !== b.program) {

			return a.program.id - b.program.id

		} else if (a.material.id !== b.material.id) {

			return a.material.id - b.material.id

		} else if (a.z !== b.z) {

			return a.z - b.z

		} else {

			return a.id - b.id

		}

	}

	function reversePainterSortStable (a, b) {

		if (a.groupOrder !== b.groupOrder) {

			return a.groupOrder - b.groupOrder

		} else if (a.renderOrder !== b.renderOrder) {

			return a.renderOrder - b.renderOrder

		} else if (a.z !== b.z) {

			return b.z - a.z

		} else {

			return a.id - b.id

		}

	}


	function WebGLRenderList (properties) {

		const renderItems = []
		let renderItemsIndex = 0

		const opaque = []
		const transmissive = []
		const transparent = []

		const defaultProgram = { id: - 1 }

		function init () {

			renderItemsIndex = 0

			opaque.length = 0
			transmissive.length = 0
			transparent.length = 0

		}

		function getNextRenderItem (object, geometry, material, groupOrder, z, group) {

			let renderItem = renderItems[renderItemsIndex]
			const materialProperties = properties.get(material)

			if (renderItem === undefined) {

				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					program: materialProperties.program || defaultProgram,
					groupOrder: groupOrder,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				}

				renderItems[renderItemsIndex] = renderItem

			} else {

				renderItem.id = object.id
				renderItem.object = object
				renderItem.geometry = geometry
				renderItem.material = material
				renderItem.program = materialProperties.program || defaultProgram
				renderItem.groupOrder = groupOrder
				renderItem.renderOrder = object.renderOrder
				renderItem.z = z
				renderItem.group = group

			}

			renderItemsIndex++

			return renderItem

		}

		function push (object, geometry, material, groupOrder, z, group) {

			const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group)

			if (material.transmission > 0.0) {

				transmissive.push(renderItem)

			} else if (material.transparent === true) {

				transparent.push(renderItem)

			} else {

				opaque.push(renderItem)

			}

		}

		function unshift (object, geometry, material, groupOrder, z, group) {

			const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group)

			if (material.transmission > 0.0) {

				transmissive.unshift(renderItem)

			} else if (material.transparent === true) {

				transparent.unshift(renderItem)

			} else {

				opaque.unshift(renderItem)

			}

		}

		function sort (customOpaqueSort, customTransparentSort) {

			if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable)
			if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable)
			if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable)

		}

		function finish () {

			// Clear references from inactive renderItems in the list

			for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {

				const renderItem = renderItems[i]

				if (renderItem.id === null) break

				renderItem.id = null
				renderItem.object = null
				renderItem.geometry = null
				renderItem.material = null
				renderItem.program = null
				renderItem.group = null

			}

		}

		return {

			opaque: opaque,
			transmissive: transmissive,
			transparent: transparent,

			init: init,
			push: push,
			unshift: unshift,
			finish: finish,

			sort: sort
		}

	}

	function WebGLRenderLists (properties) {

		let lists = new WeakMap()

		function get (scene, renderCallDepth) {

			let list

			if (lists.has(scene) === false) {

				list = new WebGLRenderList(properties)
				lists.set(scene, [list])

			} else {

				if (renderCallDepth >= lists.get(scene).length) {

					list = new WebGLRenderList(properties)
					lists.get(scene).push(list)

				} else {

					list = lists.get(scene)[renderCallDepth]

				}

			}

			return list

		}

		function dispose () {

			lists = new WeakMap()

		}

		return {
			get: get,
			dispose: dispose
		}

	}

	function UniformsCache () {
		const lights = {}

		return {
			get: function (light) {
				if (lights[light.id] !== undefined) {
					return lights[light.id]
				}

				let uniforms

				switch (light.type) {
					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color(),
							position: new Vector3()
						}
						break

					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0
						}
						break

					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0
						}
						break

					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						}
						break

					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
						}
						break
				}

				lights[light.id] = uniforms

				return uniforms
			}
		}
	}

	function ShadowUniformsCache () {
		const lights = {}

		return {
			get: function (light) {
				if (lights[light.id] !== undefined) {
					return lights[light.id]
				}

				let uniforms

				switch (light.type) {
					case 'DirectionalLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						}
						break

					case 'SpotLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						}
						break

					case 'PointLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						}
						break

					// TODO (abelnation): set RectAreaLight shadow uniforms
				}

				lights[light.id] = uniforms

				return uniforms
			}
		}
	}

	let nextVersion = 0

	function shadowCastingLightsFirst (lightA, lightB) {
		return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0)
	}

	function WebGLLights (extensions, capabilities) {
		const cache = new UniformsCache()

		const shadowCache = ShadowUniformsCache()

		const state = {
			version: 0,

			hash: {
				directionalLength: -1,
				pointLength: -1,
				spotLength: -1,
				rectAreaLength: -1,
				hemiLength: -1,

				numDirectionalShadows: -1,
				numPointShadows: -1,
				numSpotShadows: -1
			},

			ambient: [0, 0, 0],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadow: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []
		}

		for (let i = 0; i < 9; i++) state.probe.push(new Vector3())

		const vector3 = new Vector3()
		const matrix4 = new Matrix4()
		const matrix42 = new Matrix4()

		function setup (lights) {
			let r = 0,
				g = 0,
				b = 0

			for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0)

			let directionalLength = 0
			let pointLength = 0
			let spotLength = 0
			let rectAreaLength = 0
			let hemiLength = 0

			let numDirectionalShadows = 0
			let numPointShadows = 0
			let numSpotShadows = 0

			lights.sort(shadowCastingLightsFirst)

			for (let i = 0, l = lights.length; i < l; i++) {
				const light = lights[i]

				const color = light.color
				const intensity = light.intensity
				const distance = light.distance

				const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null

				if (light.isAmbientLight) {
					r += color.r * intensity
					g += color.g * intensity
					b += color.b * intensity
				} else if (light.isLightProbe) {
					for (let j = 0; j < 9; j++) {
						state.probe[j].addScaledVector(light.sh.coefficients[j], intensity)
					}
				} else if (light.isDirectionalLight) {
					const uniforms = cache.get(light)

					uniforms.position.setFromMatrixPosition(light.matrixWorld)
					uniforms.color.copy(light.color).multiplyScalar(light.intensity)

					if (light.castShadow) {
						const shadow = light.shadow

						const shadowUniforms = shadowCache.get(light)

						shadowUniforms.shadowBias = shadow.bias
						shadowUniforms.shadowNormalBias = shadow.normalBias
						shadowUniforms.shadowRadius = shadow.radius
						shadowUniforms.shadowMapSize = shadow.mapSize

						state.directionalShadow[directionalLength] = shadowUniforms
						state.directionalShadowMap[directionalLength] = shadowMap
						state.directionalShadowMatrix[directionalLength] = light.shadow.matrix

						numDirectionalShadows++
					}

					state.directional[directionalLength] = uniforms

					directionalLength++
				} else if (light.isSpotLight) {
					const uniforms = cache.get(light)

					uniforms.position.setFromMatrixPosition(light.matrixWorld)

					uniforms.color.copy(color).multiplyScalar(intensity)
					uniforms.distance = distance

					uniforms.coneCos = Math.cos(light.angle)
					uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra))
					uniforms.decay = light.decay

					if (light.castShadow) {
						const shadow = light.shadow

						const shadowUniforms = shadowCache.get(light)

						shadowUniforms.shadowBias = shadow.bias
						shadowUniforms.shadowNormalBias = shadow.normalBias
						shadowUniforms.shadowRadius = shadow.radius
						shadowUniforms.shadowMapSize = shadow.mapSize

						state.spotShadow[spotLength] = shadowUniforms
						state.spotShadowMap[spotLength] = shadowMap
						state.spotShadowMatrix[spotLength] = light.shadow.matrix

						numSpotShadows++
					}

					state.spot[spotLength] = uniforms

					spotLength++
				} else if (light.isRectAreaLight) {
					const uniforms = cache.get(light)

					// (a) intensity is the total visible light emitted
					//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

					// (b) intensity is the brightness of the light
					uniforms.color.copy(color).multiplyScalar(intensity)

					uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0)
					uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0)

					state.rectArea[rectAreaLength] = uniforms

					rectAreaLength++
				} else if (light.isPointLight) {
					const uniforms = cache.get(light)

					uniforms.color.copy(light.color).multiplyScalar(light.intensity)
					uniforms.distance = light.distance
					uniforms.decay = light.decay

					if (light.castShadow) {
						const shadow = light.shadow

						const shadowUniforms = shadowCache.get(light)

						shadowUniforms.shadowBias = shadow.bias
						shadowUniforms.shadowNormalBias = shadow.normalBias
						shadowUniforms.shadowRadius = shadow.radius
						shadowUniforms.shadowMapSize = shadow.mapSize
						shadowUniforms.shadowCameraNear = shadow.camera.near
						shadowUniforms.shadowCameraFar = shadow.camera.far

						state.pointShadow[pointLength] = shadowUniforms
						state.pointShadowMap[pointLength] = shadowMap
						state.pointShadowMatrix[pointLength] = light.shadow.matrix

						numPointShadows++
					}

					state.point[pointLength] = uniforms

					pointLength++
				} else if (light.isHemisphereLight) {
					const uniforms = cache.get(light)

					uniforms.skyColor.copy(light.color).multiplyScalar(intensity)
					uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity)

					state.hemi[hemiLength] = uniforms

					hemiLength++
				}
			}

			if (rectAreaLength > 0) {
				if (capabilities.isWebGL2) {
					// WebGL 2

					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2
				} else {
					// WebGL 1

					if (extensions.has('OES_texture_float_linear') === true) {
						state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1
						state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2
					} else if (extensions.has('OES_texture_half_float_linear') === true) {
						state.rectAreaLTC1 = UniformsLib.LTC_HALF_1
						state.rectAreaLTC2 = UniformsLib.LTC_HALF_2
					} else {
						console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.')
					}
				}
			}

			state.ambient[0] = r
			state.ambient[1] = g
			state.ambient[2] = b

			const hash = state.hash

			if (
				hash.directionalLength !== directionalLength ||
				hash.pointLength !== pointLength ||
				hash.spotLength !== spotLength ||
				hash.rectAreaLength !== rectAreaLength ||
				hash.hemiLength !== hemiLength ||
				hash.numDirectionalShadows !== numDirectionalShadows ||
				hash.numPointShadows !== numPointShadows ||
				hash.numSpotShadows !== numSpotShadows
			) {
				state.directional.length = directionalLength
				state.spot.length = spotLength
				state.rectArea.length = rectAreaLength
				state.point.length = pointLength
				state.hemi.length = hemiLength

				state.directionalShadow.length = numDirectionalShadows
				state.directionalShadowMap.length = numDirectionalShadows
				state.pointShadow.length = numPointShadows
				state.pointShadowMap.length = numPointShadows
				state.spotShadow.length = numSpotShadows
				state.spotShadowMap.length = numSpotShadows
				state.directionalShadowMatrix.length = numDirectionalShadows
				state.pointShadowMatrix.length = numPointShadows
				state.spotShadowMatrix.length = numSpotShadows

				hash.directionalLength = directionalLength
				hash.pointLength = pointLength
				hash.spotLength = spotLength
				hash.rectAreaLength = rectAreaLength
				hash.hemiLength = hemiLength

				hash.numDirectionalShadows = numDirectionalShadows
				hash.numPointShadows = numPointShadows
				hash.numSpotShadows = numSpotShadows

				state.version = nextVersion++
			}
		}

		function setupView (lights, camera) {
			let directionalLength = 0
			let pointLength = 0
			let spotLength = 0
			let rectAreaLength = 0
			let hemiLength = 0

			const viewMatrix = camera.matrixWorldInverse

			for (let i = 0, l = lights.length; i < l; i++) {
				const light = lights[i]

				if (light.isDirectionalLight) {
					const uniforms = state.directional[directionalLength]

					uniforms.direction.setFromMatrixPosition(light.matrixWorld)
					vector3.setFromMatrixPosition(light.target.matrixWorld)
					uniforms.direction.sub(vector3)
					uniforms.direction.transformDirection(viewMatrix)

					directionalLength++
				} else if (light.isSpotLight) {
					const uniforms = state.spot[spotLength]

					uniforms.position.setFromMatrixPosition(light.matrixWorld)
					uniforms.position.applyMatrix4(viewMatrix)

					uniforms.direction.setFromMatrixPosition(light.matrixWorld)
					vector3.setFromMatrixPosition(light.target.matrixWorld)
					uniforms.direction.sub(vector3)
					uniforms.direction.transformDirection(viewMatrix)

					spotLength++
				} else if (light.isRectAreaLight) {
					const uniforms = state.rectArea[rectAreaLength]

					uniforms.position.setFromMatrixPosition(light.matrixWorld)
					uniforms.position.applyMatrix4(viewMatrix)

					// extract local rotation of light to derive width/height half vectors
					matrix42.identity()
					matrix4.copy(light.matrixWorld)
					matrix4.premultiply(viewMatrix)
					matrix42.extractRotation(matrix4)

					uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0)
					uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0)

					uniforms.halfWidth.applyMatrix4(matrix42)
					uniforms.halfHeight.applyMatrix4(matrix42)

					rectAreaLength++
				} else if (light.isPointLight) {
					const uniforms = state.point[pointLength]

					uniforms.position.setFromMatrixPosition(light.matrixWorld)
					uniforms.position.applyMatrix4(viewMatrix)

					pointLength++
				} else if (light.isHemisphereLight) {
					const uniforms = state.hemi[hemiLength]

					uniforms.direction.setFromMatrixPosition(light.matrixWorld)
					uniforms.direction.transformDirection(viewMatrix)
					uniforms.direction.normalize()

					hemiLength++
				}
			}
		}

		return {
			setup: setup,
			setupView: setupView,
			state: state
		}
	}

	function WebGLRenderState (extensions, capabilities) {

		const lights = new WebGLLights(extensions, capabilities)

		const lightsArray = []
		const shadowsArray = []

		function init () {

			lightsArray.length = 0
			shadowsArray.length = 0

		}

		function pushLight (light) {

			lightsArray.push(light)

		}

		function pushShadow (shadowLight) {

			shadowsArray.push(shadowLight)

		}

		function setupLights () {

			lights.setup(lightsArray)

		}

		function setupLightsView (camera) {

			lights.setupView(lightsArray, camera)

		}

		const state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,

			lights: lights
		}

		return {
			init: init,
			state: state,
			setupLights: setupLights,
			setupLightsView: setupLightsView,

			pushLight: pushLight,
			pushShadow: pushShadow
		}

	}

	function WebGLRenderStates (extensions, capabilities) {

		let renderStates = new WeakMap()

		function get (scene, renderCallDepth = 0) {

			let renderState

			if (renderStates.has(scene) === false) {

				renderState = new WebGLRenderState(extensions, capabilities)
				renderStates.set(scene, [renderState])

			} else {

				if (renderCallDepth >= renderStates.get(scene).length) {

					renderState = new WebGLRenderState(extensions, capabilities)
					renderStates.get(scene).push(renderState)

				} else {

					renderState = renderStates.get(scene)[renderCallDepth]

				}

			}

			return renderState

		}

		function dispose () {

			renderStates = new WeakMap()

		}

		return {
			get: get,
			dispose: dispose
		}

	}

	var vsm_frag = /* glsl */`
uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;

#include <packing>

void main() {

	float mean = 0.0;
	float squared_mean = 0.0;

	// This seems totally useless but it's a crazy work around for a Adreno compiler bug
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );

	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {

		#ifdef HORIZONTAL_PASS

			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;

		#else

			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;

		#endif

	}

	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;

	float std_dev = sqrt( squared_mean - mean * mean );

	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );

}
`

	var vsm_vert = /* glsl */`
void main() {

	gl_Position = vec4( position, 1.0 );

}
`

	function WebGLShadowMap (_renderer, _objects, _capabilities) {
		let _frustum = new Frustum()

		const _shadowMapSize = new Vector2(),
			_viewportSize = new Vector2(),
			_viewport = new Vector4(),
			_depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
			_distanceMaterial = new MeshDistanceMaterial(),
			_materialCache = {},
			_maxTextureSize = _capabilities.maxTextureSize

		const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide }

		const shadowMaterialVertical = new ShaderMaterial({
			defines: {
				SAMPLE_RATE: 2.0 / 8.0,
				HALF_SAMPLE_RATE: 1.0 / 8.0
			},

			uniforms: {
				shadow_pass: { value: null },
				resolution: { value: new Vector2() },
				radius: { value: 4.0 }
			},

			vertexShader: vsm_vert,

			fragmentShader: vsm_frag
		})

		const shadowMaterialHorizontal = shadowMaterialVertical.clone()
		shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1

		const fullScreenTri = new BufferGeometry()
		fullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3))

		const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical)

		const scope = this

		this.enabled = false

		this.autoUpdate = true
		this.needsUpdate = false

		this.type = PCFShadowMap

		this.render = function (lights, scene, camera) {
			if (scope.enabled === false) return
			if (scope.autoUpdate === false && scope.needsUpdate === false) return

			if (lights.length === 0) return

			const currentRenderTarget = _renderer.getRenderTarget()
			const activeCubeFace = _renderer.getActiveCubeFace()
			const activeMipmapLevel = _renderer.getActiveMipmapLevel()

			const _state = _renderer.state

			// Set GL state for depth map.
			_state.setBlending(NoBlending)
			_state.buffers.color.setClear(1, 1, 1, 1)
			_state.buffers.depth.setTest(true)
			_state.setScissorTest(false)

			// render depth map

			for (let i = 0, il = lights.length; i < il; i++) {
				const light = lights[i]
				const shadow = light.shadow

				if (shadow === undefined) {
					console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.')
					continue
				}

				if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue

				_shadowMapSize.copy(shadow.mapSize)

				const shadowFrameExtents = shadow.getFrameExtents()

				_shadowMapSize.multiply(shadowFrameExtents)

				_viewportSize.copy(shadow.mapSize)

				if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
					if (_shadowMapSize.x > _maxTextureSize) {
						_viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x)
						_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x
						shadow.mapSize.x = _viewportSize.x
					}

					if (_shadowMapSize.y > _maxTextureSize) {
						_viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y)
						_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y
						shadow.mapSize.y = _viewportSize.y
					}
				}

				if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
					const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat }

					shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars)
					shadow.map.texture.name = light.name + '.shadowMap'

					shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars)

					shadow.camera.updateProjectionMatrix()
				}

				if (shadow.map === null) {
					const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat }

					shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars)
					shadow.map.texture.name = light.name + '.shadowMap'

					shadow.camera.updateProjectionMatrix()
				}

				_renderer.setRenderTarget(shadow.map)
				_renderer.clear()

				const viewportCount = shadow.getViewportCount()

				for (let vp = 0; vp < viewportCount; vp++) {
					const viewport = shadow.getViewport(vp)

					_viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w)

					_state.viewport(_viewport)

					shadow.updateMatrices(light, vp)

					_frustum = shadow.getFrustum()

					renderObject(scene, camera, shadow.camera, light, this.type)
				}

				// do blur pass for VSM

				if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
					VSMPass(shadow, camera)
				}

				shadow.needsUpdate = false
			}

			scope.needsUpdate = false

			_renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel)
		}

		function VSMPass (shadow, camera) {
			const geometry = _objects.update(fullScreenMesh)

			// vertical pass

			shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture
			shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize
			shadowMaterialVertical.uniforms.radius.value = shadow.radius
			_renderer.setRenderTarget(shadow.mapPass)
			_renderer.clear()
			_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null)

			// horizontal pass

			shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture
			shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize
			shadowMaterialHorizontal.uniforms.radius.value = shadow.radius
			_renderer.setRenderTarget(shadow.map)
			_renderer.clear()
			_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null)
		}

		function getDepthMaterial (object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
			let result = null

			const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial

			if (customMaterial !== undefined) {
				result = customMaterial
			} else {
				result = light.isPointLight === true ? _distanceMaterial : _depthMaterial
			}

			if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
				// in this case we need a unique material instance reflecting the
				// appropriate state

				const keyA = result.uuid,
					keyB = material.uuid

				let materialsForVariant = _materialCache[keyA]

				if (materialsForVariant === undefined) {
					materialsForVariant = {}
					_materialCache[keyA] = materialsForVariant
				}

				let cachedMaterial = materialsForVariant[keyB]

				if (cachedMaterial === undefined) {
					cachedMaterial = result.clone()
					materialsForVariant[keyB] = cachedMaterial
				}

				result = cachedMaterial
			}

			result.visible = material.visible
			result.wireframe = material.wireframe

			if (type === VSMShadowMap) {
				result.side = material.shadowSide !== null ? material.shadowSide : material.side
			} else {
				result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side]
			}

			result.clipShadows = material.clipShadows
			result.clippingPlanes = material.clippingPlanes
			result.clipIntersection = material.clipIntersection

			result.wireframeLinewidth = material.wireframeLinewidth
			result.linewidth = material.linewidth

			if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
				result.referencePosition.setFromMatrixPosition(light.matrixWorld)
				result.nearDistance = shadowCameraNear
				result.farDistance = shadowCameraFar
			}

			return result
		}

		function renderObject (object, camera, shadowCamera, light, type) {
			if (object.visible === false) return

			const visible = object.layers.test(camera.layers)

			if (visible && (object.isMesh || object.isLine || object.isPoints)) {
				if ((object.castShadow || (object.receiveShadow && type === VSMShadowMap)) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
					object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld)

					const geometry = _objects.update(object)
					const material = object.material

					if (Array.isArray(material)) {
						const groups = geometry.groups

						for (let k = 0, kl = groups.length; k < kl; k++) {
							const group = groups[k]
							const groupMaterial = material[group.materialIndex]

							if (groupMaterial && groupMaterial.visible) {
								const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type)

								_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group)
							}
						}
					} else if (material.visible) {
						const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type)

						_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null)
					}
				}
			}

			const children = object.children

			for (let i = 0, l = children.length; i < l; i++) {
				renderObject(children[i], camera, shadowCamera, light, type)
			}
		}
	}

	function WebGLState (gl, extensions, capabilities) {
		const isWebGL2 = capabilities.isWebGL2

		function ColorBuffer () {
			let locked = false

			const color = new Vector4()
			let currentColorMask = null
			const currentColorClear = new Vector4(0, 0, 0, 0)

			return {
				setMask: function (colorMask) {
					if (currentColorMask !== colorMask && !locked) {
						gl.colorMask(colorMask, colorMask, colorMask, colorMask)
						currentColorMask = colorMask
					}
				},

				setLocked: function (lock) {
					locked = lock
				},

				setClear: function (r, g, b, a, premultipliedAlpha) {
					if (premultipliedAlpha === true) {
						r *= a
						g *= a
						b *= a
					}

					color.set(r, g, b, a)

					if (currentColorClear.equals(color) === false) {
						gl.clearColor(r, g, b, a)
						currentColorClear.copy(color)
					}
				},

				reset: function () {
					locked = false

					currentColorMask = null
					currentColorClear.set(-1, 0, 0, 0) // set to invalid state
				}
			}
		}

		function DepthBuffer () {
			let locked = false

			let currentDepthMask = null
			let currentDepthFunc = null
			let currentDepthClear = null

			return {
				setTest: function (depthTest) {
					if (depthTest) {
						enable(gl.DEPTH_TEST)
					} else {
						disable(gl.DEPTH_TEST)
					}
				},

				setMask: function (depthMask) {
					if (currentDepthMask !== depthMask && !locked) {
						gl.depthMask(depthMask)
						currentDepthMask = depthMask
					}
				},

				setFunc: function (depthFunc) {
					if (currentDepthFunc !== depthFunc) {
						if (depthFunc) {
							switch (depthFunc) {
								case NeverDepth:
									gl.depthFunc(gl.NEVER)
									break

								case AlwaysDepth:
									gl.depthFunc(gl.ALWAYS)
									break

								case LessDepth:
									gl.depthFunc(gl.LESS)
									break

								case LessEqualDepth:
									gl.depthFunc(gl.LEQUAL)
									break

								case EqualDepth:
									gl.depthFunc(gl.EQUAL)
									break

								case GreaterEqualDepth:
									gl.depthFunc(gl.GEQUAL)
									break

								case GreaterDepth:
									gl.depthFunc(gl.GREATER)
									break

								case NotEqualDepth:
									gl.depthFunc(gl.NOTEQUAL)
									break

								default:
									gl.depthFunc(gl.LEQUAL)
							}
						} else {
							gl.depthFunc(gl.LEQUAL)
						}

						currentDepthFunc = depthFunc
					}
				},

				setLocked: function (lock) {
					locked = lock
				},

				setClear: function (depth) {
					if (currentDepthClear !== depth) {
						gl.clearDepth(depth)
						currentDepthClear = depth
					}
				},

				reset: function () {
					locked = false

					currentDepthMask = null
					currentDepthFunc = null
					currentDepthClear = null
				}
			}
		}

		function StencilBuffer () {
			let locked = false

			let currentStencilMask = null
			let currentStencilFunc = null
			let currentStencilRef = null
			let currentStencilFuncMask = null
			let currentStencilFail = null
			let currentStencilZFail = null
			let currentStencilZPass = null
			let currentStencilClear = null

			return {
				setTest: function (stencilTest) {
					if (!locked) {
						if (stencilTest) {
							enable(gl.STENCIL_TEST)
						} else {
							disable(gl.STENCIL_TEST)
						}
					}
				},

				setMask: function (stencilMask) {
					if (currentStencilMask !== stencilMask && !locked) {
						gl.stencilMask(stencilMask)
						currentStencilMask = stencilMask
					}
				},

				setFunc: function (stencilFunc, stencilRef, stencilMask) {
					if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
						gl.stencilFunc(stencilFunc, stencilRef, stencilMask)

						currentStencilFunc = stencilFunc
						currentStencilRef = stencilRef
						currentStencilFuncMask = stencilMask
					}
				},

				setOp: function (stencilFail, stencilZFail, stencilZPass) {
					if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
						gl.stencilOp(stencilFail, stencilZFail, stencilZPass)

						currentStencilFail = stencilFail
						currentStencilZFail = stencilZFail
						currentStencilZPass = stencilZPass
					}
				},

				setLocked: function (lock) {
					locked = lock
				},

				setClear: function (stencil) {
					if (currentStencilClear !== stencil) {
						gl.clearStencil(stencil)
						currentStencilClear = stencil
					}
				},

				reset: function () {
					locked = false

					currentStencilMask = null
					currentStencilFunc = null
					currentStencilRef = null
					currentStencilFuncMask = null
					currentStencilFail = null
					currentStencilZFail = null
					currentStencilZPass = null
					currentStencilClear = null
				}
			}
		}

		//

		const colorBuffer = new ColorBuffer()
		const depthBuffer = new DepthBuffer()
		const stencilBuffer = new StencilBuffer()

		let enabledCapabilities = {}

		let xrFramebuffer = null
		let currentBoundFramebuffers = {}

		let currentProgram = null

		let currentBlendingEnabled = false
		let currentBlending = null
		let currentBlendEquation = null
		let currentBlendSrc = null
		let currentBlendDst = null
		let currentBlendEquationAlpha = null
		let currentBlendSrcAlpha = null
		let currentBlendDstAlpha = null
		let currentPremultipledAlpha = false

		let currentFlipSided = null
		let currentCullFace = null

		let currentLineWidth = null

		let currentPolygonOffsetFactor = null
		let currentPolygonOffsetUnits = null

		const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)

		let lineWidthAvailable = false
		let version = 0
		const glVersion = gl.getParameter(gl.VERSION)

		if (glVersion.indexOf('WebGL') !== -1) {
			version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1])
			lineWidthAvailable = version >= 1.0
		} else if (glVersion.indexOf('OpenGL ES') !== -1) {
			version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1])
			lineWidthAvailable = version >= 2.0
		}

		let currentTextureSlot = null
		let currentBoundTextures = {}

		const scissorParam = gl.getParameter(gl.SCISSOR_BOX)
		const viewportParam = gl.getParameter(gl.VIEWPORT)

		const currentScissor = new Vector4().fromArray(scissorParam)
		const currentViewport = new Vector4().fromArray(viewportParam)

		function createTexture (type, target, count) {
			const data = new Uint8Array(4) // 4 is required to match default unpack alignment of 4.
			const texture = gl.createTexture()

			gl.bindTexture(type, texture)
			gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
			gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST)

			for (let i = 0; i < count; i++) {
				gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data)
			}

			return texture
		}

		const emptyTextures = {}
		emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1)
		emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6)

		// init

		colorBuffer.setClear(0, 0, 0, 1)
		depthBuffer.setClear(1)
		stencilBuffer.setClear(0)

		enable(gl.DEPTH_TEST)
		depthBuffer.setFunc(LessEqualDepth)

		setFlipSided(false)
		setCullFace(CullFaceBack)
		enable(gl.CULL_FACE)

		setBlending(NoBlending)

		//

		function enable (id) {
			if (enabledCapabilities[id] !== true) {
				gl.enable(id)
				enabledCapabilities[id] = true
			}
		}

		function disable (id) {
			if (enabledCapabilities[id] !== false) {
				gl.disable(id)
				enabledCapabilities[id] = false
			}
		}

		function bindXRFramebuffer (framebuffer) {
			if (framebuffer !== xrFramebuffer) {
				gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer)

				xrFramebuffer = framebuffer
			}
		}

		function bindFramebuffer (target, framebuffer) {
			if (framebuffer === null && xrFramebuffer !== null) framebuffer = xrFramebuffer // use active XR framebuffer if available

			if (currentBoundFramebuffers[target] !== framebuffer) {
				gl.bindFramebuffer(target, framebuffer)

				currentBoundFramebuffers[target] = framebuffer

				if (isWebGL2) {
					// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER

					if (target === gl.DRAW_FRAMEBUFFER) {
						currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer
					}

					if (target === gl.FRAMEBUFFER) {
						currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer
					}
				}

				return true
			}

			return false
		}

		function useProgram (program) {
			if (currentProgram !== program) {
				gl.useProgram(program)

				currentProgram = program

				return true
			}

			return false
		}

		const equationToGL = {
			[AddEquation]: gl.FUNC_ADD,
			[SubtractEquation]: gl.FUNC_SUBTRACT,
			[ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
		}

		if (isWebGL2) {
			equationToGL[MinEquation] = gl.MIN
			equationToGL[MaxEquation] = gl.MAX
		} else {
			const extension = extensions.get('EXT_blend_minmax')

			if (extension !== null) {
				equationToGL[MinEquation] = extension.MIN_EXT
				equationToGL[MaxEquation] = extension.MAX_EXT
			}
		}

		const factorToGL = {
			[ZeroFactor]: gl.ZERO,
			[OneFactor]: gl.ONE,
			[SrcColorFactor]: gl.SRC_COLOR,
			[SrcAlphaFactor]: gl.SRC_ALPHA,
			[SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
			[DstColorFactor]: gl.DST_COLOR,
			[DstAlphaFactor]: gl.DST_ALPHA,
			[OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
			[OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
			[OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
			[OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA
		}

		function setBlending (blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
			if (blending === NoBlending) {
				if (currentBlendingEnabled === true) {
					disable(gl.BLEND)
					currentBlendingEnabled = false
				}

				return
			}

			if (currentBlendingEnabled === false) {
				enable(gl.BLEND)
				currentBlendingEnabled = true
			}

			if (blending !== CustomBlending) {
				if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
					if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
						gl.blendEquation(gl.FUNC_ADD)

						currentBlendEquation = AddEquation
						currentBlendEquationAlpha = AddEquation
					}

					if (premultipliedAlpha) {
						switch (blending) {
							case NormalBlending:
								gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA)
								break

							case AdditiveBlending:
								gl.blendFunc(gl.ONE, gl.ONE)
								break

							case SubtractiveBlending:
								gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA)
								break

							case MultiplyBlending:
								gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA)
								break

							default:
								console.error('THREE.WebGLState: Invalid blending: ', blending)
								break
						}
					} else {
						switch (blending) {
							case NormalBlending:
								gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA)
								break

							case AdditiveBlending:
								gl.blendFunc(gl.SRC_ALPHA, gl.ONE)
								break

							case SubtractiveBlending:
								gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR)
								break

							case MultiplyBlending:
								gl.blendFunc(gl.ZERO, gl.SRC_COLOR)
								break

							default:
								console.error('THREE.WebGLState: Invalid blending: ', blending)
								break
						}
					}

					currentBlendSrc = null
					currentBlendDst = null
					currentBlendSrcAlpha = null
					currentBlendDstAlpha = null

					currentBlending = blending
					currentPremultipledAlpha = premultipliedAlpha
				}

				return
			}

			// custom blending

			blendEquationAlpha = blendEquationAlpha || blendEquation
			blendSrcAlpha = blendSrcAlpha || blendSrc
			blendDstAlpha = blendDstAlpha || blendDst

			if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
				gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha])

				currentBlendEquation = blendEquation
				currentBlendEquationAlpha = blendEquationAlpha
			}

			if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
				gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha])

				currentBlendSrc = blendSrc
				currentBlendDst = blendDst
				currentBlendSrcAlpha = blendSrcAlpha
				currentBlendDstAlpha = blendDstAlpha
			}

			currentBlending = blending
			currentPremultipledAlpha = null
		}

		function setMaterial (material, frontFaceCW) {
			material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE)

			let flipSided = material.side === BackSide
			if (frontFaceCW) flipSided = !flipSided

			setFlipSided(flipSided)

			material.blending === NormalBlending && material.transparent === false
				? setBlending(NoBlending)
				: setBlending(
					material.blending,
					material.blendEquation,
					material.blendSrc,
					material.blendDst,
					material.blendEquationAlpha,
					material.blendSrcAlpha,
					material.blendDstAlpha,
					material.premultipliedAlpha
				)

			depthBuffer.setFunc(material.depthFunc)
			depthBuffer.setTest(material.depthTest)
			depthBuffer.setMask(material.depthWrite)
			colorBuffer.setMask(material.colorWrite)

			const stencilWrite = material.stencilWrite
			stencilBuffer.setTest(stencilWrite)
			if (stencilWrite) {
				stencilBuffer.setMask(material.stencilWriteMask)
				stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask)
				stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass)
			}

			setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits)

			material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE)
		}

		//

		function setFlipSided (flipSided) {
			if (currentFlipSided !== flipSided) {
				if (flipSided) {
					gl.frontFace(gl.CW)
				} else {
					gl.frontFace(gl.CCW)
				}

				currentFlipSided = flipSided
			}
		}

		function setCullFace (cullFace) {
			if (cullFace !== CullFaceNone) {
				enable(gl.CULL_FACE)

				if (cullFace !== currentCullFace) {
					if (cullFace === CullFaceBack) {
						gl.cullFace(gl.BACK)
					} else if (cullFace === CullFaceFront) {
						gl.cullFace(gl.FRONT)
					} else {
						gl.cullFace(gl.FRONT_AND_BACK)
					}
				}
			} else {
				disable(gl.CULL_FACE)
			}

			currentCullFace = cullFace
		}

		function setLineWidth (width) {
			if (width !== currentLineWidth) {
				if (lineWidthAvailable) gl.lineWidth(width)

				currentLineWidth = width
			}
		}

		function setPolygonOffset (polygonOffset, factor, units) {
			if (polygonOffset) {
				enable(gl.POLYGON_OFFSET_FILL)

				if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
					gl.polygonOffset(factor, units)

					currentPolygonOffsetFactor = factor
					currentPolygonOffsetUnits = units
				}
			} else {
				disable(gl.POLYGON_OFFSET_FILL)
			}
		}

		function setScissorTest (scissorTest) {
			if (scissorTest) {
				enable(gl.SCISSOR_TEST)
			} else {
				disable(gl.SCISSOR_TEST)
			}
		}

		// texture

		function activeTexture (webglSlot) {
			if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1

			if (currentTextureSlot !== webglSlot) {
				gl.activeTexture(webglSlot)
				currentTextureSlot = webglSlot
			}
		}

		function bindTexture (webglType, webglTexture) {
			if (currentTextureSlot === null) {
				activeTexture()
			}

			let boundTexture = currentBoundTextures[currentTextureSlot]

			if (boundTexture === undefined) {
				boundTexture = { type: undefined, texture: undefined }
				currentBoundTextures[currentTextureSlot] = boundTexture
			}

			if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
				gl.bindTexture(webglType, webglTexture || emptyTextures[webglType])

				boundTexture.type = webglType
				boundTexture.texture = webglTexture
			}
		}

		function unbindTexture () {
			const boundTexture = currentBoundTextures[currentTextureSlot]

			if (boundTexture !== undefined && boundTexture.type !== undefined) {
				gl.bindTexture(boundTexture.type, null)

				boundTexture.type = undefined
				boundTexture.texture = undefined
			}
		}

		function compressedTexImage2D () {
			try {
				gl.compressedTexImage2D.apply(gl, arguments)
			} catch (error) {
				console.error('THREE.WebGLState:', error)
			}
		}

		function texImage2D () {
			try {
				gl.texImage2D.apply(gl, arguments)
			} catch (error) {
				console.error('THREE.WebGLState:', error)
			}
		}

		function texImage3D () {
			try {
				gl.texImage3D.apply(gl, arguments)
			} catch (error) {
				console.error('THREE.WebGLState:', error)
			}
		}

		//

		function scissor (scissor) {
			if (currentScissor.equals(scissor) === false) {
				gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w)
				currentScissor.copy(scissor)
			}
		}

		function viewport (viewport) {
			if (currentViewport.equals(viewport) === false) {
				gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w)
				currentViewport.copy(viewport)
			}
		}

		//

		function reset () {
			// reset state

			gl.disable(gl.BLEND)
			gl.disable(gl.CULL_FACE)
			gl.disable(gl.DEPTH_TEST)
			gl.disable(gl.POLYGON_OFFSET_FILL)
			gl.disable(gl.SCISSOR_TEST)
			gl.disable(gl.STENCIL_TEST)
			gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE)

			gl.blendEquation(gl.FUNC_ADD)
			gl.blendFunc(gl.ONE, gl.ZERO)
			gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO)

			gl.colorMask(true, true, true, true)
			gl.clearColor(0, 0, 0, 0)

			gl.depthMask(true)
			gl.depthFunc(gl.LESS)
			gl.clearDepth(1)

			gl.stencilMask(0xffffffff)
			gl.stencilFunc(gl.ALWAYS, 0, 0xffffffff)
			gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP)
			gl.clearStencil(0)

			gl.cullFace(gl.BACK)
			gl.frontFace(gl.CCW)

			gl.polygonOffset(0, 0)

			gl.activeTexture(gl.TEXTURE0)

			gl.bindFramebuffer(gl.FRAMEBUFFER, null)

			if (isWebGL2 === true) {
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null)
				gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null)
			}

			gl.useProgram(null)

			gl.lineWidth(1)

			gl.scissor(0, 0, gl.canvas.width, gl.canvas.height)
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)

			// reset internals

			enabledCapabilities = {}

			currentTextureSlot = null
			currentBoundTextures = {}

			xrFramebuffer = null
			currentBoundFramebuffers = {}

			currentProgram = null

			currentBlendingEnabled = false
			currentBlending = null
			currentBlendEquation = null
			currentBlendSrc = null
			currentBlendDst = null
			currentBlendEquationAlpha = null
			currentBlendSrcAlpha = null
			currentBlendDstAlpha = null
			currentPremultipledAlpha = false

			currentFlipSided = null
			currentCullFace = null

			currentLineWidth = null

			currentPolygonOffsetFactor = null
			currentPolygonOffsetUnits = null

			currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height)
			currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height)

			colorBuffer.reset()
			depthBuffer.reset()
			stencilBuffer.reset()
		}

		return {
			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},

			enable: enable,
			disable: disable,

			bindFramebuffer: bindFramebuffer,
			bindXRFramebuffer: bindXRFramebuffer,

			useProgram: useProgram,

			setBlending: setBlending,
			setMaterial: setMaterial,

			setFlipSided: setFlipSided,
			setCullFace: setCullFace,

			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,

			setScissorTest: setScissorTest,

			activeTexture: activeTexture,
			bindTexture: bindTexture,
			unbindTexture: unbindTexture,
			compressedTexImage2D: compressedTexImage2D,
			texImage2D: texImage2D,
			texImage3D: texImage3D,

			scissor: scissor,
			viewport: viewport,

			reset: reset
		}
	}

	for (let i = 0; i < 256; i++) {

		(i < 16 ? '0' : '') + (i).toString(16)

	}

	function isPowerOfTwo (value) {

		return (value & (value - 1)) === 0 && value !== 0

	}

	function floorPowerOfTwo (value) {

		return Math.pow(2, Math.floor(Math.log(value) / Math.LN2))

	}

	function WebGLTextures (_gl, extensions, state, properties, capabilities, utils, info) {
		const isWebGL2 = capabilities.isWebGL2
		const maxTextures = capabilities.maxTextures
		const maxCubemapSize = capabilities.maxCubemapSize
		const maxTextureSize = capabilities.maxTextureSize
		const maxSamples = capabilities.maxSamples

		const _videoTextures = new WeakMap()
		let _canvas

		// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
		// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
		// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

		let useOffscreenCanvas = false

		try {
			useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext('2d') !== null
		} catch (err) {
			// Ignore any errors
		}

		function createCanvas (width, height) {
			// Use OffscreenCanvas when available. Specially needed in web workers

			return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas')
		}

		function resizeImage (image, needsPowerOfTwo, needsNewCanvas, maxSize) {
			let scale = 1

			// handle case if texture exceeds max size

			if (image.width > maxSize || image.height > maxSize) {
				scale = maxSize / Math.max(image.width, image.height)
			}

			// only perform resize if necessary

			if (scale < 1 || needsPowerOfTwo === true) {
				// only perform resize for certain image types

				if (
					(typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) ||
					(typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement) ||
					(typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)
				) {
					const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor

					const width = floor(scale * image.width)
					const height = floor(scale * image.height)

					if (_canvas === undefined) _canvas = createCanvas(width, height)

					// cube textures can't reuse the same canvas

					const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas

					canvas.width = width
					canvas.height = height

					const context = canvas.getContext('2d')
					context.drawImage(image, 0, 0, width, height)

					console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').')

					return canvas
				} else {
					if ('data' in image) {
						console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').')
					}

					return image
				}
			}

			return image
		}

		function isPowerOfTwo$1 (image) {
			return isPowerOfTwo(image.width) && isPowerOfTwo(image.height)
		}

		function textureNeedsPowerOfTwo (texture) {
			if (isWebGL2) return false

			return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter)
		}

		function textureNeedsGenerateMipmaps (texture, supportsMips) {
			return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter
		}

		function generateMipmap (target, texture, width, height, depth = 1) {
			_gl.generateMipmap(target)

			const textureProperties = properties.get(texture)

			textureProperties.__maxMipLevel = Math.log2(Math.max(width, height, depth))
		}

		function getInternalFormat (internalFormatName, glFormat, glType) {
			if (isWebGL2 === false) return glFormat

			if (internalFormatName !== null) {
				if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName]

				console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'")
			}

			let internalFormat = glFormat

			if (glFormat === _gl.RED) {
				if (glType === _gl.FLOAT) internalFormat = _gl.R32F
				if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F
				if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8
			}

			if (glFormat === _gl.RGB) {
				if (glType === _gl.FLOAT) internalFormat = _gl.RGB32F
				if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGB16F
				if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8
			}

			if (glFormat === _gl.RGBA) {
				if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F
				if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F
				if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGBA8
			}

			if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
				extensions.get('EXT_color_buffer_float')
			}

			return internalFormat
		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback (f) {
			if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
				return _gl.NEAREST
			}

			return _gl.LINEAR
		}

		//

		function onTextureDispose (event) {
			const texture = event.target

			texture.removeEventListener('dispose', onTextureDispose)

			deallocateTexture(texture)

			if (texture.isVideoTexture) {
				_videoTextures.delete(texture)
			}

			info.memory.textures--
		}

		function onRenderTargetDispose (event) {
			const renderTarget = event.target

			renderTarget.removeEventListener('dispose', onRenderTargetDispose)

			deallocateRenderTarget(renderTarget)
		}

		//

		function deallocateTexture (texture) {
			const textureProperties = properties.get(texture)

			if (textureProperties.__webglInit === undefined) return

			_gl.deleteTexture(textureProperties.__webglTexture)

			properties.remove(texture)
		}

		function deallocateRenderTarget (renderTarget) {
			const texture = renderTarget.texture

			const renderTargetProperties = properties.get(renderTarget)
			const textureProperties = properties.get(texture)

			if (!renderTarget) return

			if (textureProperties.__webglTexture !== undefined) {
				_gl.deleteTexture(textureProperties.__webglTexture)

				info.memory.textures--
			}

			if (renderTarget.depthTexture) {
				renderTarget.depthTexture.dispose()
			}

			if (renderTarget.isWebGLCubeRenderTarget) {
				for (let i = 0; i < 6; i++) {
					_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i])
					if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i])
				}
			} else {
				_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer)
				if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer)
				if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer)
				if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer)
				if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer)
			}

			if (renderTarget.isWebGLMultipleRenderTargets) {
				for (let i = 0, il = texture.length; i < il; i++) {
					const attachmentProperties = properties.get(texture[i])

					if (attachmentProperties.__webglTexture) {
						_gl.deleteTexture(attachmentProperties.__webglTexture)

						info.memory.textures--
					}

					properties.remove(texture[i])
				}
			}

			properties.remove(texture)
			properties.remove(renderTarget)
		}

		//

		let textureUnits = 0

		function resetTextureUnits () {
			textureUnits = 0
		}

		function allocateTextureUnit () {
			const textureUnit = textureUnits

			if (textureUnit >= maxTextures) {
				console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures)
			}

			textureUnits += 1

			return textureUnit
		}

		//

		function setTexture2D (texture, slot) {
			const textureProperties = properties.get(texture)

			if (texture.isVideoTexture) updateVideoTexture(texture)

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				const image = texture.image

				if (image === undefined) {
					console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined')
				} else if (image.complete === false) {
					console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete')
				} else {
					uploadTexture(textureProperties, texture, slot)
					return
				}
			}

			state.activeTexture(_gl.TEXTURE0 + slot)
			state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture)
		}

		function setTexture2DArray (texture, slot) {
			const textureProperties = properties.get(texture)

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadTexture(textureProperties, texture, slot)
				return
			}

			state.activeTexture(_gl.TEXTURE0 + slot)
			state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture)
		}

		function setTexture3D (texture, slot) {
			const textureProperties = properties.get(texture)

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadTexture(textureProperties, texture, slot)
				return
			}

			state.activeTexture(_gl.TEXTURE0 + slot)
			state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture)
		}

		function setTextureCube (texture, slot) {
			const textureProperties = properties.get(texture)

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadCubeTexture(textureProperties, texture, slot)
				return
			}

			state.activeTexture(_gl.TEXTURE0 + slot)
			state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture)
		}

		const wrappingToGL = {
			[RepeatWrapping]: _gl.REPEAT,
			[ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
			[MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
		}

		const filterToGL = {
			[NearestFilter]: _gl.NEAREST,
			[NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
			[NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,

			[LinearFilter]: _gl.LINEAR,
			[LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
			[LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
		}

		function setTextureParameters (textureType, texture, supportsMips) {
			if (supportsMips) {
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS])
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT])

				if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
					_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR])
				}

				_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter])
				_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter])
			} else {
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE)
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE)

				if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
					_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE)
				}

				if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
					console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.')
				}

				_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter))
				_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter))

				if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
					console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.')
				}
			}

			if (extensions.has('EXT_texture_filter_anisotropic') === true) {
				const extension = extensions.get('EXT_texture_filter_anisotropic')

				if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return // verify extension for WebGL 1 and WebGL 2
				if (isWebGL2 === false && texture.type === HalfFloatType && extensions.has('OES_texture_half_float_linear') === false) return // verify extension for WebGL 1 only

				if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
					_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()))
					properties.get(texture).__currentAnisotropy = texture.anisotropy
				}
			}
		}

		function initTexture (textureProperties, texture) {
			if (textureProperties.__webglInit === undefined) {
				textureProperties.__webglInit = true

				texture.addEventListener('dispose', onTextureDispose)

				textureProperties.__webglTexture = _gl.createTexture()

				info.memory.textures++
			}
		}

		function uploadTexture (textureProperties, texture, slot) {
			let textureType = _gl.TEXTURE_2D

			if (texture.isDataTexture2DArray) textureType = _gl.TEXTURE_2D_ARRAY
			if (texture.isDataTexture3D) textureType = _gl.TEXTURE_3D

			initTexture(textureProperties, texture)

			state.activeTexture(_gl.TEXTURE0 + slot)
			state.bindTexture(textureType, textureProperties.__webglTexture)

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY)
			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha)
			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment)
			_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE)

			const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false
			const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize)

			const supportsMips = isPowerOfTwo$1(image) || isWebGL2,
				glFormat = utils.convert(texture.format)

			let glType = utils.convert(texture.type),
				glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType)

			setTextureParameters(textureType, texture, supportsMips)

			let mipmap
			const mipmaps = texture.mipmaps

			if (texture.isDepthTexture) {
				// populate depth texture with dummy data

				glInternalFormat = _gl.DEPTH_COMPONENT

				if (isWebGL2) {
					if (texture.type === FloatType) {
						glInternalFormat = _gl.DEPTH_COMPONENT32F
					} else if (texture.type === UnsignedIntType) {
						glInternalFormat = _gl.DEPTH_COMPONENT24
					} else if (texture.type === UnsignedInt248Type) {
						glInternalFormat = _gl.DEPTH24_STENCIL8
					} else {
						glInternalFormat = _gl.DEPTH_COMPONENT16 // WebGL2 requires sized internalformat for glTexImage2D
					}
				} else {
					if (texture.type === FloatType) {
						console.error('WebGLRenderer: Floating point depth texture requires WebGL2.')
					}
				}

				// validation checks for WebGL 1

				if (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
						console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.')

						texture.type = UnsignedShortType
						glType = utils.convert(texture.type)
					}
				}

				if (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					glInternalFormat = _gl.DEPTH_STENCIL

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if (texture.type !== UnsignedInt248Type) {
						console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.')

						texture.type = UnsignedInt248Type
						glType = utils.convert(texture.type)
					}
				}

				//

				state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null)
			} else if (texture.isDataTexture) {
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if (mipmaps.length > 0 && supportsMips) {
					for (let i = 0, il = mipmaps.length; i < il; i++) {
						mipmap = mipmaps[i]
						state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data)
					}

					texture.generateMipmaps = false
					textureProperties.__maxMipLevel = mipmaps.length - 1
				} else {
					state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data)
					textureProperties.__maxMipLevel = 0
				}
			} else if (texture.isCompressedTexture) {
				for (let i = 0, il = mipmaps.length; i < il; i++) {
					mipmap = mipmaps[i]

					if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
						if (glFormat !== null) {
							state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data)
						} else {
							console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()')
						}
					} else {
						state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data)
					}
				}

				textureProperties.__maxMipLevel = mipmaps.length - 1
			} else if (texture.isDataTexture2DArray) {
				state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data)
				textureProperties.__maxMipLevel = 0
			} else if (texture.isDataTexture3D) {
				state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data)
				textureProperties.__maxMipLevel = 0
			} else {
				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if (mipmaps.length > 0 && supportsMips) {
					for (let i = 0, il = mipmaps.length; i < il; i++) {
						mipmap = mipmaps[i]
						state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap)
					}

					texture.generateMipmaps = false
					textureProperties.__maxMipLevel = mipmaps.length - 1
				} else {
					state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image)
					textureProperties.__maxMipLevel = 0
				}
			}

			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				generateMipmap(textureType, texture, image.width, image.height)
			}

			textureProperties.__version = texture.version

			if (texture.onUpdate) texture.onUpdate(texture)
		}

		function uploadCubeTexture (textureProperties, texture, slot) {
			if (texture.image.length !== 6) return

			initTexture(textureProperties, texture)

			state.activeTexture(_gl.TEXTURE0 + slot)
			state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture)

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY)
			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha)
			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment)
			_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE)

			const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture)
			const isDataTexture = texture.image[0] && texture.image[0].isDataTexture

			const cubeImage = []

			for (let i = 0; i < 6; i++) {
				if (!isCompressed && !isDataTexture) {
					cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize)
				} else {
					cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i]
				}
			}

			const image = cubeImage[0],
				supportsMips = isPowerOfTwo$1(image) || isWebGL2,
				glFormat = utils.convert(texture.format),
				glType = utils.convert(texture.type),
				glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType)

			setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips)

			let mipmaps

			if (isCompressed) {
				for (let i = 0; i < 6; i++) {
					mipmaps = cubeImage[i].mipmaps

					for (let j = 0; j < mipmaps.length; j++) {
						const mipmap = mipmaps[j]

						if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
							if (glFormat !== null) {
								state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data)
							} else {
								console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()')
							}
						} else {
							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data)
						}
					}
				}

				textureProperties.__maxMipLevel = mipmaps.length - 1
			} else {
				mipmaps = texture.mipmaps

				for (let i = 0; i < 6; i++) {
					if (isDataTexture) {
						state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data)

						for (let j = 0; j < mipmaps.length; j++) {
							const mipmap = mipmaps[j]
							const mipmapImage = mipmap.image[i].image

							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data)
						}
					} else {
						state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i])

						for (let j = 0; j < mipmaps.length; j++) {
							const mipmap = mipmaps[j]

							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i])
						}
					}
				}

				textureProperties.__maxMipLevel = mipmaps.length
			}

			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				// We assume images for cube map have the same size.
				generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, image.width, image.height)
			}

			textureProperties.__version = texture.version

			if (texture.onUpdate) texture.onUpdate(texture)
		}

		// Render targets

		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture (framebuffer, renderTarget, texture, attachment, textureTarget) {
			const glFormat = utils.convert(texture.format)
			const glType = utils.convert(texture.type)
			const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType)

			if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
				state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null)
			} else {
				state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null)
			}

			state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer)
			_gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0)
			state.bindFramebuffer(_gl.FRAMEBUFFER, null)
		}

		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage (renderbuffer, renderTarget, isMultisample) {
			_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer)

			if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
				let glInternalFormat = _gl.DEPTH_COMPONENT16

				if (isMultisample) {
					const depthTexture = renderTarget.depthTexture

					if (depthTexture && depthTexture.isDepthTexture) {
						if (depthTexture.type === FloatType) {
							glInternalFormat = _gl.DEPTH_COMPONENT32F
						} else if (depthTexture.type === UnsignedIntType) {
							glInternalFormat = _gl.DEPTH_COMPONENT24
						}
					}

					const samples = getRenderTargetSamples(renderTarget)

					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height)
				} else {
					_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height)
				}

				_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer)
			} else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
				if (isMultisample) {
					const samples = getRenderTargetSamples(renderTarget)

					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height)
				} else {
					_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height)
				}

				_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer)
			} else {
				// Use the first texture for MRT so far
				const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture

				const glFormat = utils.convert(texture.format)
				const glType = utils.convert(texture.type)
				const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType)

				if (isMultisample) {
					const samples = getRenderTargetSamples(renderTarget)

					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height)
				} else {
					_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height)
				}
			}

			_gl.bindRenderbuffer(_gl.RENDERBUFFER, null)
		}

		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture (framebuffer, renderTarget) {
			const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget
			if (isCube) throw new Error('Depth Texture with cube render targets is not supported')

			state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer)

			if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
				throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture')
			}

			// upload an empty depth texture with framebuffer size
			if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
				renderTarget.depthTexture.image.width = renderTarget.width
				renderTarget.depthTexture.image.height = renderTarget.height
				renderTarget.depthTexture.needsUpdate = true
			}

			setTexture2D(renderTarget.depthTexture, 0)

			const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture

			if (renderTarget.depthTexture.format === DepthFormat) {
				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0)
			} else if (renderTarget.depthTexture.format === DepthStencilFormat) {
				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0)
			} else {
				throw new Error('Unknown depthTexture format')
			}
		}

		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer (renderTarget) {
			const renderTargetProperties = properties.get(renderTarget)

			const isCube = renderTarget.isWebGLCubeRenderTarget === true

			if (renderTarget.depthTexture) {
				if (isCube) throw new Error('target.depthTexture not supported in Cube render targets')

				setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget)
			} else {
				if (isCube) {
					renderTargetProperties.__webglDepthbuffer = []

					for (let i = 0; i < 6; i++) {
						state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i])
						renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer()
						setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false)
					}
				} else {
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer)
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer()
					setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false)
				}
			}

			state.bindFramebuffer(_gl.FRAMEBUFFER, null)
		}

		// Set up GL resources for the render target
		function setupRenderTarget (renderTarget) {
			const texture = renderTarget.texture

			const renderTargetProperties = properties.get(renderTarget)
			const textureProperties = properties.get(texture)

			renderTarget.addEventListener('dispose', onRenderTargetDispose)

			if (renderTarget.isWebGLMultipleRenderTargets !== true) {
				textureProperties.__webglTexture = _gl.createTexture()
				textureProperties.__version = texture.version
				info.memory.textures++
			}

			const isCube = renderTarget.isWebGLCubeRenderTarget === true
			const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true
			const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true
			const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray
			const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2

			// Handles WebGL2 RGBFormat fallback - #18858

			if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
				texture.format = RGBAFormat

				console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.')
			}

			// Setup framebuffer

			if (isCube) {
				renderTargetProperties.__webglFramebuffer = []

				for (let i = 0; i < 6; i++) {
					renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer()
				}
			} else {
				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer()

				if (isMultipleRenderTargets) {
					if (capabilities.drawBuffers) {
						const textures = renderTarget.texture

						for (let i = 0, il = textures.length; i < il; i++) {
							const attachmentProperties = properties.get(textures[i])

							if (attachmentProperties.__webglTexture === undefined) {
								attachmentProperties.__webglTexture = _gl.createTexture()

								info.memory.textures++
							}
						}
					} else {
						console.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.')
					}
				} else if (isMultisample) {
					if (isWebGL2) {
						renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer()
						renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer()

						_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer)

						const glFormat = utils.convert(texture.format)
						const glType = utils.convert(texture.type)
						const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType)
						const samples = getRenderTargetSamples(renderTarget)
						_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height)

						state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer)
						_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer)
						_gl.bindRenderbuffer(_gl.RENDERBUFFER, null)

						if (renderTarget.depthBuffer) {
							renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer()
							setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true)
						}

						state.bindFramebuffer(_gl.FRAMEBUFFER, null)
					} else {
						console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.')
					}
				}
			}

			// Setup color buffer

			if (isCube) {
				state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture)
				setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips)

				for (let i = 0; i < 6; i++) {
					setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i)
				}

				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, renderTarget.width, renderTarget.height)
				}

				state.bindTexture(_gl.TEXTURE_CUBE_MAP, null)
			} else if (isMultipleRenderTargets) {
				const textures = renderTarget.texture

				for (let i = 0, il = textures.length; i < il; i++) {
					const attachment = textures[i]
					const attachmentProperties = properties.get(attachment)

					state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture)
					setTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips)
					setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D)

					if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
						generateMipmap(_gl.TEXTURE_2D, attachment, renderTarget.width, renderTarget.height)
					}
				}

				state.bindTexture(_gl.TEXTURE_2D, null)
			} else {
				let glTextureType = _gl.TEXTURE_2D

				if (isRenderTarget3D) {
					// Render targets containing layers, i.e: Texture 3D and 2d arrays

					if (isWebGL2) {
						const isTexture3D = texture.isDataTexture3D
						glTextureType = isTexture3D ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY
					} else {
						console.warn('THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.')
					}
				}

				state.bindTexture(glTextureType, textureProperties.__webglTexture)
				setTextureParameters(glTextureType, texture, supportsMips)
				setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType)

				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					generateMipmap(glTextureType, texture, renderTarget.width, renderTarget.height, renderTarget.depth)
				}

				state.bindTexture(glTextureType, null)
			}

			// Setup depth and stencil buffers

			if (renderTarget.depthBuffer) {
				setupDepthRenderbuffer(renderTarget)
			}
		}

		function updateRenderTargetMipmap (renderTarget) {
			const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2

			const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture]

			for (let i = 0, il = textures.length; i < il; i++) {
				const texture = textures[i]

				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D
					const webglTexture = properties.get(texture).__webglTexture

					state.bindTexture(target, webglTexture)
					generateMipmap(target, texture, renderTarget.width, renderTarget.height)
					state.bindTexture(target, null)
				}
			}
		}

		function updateMultisampleRenderTarget (renderTarget) {
			if (renderTarget.isWebGLMultisampleRenderTarget) {
				if (isWebGL2) {
					const width = renderTarget.width
					const height = renderTarget.height
					let mask = _gl.COLOR_BUFFER_BIT

					if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT
					if (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT

					const renderTargetProperties = properties.get(renderTarget)

					state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer)
					state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer)

					_gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST)

					state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null)
					state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer)
				} else {
					console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.')
				}
			}
		}

		function getRenderTargetSamples (renderTarget) {
			return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0
		}

		function updateVideoTexture (texture) {
			const frame = info.render.frame

			// Check the last frame we updated the VideoTexture

			if (_videoTextures.get(texture) !== frame) {
				_videoTextures.set(texture, frame)
				texture.update()
			}
		}

		// backwards compatibility

		let warnedTexture2D = false
		let warnedTextureCube = false

		function safeSetTexture2D (texture, slot) {
			if (texture && texture.isWebGLRenderTarget) {
				if (warnedTexture2D === false) {
					console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.")
					warnedTexture2D = true
				}

				texture = texture.texture
			}

			setTexture2D(texture, slot)
		}

		function safeSetTextureCube (texture, slot) {
			if (texture && texture.isWebGLCubeRenderTarget) {
				if (warnedTextureCube === false) {
					console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.")
					warnedTextureCube = true
				}

				texture = texture.texture
			}

			setTextureCube(texture, slot)
		}

		//

		this.allocateTextureUnit = allocateTextureUnit
		this.resetTextureUnits = resetTextureUnits

		this.setTexture2D = setTexture2D
		this.setTexture2DArray = setTexture2DArray
		this.setTexture3D = setTexture3D
		this.setTextureCube = setTextureCube
		this.setupRenderTarget = setupRenderTarget
		this.updateRenderTargetMipmap = updateRenderTargetMipmap
		this.updateMultisampleRenderTarget = updateMultisampleRenderTarget

		this.safeSetTexture2D = safeSetTexture2D
		this.safeSetTextureCube = safeSetTextureCube
	}

	function WebGLUtils (gl, extensions, capabilities) {
		const isWebGL2 = capabilities.isWebGL2

		function convert (p) {
			let extension

			if (p === UnsignedByteType) return gl.UNSIGNED_BYTE
			if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4
			if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1
			if (p === UnsignedShort565Type) return gl.UNSIGNED_SHORT_5_6_5

			if (p === ByteType) return gl.BYTE
			if (p === ShortType) return gl.SHORT
			if (p === UnsignedShortType) return gl.UNSIGNED_SHORT
			if (p === IntType) return gl.INT
			if (p === UnsignedIntType) return gl.UNSIGNED_INT
			if (p === FloatType) return gl.FLOAT

			if (p === HalfFloatType) {
				if (isWebGL2) return gl.HALF_FLOAT

				extension = extensions.get('OES_texture_half_float')

				if (extension !== null) {
					return extension.HALF_FLOAT_OES
				} else {
					return null
				}
			}

			if (p === AlphaFormat) return gl.ALPHA
			if (p === RGBFormat) return gl.RGB
			if (p === RGBAFormat) return gl.RGBA
			if (p === LuminanceFormat) return gl.LUMINANCE
			if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA
			if (p === DepthFormat) return gl.DEPTH_COMPONENT
			if (p === DepthStencilFormat) return gl.DEPTH_STENCIL
			if (p === RedFormat) return gl.RED

			// WebGL2 formats.

			if (p === RedIntegerFormat) return gl.RED_INTEGER
			if (p === RGFormat) return gl.RG
			if (p === RGIntegerFormat) return gl.RG_INTEGER
			if (p === RGBIntegerFormat) return gl.RGB_INTEGER
			if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER

			if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
				extension = extensions.get('WEBGL_compressed_texture_s3tc')

				if (extension !== null) {
					if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT
					if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT
					if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT
					if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT
				} else {
					return null
				}
			}

			if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
				extension = extensions.get('WEBGL_compressed_texture_pvrtc')

				if (extension !== null) {
					if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
					if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG
					if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
					if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
				} else {
					return null
				}
			}

			if (p === RGB_ETC1_Format) {
				extension = extensions.get('WEBGL_compressed_texture_etc1')

				if (extension !== null) {
					return extension.COMPRESSED_RGB_ETC1_WEBGL
				} else {
					return null
				}
			}

			if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
				extension = extensions.get('WEBGL_compressed_texture_etc')

				if (extension !== null) {
					if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2
					if (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC
				}
			}

			if (
				p === RGBA_ASTC_4x4_Format ||
				p === RGBA_ASTC_5x4_Format ||
				p === RGBA_ASTC_5x5_Format ||
				p === RGBA_ASTC_6x5_Format ||
				p === RGBA_ASTC_6x6_Format ||
				p === RGBA_ASTC_8x5_Format ||
				p === RGBA_ASTC_8x6_Format ||
				p === RGBA_ASTC_8x8_Format ||
				p === RGBA_ASTC_10x5_Format ||
				p === RGBA_ASTC_10x6_Format ||
				p === RGBA_ASTC_10x8_Format ||
				p === RGBA_ASTC_10x10_Format ||
				p === RGBA_ASTC_12x10_Format ||
				p === RGBA_ASTC_12x12_Format ||
				p === SRGB8_ALPHA8_ASTC_4x4_Format ||
				p === SRGB8_ALPHA8_ASTC_5x4_Format ||
				p === SRGB8_ALPHA8_ASTC_5x5_Format ||
				p === SRGB8_ALPHA8_ASTC_6x5_Format ||
				p === SRGB8_ALPHA8_ASTC_6x6_Format ||
				p === SRGB8_ALPHA8_ASTC_8x5_Format ||
				p === SRGB8_ALPHA8_ASTC_8x6_Format ||
				p === SRGB8_ALPHA8_ASTC_8x8_Format ||
				p === SRGB8_ALPHA8_ASTC_10x5_Format ||
				p === SRGB8_ALPHA8_ASTC_10x6_Format ||
				p === SRGB8_ALPHA8_ASTC_10x8_Format ||
				p === SRGB8_ALPHA8_ASTC_10x10_Format ||
				p === SRGB8_ALPHA8_ASTC_12x10_Format ||
				p === SRGB8_ALPHA8_ASTC_12x12_Format
			) {
				extension = extensions.get('WEBGL_compressed_texture_astc')

				if (extension !== null) {
					// TODO Complete?

					return p
				} else {
					return null
				}
			}

			if (p === RGBA_BPTC_Format) {
				extension = extensions.get('EXT_texture_compression_bptc')

				if (extension !== null) {
					// TODO Complete?

					return p
				} else {
					return null
				}
			}

			if (p === UnsignedInt248Type) {
				if (isWebGL2) return gl.UNSIGNED_INT_24_8

				extension = extensions.get('WEBGL_depth_texture')

				if (extension !== null) {
					return extension.UNSIGNED_INT_24_8_WEBGL
				} else {
					return null
				}
			}
		}

		return { convert: convert }
	}

	const _moveEvent = { type: 'move' }

	class WebXRController {
		constructor() {
			this._targetRay = null
			this._grip = null
			this._hand = null
		}

		getHandSpace () {
			if (this._hand === null) {
				this._hand = new Group$1()
				this._hand.matrixAutoUpdate = false
				this._hand.visible = false

				this._hand.joints = {}
				this._hand.inputState = { pinching: false }
			}

			return this._hand
		}

		getTargetRaySpace () {
			if (this._targetRay === null) {
				this._targetRay = new Group$1()
				this._targetRay.matrixAutoUpdate = false
				this._targetRay.visible = false
				this._targetRay.hasLinearVelocity = false
				this._targetRay.linearVelocity = new Vector3()
				this._targetRay.hasAngularVelocity = false
				this._targetRay.angularVelocity = new Vector3()
			}

			return this._targetRay
		}

		getGripSpace () {
			if (this._grip === null) {
				this._grip = new Group$1()
				this._grip.matrixAutoUpdate = false
				this._grip.visible = false
				this._grip.hasLinearVelocity = false
				this._grip.linearVelocity = new Vector3()
				this._grip.hasAngularVelocity = false
				this._grip.angularVelocity = new Vector3()
			}

			return this._grip
		}

		dispatchEvent (event) {
			if (this._targetRay !== null) {
				this._targetRay.dispatchEvent(event)
			}

			if (this._grip !== null) {
				this._grip.dispatchEvent(event)
			}

			if (this._hand !== null) {
				this._hand.dispatchEvent(event)
			}

			return this
		}

		disconnect (inputSource) {
			this.dispatchEvent({ type: 'disconnected', data: inputSource })

			if (this._targetRay !== null) {
				this._targetRay.visible = false
			}

			if (this._grip !== null) {
				this._grip.visible = false
			}

			if (this._hand !== null) {
				this._hand.visible = false
			}

			return this
		}

		update (inputSource, frame, referenceSpace) {
			let inputPose = null
			let gripPose = null
			let handPose = null

			const targetRay = this._targetRay
			const grip = this._grip
			const hand = this._hand

			if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
				if (targetRay !== null) {
					inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace)

					if (inputPose !== null) {
						targetRay.matrix.fromArray(inputPose.transform.matrix)
						targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale)

						if (inputPose.linearVelocity) {
							targetRay.hasLinearVelocity = true
							targetRay.linearVelocity.copy(inputPose.linearVelocity)
						} else {
							targetRay.hasLinearVelocity = false
						}

						if (inputPose.angularVelocity) {
							targetRay.hasAngularVelocity = true
							targetRay.angularVelocity.copy(inputPose.angularVelocity)
						} else {
							targetRay.hasAngularVelocity = false
						}

						this.dispatchEvent(_moveEvent)
					}
				}

				if (hand && inputSource.hand) {
					handPose = true

					for (const inputjoint of inputSource.hand.values()) {
						// Update the joints groups with the XRJoint poses
						const jointPose = frame.getJointPose(inputjoint, referenceSpace)

						if (hand.joints[inputjoint.jointName] === undefined) {
							// The transform of this joint will be updated with the joint pose on each frame
							const joint = new Group$1()
							joint.matrixAutoUpdate = false
							joint.visible = false
							hand.joints[inputjoint.jointName] = joint
							// ??
							hand.add(joint)
						}

						const joint = hand.joints[inputjoint.jointName]

						if (jointPose !== null) {
							joint.matrix.fromArray(jointPose.transform.matrix)
							joint.matrix.decompose(joint.position, joint.rotation, joint.scale)
							joint.jointRadius = jointPose.radius
						}

						joint.visible = jointPose !== null
					}

					// Custom events

					// Check pinchz
					const indexTip = hand.joints['index-finger-tip']
					const thumbTip = hand.joints['thumb-tip']
					const distance = indexTip.position.distanceTo(thumbTip.position)

					const distanceToPinch = 0.02
					const threshold = 0.005

					if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
						hand.inputState.pinching = false
						this.dispatchEvent({
							type: 'pinchend',
							handedness: inputSource.handedness,
							target: this
						})
					} else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
						hand.inputState.pinching = true
						this.dispatchEvent({
							type: 'pinchstart',
							handedness: inputSource.handedness,
							target: this
						})
					}
				} else {
					if (grip !== null && inputSource.gripSpace) {
						gripPose = frame.getPose(inputSource.gripSpace, referenceSpace)

						if (gripPose !== null) {
							grip.matrix.fromArray(gripPose.transform.matrix)
							grip.matrix.decompose(grip.position, grip.rotation, grip.scale)

							if (gripPose.linearVelocity) {
								grip.hasLinearVelocity = true
								grip.linearVelocity.copy(gripPose.linearVelocity)
							} else {
								grip.hasLinearVelocity = false
							}

							if (gripPose.angularVelocity) {
								grip.hasAngularVelocity = true
								grip.angularVelocity.copy(gripPose.angularVelocity)
							} else {
								grip.hasAngularVelocity = false
							}
						}
					}
				}
			}

			if (targetRay !== null) {
				targetRay.visible = inputPose !== null
			}

			if (grip !== null) {
				grip.visible = gripPose !== null
			}

			if (hand !== null) {
				hand.visible = handPose !== null
			}

			return this
		}
	}

	class WebXRManager extends EventDispatcher {
		constructor(renderer, gl) {
			super()

			const scope = this
			const state = renderer.state

			let session = null
			let framebufferScaleFactor = 1.0

			let referenceSpace = null
			let referenceSpaceType = 'local-floor'

			let pose = null
			let glBinding = null
			let glFramebuffer = null
			let glProjLayer = null
			let glBaseLayer = null

			const controllers = []
			const inputSourcesMap = new Map()

			//

			const cameraL = new PerspectiveCamera()
			cameraL.layers.enable(1)
			cameraL.viewport = new Vector4()

			const cameraR = new PerspectiveCamera()
			cameraR.layers.enable(2)
			cameraR.viewport = new Vector4()

			const cameras = [cameraL, cameraR]

			const cameraVR = new ArrayCamera()
			cameraVR.layers.enable(1)
			cameraVR.layers.enable(2)

			let _currentDepthNear = null
			let _currentDepthFar = null

			//

			this.cameraAutoUpdate = true
			this.enabled = false

			this.isPresenting = false

			this.getController = function (index) {
				let controller = controllers[index]

				if (controller === undefined) {
					controller = new WebXRController()
					controllers[index] = controller
				}

				return controller.getTargetRaySpace()
			}

			this.getControllerGrip = function (index) {
				let controller = controllers[index]

				if (controller === undefined) {
					controller = new WebXRController()
					controllers[index] = controller
				}

				return controller.getGripSpace()
			}

			this.getHand = function (index) {
				let controller = controllers[index]

				if (controller === undefined) {
					controller = new WebXRController()
					controllers[index] = controller
				}

				return controller.getHandSpace()
			}

			//

			function onSessionEvent (event) {
				const controller = inputSourcesMap.get(event.inputSource)

				if (controller) {
					controller.dispatchEvent({ type: event.type, data: event.inputSource })
				}
			}

			function onSessionEnd () {
				inputSourcesMap.forEach(function (controller, inputSource) {
					controller.disconnect(inputSource)
				})

				inputSourcesMap.clear()

				_currentDepthNear = null
				_currentDepthFar = null

				// restore framebuffer/rendering state

				state.bindXRFramebuffer(null)
				renderer.setRenderTarget(renderer.getRenderTarget())

				//

				animation.stop()

				scope.isPresenting = false

				scope.dispatchEvent({ type: 'sessionend' })
			}

			this.setFramebufferScaleFactor = function (value) {
				framebufferScaleFactor = value

				if (scope.isPresenting === true) {
					console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.')
				}
			}

			this.setReferenceSpaceType = function (value) {
				referenceSpaceType = value

				if (scope.isPresenting === true) {
					console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.')
				}
			}

			this.getReferenceSpace = function () {
				return referenceSpace
			}

			this.getSession = function () {
				return session
			}

			this.setSession = async function (value) {
				session = value

				if (session !== null) {
					session.addEventListener('select', onSessionEvent)
					session.addEventListener('selectstart', onSessionEvent)
					session.addEventListener('selectend', onSessionEvent)
					session.addEventListener('squeeze', onSessionEvent)
					session.addEventListener('squeezestart', onSessionEvent)
					session.addEventListener('squeezeend', onSessionEvent)
					session.addEventListener('end', onSessionEnd)
					session.addEventListener('inputsourceschange', onInputSourcesChange)

					const attributes = gl.getContextAttributes()

					if (attributes.xrCompatible !== true) {
						await gl.makeXRCompatible()
					}

					if (session.renderState.layers === undefined) {
						const layerInit = {
							antialias: attributes.antialias,
							alpha: attributes.alpha,
							depth: attributes.depth,
							stencil: attributes.stencil,
							framebufferScaleFactor: framebufferScaleFactor
						}

						glBaseLayer = new XRWebGLLayer(session, gl, layerInit)

						session.updateRenderState({ baseLayer: glBaseLayer })
					} else {
						let depthFormat = 0

						// for anti-aliased output, use classic webgllayer for now
						if (attributes.antialias) {
							const layerInit = {
								antialias: true,
								alpha: attributes.alpha,
								depth: attributes.depth,
								stencil: attributes.stencil,
								framebufferScaleFactor: framebufferScaleFactor
							}

							glBaseLayer = new XRWebGLLayer(session, gl, layerInit)

							session.updateRenderState({ layers: [glBaseLayer] })
						} else {
							if (attributes.depth) {
								depthFormat = attributes.stencil ? gl.DEPTH_STENCIL : gl.DEPTH_COMPONENT
							}

							const projectionlayerInit = {
								colorFormat: attributes.alpha ? gl.RGBA : gl.RGB,
								depthFormat: depthFormat,
								scaleFactor: framebufferScaleFactor
							}

							glBinding = new XRWebGLBinding(session, gl)

							glProjLayer = glBinding.createProjectionLayer(projectionlayerInit)

							glFramebuffer = gl.createFramebuffer()

							session.updateRenderState({ layers: [glProjLayer] })
						}
					}

					referenceSpace = await session.requestReferenceSpace(referenceSpaceType)

					animation.setContext(session)
					animation.start()

					scope.isPresenting = true

					scope.dispatchEvent({ type: 'sessionstart' })
				}
			}

			function onInputSourcesChange (event) {
				const inputSources = session.inputSources

				// Assign inputSources to available controllers

				for (let i = 0; i < controllers.length; i++) {
					inputSourcesMap.set(inputSources[i], controllers[i])
				}

				// Notify disconnected

				for (let i = 0; i < event.removed.length; i++) {
					const inputSource = event.removed[i]
					const controller = inputSourcesMap.get(inputSource)

					if (controller) {
						controller.dispatchEvent({ type: 'disconnected', data: inputSource })
						inputSourcesMap.delete(inputSource)
					}
				}

				// Notify connected

				for (let i = 0; i < event.added.length; i++) {
					const inputSource = event.added[i]
					const controller = inputSourcesMap.get(inputSource)

					if (controller) {
						controller.dispatchEvent({ type: 'connected', data: inputSource })
					}
				}
			}

			//

			const cameraLPos = new Vector3()
			const cameraRPos = new Vector3()

			/**
			 * Assumes 2 cameras that are parallel and share an X-axis, and that
			 * the cameras' projection and world matrices have already been set.
			 * And that near and far planes are identical for both cameras.
			 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
			 */
			function setProjectionFromUnion (camera, cameraL, cameraR) {
				cameraLPos.setFromMatrixPosition(cameraL.matrixWorld)
				cameraRPos.setFromMatrixPosition(cameraR.matrixWorld)

				const ipd = cameraLPos.distanceTo(cameraRPos)

				const projL = cameraL.projectionMatrix.elements
				const projR = cameraR.projectionMatrix.elements

				// VR systems will have identical far and near planes, and
				// most likely identical top and bottom frustum extents.
				// Use the left camera for these values.
				const near = projL[14] / (projL[10] - 1)
				const far = projL[14] / (projL[10] + 1)
				const topFov = (projL[9] + 1) / projL[5]
				const bottomFov = (projL[9] - 1) / projL[5]

				const leftFov = (projL[8] - 1) / projL[0]
				const rightFov = (projR[8] + 1) / projR[0]
				const left = near * leftFov
				const right = near * rightFov

				// Calculate the new camera's position offset from the
				// left camera. xOffset should be roughly half `ipd`.
				const zOffset = ipd / (-leftFov + rightFov)
				const xOffset = zOffset * -leftFov

				// TODO: Better way to apply this offset?
				cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale)
				camera.translateX(xOffset)
				camera.translateZ(zOffset)
				camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale)
				camera.matrixWorldInverse.copy(camera.matrixWorld).invert()

				// Find the union of the frustum values of the cameras and scale
				// the values so that the near plane's position does not change in world space,
				// although must now be relative to the new union camera.
				const near2 = near + zOffset
				const far2 = far + zOffset
				const left2 = left - xOffset
				const right2 = right + (ipd - xOffset)
				const top2 = ((topFov * far) / far2) * near2
				const bottom2 = ((bottomFov * far) / far2) * near2

				camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2)
			}

			function updateCamera (camera, parent) {
				if (parent === null) {
					camera.matrixWorld.copy(camera.matrix)
				} else {
					camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix)
				}

				camera.matrixWorldInverse.copy(camera.matrixWorld).invert()
			}

			this.updateCamera = function (camera) {
				if (session === null) return

				cameraVR.near = cameraR.near = cameraL.near = camera.near
				cameraVR.far = cameraR.far = cameraL.far = camera.far

				if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
					// Note that the new renderState won't apply until the next frame. See #18320

					session.updateRenderState({
						depthNear: cameraVR.near,
						depthFar: cameraVR.far
					})

					_currentDepthNear = cameraVR.near
					_currentDepthFar = cameraVR.far
				}

				const parent = camera.parent
				const cameras = cameraVR.cameras

				updateCamera(cameraVR, parent)

				for (let i = 0; i < cameras.length; i++) {
					updateCamera(cameras[i], parent)
				}

				cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale)

				// update user camera and its children

				camera.position.copy(cameraVR.position)
				camera.quaternion.copy(cameraVR.quaternion)
				camera.scale.copy(cameraVR.scale)
				camera.matrix.copy(cameraVR.matrix)
				camera.matrixWorld.copy(cameraVR.matrixWorld)

				const children = camera.children

				for (let i = 0, l = children.length; i < l; i++) {
					children[i].updateMatrixWorld(true)
				}

				// update projection matrix for proper view frustum culling

				if (cameras.length === 2) {
					setProjectionFromUnion(cameraVR, cameraL, cameraR)
				} else {
					// assume single camera setup (AR)

					cameraVR.projectionMatrix.copy(cameraL.projectionMatrix)
				}
			}

			this.getCamera = function () {
				return cameraVR
			}

			this.getFoveation = function () {
				if (glProjLayer !== null) {
					return glProjLayer.fixedFoveation
				}

				if (glBaseLayer !== null) {
					return glBaseLayer.fixedFoveation
				}

				return undefined
			}

			this.setFoveation = function (foveation) {
				// 0 = no foveation = full resolution
				// 1 = maximum foveation = the edges render at lower resolution

				if (glProjLayer !== null) {
					glProjLayer.fixedFoveation = foveation
				}

				if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) {
					glBaseLayer.fixedFoveation = foveation
				}
			}

			// Animation Loop

			let onAnimationFrameCallback = null

			function onAnimationFrame (time, frame) {
				pose = frame.getViewerPose(referenceSpace)

				if (pose !== null) {
					const views = pose.views

					if (glBaseLayer !== null) {
						state.bindXRFramebuffer(glBaseLayer.framebuffer)
					}

					let cameraVRNeedsUpdate = false

					// check if it's necessary to rebuild cameraVR's camera list

					if (views.length !== cameraVR.cameras.length) {
						cameraVR.cameras.length = 0

						cameraVRNeedsUpdate = true
					}

					for (let i = 0; i < views.length; i++) {
						const view = views[i]

						let viewport = null

						if (glBaseLayer !== null) {
							viewport = glBaseLayer.getViewport(view)
						} else {
							const glSubImage = glBinding.getViewSubImage(glProjLayer, view)

							state.bindXRFramebuffer(glFramebuffer)

							if (glSubImage.depthStencilTexture !== undefined) {
								gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, glSubImage.depthStencilTexture, 0)
							}

							gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glSubImage.colorTexture, 0)

							viewport = glSubImage.viewport
						}

						const camera = cameras[i]

						camera.matrix.fromArray(view.transform.matrix)

						camera.projectionMatrix.fromArray(view.projectionMatrix)

						camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height)

						if (i === 0) {
							cameraVR.matrix.copy(camera.matrix)
						}

						if (cameraVRNeedsUpdate === true) {
							cameraVR.cameras.push(camera)
						}
					}
				}

				//

				const inputSources = session.inputSources

				for (let i = 0; i < controllers.length; i++) {
					const controller = controllers[i]
					const inputSource = inputSources[i]

					controller.update(inputSource, frame, referenceSpace)
				}

				if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame)
			}

			const animation = new WebGLAnimation()

			animation.setAnimationLoop(onAnimationFrame)

			this.setAnimationLoop = function (callback) {
				onAnimationFrameCallback = callback
			}

			this.dispose = function () { }
		}
	}

	function WebGLMaterials (properties) {
		function refreshFogUniforms (uniforms, fog) {
			uniforms.fogColor.value.copy(fog.color)

			if (fog.isFog) {
				uniforms.fogNear.value = fog.near
				uniforms.fogFar.value = fog.far
			} else if (fog.isFogExp2) {
				uniforms.fogDensity.value = fog.density
			}
		}

		function refreshMaterialUniforms (uniforms, material, pixelRatio, height, transmissionRenderTarget) {
			if (material.isMeshBasicMaterial) {
				refreshUniformsCommon(uniforms, material)
			} else if (material.isMeshLambertMaterial) {
				refreshUniformsCommon(uniforms, material)
				refreshUniformsLambert(uniforms, material)
			} else if (material.isMeshToonMaterial) {
				refreshUniformsCommon(uniforms, material)
				refreshUniformsToon(uniforms, material)
			} else if (material.isMeshPhongMaterial) {
				refreshUniformsCommon(uniforms, material)
				refreshUniformsPhong(uniforms, material)
			} else if (material.isMeshStandardMaterial) {
				refreshUniformsCommon(uniforms, material)

				if (material.isMeshPhysicalMaterial) {
					refreshUniformsPhysical(uniforms, material, transmissionRenderTarget)
				} else {
					refreshUniformsStandard(uniforms, material)
				}
			} else if (material.isMeshMatcapMaterial) {
				refreshUniformsCommon(uniforms, material)
				refreshUniformsMatcap(uniforms, material)
			} else if (material.isMeshDepthMaterial) {
				refreshUniformsCommon(uniforms, material)
				refreshUniformsDepth(uniforms, material)
			} else if (material.isMeshDistanceMaterial) {
				refreshUniformsCommon(uniforms, material)
				refreshUniformsDistance(uniforms, material)
			} else if (material.isMeshNormalMaterial) {
				refreshUniformsCommon(uniforms, material)
				refreshUniformsNormal(uniforms, material)
			} else if (material.isLineBasicMaterial) {
				refreshUniformsLine(uniforms, material)

				if (material.isLineDashedMaterial) {
					refreshUniformsDash(uniforms, material)
				}
			} else if (material.isPointsMaterial) {
				refreshUniformsPoints(uniforms, material, pixelRatio, height)
			} else if (material.isSpriteMaterial) {
				refreshUniformsSprites(uniforms, material)
			} else if (material.isShadowMaterial) {
				uniforms.color.value.copy(material.color)
				uniforms.opacity.value = material.opacity
			} else if (material.isShaderMaterial) {
				material.uniformsNeedUpdate = false // #15581
			}
		}

		function refreshUniformsCommon (uniforms, material) {
			uniforms.opacity.value = material.opacity

			if (material.color) {
				uniforms.diffuse.value.copy(material.color)
			}

			if (material.emissive) {
				uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity)
			}

			if (material.map) {
				uniforms.map.value = material.map
			}

			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap
			}

			if (material.specularMap) {
				uniforms.specularMap.value = material.specularMap
			}

			const envMap = properties.get(material).envMap

			if (envMap) {
				uniforms.envMap.value = envMap

				uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1

				uniforms.reflectivity.value = material.reflectivity
				uniforms.refractionRatio.value = material.refractionRatio

				const maxMipLevel = properties.get(envMap).__maxMipLevel

				if (maxMipLevel !== undefined) {
					uniforms.maxMipLevel.value = maxMipLevel
				}
			}

			if (material.lightMap) {
				uniforms.lightMap.value = material.lightMap
				uniforms.lightMapIntensity.value = material.lightMapIntensity
			}

			if (material.aoMap) {
				uniforms.aoMap.value = material.aoMap
				uniforms.aoMapIntensity.value = material.aoMapIntensity
			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. displacementMap map
			// 4. normal map
			// 5. bump map
			// 6. roughnessMap map
			// 7. metalnessMap map
			// 8. alphaMap map
			// 9. emissiveMap map
			// 10. clearcoat map
			// 11. clearcoat normal map
			// 12. clearcoat roughnessMap map
			// 13. specular intensity map
			// 14. specular tint map

			let uvScaleMap

			if (material.map) {
				uvScaleMap = material.map
			} else if (material.specularMap) {
				uvScaleMap = material.specularMap
			} else if (material.displacementMap) {
				uvScaleMap = material.displacementMap
			} else if (material.normalMap) {
				uvScaleMap = material.normalMap
			} else if (material.bumpMap) {
				uvScaleMap = material.bumpMap
			} else if (material.roughnessMap) {
				uvScaleMap = material.roughnessMap
			} else if (material.metalnessMap) {
				uvScaleMap = material.metalnessMap
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap
			} else if (material.emissiveMap) {
				uvScaleMap = material.emissiveMap
			} else if (material.clearcoatMap) {
				uvScaleMap = material.clearcoatMap
			} else if (material.clearcoatNormalMap) {
				uvScaleMap = material.clearcoatNormalMap
			} else if (material.clearcoatRoughnessMap) {
				uvScaleMap = material.clearcoatRoughnessMap
			} else if (material.specularIntensityMap) {
				uvScaleMap = material.specularIntensityMap
			} else if (material.specularTintMap) {
				uvScaleMap = material.specularTintMap
			}

			if (uvScaleMap !== undefined) {
				// backwards compatibility
				if (uvScaleMap.isWebGLRenderTarget) {
					uvScaleMap = uvScaleMap.texture
				}

				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix()
				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix)
			}

			// uv repeat and offset setting priorities for uv2
			// 1. ao map
			// 2. light map

			let uv2ScaleMap

			if (material.aoMap) {
				uv2ScaleMap = material.aoMap
			} else if (material.lightMap) {
				uv2ScaleMap = material.lightMap
			}

			if (uv2ScaleMap !== undefined) {
				// backwards compatibility
				if (uv2ScaleMap.isWebGLRenderTarget) {
					uv2ScaleMap = uv2ScaleMap.texture
				}

				if (uv2ScaleMap.matrixAutoUpdate === true) {
					uv2ScaleMap.updateMatrix()
				}

				uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix)
			}
		}

		function refreshUniformsLine (uniforms, material) {
			uniforms.diffuse.value.copy(material.color)
			uniforms.opacity.value = material.opacity
		}

		function refreshUniformsDash (uniforms, material) {
			uniforms.dashSize.value = material.dashSize
			uniforms.totalSize.value = material.dashSize + material.gapSize
			uniforms.scale.value = material.scale
		}

		function refreshUniformsPoints (uniforms, material, pixelRatio, height) {
			uniforms.diffuse.value.copy(material.color)
			uniforms.opacity.value = material.opacity
			uniforms.size.value = material.size * pixelRatio
			uniforms.scale.value = height * 0.5

			if (material.map) {
				uniforms.map.value = material.map
			}

			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap
			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map

			let uvScaleMap

			if (material.map) {
				uvScaleMap = material.map
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap
			}

			if (uvScaleMap !== undefined) {
				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix()
				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix)
			}
		}

		function refreshUniformsSprites (uniforms, material) {
			uniforms.diffuse.value.copy(material.color)
			uniforms.opacity.value = material.opacity
			uniforms.rotation.value = material.rotation

			if (material.map) {
				uniforms.map.value = material.map
			}

			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap
			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map

			let uvScaleMap

			if (material.map) {
				uvScaleMap = material.map
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap
			}

			if (uvScaleMap !== undefined) {
				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix()
				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix)
			}
		}

		function refreshUniformsLambert (uniforms, material) {
			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap
			}
		}

		function refreshUniformsPhong (uniforms, material) {
			uniforms.specular.value.copy(material.specular)
			uniforms.shininess.value = Math.max(material.shininess, 1e-4) // to prevent pow( 0.0, 0.0 )

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap
				uniforms.bumpScale.value = material.bumpScale
				if (material.side === BackSide) uniforms.bumpScale.value *= -1
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap
				uniforms.normalScale.value.copy(material.normalScale)
				if (material.side === BackSide) uniforms.normalScale.value.negate()
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap
				uniforms.displacementScale.value = material.displacementScale
				uniforms.displacementBias.value = material.displacementBias
			}
		}

		function refreshUniformsToon (uniforms, material) {
			if (material.gradientMap) {
				uniforms.gradientMap.value = material.gradientMap
			}

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap
				uniforms.bumpScale.value = material.bumpScale
				if (material.side === BackSide) uniforms.bumpScale.value *= -1
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap
				uniforms.normalScale.value.copy(material.normalScale)
				if (material.side === BackSide) uniforms.normalScale.value.negate()
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap
				uniforms.displacementScale.value = material.displacementScale
				uniforms.displacementBias.value = material.displacementBias
			}
		}

		function refreshUniformsStandard (uniforms, material) {
			uniforms.roughness.value = material.roughness
			uniforms.metalness.value = material.metalness

			if (material.roughnessMap) {
				uniforms.roughnessMap.value = material.roughnessMap
			}

			if (material.metalnessMap) {
				uniforms.metalnessMap.value = material.metalnessMap
			}

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap
				uniforms.bumpScale.value = material.bumpScale
				if (material.side === BackSide) uniforms.bumpScale.value *= -1
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap
				uniforms.normalScale.value.copy(material.normalScale)
				if (material.side === BackSide) uniforms.normalScale.value.negate()
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap
				uniforms.displacementScale.value = material.displacementScale
				uniforms.displacementBias.value = material.displacementBias
			}

			const envMap = properties.get(material).envMap

			if (envMap) {
				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity
			}
		}

		function refreshUniformsPhysical (uniforms, material, transmissionRenderTarget) {
			refreshUniformsStandard(uniforms, material)

			uniforms.reflectivity.value = material.reflectivity // also part of uniforms common

			uniforms.clearcoat.value = material.clearcoat
			uniforms.clearcoatRoughness.value = material.clearcoatRoughness

			if (material.sheen) uniforms.sheen.value.copy(material.sheen)

			if (material.clearcoatMap) {
				uniforms.clearcoatMap.value = material.clearcoatMap
			}

			if (material.clearcoatRoughnessMap) {
				uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap
			}

			if (material.clearcoatNormalMap) {
				uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale)
				uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap

				if (material.side === BackSide) {
					uniforms.clearcoatNormalScale.value.negate()
				}
			}

			uniforms.transmission.value = material.transmission

			if (material.transmissionMap) {
				uniforms.transmissionMap.value = material.transmissionMap
			}

			if (material.transmission > 0.0) {
				uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture
				uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height)
			}

			uniforms.thickness.value = material.thickness

			if (material.thicknessMap) {
				uniforms.thicknessMap.value = material.thicknessMap
			}

			uniforms.attenuationDistance.value = material.attenuationDistance
			uniforms.attenuationTint.value.copy(material.attenuationTint)

			uniforms.specularIntensity.value = material.specularIntensity
			uniforms.specularTint.value.copy(material.specularTint)

			if (material.specularIntensityMap) {
				uniforms.specularIntensityMap.value = material.specularIntensityMap
			}

			if (material.specularTintMap) {
				uniforms.specularTintMap.value = material.specularTintMap
			}
		}

		function refreshUniformsMatcap (uniforms, material) {
			if (material.matcap) {
				uniforms.matcap.value = material.matcap
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap
				uniforms.bumpScale.value = material.bumpScale
				if (material.side === BackSide) uniforms.bumpScale.value *= -1
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap
				uniforms.normalScale.value.copy(material.normalScale)
				if (material.side === BackSide) uniforms.normalScale.value.negate()
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap
				uniforms.displacementScale.value = material.displacementScale
				uniforms.displacementBias.value = material.displacementBias
			}
		}

		function refreshUniformsDepth (uniforms, material) {
			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap
				uniforms.displacementScale.value = material.displacementScale
				uniforms.displacementBias.value = material.displacementBias
			}
		}

		function refreshUniformsDistance (uniforms, material) {
			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap
				uniforms.displacementScale.value = material.displacementScale
				uniforms.displacementBias.value = material.displacementBias
			}

			uniforms.referencePosition.value.copy(material.referencePosition)
			uniforms.nearDistance.value = material.nearDistance
			uniforms.farDistance.value = material.farDistance
		}

		function refreshUniformsNormal (uniforms, material) {
			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap
				uniforms.bumpScale.value = material.bumpScale
				if (material.side === BackSide) uniforms.bumpScale.value *= -1
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap
				uniforms.normalScale.value.copy(material.normalScale)
				if (material.side === BackSide) uniforms.normalScale.value.negate()
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap
				uniforms.displacementScale.value = material.displacementScale
				uniforms.displacementBias.value = material.displacementBias
			}
		}

		return {
			refreshFogUniforms: refreshFogUniforms,
			refreshMaterialUniforms: refreshMaterialUniforms
		}
	}

	function createCanvasElement () {
		const canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas')
		canvas.style.display = 'block'
		return canvas
	}

	function WebGLRenderer (parameters = {}) {
		const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
			_context = parameters.context !== undefined ? parameters.context : null,
			_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
			_depth = parameters.depth !== undefined ? parameters.depth : true,
			_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
			_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
			_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
			_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
			_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
			_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false

		let currentRenderList = null
		let currentRenderState = null

		// render() can be called from within a callback triggered by another render.
		// We track this so that the nested render call gets its list and state isolated from the parent render call.

		const renderListStack = []
		const renderStateStack = []

		// public properties

		this.domElement = _canvas

		// Debug configuration container
		this.debug = {
			/**
			 * Enables error checking and reporting when shader programs are being compiled
			 * @type {boolean}
			 */
			checkShaderErrors: true
		}

		// clearing

		this.autoClear = true
		this.autoClearColor = true
		this.autoClearDepth = true
		this.autoClearStencil = true

		// scene graph

		this.sortObjects = true

		// user-defined clipping

		this.clippingPlanes = []
		this.localClippingEnabled = false

		// physically based shading

		this.gammaFactor = 2.0 // for backwards compatibility
		this.outputEncoding = LinearEncoding

		// physical lights

		this.physicallyCorrectLights = false

		// tone mapping

		this.toneMapping = NoToneMapping
		this.toneMappingExposure = 1.0

		// internal properties

		const _this = this

		let _isContextLost = false

		// internal state cache

		let _currentActiveCubeFace = 0
		let _currentActiveMipmapLevel = 0
		let _currentRenderTarget = null
		let _currentMaterialId = -1

		let _currentCamera = null

		const _currentViewport = new Vector4()
		const _currentScissor = new Vector4()
		let _currentScissorTest = null

		//

		let _width = _canvas.width
		let _height = _canvas.height

		let _pixelRatio = 1
		let _opaqueSort = null
		let _transparentSort = null

		const _viewport = new Vector4(0, 0, _width, _height)
		const _scissor = new Vector4(0, 0, _width, _height)
		let _scissorTest = false

		//

		const _currentDrawBuffers = []

		// frustum

		const _frustum = new Frustum()

		// clipping

		let _clippingEnabled = false
		let _localClippingEnabled = false

		// transmission

		let _transmissionRenderTarget = null

		// camera matrices cache

		const _projScreenMatrix = new Matrix4()

		const _vector3 = new Vector3()

		const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true }

		function getTargetPixelRatio () {
			return _currentRenderTarget === null ? _pixelRatio : 1
		}

		// initialize

		let _gl = _context

		function getContext (contextNames, contextAttributes) {
			for (let i = 0; i < contextNames.length; i++) {
				const contextName = contextNames[i]
				const context = _canvas.getContext(contextName, contextAttributes)
				if (context !== null) return context
			}

			return null
		}

		try {
			const contextAttributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference,
				failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
			}

			// event listeners must be registered before WebGL context is created, see #12753

			_canvas.addEventListener('webglcontextlost', onContextLost, false)
			_canvas.addEventListener('webglcontextrestored', onContextRestore, false)

			if (_gl === null) {
				const contextNames = ['webgl2', 'webgl', 'experimental-webgl']

				if (_this.isWebGL1Renderer === true) {
					contextNames.shift()
				}

				_gl = getContext(contextNames, contextAttributes)

				if (_gl === null) {
					if (getContext(contextNames)) {
						throw new Error('Error creating WebGL context with your selected attributes.')
					} else {
						throw new Error('Error creating WebGL context.')
					}
				}
			}

			// Some experimental-webgl implementations do not have getShaderPrecisionFormat

			if (_gl.getShaderPrecisionFormat === undefined) {
				_gl.getShaderPrecisionFormat = function () {
					return { rangeMin: 1, rangeMax: 1, precision: 1 }
				}
			}
		} catch (error) {
			console.error('THREE.WebGLRenderer: ' + error.message)
			throw error
		}

		let extensions, capabilities, state, info
		let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects
		let programCache, materials, renderLists, renderStates, clipping, shadowMap

		let background, morphtargets, bufferRenderer, indexedBufferRenderer

		let utils, bindingStates

		function initGLContext () {
			extensions = new WebGLExtensions(_gl)

			capabilities = new WebGLCapabilities(_gl, extensions, parameters)

			extensions.init(capabilities)

			utils = new WebGLUtils(_gl, extensions, capabilities)

			state = new WebGLState(_gl, extensions, capabilities)

			_currentDrawBuffers[0] = _gl.BACK

			info = new WebGLInfo(_gl)
			properties = new WebGLProperties()
			textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info)
			cubemaps = new WebGLCubeMaps(_this)
			cubeuvmaps = new WebGLCubeUVMaps(_this)
			attributes = new WebGLAttributes(_gl, capabilities)
			bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities)
			geometries = new WebGLGeometries(_gl, attributes, info, bindingStates)
			objects = new WebGLObjects(_gl, geometries, attributes, info)
			morphtargets = new WebGLMorphtargets(_gl)
			clipping = new WebGLClipping(properties)
			programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping)
			materials = new WebGLMaterials(properties)
			renderLists = new WebGLRenderLists(properties)
			renderStates = new WebGLRenderStates(extensions, capabilities)
			background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha)
			shadowMap = new WebGLShadowMap(_this, objects, capabilities)

			bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities)
			indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities)

			info.programs = programCache.programs

			_this.capabilities = capabilities
			_this.extensions = extensions
			_this.properties = properties
			_this.renderLists = renderLists
			_this.shadowMap = shadowMap
			_this.state = state
			_this.info = info
		}

		initGLContext()

		// xr

		const xr = new WebXRManager(_this, _gl)

		this.xr = xr

		// API

		this.getContext = function () {
			return _gl
		}

		this.getContextAttributes = function () {
			return _gl.getContextAttributes()
		}

		this.forceContextLoss = function () {
			const extension = extensions.get('WEBGL_lose_context')
			if (extension) extension.loseContext()
		}

		this.forceContextRestore = function () {
			const extension = extensions.get('WEBGL_lose_context')
			if (extension) extension.restoreContext()
		}

		this.getPixelRatio = function () {
			return _pixelRatio
		}

		this.setPixelRatio = function (value) {
			if (value === undefined) return

			_pixelRatio = value

			this.setSize(_width, _height, false)
		}

		this.getSize = function (target) {
			return target.set(_width, _height)
		}

		this.setSize = function (width, height, updateStyle) {
			if (xr.isPresenting) {
				console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.")
				return
			}

			_width = width
			_height = height

			_canvas.width = Math.floor(width * _pixelRatio)
			_canvas.height = Math.floor(height * _pixelRatio)

			if (updateStyle !== false) {
				_canvas.style.width = width + 'px'
				_canvas.style.height = height + 'px'
			}

			this.setViewport(0, 0, width, height)
		}

		this.getDrawingBufferSize = function (target) {
			return target.set(_width * _pixelRatio, _height * _pixelRatio).floor()
		}

		this.setDrawingBufferSize = function (width, height, pixelRatio) {
			_width = width
			_height = height

			_pixelRatio = pixelRatio

			_canvas.width = Math.floor(width * pixelRatio)
			_canvas.height = Math.floor(height * pixelRatio)

			this.setViewport(0, 0, width, height)
		}

		this.getCurrentViewport = function (target) {
			return target.copy(_currentViewport)
		}

		this.getViewport = function (target) {
			return target.copy(_viewport)
		}

		this.setViewport = function (x, y, width, height) {
			if (x.isVector4) {
				_viewport.set(x.x, x.y, x.z, x.w)
			} else {
				_viewport.set(x, y, width, height)
			}

			state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor())
		}

		this.getScissor = function (target) {
			return target.copy(_scissor)
		}

		this.setScissor = function (x, y, width, height) {
			if (x.isVector4) {
				_scissor.set(x.x, x.y, x.z, x.w)
			} else {
				_scissor.set(x, y, width, height)
			}

			state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor())
		}

		this.getScissorTest = function () {
			return _scissorTest
		}

		this.setScissorTest = function (boolean) {
			state.setScissorTest((_scissorTest = boolean))
		}

		this.setOpaqueSort = function (method) {
			_opaqueSort = method
		}

		this.setTransparentSort = function (method) {
			_transparentSort = method
		}

		// Clearing

		this.getClearColor = function (target) {
			return target.copy(background.getClearColor())
		}

		this.setClearColor = function () {
			background.setClearColor.apply(background, arguments)
		}

		this.getClearAlpha = function () {
			return background.getClearAlpha()
		}

		this.setClearAlpha = function () {
			background.setClearAlpha.apply(background, arguments)
		}

		this.clear = function (color, depth, stencil) {
			let bits = 0

			if (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT
			if (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT
			if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT

			_gl.clear(bits)
		}

		this.clearColor = function () {
			this.clear(true, false, false)
		}

		this.clearDepth = function () {
			this.clear(false, true, false)
		}

		this.clearStencil = function () {
			this.clear(false, false, true)
		}

		//

		this.dispose = function () {
			_canvas.removeEventListener('webglcontextlost', onContextLost, false)
			_canvas.removeEventListener('webglcontextrestored', onContextRestore, false)

			renderLists.dispose()
			renderStates.dispose()
			properties.dispose()
			cubemaps.dispose()
			cubeuvmaps.dispose()
			objects.dispose()
			bindingStates.dispose()

			xr.dispose()

			xr.removeEventListener('sessionstart', onXRSessionStart)
			xr.removeEventListener('sessionend', onXRSessionEnd)

			if (_transmissionRenderTarget) {
				_transmissionRenderTarget.dispose()
				_transmissionRenderTarget = null
			}

			animation.stop()
		}

		// Events

		function onContextLost (event) {
			event.preventDefault()

			console.log('THREE.WebGLRenderer: Context Lost.')

			_isContextLost = true
		}

		function onContextRestore (/* event */) {
			console.log('THREE.WebGLRenderer: Context Restored.')

			_isContextLost = false

			const infoAutoReset = info.autoReset
			const shadowMapEnabled = shadowMap.enabled
			const shadowMapAutoUpdate = shadowMap.autoUpdate
			const shadowMapNeedsUpdate = shadowMap.needsUpdate
			const shadowMapType = shadowMap.type

			initGLContext()

			info.autoReset = infoAutoReset
			shadowMap.enabled = shadowMapEnabled
			shadowMap.autoUpdate = shadowMapAutoUpdate
			shadowMap.needsUpdate = shadowMapNeedsUpdate
			shadowMap.type = shadowMapType
		}

		function onMaterialDispose (event) {
			const material = event.target

			material.removeEventListener('dispose', onMaterialDispose)

			deallocateMaterial(material)
		}

		// Buffer deallocation

		function deallocateMaterial (material) {
			releaseMaterialProgramReferences(material)

			properties.remove(material)
		}

		function releaseMaterialProgramReferences (material) {
			const programs = properties.get(material).programs

			if (programs !== undefined) {
				programs.forEach(function (program) {
					programCache.releaseProgram(program)
				})
			}
		}

		// Buffer rendering

		function renderObjectImmediate (object, program) {
			object.render(function (object) {
				_this.renderBufferImmediate(object, program)
			})
		}

		this.renderBufferImmediate = function (object, program) {
			bindingStates.initAttributes()

			const buffers = properties.get(object)

			if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer()
			if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer()
			if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer()
			if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer()

			const programAttributes = program.getAttributes()

			if (object.hasPositions) {
				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position)
				_gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW)

				bindingStates.enableAttribute(programAttributes.position)
				_gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0)
			}

			if (object.hasNormals) {
				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal)
				_gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW)

				bindingStates.enableAttribute(programAttributes.normal)
				_gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0)
			}

			if (object.hasUvs) {
				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv)
				_gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW)

				bindingStates.enableAttribute(programAttributes.uv)
				_gl.vertexAttribPointer(programAttributes.uv, 2, _gl.FLOAT, false, 0, 0)
			}

			if (object.hasColors) {
				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color)
				_gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW)

				bindingStates.enableAttribute(programAttributes.color)
				_gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0)
			}

			bindingStates.disableUnusedAttributes()

			_gl.drawArrays(_gl.TRIANGLES, 0, object.count)

			object.count = 0
		}

		this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {
			if (scene === null) scene = _emptyScene // renderBufferDirect second parameter used to be fog (could be null)

			const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0

			const program = setProgram(camera, scene, material, object)

			state.setMaterial(material, frontFaceCW)

			//

			let index = geometry.index
			const position = geometry.attributes.position

			//

			if (index === null) {
				if (position === undefined || position.count === 0) return
			} else if (index.count === 0) {
				return
			}

			//

			let rangeFactor = 1

			if (material.wireframe === true) {
				index = geometries.getWireframeAttribute(geometry)
				rangeFactor = 2
			}

			if (geometry.morphAttributes.position !== undefined || geometry.morphAttributes.normal !== undefined) {
				morphtargets.update(object, geometry, material, program)
			}

			bindingStates.setup(object, material, program, geometry, index)

			let attribute
			let renderer = bufferRenderer

			if (index !== null) {
				attribute = attributes.get(index)

				renderer = indexedBufferRenderer
				renderer.setIndex(attribute)
			}

			//

			const dataCount = index !== null ? index.count : position.count

			const rangeStart = geometry.drawRange.start * rangeFactor
			const rangeCount = geometry.drawRange.count * rangeFactor

			const groupStart = group !== null ? group.start * rangeFactor : 0
			const groupCount = group !== null ? group.count * rangeFactor : Infinity

			const drawStart = Math.max(rangeStart, groupStart)
			const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1

			const drawCount = Math.max(0, drawEnd - drawStart + 1)

			if (drawCount === 0) return

			//

			if (object.isMesh) {
				if (material.wireframe === true) {
					state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio())
					renderer.setMode(_gl.LINES)
				} else {
					renderer.setMode(_gl.TRIANGLES)
				}
			} else if (object.isLine) {
				let lineWidth = material.linewidth

				if (lineWidth === undefined) lineWidth = 1 // Not using Line*Material

				state.setLineWidth(lineWidth * getTargetPixelRatio())

				if (object.isLineSegments) {
					renderer.setMode(_gl.LINES)
				} else if (object.isLineLoop) {
					renderer.setMode(_gl.LINE_LOOP)
				} else {
					renderer.setMode(_gl.LINE_STRIP)
				}
			} else if (object.isPoints) {
				renderer.setMode(_gl.POINTS)
			} else if (object.isSprite) {
				renderer.setMode(_gl.TRIANGLES)
			}

			if (object.isInstancedMesh) {
				renderer.renderInstances(drawStart, drawCount, object.count)
			} else if (geometry.isInstancedBufferGeometry) {
				const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount)

				renderer.renderInstances(drawStart, drawCount, instanceCount)
			} else {
				renderer.render(drawStart, drawCount)
			}
		}

		// Compile

		this.compile = function (scene, camera) {
			currentRenderState = renderStates.get(scene)
			currentRenderState.init()

			renderStateStack.push(currentRenderState)

			scene.traverseVisible(function (object) {
				if (object.isLight && object.layers.test(camera.layers)) {
					currentRenderState.pushLight(object)

					if (object.castShadow) {
						currentRenderState.pushShadow(object)
					}
				}
			})

			currentRenderState.setupLights()

			scene.traverse(function (object) {
				const material = object.material

				if (material) {
					if (Array.isArray(material)) {
						for (let i = 0; i < material.length; i++) {
							const material2 = material[i]

							getProgram(material2, scene, object)
						}
					} else {
						getProgram(material, scene, object)
					}
				}
			})

			renderStateStack.pop()
			currentRenderState = null
		}

		// Animation Loop

		let onAnimationFrameCallback = null

		function onAnimationFrame (time) {
			if (onAnimationFrameCallback) onAnimationFrameCallback(time)
		}

		function onXRSessionStart () {
			animation.stop()
		}

		function onXRSessionEnd () {
			animation.start()
		}

		const animation = new WebGLAnimation()
		animation.setAnimationLoop(onAnimationFrame)

		if (typeof window !== 'undefined') animation.setContext(window)

		this.setAnimationLoop = function (callback) {
			onAnimationFrameCallback = callback
			xr.setAnimationLoop(callback)

			callback === null ? animation.stop() : animation.start()
		}

		xr.addEventListener('sessionstart', onXRSessionStart)
		xr.addEventListener('sessionend', onXRSessionEnd)

		// Rendering

		this.render = function (scene, camera) {
			if (camera !== undefined && camera.isCamera !== true) {
				console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.')
				return
			}

			if (_isContextLost === true) return

			// update scene graph

			if (scene.autoUpdate === true) scene.updateMatrixWorld()

			// update camera matrices and frustum

			if (camera.parent === null) camera.updateMatrixWorld()

			if (xr.enabled === true && xr.isPresenting === true) {
				if (xr.cameraAutoUpdate === true) xr.updateCamera(camera)

				camera = xr.getCamera() // use XR camera for rendering
			}

			//
			if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget)

			currentRenderState = renderStates.get(scene, renderStateStack.length)
			currentRenderState.init()

			renderStateStack.push(currentRenderState)

			_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse)
			_frustum.setFromProjectionMatrix(_projScreenMatrix)

			_localClippingEnabled = this.localClippingEnabled
			_clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera)

			currentRenderList = renderLists.get(scene, renderListStack.length)
			currentRenderList.init()

			renderListStack.push(currentRenderList)

			projectObject(scene, camera, 0, _this.sortObjects)

			currentRenderList.finish()

			if (_this.sortObjects === true) {
				currentRenderList.sort(_opaqueSort, _transparentSort)
			}

			//

			if (_clippingEnabled === true) clipping.beginShadows()

			const shadowsArray = currentRenderState.state.shadowsArray

			shadowMap.render(shadowsArray, scene, camera)

			currentRenderState.setupLights()
			currentRenderState.setupLightsView(camera)

			if (_clippingEnabled === true) clipping.endShadows()

			//

			if (this.info.autoReset === true) this.info.reset()

			//

			background.render(currentRenderList, scene)

			// render scene

			const opaqueObjects = currentRenderList.opaque
			const transmissiveObjects = currentRenderList.transmissive
			const transparentObjects = currentRenderList.transparent

			if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera)
			if (transmissiveObjects.length > 0) renderTransmissiveObjects(opaqueObjects, transmissiveObjects, scene, camera)
			if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera)

			//

			if (_currentRenderTarget !== null) {
				// resolve multisample renderbuffers to a single-sample texture if necessary

				textures.updateMultisampleRenderTarget(_currentRenderTarget)

				// Generate mipmap if we're using any kind of mipmap filtering

				textures.updateRenderTargetMipmap(_currentRenderTarget)
			}

			//

			if (scene.isScene === true) scene.onAfterRender(_this, scene, camera)

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest(true)
			state.buffers.depth.setMask(true)
			state.buffers.color.setMask(true)

			state.setPolygonOffset(false)

			// _gl.finish();

			bindingStates.resetDefaultState()
			_currentMaterialId = -1
			_currentCamera = null

			renderStateStack.pop()

			if (renderStateStack.length > 0) {
				currentRenderState = renderStateStack[renderStateStack.length - 1]
			} else {
				currentRenderState = null
			}

			renderListStack.pop()

			if (renderListStack.length > 0) {
				currentRenderList = renderListStack[renderListStack.length - 1]
			} else {
				currentRenderList = null
			}
		}

		function projectObject (object, camera, groupOrder, sortObjects) {
			if (object.visible === false) return

			const visible = object.layers.test(camera.layers)

			if (visible) {
				if (object.isGroup) {
					groupOrder = object.renderOrder
				} else if (object.isLOD) {
					if (object.autoUpdate === true) object.update(camera)
				} else if (object.isLight) {
					currentRenderState.pushLight(object)

					if (object.castShadow) {
						currentRenderState.pushShadow(object)
					}
				} else if (object.isSprite) {
					if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
						if (sortObjects) {
							_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix)
						}

						const geometry = objects.update(object)
						const material = object.material

						if (material.visible) {
							currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null)
						}
					}
				} else if (object.isImmediateRenderObject) {
					if (sortObjects) {
						_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix)
					}

					currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null)
				} else if (object.isMesh || object.isLine || object.isPoints) {
					if (object.isSkinnedMesh) {
						// update skeleton only once in a frame

						if (object.skeleton.frame !== info.render.frame) {
							object.skeleton.update()
							object.skeleton.frame = info.render.frame
						}
					}

					if (!object.frustumCulled || _frustum.intersectsObject(object)) {
						if (sortObjects) {
							_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix)
						}

						const geometry = objects.update(object)
						const material = object.material

						if (Array.isArray(material)) {
							const groups = geometry.groups

							for (let i = 0, l = groups.length; i < l; i++) {
								const group = groups[i]
								const groupMaterial = material[group.materialIndex]

								if (groupMaterial && groupMaterial.visible) {
									currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group)
								}
							}
						} else if (material.visible) {
							currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null)
						}
					}
				}
			}

			const children = object.children

			for (let i = 0, l = children.length; i < l; i++) {
				projectObject(children[i], camera, groupOrder, sortObjects)
			}
		}

		function renderTransmissiveObjects (opaqueObjects, transmissiveObjects, scene, camera) {
			if (_transmissionRenderTarget === null) {
				const needsAntialias = _antialias === true && capabilities.isWebGL2 === true
				const renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget : WebGLRenderTarget

				_transmissionRenderTarget = new renderTargetType(1024, 1024, {
					generateMipmaps: true,
					type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
					minFilter: LinearMipmapLinearFilter,
					magFilter: NearestFilter,
					wrapS: ClampToEdgeWrapping,
					wrapT: ClampToEdgeWrapping
				})
			}

			const currentRenderTarget = _this.getRenderTarget()
			_this.setRenderTarget(_transmissionRenderTarget)
			_this.clear()

			// Turn off the features which can affect the frag color for opaque objects pass.
			// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
			const currentToneMapping = _this.toneMapping
			_this.toneMapping = NoToneMapping

			renderObjects(opaqueObjects, scene, camera)

			_this.toneMapping = currentToneMapping

			textures.updateMultisampleRenderTarget(_transmissionRenderTarget)
			textures.updateRenderTargetMipmap(_transmissionRenderTarget)

			_this.setRenderTarget(currentRenderTarget)

			renderObjects(transmissiveObjects, scene, camera)
		}

		function renderObjects (renderList, scene, camera) {
			const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null

			if (camera.isArrayCamera) {
				const cameras = camera.cameras

				for (let i = 0, l = cameras.length; i < l; i++) {
					const camera2 = cameras[i]

					state.viewport(_currentViewport.copy(camera2.viewport))

					currentRenderState.setupLightsView(camera2)

					for (let j = 0, jl = renderList.length; j < jl; j++) {
						const renderItem = renderList[j]

						const object = renderItem.object
						const geometry = renderItem.geometry
						const material = overrideMaterial === null ? renderItem.material : overrideMaterial
						const group = renderItem.group

						if (object.layers.test(camera2.layers)) {
							renderObject(object, scene, camera2, geometry, material, group)
						}
					}
				}
			} else {
				for (let j = 0, jl = renderList.length; j < jl; j++) {
					const renderItem = renderList[j]

					const object = renderItem.object
					const geometry = renderItem.geometry
					const material = overrideMaterial === null ? renderItem.material : overrideMaterial
					const group = renderItem.group

					renderObject(object, scene, camera, geometry, material, group)
				}
			}
		}

		function renderObject (object, scene, camera, geometry, material, group) {
			object.onBeforeRender(_this, scene, camera, geometry, material, group)

			object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld)
			object.normalMatrix.getNormalMatrix(object.modelViewMatrix)

			if (object.isImmediateRenderObject) {
				const program = setProgram(camera, scene, material, object)

				state.setMaterial(material)

				bindingStates.reset()

				renderObjectImmediate(object, program)
			} else {
				if (material.transparent === true && material.side === DoubleSide) {
					material.side = BackSide
					material.needsUpdate = true
					_this.renderBufferDirect(camera, scene, geometry, material, object, group)

					material.side = FrontSide
					material.needsUpdate = true
					_this.renderBufferDirect(camera, scene, geometry, material, object, group)

					material.side = DoubleSide
				} else {
					_this.renderBufferDirect(camera, scene, geometry, material, object, group)
				}
			}

			object.onAfterRender(_this, scene, camera, geometry, material, group)
		}

		function getProgram (material, scene, object) {
			if (scene.isScene !== true) scene = _emptyScene // scene could be a Mesh, Line, Points, ...

			const materialProperties = properties.get(material)

			const lights = currentRenderState.state.lights
			const shadowsArray = currentRenderState.state.shadowsArray

			const lightsStateVersion = lights.state.version

			const parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object)
			const programCacheKey = programCache.getProgramCacheKey(parameters)

			let programs = materialProperties.programs

			// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

			materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null
			materialProperties.fog = scene.fog
			materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment)

			if (programs === undefined) {
				// new material

				material.addEventListener('dispose', onMaterialDispose)

				programs = new Map()
				materialProperties.programs = programs
			}

			let program = programs.get(programCacheKey)

			if (program !== undefined) {
				// early out if program and light state is identical

				if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
					updateCommonMaterialProperties(material, parameters)

					return program
				}
			} else {
				parameters.uniforms = programCache.getUniforms(material)

				material.onBuild(parameters, _this)

				material.onBeforeCompile(parameters, _this)

				program = programCache.acquireProgram(parameters, programCacheKey)
				programs.set(programCacheKey, program)

				materialProperties.uniforms = parameters.uniforms
			}

			const uniforms = materialProperties.uniforms

			if ((!material.isShaderMaterial && !material.isRawShaderMaterial) || material.clipping === true) {
				uniforms.clippingPlanes = clipping.uniform
			}

			updateCommonMaterialProperties(material, parameters)

			// store the light setup it was created for

			materialProperties.needsLights = materialNeedsLights(material)
			materialProperties.lightsStateVersion = lightsStateVersion

			if (materialProperties.needsLights) {
				// wire up the material to this renderer's lighting state

				uniforms.ambientLightColor.value = lights.state.ambient
				uniforms.lightProbe.value = lights.state.probe
				uniforms.directionalLights.value = lights.state.directional
				uniforms.directionalLightShadows.value = lights.state.directionalShadow
				uniforms.spotLights.value = lights.state.spot
				uniforms.spotLightShadows.value = lights.state.spotShadow
				uniforms.rectAreaLights.value = lights.state.rectArea
				uniforms.ltc_1.value = lights.state.rectAreaLTC1
				uniforms.ltc_2.value = lights.state.rectAreaLTC2
				uniforms.pointLights.value = lights.state.point
				uniforms.pointLightShadows.value = lights.state.pointShadow
				uniforms.hemisphereLights.value = lights.state.hemi

				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix
				uniforms.spotShadowMap.value = lights.state.spotShadowMap
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix
				uniforms.pointShadowMap.value = lights.state.pointShadowMap
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix
				// TODO (abelnation): add area lights shadow info to uniforms
			}

			const progUniforms = program.getUniforms()
			const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms)

			materialProperties.currentProgram = program
			materialProperties.uniformsList = uniformsList

			return program
		}

		function updateCommonMaterialProperties (material, parameters) {
			const materialProperties = properties.get(material)

			materialProperties.outputEncoding = parameters.outputEncoding
			materialProperties.instancing = parameters.instancing
			materialProperties.skinning = parameters.skinning
			materialProperties.morphTargets = parameters.morphTargets
			materialProperties.morphNormals = parameters.morphNormals
			materialProperties.numClippingPlanes = parameters.numClippingPlanes
			materialProperties.numIntersection = parameters.numClipIntersection
			materialProperties.vertexAlphas = parameters.vertexAlphas
			materialProperties.vertexTangents = parameters.vertexTangents
		}

		function setProgram (camera, scene, material, object) {
			if (scene.isScene !== true) scene = _emptyScene // scene could be a Mesh, Line, Points, ...

			textures.resetTextureUnits()

			const fog = scene.fog
			const environment = material.isMeshStandardMaterial ? scene.environment : null
			const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding
			const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment)
			const vertexAlphas = material.vertexColors === true && !!object.geometry && !!object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4
			const vertexTangents = !!object.geometry && !!object.geometry.attributes.tangent
			const morphTargets = !!object.geometry && !!object.geometry.morphAttributes.position
			const morphNormals = !!object.geometry && !!object.geometry.morphAttributes.normal

			const materialProperties = properties.get(material)
			const lights = currentRenderState.state.lights

			if (_clippingEnabled === true) {
				if (_localClippingEnabled === true || camera !== _currentCamera) {
					const useCache = camera === _currentCamera && material.id === _currentMaterialId

					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					clipping.setState(material, camera, useCache)
				}
			}

			//

			let needsProgramChange = false

			if (material.version === materialProperties.__version) {
				if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
					needsProgramChange = true
				} else if (materialProperties.outputEncoding !== encoding) {
					needsProgramChange = true
				} else if (object.isInstancedMesh && materialProperties.instancing === false) {
					needsProgramChange = true
				} else if (!object.isInstancedMesh && materialProperties.instancing === true) {
					needsProgramChange = true
				} else if (object.isSkinnedMesh && materialProperties.skinning === false) {
					needsProgramChange = true
				} else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
					needsProgramChange = true
				} else if (materialProperties.envMap !== envMap) {
					needsProgramChange = true
				} else if (material.fog && materialProperties.fog !== fog) {
					needsProgramChange = true
				} else if (
					materialProperties.numClippingPlanes !== undefined &&
					(materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)
				) {
					needsProgramChange = true
				} else if (materialProperties.vertexAlphas !== vertexAlphas) {
					needsProgramChange = true
				} else if (materialProperties.vertexTangents !== vertexTangents) {
					needsProgramChange = true
				} else if (materialProperties.morphTargets !== morphTargets) {
					needsProgramChange = true
				} else if (materialProperties.morphNormals !== morphNormals) {
					needsProgramChange = true
				}
			} else {
				needsProgramChange = true
				materialProperties.__version = material.version
			}

			//

			let program = materialProperties.currentProgram

			if (needsProgramChange === true) {
				program = getProgram(material, scene, object)
			}

			let refreshProgram = false
			let refreshMaterial = false
			let refreshLights = false

			const p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.uniforms

			if (state.useProgram(program.program)) {
				refreshProgram = true
				refreshMaterial = true
				refreshLights = true
			}

			if (material.id !== _currentMaterialId) {
				_currentMaterialId = material.id

				refreshMaterial = true
			}

			if (refreshProgram || _currentCamera !== camera) {
				p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix)

				if (capabilities.logarithmicDepthBuffer) {
					p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2))
				}

				if (_currentCamera !== camera) {
					_currentCamera = camera

					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true // set to true on material change
					refreshLights = true // remains set until update done
				}

				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)

				if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
					const uCamPos = p_uniforms.map.cameraPosition

					if (uCamPos !== undefined) {
						uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld))
					}
				}

				if (
					material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial
				) {
					p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true)
				}

				if (
					material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ||
					material.isShadowMaterial ||
					object.isSkinnedMesh
				) {
					p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse)
				}
			}

			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// otherwise textures used for skinning can take over texture units reserved for other material textures

			if (object.isSkinnedMesh) {
				p_uniforms.setOptional(_gl, object, 'bindMatrix')
				p_uniforms.setOptional(_gl, object, 'bindMatrixInverse')

				const skeleton = object.skeleton

				if (skeleton) {
					if (capabilities.floatVertexTextures) {
						if (skeleton.boneTexture === null) skeleton.computeBoneTexture()

						p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures)
						p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize)
					} else {
						p_uniforms.setOptional(_gl, skeleton, 'boneMatrices')
					}
				}
			}

			if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
				materialProperties.receiveShadow = object.receiveShadow
				p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow)
			}

			if (refreshMaterial) {
				p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure)

				if (materialProperties.needsLights) {
					// the current material requires lighting info

					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required

					markUniformsLightsNeedsUpdate(m_uniforms, refreshLights)
				}

				// refresh uniforms common to several materials

				if (fog && material.fog) {
					materials.refreshFogUniforms(m_uniforms, fog)
				}

				materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget)

				WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures)
			}

			if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
				WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures)
				material.uniformsNeedUpdate = false
			}

			if (material.isSpriteMaterial) {
				p_uniforms.setValue(_gl, 'center', object.center)
			}

			// common matrices

			p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix)
			p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix)
			p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld)

			return program
		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate (uniforms, value) {
			uniforms.ambientLightColor.needsUpdate = value
			uniforms.lightProbe.needsUpdate = value

			uniforms.directionalLights.needsUpdate = value
			uniforms.directionalLightShadows.needsUpdate = value
			uniforms.pointLights.needsUpdate = value
			uniforms.pointLightShadows.needsUpdate = value
			uniforms.spotLights.needsUpdate = value
			uniforms.spotLightShadows.needsUpdate = value
			uniforms.rectAreaLights.needsUpdate = value
			uniforms.hemisphereLights.needsUpdate = value
		}

		function materialNeedsLights (material) {
			return (
				material.isMeshLambertMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshPhongMaterial ||
				material.isMeshStandardMaterial ||
				material.isShadowMaterial ||
				(material.isShaderMaterial && material.lights === true)
			)
		}

		this.getActiveCubeFace = function () {
			return _currentActiveCubeFace
		}

		this.getActiveMipmapLevel = function () {
			return _currentActiveMipmapLevel
		}

		this.getRenderTarget = function () {
			return _currentRenderTarget
		}

		this.setRenderTarget = function (renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
			_currentRenderTarget = renderTarget
			_currentActiveCubeFace = activeCubeFace
			_currentActiveMipmapLevel = activeMipmapLevel

			if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
				textures.setupRenderTarget(renderTarget)
			}

			let framebuffer = null
			let isCube = false
			let isRenderTarget3D = false

			if (renderTarget) {
				const texture = renderTarget.texture

				if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
					isRenderTarget3D = true
				}

				const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer

				if (renderTarget.isWebGLCubeRenderTarget) {
					framebuffer = __webglFramebuffer[activeCubeFace]
					isCube = true
				} else if (renderTarget.isWebGLMultisampleRenderTarget) {
					framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer
				} else {
					framebuffer = __webglFramebuffer
				}

				_currentViewport.copy(renderTarget.viewport)
				_currentScissor.copy(renderTarget.scissor)
				_currentScissorTest = renderTarget.scissorTest
			} else {
				_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor()
				_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor()
				_currentScissorTest = _scissorTest
			}

			const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer)

			if (framebufferBound && capabilities.drawBuffers) {
				let needsUpdate = false

				if (renderTarget) {
					if (renderTarget.isWebGLMultipleRenderTargets) {
						const textures = renderTarget.texture

						if (_currentDrawBuffers.length !== textures.length || _currentDrawBuffers[0] !== _gl.COLOR_ATTACHMENT0) {
							for (let i = 0, il = textures.length; i < il; i++) {
								_currentDrawBuffers[i] = _gl.COLOR_ATTACHMENT0 + i
							}

							_currentDrawBuffers.length = textures.length

							needsUpdate = true
						}
					} else {
						if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== _gl.COLOR_ATTACHMENT0) {
							_currentDrawBuffers[0] = _gl.COLOR_ATTACHMENT0
							_currentDrawBuffers.length = 1

							needsUpdate = true
						}
					}
				} else {
					if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== _gl.BACK) {
						_currentDrawBuffers[0] = _gl.BACK
						_currentDrawBuffers.length = 1

						needsUpdate = true
					}
				}

				if (needsUpdate) {
					if (capabilities.isWebGL2) {
						_gl.drawBuffers(_currentDrawBuffers)
					} else {
						extensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(_currentDrawBuffers)
					}
				}
			}

			state.viewport(_currentViewport)
			state.scissor(_currentScissor)
			state.setScissorTest(_currentScissorTest)

			if (isCube) {
				const textureProperties = properties.get(renderTarget.texture)
				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel)
			} else if (isRenderTarget3D) {
				const textureProperties = properties.get(renderTarget.texture)
				const layer = activeCubeFace || 0
				_gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer)
			}
		}

		this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
			if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
				console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.')
				return
			}

			let framebuffer = properties.get(renderTarget).__webglFramebuffer

			if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
				framebuffer = framebuffer[activeCubeFaceIndex]
			}

			if (framebuffer) {
				state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer)

				try {
					const texture = renderTarget.texture
					const textureFormat = texture.format
					const textureType = texture.type

					if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.')
						return
					}

					const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || (capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float')))

					if (
						textureType !== UnsignedByteType &&
						utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
						!(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
						!halfFloatSupportedByExt
					) {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.')
						return
					}

					if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

						if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
							_gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer)
						}
					} else {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.')
					}
				} finally {
					// restore framebuffer of current render target if necessary

					const framebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null
					state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer)
				}
			}
		}

		this.copyFramebufferToTexture = function (position, texture, level = 0) {
			const levelScale = Math.pow(2, -level)
			const width = Math.floor(texture.image.width * levelScale)
			const height = Math.floor(texture.image.height * levelScale)

			let glFormat = utils.convert(texture.format)

			if (capabilities.isWebGL2) {
				// Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100
				// Not needed in Chrome 93+

				if (glFormat === _gl.RGB) glFormat = _gl.RGB8
				if (glFormat === _gl.RGBA) glFormat = _gl.RGBA8
			}

			textures.setTexture2D(texture, 0)

			_gl.copyTexImage2D(_gl.TEXTURE_2D, level, glFormat, position.x, position.y, width, height, 0)

			state.unbindTexture()
		}

		this.copyTextureToTexture = function (position, srcTexture, dstTexture, level = 0) {
			const width = srcTexture.image.width
			const height = srcTexture.image.height
			const glFormat = utils.convert(dstTexture.format)
			const glType = utils.convert(dstTexture.type)

			textures.setTexture2D(dstTexture, 0)

			// As another texture upload may have changed pixelStorei
			// parameters, make sure they are correct for the dstTexture
			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY)
			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha)
			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment)

			if (srcTexture.isDataTexture) {
				_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data)
			} else {
				if (srcTexture.isCompressedTexture) {
					_gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data)
				} else {
					_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image)
				}
			}

			// Generate mipmaps only when copying level 0
			if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D)

			state.unbindTexture()
		}

		this.copyTextureToTexture3D = function (sourceBox, position, srcTexture, dstTexture, level = 0) {
			if (_this.isWebGL1Renderer) {
				console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.')
				return
			}

			const width = sourceBox.max.x - sourceBox.min.x + 1
			const height = sourceBox.max.y - sourceBox.min.y + 1
			const depth = sourceBox.max.z - sourceBox.min.z + 1
			const glFormat = utils.convert(dstTexture.format)
			const glType = utils.convert(dstTexture.type)
			let glTarget

			if (dstTexture.isDataTexture3D) {
				textures.setTexture3D(dstTexture, 0)
				glTarget = _gl.TEXTURE_3D
			} else if (dstTexture.isDataTexture2DArray) {
				textures.setTexture2DArray(dstTexture, 0)
				glTarget = _gl.TEXTURE_2D_ARRAY
			} else {
				console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.')
				return
			}

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY)
			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha)
			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment)

			const unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH)
			const unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT)
			const unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS)
			const unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS)
			const unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES)

			const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image

			_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width)
			_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height)
			_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x)
			_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y)
			_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z)

			if (srcTexture.isDataTexture || srcTexture.isDataTexture3D) {
				_gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data)
			} else {
				if (srcTexture.isCompressedTexture) {
					console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.')
					_gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data)
				} else {
					_gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image)
				}
			}

			_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen)
			_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight)
			_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels)
			_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows)
			_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages)

			// Generate mipmaps only when copying level 0
			if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget)

			state.unbindTexture()
		}

		this.initTexture = function (texture) {
			textures.setTexture2D(texture, 0)

			state.unbindTexture()
		}

		this.resetState = function () {
			_currentActiveCubeFace = 0
			_currentActiveMipmapLevel = 0
			_currentRenderTarget = null

			state.reset()
			bindingStates.reset()
		}

		if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
			__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this })) // eslint-disable-line no-undef
		}
	}

	class GLTFLoader extends Loader {
		dracoLoader
		ktx2Loader
		meshoptDecoder
		pluginCallbacks
		constructor(manager) {
			super(manager)
			this.pluginCallbacks = []
			this.register(function (parser) {
				return new GLTFMaterialsClearcoatExtension(parser)
			})
			this.register(function (parser) {
				return new GLTFTextureBasisUExtension(parser)
			})
			this.register(function (parser) {
				return new GLTFTextureWebPExtension(parser)
			})
			this.register(function (parser) {
				return new GLTFMaterialsTransmissionExtension(parser)
			})
			this.register(function (parser) {
				return new GLTFMaterialsVolumeExtension(parser)
			})
			this.register(function (parser) {
				return new GLTFMaterialsIorExtension(parser)
			})
			this.register(function (parser) {
				return new GLTFMaterialsSpecularExtension(parser)
			})
			this.register(function (parser) {
				return new GLTFLightsExtension(parser)
			})
			this.register(function (parser) {
				return new GLTFMeshoptCompression(parser)
			})
		}
		load (url, onLoad, onProgress, onError) {
			const scope = this
			let resourcePath
			if (this.resourcePath !== '') {
				resourcePath = this.resourcePath
			}
			else if (this.path !== '') {
				resourcePath = this.path
			}
			else {
				resourcePath = LoaderUtils.extractUrlBase(url)
			}
			// Tells the LoadingManager to track an extra item, which resolves after
			// the model is fully loaded. This means the count of items loaded will
			// be incorrect, but ensures manager.onLoad() does not fire early.
			this.manager.itemStart(url)
			const _onError = function (e) {
				if (onError) {
					onError(e)
				}
				else {
					console.error(e)
				}
				scope.manager.itemError(url)
				scope.manager.itemEnd(url)
			}
			const loader = new FileLoader(this.manager)
			loader.setPath(this.path)
			loader.setResponseType('arraybuffer')
			loader.setRequestHeader(this.requestHeader)
			loader.setWithCredentials(this.withCredentials)
			loader.load(url, function (data) {
				try {
					scope.parse(data, resourcePath, function (gltf) {
						onLoad(gltf)
						scope.manager.itemEnd(url)
					}, _onError)
				}
				catch (e) {
					_onError(e)
				}
			}, onProgress, _onError)
		}
		setDRACOLoader (dracoLoader) {
			this.dracoLoader = dracoLoader
			return this
		}
		setDDSLoader () {
			throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
		}
		setKTX2Loader (ktx2Loader) {
			this.ktx2Loader = ktx2Loader
			return this
		}
		setMeshoptDecoder (meshoptDecoder) {
			this.meshoptDecoder = meshoptDecoder
			return this
		}
		register (callback) {
			if (this.pluginCallbacks.indexOf(callback) === -1) {
				this.pluginCallbacks.push(callback)
			}
			return this
		}
		unregister (callback) {
			if (this.pluginCallbacks.indexOf(callback) !== -1) {
				this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1)
			}
			return this
		}
		parse (data, path, onLoad, onError) {
			let content
			const extensions = {}
			const plugins = {}
			if (typeof data === 'string') {
				content = data
			}
			else {
				const magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4))
				if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
					try {
						extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data)
					}
					catch (error) {
						if (onError)
							onError(error)
						return
					}
					content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content
				}
				else {
					content = LoaderUtils.decodeText(new Uint8Array(data))
				}
			}
			const json = JSON.parse(content)
			if (json.asset === undefined || json.asset.version[0] < 2) {
				if (onError)
					onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'))
				return
			}
			const parser = new GLTFParser(json, {
				path: path || this.resourcePath || '',
				crossOrigin: this.crossOrigin,
				requestHeader: this.requestHeader,
				manager: this.manager,
				ktx2Loader: this.ktx2Loader,
				meshoptDecoder: this.meshoptDecoder
			})
			parser.fileLoader.setRequestHeader(this.requestHeader)
			for (let i = 0; i < this.pluginCallbacks.length; i++) {
				const plugin = this.pluginCallbacks[i](parser)
				plugins[plugin.name] = plugin
				// Workaround to avoid determining as unknown extension
				// in addUnknownExtensionsToUserData().
				// Remove this workaround if we move all the existing
				// extension handlers to plugin system
				extensions[plugin.name] = true
			}
			if (json.extensionsUsed) {
				for (let i = 0; i < json.extensionsUsed.length; ++i) {
					const extensionName = json.extensionsUsed[i]
					const extensionsRequired = json.extensionsRequired || []
					switch (extensionName) {
						case EXTENSIONS.KHR_MATERIALS_UNLIT:
							extensions[extensionName] = new GLTFMaterialsUnlitExtension()
							break
						case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
							extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension()
							break
						case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
							extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader)
							break
						case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
							extensions[extensionName] = new GLTFTextureTransformExtension()
							break
						case EXTENSIONS.KHR_MESH_QUANTIZATION:
							extensions[extensionName] = new GLTFMeshQuantizationExtension()
							break
						default:
							if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {
								console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".')
							}
					}
				}
			}
			parser.setExtensions(extensions)
			parser.setPlugins(plugins)
			parser.parse(onLoad, onError)
		}
	}
	/* GLTFREGISTRY */
	class GLTFRegistry {
		objects
		constructor() {
			this.objects = {}
		}
		get (key) {
			return this.objects[key]
		}
		add (key, object) {
			this.objects[key] = object
		}
		remove (key) {
			delete this.objects[key]
		}
		removeAll () {
			this.objects = {}
		}
	}
	/*********************************/
	/********** EXTENSIONS ***********/
	/*********************************/
	const EXTENSIONS = {
		KHR_BINARY_GLTF: 'KHR_binary_glTF',
		KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
		KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
		KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
		KHR_MATERIALS_IOR: 'KHR_materials_ior',
		KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
		KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
		KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
		KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
		KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
		KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
		KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
		KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
		EXT_TEXTURE_WEBP: 'EXT_texture_webp',
		EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
	}
	/**
	 * Punctual Lights Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
	 */
	class GLTFLightsExtension {
		parser
		name
		cache
		constructor(parser) {
			this.parser = parser
			this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL
			// Object3D instance caches
			this.cache = { refs: {}, uses: {} }
		}
		_markDefs () {
			const parser = this.parser
			const nodeDefs = this.parser.json.nodes || []
			for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
				const nodeDef = nodeDefs[nodeIndex]
				if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {
					parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light)
				}
			}
		}
		_loadLight (lightIndex) {
			const parser = this.parser
			const cacheKey = 'light:' + lightIndex
			let dependency = parser.cache.get(cacheKey)
			if (dependency)
				return dependency
			const json = parser.json
			const extensions = (json.extensions && json.extensions[this.name]) || {}
			const lightDefs = extensions.lights || []
			const lightDef = lightDefs[lightIndex]
			let lightNode
			const color = new Color(0xffffff)
			if (lightDef.color !== undefined)
				color.fromArray(lightDef.color)
			const range = lightDef.range !== undefined ? lightDef.range : 0
			switch (lightDef.type) {
				case 'directional':
					lightNode = new DirectionalLight(color)
					lightNode.target.position.set(0, 0, -1)
					lightNode.add(lightNode.target)
					break
				case 'point':
					lightNode = new PointLight(color)
					lightNode.distance = range
					break
				case 'spot':
					lightNode = new SpotLight(color)
					lightNode.distance = range
					// Handle spotlight properties.
					lightDef.spot = lightDef.spot || {}
					lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0
					lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0
					lightNode.angle = lightDef.spot.outerConeAngle
					lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle
					lightNode.target.position.set(0, 0, -1)
					lightNode.add(lightNode.target)
					break
				default:
					throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type)
			}
			// Some lights (e.g. spot) default to a position other than the origin. Reset the position
			// here, because node-level parsing will only override position if explicitly specified.
			lightNode.position.set(0, 0, 0)
			// lightNode.decay = 2
			if (lightDef.intensity !== undefined)
				lightNode.intensity = lightDef.intensity
			lightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex)
			dependency = Promise.resolve(lightNode)
			parser.cache.add(cacheKey, dependency)
			return dependency
		}
		createNodeAttachment (nodeIndex) {
			const self = this
			const parser = this.parser
			const json = parser.json
			const nodeDef = json.nodes[nodeIndex]
			const lightDef = (nodeDef.extensions && nodeDef.extensions[this.name]) || {}
			const lightIndex = lightDef.light
			if (lightIndex === undefined)
				return null
			return this._loadLight(lightIndex).then(function (light) {
				return parser._getNodeRef(self.cache, lightIndex, light)
			})
		}
	}
	/**
	 * Unlit Materials Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
	 */
	class GLTFMaterialsUnlitExtension {
		name
		constructor() {
			this.name = EXTENSIONS.KHR_MATERIALS_UNLIT
		}
		getMaterialType () {
			return MeshBasicMaterial
		}
		extendParams (materialParams, materialDef, parser) {
			const pending = []
			materialParams.color = new Color(1.0, 1.0, 1.0)
			materialParams.opacity = 1.0
			const metallicRoughness = materialDef.pbrMetallicRoughness
			if (metallicRoughness) {
				if (Array.isArray(metallicRoughness.baseColorFactor)) {
					const array = metallicRoughness.baseColorFactor
					materialParams.color.fromArray(array)
					materialParams.opacity = array[3]
				}
				if (metallicRoughness.baseColorTexture !== undefined) {
					pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture))
				}
			}
			return Promise.all(pending)
		}
	}
	/**
	 * Clearcoat Materials Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
	 */
	class GLTFMaterialsClearcoatExtension {
		parser
		name
		constructor(parser) {
			this.parser = parser
			this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT
		}
		getMaterialType (materialIndex) {
			const parser = this.parser
			const materialDef = parser.json.materials[materialIndex]
			if (!materialDef.extensions || !materialDef.extensions[this.name])
				return null
			return MeshPhysicalMaterial
		}
		extendMaterialParams (materialIndex, materialParams) {
			const parser = this.parser
			const materialDef = parser.json.materials[materialIndex]
			if (!materialDef.extensions || !materialDef.extensions[this.name]) {
				return Promise.resolve()
			}
			const pending = []
			const extension = materialDef.extensions[this.name]
			if (extension.clearcoatFactor !== undefined) {
				materialParams.clearcoat = extension.clearcoatFactor
			}
			if (extension.clearcoatTexture !== undefined) {
				pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture))
			}
			if (extension.clearcoatRoughnessFactor !== undefined) {
				materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor
			}
			if (extension.clearcoatRoughnessTexture !== undefined) {
				pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture))
			}
			if (extension.clearcoatNormalTexture !== undefined) {
				pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture))
				if (extension.clearcoatNormalTexture.scale !== undefined) {
					const scale = extension.clearcoatNormalTexture.scale
					// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
					materialParams.clearcoatNormalScale = new Vector2(scale, -scale)
				}
			}
			return Promise.all(pending)
		}
	}
	/**
	 * Transmission Materials Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
	 * Draft: https://github.com/KhronosGroup/glTF/pull/1698
	 */
	class GLTFMaterialsTransmissionExtension {
		parser
		name
		constructor(parser) {
			this.parser = parser
			this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION
		}
		getMaterialType (materialIndex) {
			const parser = this.parser
			const materialDef = parser.json.materials[materialIndex]
			if (!materialDef.extensions || !materialDef.extensions[this.name])
				return null
			return MeshPhysicalMaterial
		}
		extendMaterialParams (materialIndex, materialParams) {
			const parser = this.parser
			const materialDef = parser.json.materials[materialIndex]
			if (!materialDef.extensions || !materialDef.extensions[this.name]) {
				return Promise.resolve()
			}
			const pending = []
			const extension = materialDef.extensions[this.name]
			if (extension.transmissionFactor !== undefined) {
				materialParams.transmission = extension.transmissionFactor
			}
			if (extension.transmissionTexture !== undefined) {
				pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture))
			}
			return Promise.all(pending)
		}
	}
	/**
	 * Materials Volume Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
	 */
	class GLTFMaterialsVolumeExtension {
		parser
		name
		constructor(parser) {
			this.parser = parser
			this.name = EXTENSIONS.KHR_MATERIALS_VOLUME
		}
		getMaterialType (materialIndex) {
			const parser = this.parser
			const materialDef = parser.json.materials[materialIndex]
			if (!materialDef.extensions || !materialDef.extensions[this.name])
				return null
			return MeshPhysicalMaterial
		}
		extendMaterialParams (materialIndex, materialParams) {
			const parser = this.parser
			const materialDef = parser.json.materials[materialIndex]
			if (!materialDef.extensions || !materialDef.extensions[this.name]) {
				return Promise.resolve()
			}
			const pending = []
			const extension = materialDef.extensions[this.name]
			materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0
			if (extension.thicknessTexture !== undefined) {
				pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture))
			}
			materialParams.attenuationDistance = extension.attenuationDistance || 0
			const colorArray = extension.attenuationColor || [1, 1, 1]
			materialParams.attenuationTint = new Color(colorArray[0], colorArray[1], colorArray[2])
			return Promise.all(pending)
		}
	}
	/**
	 * Materials ior Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
	 */
	class GLTFMaterialsIorExtension {
		parser
		name
		constructor(parser) {
			this.parser = parser
			this.name = EXTENSIONS.KHR_MATERIALS_IOR
		}
		getMaterialType (materialIndex) {
			const parser = this.parser
			const materialDef = parser.json.materials[materialIndex]
			if (!materialDef.extensions || !materialDef.extensions[this.name])
				return null
			return MeshPhysicalMaterial
		}
		extendMaterialParams (materialIndex, materialParams) {
			const parser = this.parser
			const materialDef = parser.json.materials[materialIndex]
			if (!materialDef.extensions || !materialDef.extensions[this.name]) {
				return Promise.resolve()
			}
			const extension = materialDef.extensions[this.name]
			materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5
			return Promise.resolve()
		}
	}
	/**
	 * Materials specular Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
	 */
	class GLTFMaterialsSpecularExtension {
		parser
		name
		constructor(parser) {
			this.parser = parser
			this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR
		}
		getMaterialType (materialIndex) {
			const parser = this.parser
			const materialDef = parser.json.materials[materialIndex]
			if (!materialDef.extensions || !materialDef.extensions[this.name])
				return null
			return MeshPhysicalMaterial
		}
		extendMaterialParams (materialIndex, materialParams) {
			const parser = this.parser
			const materialDef = parser.json.materials[materialIndex]
			if (!materialDef.extensions || !materialDef.extensions[this.name]) {
				return Promise.resolve()
			}
			const pending = []
			const extension = materialDef.extensions[this.name]
			materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0
			if (extension.specularTexture !== undefined) {
				pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture))
			}
			const colorArray = extension.specularColorFactor || [1, 1, 1]
			materialParams.specularTint = new Color(colorArray[0], colorArray[1], colorArray[2])
			if (extension.specularColorTexture !== undefined) {
				pending.push(parser.assignTexture(materialParams, 'specularTintMap', extension.specularColorTexture).then(function (texture) {
					texture.encoding = sRGBEncoding
				}))
			}
			return Promise.all(pending)
		}
	}
	/**
	 * BasisU Texture Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
	 */
	class GLTFTextureBasisUExtension {
		parser
		name
		constructor(parser) {
			this.parser = parser
			this.name = EXTENSIONS.KHR_TEXTURE_BASISU
		}
		loadTexture (textureIndex) {
			const parser = this.parser
			const json = parser.json
			const textureDef = json.textures[textureIndex]
			if (!textureDef.extensions || !textureDef.extensions[this.name]) {
				return null
			}
			const extension = textureDef.extensions[this.name]
			const source = json.images[extension.source]
			const loader = parser.options.ktx2Loader
			if (!loader) {
				if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
					throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures')
				}
				else {
					// Assumes that the extension is optional and that a fallback texture is present
					return null
				}
			}
			return parser.loadTextureImage(textureIndex, source, loader)
		}
	}
	/**
	 * WebP Texture Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
	 */
	class GLTFTextureWebPExtension {
		parser
		name
		isSupported
		constructor(parser) {
			this.parser = parser
			this.name = EXTENSIONS.EXT_TEXTURE_WEBP
			this.isSupported = null
		}
		loadTexture (textureIndex) {
			const name = this.name
			const parser = this.parser
			const json = parser.json
			const textureDef = json.textures[textureIndex]
			if (!textureDef.extensions || !textureDef.extensions[name]) {
				return null
			}
			const extension = textureDef.extensions[name]
			const source = json.images[extension.source]
			let loader = parser.textureLoader
			if (source.uri) {
				const handler = parser.options.manager.getHandler(source.uri)
				if (handler !== null)
					loader = handler
			}
			return this.detectSupport().then(function (isSupported) {
				if (isSupported)
					return parser.loadTextureImage(textureIndex, source, loader)
				if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
					throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.')
				}
				// Fall back to PNG or JPEG.
				return parser.loadTexture(textureIndex)
			})
		}
		detectSupport () {
			if (!this.isSupported) {
				this.isSupported = new Promise(function (resolve) {
					const image = new Image()
					// Lossy test image. Support for lossy images doesn't guarantee support for all
					// WebP images, unfortunately.
					image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'
					image.onload = image.onerror = function () {
						resolve(image.height === 1)
					}
				})
			}
			return this.isSupported
		}
	}
	/**
	 * meshopt BufferView Compression Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
	 */
	class GLTFMeshoptCompression {
		parser
		name
		constructor(parser) {
			this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION
			this.parser = parser
		}
		loadBufferView (index) {
			const json = this.parser.json
			const bufferView = json.bufferViews[index]
			if (bufferView.extensions && bufferView.extensions[this.name]) {
				const extensionDef = bufferView.extensions[this.name]
				const buffer = this.parser.getDependency('buffer', extensionDef.buffer)
				const decoder = this.parser.options.meshoptDecoder
				if (!decoder || !decoder.supported) {
					if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
						throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files')
					}
					else {
						// Assumes that the extension is optional and that fallback buffer data is present
						return null
					}
				}
				return Promise.all([buffer, decoder.ready]).then(function (res) {
					const byteOffset = extensionDef.byteOffset || 0
					const byteLength = extensionDef.byteLength || 0
					const count = extensionDef.count
					const stride = extensionDef.byteStride
					const result = new ArrayBuffer(count * stride)
					const source = new Uint8Array(res[0], byteOffset, byteLength)
					decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter)
					return result
				})
			}
			else {
				return null
			}
		}
	}
	/* BINARY EXTENSION */
	const BINARY_EXTENSION_HEADER_MAGIC = 'glTF'
	const BINARY_EXTENSION_HEADER_LENGTH = 12
	const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4e4f534a, BIN: 0x004e4942 }
	class GLTFBinaryExtension {
		name
		content
		body
		header
		constructor(data) {
			this.name = EXTENSIONS.KHR_BINARY_GLTF
			this.content = null
			this.body = null
			const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH)
			this.header = {
				magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
				version: headerView.getUint32(4, true),
				length: headerView.getUint32(8, true)
			}
			if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
				throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.')
			}
			else if (this.header.version < 2.0) {
				throw new Error('THREE.GLTFLoader: Legacy binary file detected.')
			}
			const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH
			const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH)
			let chunkIndex = 0
			while (chunkIndex < chunkContentsLength) {
				const chunkLength = chunkView.getUint32(chunkIndex, true)
				chunkIndex += 4
				const chunkType = chunkView.getUint32(chunkIndex, true)
				chunkIndex += 4
				if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
					const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength)
					this.content = LoaderUtils.decodeText(contentArray)
				}
				else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
					const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex
					this.body = data.slice(byteOffset, byteOffset + chunkLength)
				}
				// Clients must ignore chunks with unknown types.
				chunkIndex += chunkLength
			}
			if (this.content === null) {
				throw new Error('THREE.GLTFLoader: JSON content not found.')
			}
		}
	}
	/**
	 * DRACO Mesh Compression Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
	 */
	class GLTFDracoMeshCompressionExtension {
		name
		json
		dracoLoader
		constructor(json, dracoLoader) {
			if (!dracoLoader) {
				throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.')
			}
			this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION
			this.json = json
			this.dracoLoader = dracoLoader
			this.dracoLoader.preload()
		}
		decodePrimitive (primitive, parser) {
			const json = this.json
			const dracoLoader = this.dracoLoader
			const bufferViewIndex = primitive.extensions[this.name].bufferView
			const gltfAttributeMap = primitive.extensions[this.name].attributes
			const threeAttributeMap = {}
			const attributeNormalizedMap = {}
			const attributeTypeMap = {}
			for (const attributeName in gltfAttributeMap) {
				const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase()
				threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName]
			}
			for (const attributeName in primitive.attributes) {
				const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase()
				if (gltfAttributeMap[attributeName] !== undefined) {
					const accessorDef = json.accessors[primitive.attributes[attributeName]]
					const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType]
					attributeTypeMap[threeAttributeName] = componentType
					attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true
				}
			}
			return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {
				return new Promise(function (resolve) {
					dracoLoader.decodeDracoFile(bufferView, function (geometry) {
						for (const attributeName in geometry.attributes) {
							const attribute = geometry.attributes[attributeName]
							const normalized = attributeNormalizedMap[attributeName]
							if (normalized !== undefined)
								attribute.normalized = normalized
						}
						resolve(geometry)
					}, threeAttributeMap, attributeTypeMap)
				})
			})
		}
	}
	/**
	 * Texture Transform Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
	 */
	class GLTFTextureTransformExtension {
		name
		constructor() {
			this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM
		}
		extendTexture (texture, transform) {
			if (transform.texCoord !== undefined) {
				console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.')
			}
			if (transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined) {
				// See https://github.com/mrdoob/three.js/issues/21819.
				return texture
			}
			texture = texture.clone()
			if (transform.offset !== undefined) {
				texture.offset.fromArray(transform.offset)
			}
			if (transform.rotation !== undefined) {
				texture.rotation = transform.rotation
			}
			if (transform.scale !== undefined) {
				texture.repeat.fromArray(transform.scale)
			}
			texture.needsUpdate = true
			return texture
		}
	}
	/**
	 * Specular-Glossiness Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
	 */
	/**
	 * A sub class of StandardMaterial with some of the functionality
	 * changed via the `onBeforeCompile` callback
	 * @pailhead
	 */
	class GLTFMeshStandardSGMaterial extends MeshStandardMaterial {
		isGLTFSpecularGlossinessMaterial
		_extraUniforms
		specularMap
		specular
		glossinessMap
		glossiness
		constructor(params) {
			super()
			this.isGLTFSpecularGlossinessMaterial = true
			//various chunks that need replacing
			const specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '	uniform sampler2D specularMap;', '#endif'].join('\n')
			const glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '	uniform sampler2D glossinessMap;', '#endif'].join('\n')
			const specularMapFragmentChunk = [
				'vec3 specularFactor = specular;',
				'#ifdef USE_SPECULARMAP',
				'	vec4 texelSpecular = texture2D( specularMap, vUv );',
				'	texelSpecular = sRGBToLinear( texelSpecular );',
				'	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
				'	specularFactor *= texelSpecular.rgb;',
				'#endif'
			].join('\n')
			const glossinessMapFragmentChunk = [
				'float glossinessFactor = glossiness;',
				'#ifdef USE_GLOSSINESSMAP',
				'	vec4 texelGlossiness = texture2D( glossinessMap, vUv );',
				'	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
				'	glossinessFactor *= texelGlossiness.a;',
				'#endif'
			].join('\n')
			const lightPhysicalFragmentChunk = [
				'PhysicalMaterial material;',
				'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
				'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
				'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
				'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
				'material.specularRoughness += geometryRoughness;',
				'material.specularRoughness = min( material.specularRoughness, 1.0 );',
				'material.specularColor = specularFactor;'
			].join('\n')
			const uniforms = {
				specular: { value: new Color().setHex(0xffffff) },
				glossiness: { value: 1 },
				specularMap: { value: null },
				glossinessMap: { value: null }
			}
			this._extraUniforms = uniforms
			this.onBeforeCompile = function (shader) {
				for (const uniformName in uniforms) {
					shader.uniforms[uniformName] = uniforms[uniformName]
				}
				shader.fragmentShader = shader.fragmentShader
					.replace('uniform float roughness;', 'uniform vec3 specular;')
					.replace('uniform float metalness;', 'uniform float glossiness;')
					.replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk)
					.replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk)
					.replace('#include <roughnessmap_fragment>', specularMapFragmentChunk)
					.replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk)
					.replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk)
			}
			Object.defineProperties(this, {
				specular: {
					get: function () {
						return uniforms.specular.value
					},
					set: function (v) {
						uniforms.specular.value = v
					}
				},
				specularMap: {
					get: function () {
						return uniforms.specularMap.value
					},
					set: function (v) {
						uniforms.specularMap.value = v
						if (v) {
							this.defines.USE_SPECULARMAP = '' // USE_UV is set by the renderer for specular maps
						}
						else {
							delete this.defines.USE_SPECULARMAP
						}
					}
				},
				glossiness: {
					get: function () {
						return uniforms.glossiness.value
					},
					set: function (v) {
						uniforms.glossiness.value = v
					}
				},
				glossinessMap: {
					get: function () {
						return uniforms.glossinessMap.value
					},
					set: function (v) {
						uniforms.glossinessMap.value = v
						if (v) {
							this.defines.USE_GLOSSINESSMAP = ''
							this.defines.USE_UV = ''
						}
						else {
							delete this.defines.USE_GLOSSINESSMAP
							delete this.defines.USE_UV
						}
					}
				}
			})
			// delete this.metalness
			// delete this.roughness
			// delete this.metalnessMap
			// delete this.roughnessMap
			this.setValues(params)
		}
		copy (source) {
			super.copy(source)
			this.specularMap = source.specularMap
			this.specular.copy(source.specular)
			this.glossinessMap = source.glossinessMap
			this.glossiness = source.glossiness
			// delete this.metalness
			// delete this.roughness
			// delete this.metalnessMap
			// delete this.roughnessMap
			return this
		}
	}
	class GLTFMaterialsPbrSpecularGlossinessExtension {
		name
		specularGlossinessParams
		constructor() {
			this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS
			this.specularGlossinessParams = [
				'color',
				'map',
				'lightMap',
				'lightMapIntensity',
				'aoMap',
				'aoMapIntensity',
				'emissive',
				'emissiveIntensity',
				'emissiveMap',
				'bumpMap',
				'bumpScale',
				'normalMap',
				'normalMapType',
				'displacementMap',
				'displacementScale',
				'displacementBias',
				'specularMap',
				'specular',
				'glossinessMap',
				'glossiness',
				'alphaMap',
				'envMap',
				'envMapIntensity',
				'refractionRatio'
			]
		}
		getMaterialType () {
			return GLTFMeshStandardSGMaterial
		}
		extendParams (materialParams, materialDef, parser) {
			const pbrSpecularGlossiness = materialDef.extensions[this.name]
			materialParams.color = new Color(1.0, 1.0, 1.0)
			materialParams.opacity = 1.0
			const pending = []
			if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
				const array = pbrSpecularGlossiness.diffuseFactor
				materialParams.color.fromArray(array)
				materialParams.opacity = array[3]
			}
			if (pbrSpecularGlossiness.diffuseTexture !== undefined) {
				pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture))
			}
			materialParams.emissive = new Color(0.0, 0.0, 0.0)
			materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0
			materialParams.specular = new Color(1.0, 1.0, 1.0)
			if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
				materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor)
			}
			if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {
				const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture
				pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef))
				pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef))
			}
			return Promise.all(pending)
		}
		createMaterial (materialParams) {
			const material = new GLTFMeshStandardSGMaterial(materialParams)
			material.fog = true
			material.color = materialParams.color
			material.map = materialParams.map === undefined ? null : materialParams.map
			material.lightMap = null
			material.lightMapIntensity = 1.0
			material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap
			material.aoMapIntensity = 1.0
			material.emissive = materialParams.emissive
			material.emissiveIntensity = 1.0
			material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap
			material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap
			material.bumpScale = 1
			material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap
			material.normalMapType = TangentSpaceNormalMap
			if (materialParams.normalScale)
				material.normalScale = materialParams.normalScale
			material.displacementMap = null
			material.displacementScale = 1
			material.displacementBias = 0
			material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap
			material.specular = materialParams.specular
			material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap
			material.glossiness = materialParams.glossiness
			material.alphaMap = null
			material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap
			material.envMapIntensity = 1.0
			material.refractionRatio = 0.98
			return material
		}
	}
	/**
	 * Mesh Quantization Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
	 */
	class GLTFMeshQuantizationExtension {
		name
		constructor() {
			this.name = EXTENSIONS.KHR_MESH_QUANTIZATION
		}
	}
	/*********************************/
	/********** INTERPOLATION ********/
	/*********************************/
	// Spline Interpolation
	// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
	class GLTFCubicSplineInterpolant extends Interpolant {
		beforeStart_
		afterEnd_
		interpolate_
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			super(parameterPositions, sampleValues, sampleSize, resultBuffer)
		}
		copySampleValue_ (index) {
			// Copies a sample value to the result buffer. See description of glTF
			// CUBICSPLINE values layout in interpolate_() function below.
			const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize
			for (let i = 0; i !== valueSize; i++) {
				result[i] = values[offset + i]
			}
			return result
		}
	}
	GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_
	GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_
	GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
		const result = this.resultBuffer
		const values = this.sampleValues
		const stride = this.valueSize
		const stride2 = stride * 2
		const stride3 = stride * 3
		const td = t1 - t0
		const p = (t - t0) / td
		const pp = p * p
		const ppp = pp * p
		const offset1 = i1 * stride3
		const offset0 = offset1 - stride3
		const s2 = -2 * ppp + 3 * pp
		const s3 = ppp - pp
		const s0 = 1 - s2
		const s1 = s3 - pp + p
		// Layout of keyframe output values for CUBICSPLINE animations:
		//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
		for (let i = 0; i !== stride; i++) {
			const p0 = values[offset0 + i + stride] // splineVertex_k
			const m0 = values[offset0 + i + stride2] * td // outTangent_k * (t_k+1 - t_k)
			const p1 = values[offset1 + i + stride] // splineVertex_k+1
			const m1 = values[offset1 + i] * td // inTangent_k+1 * (t_k+1 - t_k)
			result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1
		}
		return result
	}
	/*********************************/
	/********** INTERNALS ************/
	/*********************************/
	/* CONSTANTS */
	const WEBGL_CONSTANTS = {
		FLOAT: 5126,
		//FLOAT_MAT2: 35674,
		FLOAT_MAT3: 35675,
		FLOAT_MAT4: 35676,
		FLOAT_VEC2: 35664,
		FLOAT_VEC3: 35665,
		FLOAT_VEC4: 35666,
		LINEAR: 9729,
		REPEAT: 10497,
		SAMPLER_2D: 35678,
		POINTS: 0,
		LINES: 1,
		LINE_LOOP: 2,
		LINE_STRIP: 3,
		TRIANGLES: 4,
		TRIANGLE_STRIP: 5,
		TRIANGLE_FAN: 6,
		UNSIGNED_BYTE: 5121,
		UNSIGNED_SHORT: 5123
	}
	const WEBGL_COMPONENT_TYPES = {
		5120: Int8Array,
		5121: Uint8Array,
		5122: Int16Array,
		5123: Uint16Array,
		5125: Uint32Array,
		5126: Float32Array
	}
	const WEBGL_FILTERS = {
		9728: NearestFilter,
		9729: LinearFilter,
		9984: NearestMipmapNearestFilter,
		9985: LinearMipmapNearestFilter,
		9986: NearestMipmapLinearFilter,
		9987: LinearMipmapLinearFilter
	}
	const WEBGL_WRAPPINGS = {
		33071: ClampToEdgeWrapping,
		33648: MirroredRepeatWrapping,
		10497: RepeatWrapping
	}
	const WEBGL_TYPE_SIZES = {
		SCALAR: 1,
		VEC2: 2,
		VEC3: 3,
		VEC4: 4,
		MAT2: 4,
		MAT3: 9,
		MAT4: 16
	}
	const ATTRIBUTES = {
		POSITION: 'position',
		NORMAL: 'normal',
		TANGENT: 'tangent',
		TEXCOORD_0: 'uv',
		TEXCOORD_1: 'uv2',
		COLOR_0: 'color',
		WEIGHTS_0: 'skinWeight',
		JOINTS_0: 'skinIndex'
	}
	const PATH_PROPERTIES = {
		scale: 'scale',
		translation: 'position',
		rotation: 'quaternion',
		weights: 'morphTargetInfluences'
	}
	const INTERPOLATION = {
		CUBICSPLINE: undefined,
		// keyframe track will be initialized with a default interpolation type, then modified.
		LINEAR: InterpolateLinear,
		STEP: InterpolateDiscrete
	}
	const ALPHA_MODES = {
		OPAQUE: 'OPAQUE',
		MASK: 'MASK',
		BLEND: 'BLEND'
	}
	/* UTILITY FUNCTIONS */
	function resolveURL (url, path) {
		// Invalid URL
		if (typeof url !== 'string' || url === '')
			return ''
		// Host Relative URL
		if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
			path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1')
		}
		// Absolute URL http://,https://,//
		if (/^(https?:)?\/\//i.test(url))
			return url
		// Data URI
		if (/^data:.*,.*$/i.test(url))
			return url
		// Blob URL
		if (/^blob:.*$/i.test(url))
			return url
		// Relative URL
		return path + url
	}
	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
	 */
	function createDefaultMaterial (cache) {
		if (cache['DefaultMaterial'] === undefined) {
			cache['DefaultMaterial'] = new MeshStandardMaterial({
				color: 0xffffff,
				emissive: 0x000000,
				metalness: 1,
				roughness: 1,
				transparent: false,
				depthTest: true,
				side: FrontSide
			})
		}
		return cache['DefaultMaterial']
	}
	function addUnknownExtensionsToUserData (knownExtensions, object, objectDef) {
		// Add unknown glTF extensions to an object's userData.
		for (const name in objectDef.extensions) {
			if (knownExtensions[name] === undefined) {
				object.userData.gltfExtensions = object.userData.gltfExtensions || {}
				object.userData.gltfExtensions[name] = objectDef.extensions[name]
			}
		}
	}
	/**
	 * @param {Object3D|Material|BufferGeometry} object
	 * @param {GLTF.definition} gltfDef
	 */
	function assignExtrasToUserData (object, gltfDef) {
		if (gltfDef.extras !== undefined) {
			if (typeof gltfDef.extras === 'object') {
				Object.assign(object.userData, gltfDef.extras)
			}
			else {
				console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras)
			}
		}
	}
	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
	 *
	 * @param {BufferGeometry} geometry
	 * @param {Array<GLTF.Target>} targets
	 * @param {GLTFParser} parser
	 * @return {Promise<BufferGeometry>}
	 */
	function addMorphTargets (geometry, targets, parser) {
		let hasMorphPosition = false
		let hasMorphNormal = false
		for (let i = 0, il = targets.length; i < il; i++) {
			const target = targets[i]
			if (target.POSITION !== undefined)
				hasMorphPosition = true
			if (target.NORMAL !== undefined)
				hasMorphNormal = true
			if (hasMorphPosition && hasMorphNormal)
				break
		}
		if (!hasMorphPosition && !hasMorphNormal)
			return Promise.resolve(geometry)
		const pendingPositionAccessors = []
		const pendingNormalAccessors = []
		for (let i = 0, il = targets.length; i < il; i++) {
			const target = targets[i]
			if (hasMorphPosition) {
				const pendingAccessor = target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position
				pendingPositionAccessors.push(pendingAccessor)
			}
			if (hasMorphNormal) {
				const pendingAccessor = target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal
				pendingNormalAccessors.push(pendingAccessor)
			}
		}
		return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function (accessors) {
			const morphPositions = accessors[0]
			const morphNormals = accessors[1]
			if (hasMorphPosition)
				geometry.morphAttributes.position = morphPositions
			if (hasMorphNormal)
				geometry.morphAttributes.normal = morphNormals
			geometry.morphTargetsRelative = true
			return geometry
		})
	}
	/**
	 * @param {Mesh} mesh
	 * @param {GLTF.Mesh} meshDef
	 */
	function updateMorphTargets (mesh, meshDef) {
		mesh.updateMorphTargets()
		if (meshDef.weights !== undefined) {
			for (let i = 0, il = meshDef.weights.length; i < il; i++) {
				mesh.morphTargetInfluences[i] = meshDef.weights[i]
			}
		}
		// .extras has user-defined data, so check that .extras.targetNames is an array.
		if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
			const targetNames = meshDef.extras.targetNames
			if (mesh.morphTargetInfluences.length === targetNames.length) {
				mesh.morphTargetDictionary = {}
				for (let i = 0, il = targetNames.length; i < il; i++) {
					mesh.morphTargetDictionary[targetNames[i]] = i
				}
			}
			else {
				console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.')
			}
		}
	}
	function createPrimitiveKey (primitiveDef) {
		const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]
		let geometryKey
		if (dracoExtension) {
			geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes)
		}
		else {
			geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode
		}
		return geometryKey
	}
	function createAttributesKey (attributes) {
		let attributesKey = ''
		const keys = Object.keys(attributes).sort()
		for (let i = 0, il = keys.length; i < il; i++) {
			attributesKey += keys[i] + ':' + attributes[keys[i]] + ';'
		}
		return attributesKey
	}
	function getNormalizedComponentScale (constructor) {
		// Reference:
		// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data
		switch (constructor) {
			case Int8Array:
				return 1 / 127
			case Uint8Array:
				return 1 / 255
			case Int16Array:
				return 1 / 32767
			case Uint16Array:
				return 1 / 65535
			default:
				throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.')
		}
	}
	/* GLTF PARSER */
	class GLTFParser {
		json
		extensions
		plugins
		options
		cache
		associations
		primitiveCache
		meshCache
		cameraCache
		lightCache
		textureCache
		nodeNamesUsed
		textureLoader
		fileLoader
		constructor(json = {}, options = {}) {
			this.json = json
			this.extensions = {}
			this.plugins = {}
			this.options = options
			// loader object cache
			this.cache = new GLTFRegistry()
			// associations between Three.js objects and glTF elements
			this.associations = new Map()
			// BufferGeometry caching
			this.primitiveCache = {}
			// Object3D instance caches
			this.meshCache = { refs: {}, uses: {} }
			this.cameraCache = { refs: {}, uses: {} }
			this.lightCache = { refs: {}, uses: {} }
			this.textureCache = {}
			// Track node names, to ensure no duplicates
			this.nodeNamesUsed = {}
			// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
			// expensive work of uploading a texture to the GPU off the main thread.
			if (typeof createImageBitmap !== 'undefined' && /Firefox/.test(navigator.userAgent) === false) {
				this.textureLoader = new ImageBitmapLoader(this.options.manager)
			}
			else {
				this.textureLoader = new TextureLoader(this.options.manager)
			}
			this.textureLoader.setCrossOrigin(this.options.crossOrigin)
			this.textureLoader.setRequestHeader(this.options.requestHeader)
			this.fileLoader = new FileLoader(this.options.manager)
			this.fileLoader.setResponseType('arraybuffer')
			if (this.options.crossOrigin === 'use-credentials') {
				this.fileLoader.setWithCredentials(true)
			}
		}
		setExtensions (extensions) {
			this.extensions = extensions
		}
		setPlugins (plugins) {
			this.plugins = plugins
		}
		parse (onLoad, onError) {
			const parser = this
			const json = this.json
			const extensions = this.extensions
			// Clear the loader cache
			this.cache.removeAll()
			// pre processing
			// assignInstancingMeshes(this.json)
			// Mark the special nodes/meshes in json for efficient parse
			this._invokeAll(function (ext) {
				return ext._markDefs && ext._markDefs()
			})
			Promise.all(this._invokeAll(function (ext) {
				return ext.beforeRoot && ext.beforeRoot()
			}))
				.then(function () {
					return Promise.all([parser.getDependencies('scene'), parser.getDependencies('animation'), parser.getDependencies('camera')])
				})
				.then(function (dependencies) {
					const result = {
						scene: dependencies[0][json.scene || 0],
						scenes: dependencies[0],
						animations: dependencies[1],
						cameras: dependencies[2],
						asset: json.asset,
						parser: parser,
						userData: {}
					}
					addUnknownExtensionsToUserData(extensions, result, json)
					assignExtrasToUserData(result, json)
					Promise.all(parser._invokeAll(function (ext) {
						return ext.afterRoot && ext.afterRoot(result)
					})).then(function () {
						onLoad(result)
					})
				})
				.catch(onError)
		}
		/**
		 * Marks the special nodes/meshes in json for efficient parse.
		 */
		_markDefs () {
			const nodeDefs = this.json.nodes || []
			const skinDefs = this.json.skins || []
			const meshDefs = this.json.meshes || []
			// Nothing in the node definition indicates whether it is a Bone or an
			// Object3D. Use the skins' joint references to mark bones.
			for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
				const joints = skinDefs[skinIndex].joints
				for (let i = 0, il = joints.length; i < il; i++) {
					nodeDefs[joints[i]].isBone = true
				}
			}
			// Iterate over all nodes, marking references to shared resources,
			// as well as skeleton joints.
			for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
				const nodeDef = nodeDefs[nodeIndex]
				if (nodeDef.mesh !== undefined) {
					this._addNodeRef(this.meshCache, nodeDef.mesh)
					// Nothing in the mesh definition indicates whether it is
					// a SkinnedMesh or Mesh. Use the node's mesh reference
					// to mark SkinnedMesh if node has skin.
					if (nodeDef.skin !== undefined) {
						meshDefs[nodeDef.mesh].isSkinnedMesh = true
					}
				}
				if (nodeDef.camera !== undefined) {
					this._addNodeRef(this.cameraCache, nodeDef.camera)
				}
			}
		}
		/**
		 * Counts references to shared node / Object3D resources. These resources
		 * can be reused, or "instantiated", at multiple nodes in the scene
		 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
		 * be marked. Non-scenegraph resources (like Materials, Geometries, and
		 * Textures) can be reused directly and are not marked here.
		 *
		 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
		 */
		_addNodeRef (cache, index) {
			if (index === undefined)
				return
			if (cache.refs[index] === undefined) {
				cache.refs[index] = cache.uses[index] = 0
			}
			cache.refs[index]++
		}
		/** Returns a reference to a shared resource, cloning it if necessary. */
		_getNodeRef (cache, index, object) {
			if (cache.refs[index] <= 1) {
				cache.uses[index]++
				return object
			}
			const ref = object.clone()
			ref.name = object.name + '_instance_' + cache.uses[index]++
			return ref
		}
		_invokeOne (func) {
			const extensions = Object.values(this.plugins)
			extensions.push(this)
			for (let i = 0; i < extensions.length; i++) {
				const result = func(extensions[i])
				if (result)
					return result
			}
			return null
		}
		_invokeAll (func) {
			const extensions = Object.values(this.plugins)
			extensions.unshift(this)
			const pending = []
			for (let i = 0; i < extensions.length; i++) {
				const result = func(extensions[i])
				if (result)
					pending.push(result)
			}
			return pending
		}
		/**
		 * Requests the specified dependency asynchronously, with caching.
		 * @param {string} type
		 * @param {number} index
		 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
		 */
		getDependency (type, index, joints) {
			const cacheKey = type + ':' + index
			let dependency = this.cache.get(cacheKey)
			if (!dependency) {
				switch (type) {
					case 'scene':
						dependency = this.loadScene(index)
						break
					case 'node':
						dependency = this.loadNode(index)
						break
					case 'mesh':
						dependency = this._invokeOne(function (ext) {
							return ext.loadMesh && ext.loadMesh(index)
						})
						break
					case 'accessor':
						dependency = this.loadAccessor(index)
						break
					case 'bufferView':
						dependency = this._invokeOne(function (ext) {
							return ext.loadBufferView && ext.loadBufferView(index)
						})
						break
					case 'buffer':
						dependency = this.loadBuffer(index)
						break
					case 'material':
						dependency = this._invokeOne(function (ext) {
							return ext.loadMaterial && ext.loadMaterial(index)
						})
						break
					case 'texture':
						dependency = this._invokeOne(function (ext) {
							return ext.loadTexture && ext.loadTexture(index)
						})
						break
					case 'skin':
						dependency = this.loadSkin(index)
						break
					case 'animation':
						dependency = this.loadAnimation(index)
						break
					case 'camera':
						dependency = this.loadCamera(index)
						break
					default:
						throw new Error('Unknown type: ' + type)
				}
				this.cache.add(cacheKey, dependency)
			}
			return dependency
		}
		/**
		 * Requests all dependencies of the specified type asynchronously, with caching.
		 * @param {string} type
		 * @return {Promise<Array<Object>>}
		 */
		getDependencies (type) {
			let dependencies = this.cache.get(type)
			if (!dependencies) {
				const parser = this
				const defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || []
				dependencies = Promise.all(defs.map(function (def, index) {
					return parser.getDependency(type, index)
				}))
				this.cache.add(type, dependencies)
			}
			return dependencies
		}
		/**
		 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
		 * @param {number} bufferIndex
		 * @return {Promise<ArrayBuffer>}
		 */
		loadBuffer (bufferIndex) {
			const bufferDef = this.json.buffers[bufferIndex]
			const loader = this.fileLoader
			if (bufferDef.type && bufferDef.type !== 'arraybuffer') {
				throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.')
			}
			// If present, GLB container is required to be the first buffer.
			if (bufferDef.uri === undefined && bufferIndex === 0) {
				return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body)
			}
			const options = this.options
			return new Promise(function (resolve, reject) {
				loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {
					reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'))
				})
			})
		}
		/**
		 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
		 * @param {number} bufferViewIndex
		 * @return {Promise<ArrayBuffer>}
		 */
		loadBufferView (bufferViewIndex) {
			const bufferViewDef = this.json.bufferViews[bufferViewIndex]
			return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {
				const byteLength = bufferViewDef.byteLength || 0
				const byteOffset = bufferViewDef.byteOffset || 0
				return buffer.slice(byteOffset, byteOffset + byteLength)
			})
		}
		/**
		 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
		 * @param {number} accessorIndex
		 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
		 */
		loadAccessor (accessorIndex) {
			const parser = this
			const json = this.json
			const accessorDef = this.json.accessors[accessorIndex]
			// console.log('accessorDef' , accessorDef, json , accessorIndex)
			if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {
				// Ignore empty accessors, which may be used to declare runtime
				// information about attributes coming from another source (e.g. Draco
				// compression extension).
				return Promise.resolve(null)
			}
			const pendingBufferViews = []
			if (accessorDef.bufferView !== undefined) {
				pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView))
			}
			else {
				pendingBufferViews.push(null)
			}
			if (accessorDef.sparse !== undefined) {
				pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView))
				pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView))
			}
			return Promise.all(pendingBufferViews).then(function (bufferViews) {
				const bufferView = bufferViews[0]
				const itemSize = WEBGL_TYPE_SIZES[accessorDef.type]
				const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]
				// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
				const elementBytes = TypedArray.BYTES_PER_ELEMENT
				const itemBytes = elementBytes * itemSize
				const byteOffset = accessorDef.byteOffset || 0
				const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined
				const normalized = accessorDef.normalized === true
				let array, bufferAttribute
				// The buffer is not interleaved if the stride is the item size in bytes.
				if (byteStride && byteStride !== itemBytes) {
					// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
					// This makes sure that IBA.count reflects accessor.count properly
					const ibSlice = Math.floor(byteOffset / byteStride)
					const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count
					let ib = parser.cache.get(ibCacheKey)
					if (!ib) {
						array = new TypedArray(bufferView, ibSlice * byteStride, (accessorDef.count * byteStride) / elementBytes)
						// Integer parameters to IB/IBA are in array elements, not bytes.
						ib = new InterleavedBuffer(array, byteStride / elementBytes)
						parser.cache.add(ibCacheKey, ib)
					}
					bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, (byteOffset % byteStride) / elementBytes, normalized)
				}
				else {
					if (bufferView === null) {
						array = new TypedArray(accessorDef.count * itemSize)
					}
					else {
						array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize)
					}
					bufferAttribute = new BufferAttribute(array, itemSize, normalized)
				}
				// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
				if (accessorDef.sparse !== undefined) {
					const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR
					const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType]
					const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0
					const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0
					const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices)
					const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize)
					if (bufferView !== null) {
						// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
						bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized)
					}
					for (let i = 0, il = sparseIndices.length; i < il; i++) {
						const index = sparseIndices[i]
						bufferAttribute.setX(index, sparseValues[i * itemSize])
						if (itemSize >= 2)
							bufferAttribute.setY(index, sparseValues[i * itemSize + 1])
						if (itemSize >= 3)
							bufferAttribute.setZ(index, sparseValues[i * itemSize + 2])
						if (itemSize >= 4)
							bufferAttribute.setW(index, sparseValues[i * itemSize + 3])
						if (itemSize >= 5)
							throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.')
					}
				}
				return bufferAttribute
			})
		}
		/**
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
		 * @param {number} textureIndex
		 * @return {Promise<THREE.Texture>}
		 */
		loadTexture (textureIndex) {
			const json = this.json
			const options = this.options
			const textureDef = json.textures[textureIndex]
			const source = json.images[textureDef.source]
			let loader = this.textureLoader
			if (source.uri) {
				const handler = options.manager.getHandler(source.uri)
				if (handler !== null)
					loader = handler
			}
			return this.loadTextureImage(textureIndex, source, loader)
		}
		loadTextureImage (textureIndex, source, loader) {
			const parser = this
			const json = this.json
			const options = this.options
			const textureDef = json.textures[textureIndex]
			const cacheKey = (source.uri || source.bufferView) + ':' + textureDef.sampler
			if (this.textureCache[cacheKey]) {
				// See https://github.com/mrdoob/three.js/issues/21559.
				return this.textureCache[cacheKey]
			}
			const URL = self.URL || self.webkitURL
			let sourceURI = source.uri || ''
			let isObjectURL = false
			let hasAlpha = true
			const isJPEG = sourceURI.search(/\.jpe?g($|\?)/i) > 0 || sourceURI.search(/^data\:image\/jpeg/) === 0
			if (source.mimeType === 'image/jpeg' || isJPEG)
				hasAlpha = false
			if (source.bufferView !== undefined) {
				// Load binary image data from bufferView, if provided.
				sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {
					if (source.mimeType === 'image/png') {
						// Inspect the PNG 'IHDR' chunk to determine whether the image could have an
						// alpha channel. This check is conservative  the image could have an alpha
						// channel with all values == 1, and the indexed type (colorType == 3) only
						// sometimes contains alpha.
						//
						// https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header
						const colorType = new DataView(bufferView, 25, 1).getUint8(0)
						hasAlpha = colorType === 6 || colorType === 4 || colorType === 3
					}
					isObjectURL = true
					const blob = new Blob([bufferView], { type: source.mimeType })
					sourceURI = URL.createObjectURL(blob)
					return sourceURI
				})
			}
			else if (source.uri === undefined) {
				throw new Error('THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView')
			}
			const promise = Promise.resolve(sourceURI)
				.then(function (sourceURI) {
					return new Promise(function (resolve, reject) {
						let onLoad = resolve
						if (loader.isImageBitmapLoader === true) {
							onLoad = function (imageBitmap) {
								const texture = new Texture(imageBitmap)
								texture.needsUpdate = true
								resolve(texture)
							}
						}
						loader.load(resolveURL(sourceURI, options.path), onLoad, undefined, reject)
					})
				})
				.then(function (texture) {
					// Clean up resources and configure Texture.
					if (isObjectURL === true) {
						URL.revokeObjectURL(sourceURI)
					}
					texture.flipY = false
					if (textureDef.name)
						texture.name = textureDef.name
					// When there is definitely no alpha channel in the texture, set RGBFormat to save space.
					if (!hasAlpha)
						texture.format = RGBFormat
					const samplers = json.samplers || {}
					const sampler = samplers[textureDef.sampler] || {}
					texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter
					texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter
					texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping
					texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping
					parser.associations.set(texture, {
						type: 'textures',
						index: textureIndex
					})
					return texture
				})
				.catch(function () {
					console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI)
					return null
				})
			this.textureCache[cacheKey] = promise
			return promise
		}
		/**
		 * Asynchronously assigns a texture to the given material parameters.
		 * @param {Object} materialParams
		 * @param {string} mapName
		 * @param {Object} mapDef
		 * @return {Promise<Texture>}
		 */
		assignTexture (materialParams, mapName, mapDef) {
			const parser = this
			return this.getDependency('texture', mapDef.index).then(function (texture) {
				// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
				// However, we will copy UV set 0 to UV set 1 on demand for aoMap
				if (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !(mapName === 'aoMap' && mapDef.texCoord == 1)) {
					console.warn('THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.')
				}
				if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
					const transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined
					if (transform) {
						const gltfReference = parser.associations.get(texture)
						texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform)
						parser.associations.set(texture, gltfReference)
					}
				}
				materialParams[mapName] = texture
				return texture
			})
		}
		/**
		 * Assigns final material to a Mesh, Line, or Points instance. The instance
		 * already has a material (generated from the glTF material options alone)
		 * but reuse of the same glTF material may require multiple threejs materials
		 * to accommodate different primitive types, defines, etc. New materials will
		 * be created if necessary, and reused from a cache.
		 * @param  {Object3D} mesh Mesh, Line, or Points instance.
		 */
		assignFinalMaterial (mesh) {
			const geometry = mesh.geometry
			let material = mesh.material
			const useVertexTangents = geometry.attributes.tangent !== undefined
			const useVertexColors = geometry.attributes.color !== undefined
			const useFlatShading = geometry.attributes.normal === undefined
			if (mesh.isPoints) {
				const cacheKey = 'PointsMaterial:' + material.uuid
				let pointsMaterial = this.cache.get(cacheKey)
				if (!pointsMaterial) {
					pointsMaterial = new PointsMaterial()
					Material.prototype.copy.call(pointsMaterial, material)
					pointsMaterial.color.copy(material.color)
					pointsMaterial.map = material.map
					pointsMaterial.sizeAttenuation = false // glTF spec says points should be 1px
					this.cache.add(cacheKey, pointsMaterial)
				}
				material = pointsMaterial
			}
			else if (mesh.isLine) {
				const cacheKey = 'LineBasicMaterial:' + material.uuid
				let lineMaterial = this.cache.get(cacheKey)
				if (!lineMaterial) {
					lineMaterial = new LineBasicMaterial()
					Material.prototype.copy.call(lineMaterial, material)
					lineMaterial.color.copy(material.color)
					this.cache.add(cacheKey, lineMaterial)
				}
				material = lineMaterial
			}
			// Clone the material if it will be modified
			if (useVertexTangents || useVertexColors || useFlatShading) {
				let cacheKey = 'ClonedMaterial:' + material.uuid + ':'
				if (material.isGLTFSpecularGlossinessMaterial)
					cacheKey += 'specular-glossiness:'
				if (useVertexTangents)
					cacheKey += 'vertex-tangents:'
				if (useVertexColors)
					cacheKey += 'vertex-colors:'
				if (useFlatShading)
					cacheKey += 'flat-shading:'
				let cachedMaterial = this.cache.get(cacheKey)
				if (!cachedMaterial) {
					cachedMaterial = material.clone()
					if (useVertexColors)
						cachedMaterial.vertexColors = true
					if (useFlatShading)
						cachedMaterial.flatShading = true
					if (useVertexTangents) {
						// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
						if (cachedMaterial.normalScale)
							cachedMaterial.normalScale.y *= -1
						if (cachedMaterial.clearcoatNormalScale)
							cachedMaterial.clearcoatNormalScale.y *= -1
					}
					this.cache.add(cacheKey, cachedMaterial)
					this.associations.set(cachedMaterial, this.associations.get(material))
				}
				material = cachedMaterial
			}
			// workarounds for mesh and geometry
			if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {
				geometry.setAttribute('uv2', geometry.attributes.uv)
			}
			mesh.material = material
		}
		getMaterialType ( /* materialIndex */) {
			return MeshStandardMaterial
		}
		/**
		 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
		 * @param {number} materialIndex
		 * @return {Promise<Material>}
		 */
		loadMaterial (materialIndex) {
			const parser = this
			const json = this.json
			const extensions = this.extensions
			const materialDef = json.materials[materialIndex]
			let materialType
			const materialParams = {}
			const materialExtensions = materialDef.extensions || {}
			const pending = []
			if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
				const sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]
				materialType = sgExtension.getMaterialType()
				pending.push(sgExtension.extendParams(materialParams, materialDef, parser))
			}
			else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
				const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT]
				materialType = kmuExtension.getMaterialType()
				pending.push(kmuExtension.extendParams(materialParams, materialDef, parser))
			}
			else {
				// Specification:
				// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material
				const metallicRoughness = materialDef.pbrMetallicRoughness || {}
				materialParams.color = new Color(1.0, 1.0, 1.0)
				materialParams.opacity = 1.0
				if (Array.isArray(metallicRoughness.baseColorFactor)) {
					const array = metallicRoughness.baseColorFactor
					materialParams.color.fromArray(array)
					materialParams.opacity = array[3]
				}
				if (metallicRoughness.baseColorTexture !== undefined) {
					pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture))
				}
				materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0
				materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0
				if (metallicRoughness.metallicRoughnessTexture !== undefined) {
					pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture))
					pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture))
				}
				materialType = this._invokeOne(function (ext) {
					return ext.getMaterialType && ext.getMaterialType(materialIndex)
				})
				pending.push(Promise.all(this._invokeAll(function (ext) {
					return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams)
				})))
			}
			if (materialDef.doubleSided === true) {
				materialParams.side = DoubleSide
			}
			const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE
			if (alphaMode === ALPHA_MODES.BLEND) {
				materialParams.transparent = true
				// See: https://github.com/mrdoob/three.js/issues/17706
				materialParams.depthWrite = false
			}
			else {
				materialParams.transparent = false
				if (alphaMode === ALPHA_MODES.MASK) {
					materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5
				}
			}
			if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial) {
				pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture))
				// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
				materialParams.normalScale = new Vector2(1, -1)
				if (materialDef.normalTexture.scale !== undefined) {
					materialParams.normalScale.set(materialDef.normalTexture.scale, -materialDef.normalTexture.scale)
				}
			}
			if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial) {
				pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture))
				if (materialDef.occlusionTexture.strength !== undefined) {
					materialParams.aoMapIntensity = materialDef.occlusionTexture.strength
				}
			}
			if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial) {
				materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor)
			}
			if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial) {
				pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture))
			}
			return Promise.all(pending).then(function () {
				let material
				if (materialType === GLTFMeshStandardSGMaterial) {
					material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams)
				}
				else {
					material = new materialType(materialParams)
				}
				if (materialDef.name)
					material.name = materialDef.name
				// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.
				if (material.map)
					material.map.encoding = sRGBEncoding
				if (material.emissiveMap)
					material.emissiveMap.encoding = sRGBEncoding
				assignExtrasToUserData(material, materialDef)
				parser.associations.set(material, { type: 'materials', index: materialIndex })
				if (materialDef.extensions)
					addUnknownExtensionsToUserData(extensions, material, materialDef)
				return material
			})
		}
		/** When Object3D instances are targeted by animation, they need unique names. */
		createUniqueName (originalName) {
			const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || '')
			let name = sanitizedName
			for (let i = 1; this.nodeNamesUsed[name]; ++i) {
				name = sanitizedName + '_' + i
			}
			this.nodeNamesUsed[name] = true
			return name
		}
		/**
		 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
		 *
		 * Creates BufferGeometries from primitives.
		 *
		 * @param {Array<GLTF.Primitive>} primitives
		 * @return {Promise<Array<BufferGeometry>>}
		 */
		loadGeometries (primitives) {
			const parser = this
			const extensions = this.extensions
			const cache = this.primitiveCache
			function createDracoPrimitive (primitive) {
				return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {
					return addPrimitiveAttributes(geometry, primitive, parser)
				})
			}
			const pending = []
			for (let i = 0, il = primitives.length; i < il; i++) {
				const primitive = primitives[i]
				const cacheKey = createPrimitiveKey(primitive)
				// See if we've already created this geometry
				const cached = cache[cacheKey]
				if (cached) {
					// Use the cached geometry if it exists
					pending.push(cached.promise)
				}
				else {
					let geometryPromise
					if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
						// Use DRACO geometry if available
						geometryPromise = createDracoPrimitive(primitive)
					}
					else {
						// Otherwise create a new geometry
						geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser)
					}
					// Cache this geometry
					cache[cacheKey] = { primitive: primitive, promise: geometryPromise }
					pending.push(geometryPromise)
				}
			}
			return Promise.all(pending)
		}
		/**
		 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
		 * @param {number} meshIndex
		 * @return {Promise<Group|Mesh|SkinnedMesh>}
		 */
		loadMesh (meshIndex) {
			const parser = this
			const json = this.json
			const extensions = this.extensions
			const meshDef = json.meshes[meshIndex]
			const primitives = meshDef.primitives
			const pending = []
			for (let i = 0, il = primitives.length; i < il; i++) {
				const material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency('material', primitives[i].material)
				pending.push(material)
			}
			pending.push(parser.loadGeometries(primitives))
			return Promise.all(pending).then(function (results) {
				const materials = results.slice(0, results.length - 1)
				const geometries = results[results.length - 1]
				const meshes = []
				for (let i = 0, il = geometries.length; i < il; i++) {
					const geometry = geometries[i]
					const primitive = primitives[i]
					// 1. create Mesh
					let mesh
					const material = materials[i]
					if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {
						// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
						mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material)
						if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {
							// we normalize floating point skin weight array to fix malformed assets (see #15319)
							// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
							mesh.normalizeSkinWeights()
						}
						if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
							mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode)
						}
						else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
							mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode)
						}
					}
					else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
						mesh = new LineSegments(geometry, material)
					}
					else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
						mesh = new Line(geometry, material)
					}
					else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
						mesh = new LineLoop(geometry, material)
					}
					else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
						mesh = new Points(geometry, material)
					}
					else {
						throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode)
					}
					if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
						updateMorphTargets(mesh, meshDef)
					}
					mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex)
					assignExtrasToUserData(mesh, meshDef)
					if (primitive.extensions)
						addUnknownExtensionsToUserData(extensions, mesh, primitive)
					parser.assignFinalMaterial(mesh)
					meshes.push(mesh)
				}
				if (meshes.length === 1) {
					return meshes[0]
				}
				const group = new Group$1()
				for (let i = 0, il = meshes.length; i < il; i++) {
					group.add(meshes[i])
				}
				return group
			})
		}
		/**
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
		 * @param {number} cameraIndex
		 * @return {Promise<THREE.Camera>}
		 */
		loadCamera (cameraIndex) {
			let camera
			const cameraDef = this.json.cameras[cameraIndex]
			const params = cameraDef[cameraDef.type]
			if (!params) {
				console.warn('THREE.GLTFLoader: Missing camera parameters.')
				return
			}
			if (cameraDef.type === 'perspective') {
				camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6)
			}
			else if (cameraDef.type === 'orthographic') {
				camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar)
			}
			if (cameraDef.name)
				camera.name = this.createUniqueName(cameraDef.name)
			assignExtrasToUserData(camera, cameraDef)
			return Promise.resolve(camera)
		}
		/**
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
		 * @param {number} skinIndex
		 * @return {Promise<Object>}
		 */
		loadSkin (skinIndex) {
			const skinDef = this.json.skins[skinIndex]
			const skinEntry = { joints: skinDef.joints }
			if (skinDef.inverseBindMatrices === undefined) {
				return Promise.resolve(skinEntry)
			}
			return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {
				skinEntry.inverseBindMatrices = accessor
				return skinEntry
			})
		}
		/**
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
		 * @param {number} animationIndex
		 * @return {Promise<AnimationClip>}
		 */
		loadAnimation (animationIndex) {
			const json = this.json
			const animationDef = json.animations[animationIndex]
			const pendingNodes = []
			const pendingInputAccessors = []
			const pendingOutputAccessors = []
			const pendingSamplers = []
			const pendingTargets = []
			for (let i = 0, il = animationDef.channels.length; i < il; i++) {
				const channel = animationDef.channels[i]
				const sampler = animationDef.samplers[channel.sampler]
				const target = channel.target
				const name = target.node !== undefined ? target.node : target.id // NOTE: target.id is deprecated.
				const input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input
				const output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output
				pendingNodes.push(this.getDependency('node', name))
				pendingInputAccessors.push(this.getDependency('accessor', input))
				pendingOutputAccessors.push(this.getDependency('accessor', output))
				pendingSamplers.push(sampler)
				pendingTargets.push(target)
			}
			return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {
				const nodes = dependencies[0]
				const inputAccessors = dependencies[1]
				const outputAccessors = dependencies[2]
				const samplers = dependencies[3]
				const targets = dependencies[4]
				const tracks = []
				for (let i = 0, il = nodes.length; i < il; i++) {
					const node = nodes[i]
					const inputAccessor = inputAccessors[i]
					const outputAccessor = outputAccessors[i]
					const sampler = samplers[i]
					const target = targets[i]
					if (node === undefined)
						continue
					node.updateMatrix()
					node.matrixAutoUpdate = true
					let TypedKeyframeTrack
					switch (PATH_PROPERTIES[target.path]) {
						case PATH_PROPERTIES.weights:
							TypedKeyframeTrack = NumberKeyframeTrack
							break
						case PATH_PROPERTIES.rotation:
							TypedKeyframeTrack = QuaternionKeyframeTrack
							break
						//   case PATH_PROPERTIES.position:
						case PATH_PROPERTIES.scale:
						default:
							TypedKeyframeTrack = VectorKeyframeTrack
							break
					}
					const targetName = node.name ? node.name : node.uuid
					const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear
					const targetNames = []
					if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
						// Node may be a Group (glTF mesh with several primitives) or a Mesh.
						node.traverse(function (object) {
							if (object.isMesh === true && object.morphTargetInfluences) {
								targetNames.push(object.name ? object.name : object.uuid)
							}
						})
					}
					else {
						targetNames.push(targetName)
					}
					let outputArray = outputAccessor.array
					if (outputAccessor.normalized) {
						const scale = getNormalizedComponentScale(outputArray.constructor)
						const scaled = new Float32Array(outputArray.length)
						for (let j = 0, jl = outputArray.length; j < jl; j++) {
							scaled[j] = outputArray[j] * scale
						}
						outputArray = scaled
					}
					for (let j = 0, jl = targetNames.length; j < jl; j++) {
						const track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation)
						// Override interpolation with custom factory method.
						if (sampler.interpolation === 'CUBICSPLINE') {
							track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline (result) {
								// A CUBICSPLINE keyframe in glTF has three output values for each input value,
								// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
								// must be divided by three to get the interpolant's sampleSize argument.
								return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result)
							}
							// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
							track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true
						}
						tracks.push(track)
					}
				}
				const name = animationDef.name ? animationDef.name : 'animation_' + animationIndex
				return new AnimationClip(name, undefined, tracks)
			})
		}
		createNodeMesh (nodeIndex) {
			const json = this.json
			const parser = this
			const nodeDef = json.nodes[nodeIndex]
			if (nodeDef.mesh === undefined)
				return null
			return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {
				const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh)
				// if weights are provided on the node, override weights on the mesh.
				if (nodeDef.weights !== undefined) {
					node.traverse(function (o) {
						if (!o.isMesh)
							return
						for (let i = 0, il = nodeDef.weights.length; i < il; i++) {
							o.morphTargetInfluences[i] = nodeDef.weights[i]
						}
					})
				}
				return node
			})
		}
		/**
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
		 * @param {number} nodeIndex
		 * @return {Promise<Object3D>}
		 */
		loadNode (nodeIndex) {
			const json = this.json
			const extensions = this.extensions
			const parser = this
			const nodeDef = json.nodes[nodeIndex]
			// reserve node's name before its dependencies, so the root has the intended name.
			const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : ''
			return (function () {
				const pending = []
				const meshPromise = parser._invokeOne(function (ext) {
					return ext.createNodeMesh && ext.createNodeMesh(nodeIndex)
				})
				if (meshPromise) {
					pending.push(meshPromise)
				}
				if (nodeDef.camera !== undefined) {
					pending.push(parser.getDependency('camera', nodeDef.camera).then(function (camera) {
						return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera)
					}))
				}
				parser
					._invokeAll(function (ext) {
						return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex)
					})
					.forEach(function (promise) {
						pending.push(promise)
					})
				return Promise.all(pending)
			})().then(function (objects) {
				let node
				// .isBone isn't in glTF spec. See ._markDefs
				if (nodeDef.isBone === true) {
					node = new Bone()
				}
				else if (objects.length > 1) {
					node = new Group$1()
				}
				else if (objects.length === 1) {
					node = objects[0]
				}
				else {
					node = new Object3D()
				}
				if (node !== objects[0]) {
					for (let i = 0, il = objects.length; i < il; i++) {
						node.add(objects[i])
					}
				}
				if (nodeDef.name) {
					node.userData.name = nodeDef.name
					node.name = nodeName
				}
				assignExtrasToUserData(node, nodeDef)
				if (nodeDef.extensions)
					addUnknownExtensionsToUserData(extensions, node, nodeDef)
				if (nodeDef.matrix !== undefined) {
					const matrix = new Matrix4()
					matrix.fromArray(nodeDef.matrix)
					node.applyMatrix4(matrix)
				}
				else {
					if (nodeDef.translation !== undefined) {
						node.position.fromArray(nodeDef.translation)
					}
					if (nodeDef.rotation !== undefined) {
						node.quaternion.fromArray(nodeDef.rotation)
					}
					if (nodeDef.scale !== undefined) {
						node.scale.fromArray(nodeDef.scale)
					}
				}
				parser.associations.set(node, { type: 'nodes', index: nodeIndex })
				return node
			})
		}
		/**
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
		 * @param {number} sceneIndex
		 * @return {Promise<Group>}
		 */
		loadScene (sceneIndex) {
			const json = this.json
			const extensions = this.extensions
			const sceneDef = this.json.scenes[sceneIndex]
			const parser = this
			// Loader returns Group, not Scene.
			// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
			const scene = new Group$1()
			if (sceneDef.name)
				scene.name = parser.createUniqueName(sceneDef.name)
			assignExtrasToUserData(scene, sceneDef)
			if (sceneDef.extensions)
				addUnknownExtensionsToUserData(extensions, scene, sceneDef)
			const nodeIds = sceneDef.nodes || []
			const pending = []
			for (let i = 0, il = nodeIds.length; i < il; i++) {
				pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser))
			}
			return Promise.all(pending).then(function () {
				return scene
			})
		}
	}
	function buildNodeHierachy (nodeId, parentObject, json, parser) {
		const nodeDef = json.nodes[nodeId]
		return parser
			.getDependency('node', nodeId)
			.then(function (node) {
				if (nodeDef.skin === undefined)
					return node
				// build skeleton here as well
				let skinEntry
				return parser
					.getDependency('skin', nodeDef.skin)
					.then(function (skin) {
						skinEntry = skin
						const pendingJoints = []
						for (let i = 0, il = skinEntry.joints.length; i < il; i++) {
							pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]))
						}
						return Promise.all(pendingJoints)
					})
					.then(function (jointNodes) {
						node.traverse(function (mesh) {
							if (!mesh.isMesh)
								return
							const bones = []
							const boneInverses = []
							for (let j = 0, jl = jointNodes.length; j < jl; j++) {
								const jointNode = jointNodes[j]
								if (jointNode) {
									bones.push(jointNode)
									const mat = new Matrix4()
									if (skinEntry.inverseBindMatrices !== undefined) {
										mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16)
									}
									boneInverses.push(mat)
								}
								else {
									console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j])
								}
							}
							mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld)
						})
						return node
					})
			})
			.then(function (node) {
				// build node hierachy
				parentObject.add(node)
				const pending = []
				if (nodeDef.children) {
					const children = nodeDef.children
					for (let i = 0, il = children.length; i < il; i++) {
						const child = children[i]
						pending.push(buildNodeHierachy(child, node, json, parser))
					}
				}
				return Promise.all(pending)
			})
	}
	/**
	 * @param {BufferGeometry} geometry
	 * @param {GLTF.Primitive} primitiveDef
	 * @param {GLTFParser} parser
	 */
	function computeBounds (geometry, primitiveDef, parser) {
		const attributes = primitiveDef.attributes
		const box = new Box3()
		if (attributes.POSITION !== undefined) {
			const accessor = parser.json.accessors[attributes.POSITION]
			const min = accessor.min
			const max = accessor.max
			// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.
			if (min !== undefined && max !== undefined) {
				box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]))
				if (accessor.normalized) {
					const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType])
					box.min.multiplyScalar(boxScale)
					box.max.multiplyScalar(boxScale)
				}
			}
			else {
				console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')
				return
			}
		}
		else {
			return
		}
		const targets = primitiveDef.targets
		if (targets !== undefined) {
			const maxDisplacement = new Vector3()
			const vector = new Vector3()
			for (let i = 0, il = targets.length; i < il; i++) {
				const target = targets[i]
				if (target.POSITION !== undefined) {
					const accessor = parser.json.accessors[target.POSITION]
					const min = accessor.min
					const max = accessor.max
					// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.
					if (min !== undefined && max !== undefined) {
						// we need to get max of absolute components because target weight is [-1,1]
						vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])))
						vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])))
						vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])))
						if (accessor.normalized) {
							const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType])
							vector.multiplyScalar(boxScale)
						}
						// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
						// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
						// are used to implement key-frame animations and as such only two are active at a time - this results in very large
						// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
						maxDisplacement.max(vector)
					}
					else {
						console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')
					}
				}
			}
			// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
			box.expandByVector(maxDisplacement)
		}
		geometry.boundingBox = box
		const sphere = new Sphere()
		box.getCenter(sphere.center)
		sphere.radius = box.min.distanceTo(box.max) / 2
		geometry.boundingSphere = sphere
	}
	/**
	 * @param {BufferGeometry} geometry
	 * @param {GLTF.Primitive} primitiveDef
	 * @param {GLTFParser} parser
	 * @return {Promise<BufferGeometry>}
	 */
	function addPrimitiveAttributes (geometry, primitiveDef, parser) {
		const attributes = primitiveDef.attributes
		const pending = []
		function assignAttributeAccessor (accessorIndex, attributeName) {
			return parser.getDependency('accessor', accessorIndex).then(function (accessor) {
				geometry.setAttribute(attributeName, accessor)
			})
		}
		for (const gltfAttributeName in attributes) {
			const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase()
			// Skip attributes already provided by e.g. Draco extension.
			if (threeAttributeName in geometry.attributes)
				continue
			pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName))
		}
		if (primitiveDef.indices !== undefined && !geometry.index) {
			const accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {
				geometry.setIndex(accessor)
			})
			pending.push(accessor)
		}
		assignExtrasToUserData(geometry, primitiveDef)
		computeBounds(geometry, primitiveDef, parser)
		return Promise.all(pending).then(function () {
			return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry
		})
	}
	/**
	 * @param {BufferGeometry} geometry
	 * @param {Number} drawMode
	 * @return {BufferGeometry}
	 */
	function toTrianglesDrawMode (geometry, drawMode) {
		let index = geometry.getIndex()
		// generate index if not present
		if (index === null) {
			const indices = []
			const position = geometry.getAttribute('position')
			if (position !== undefined) {
				for (let i = 0; i < position.count; i++) {
					indices.push(i)
				}
				geometry.setIndex(indices)
				index = geometry.getIndex()
			}
			else {
				console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.')
				return geometry
			}
		}
		//
		const numberOfTriangles = index.count - 2
		const newIndices = []
		if (drawMode === TriangleFanDrawMode) {
			// gl.TRIANGLE_FAN
			for (let i = 1; i <= numberOfTriangles; i++) {
				newIndices.push(index.getX(0))
				newIndices.push(index.getX(i))
				newIndices.push(index.getX(i + 1))
			}
		}
		else {
			// gl.TRIANGLE_STRIP
			for (let i = 0; i < numberOfTriangles; i++) {
				if (i % 2 === 0) {
					newIndices.push(index.getX(i))
					newIndices.push(index.getX(i + 1))
					newIndices.push(index.getX(i + 2))
				}
				else {
					newIndices.push(index.getX(i + 2))
					newIndices.push(index.getX(i + 1))
					newIndices.push(index.getX(i))
				}
			}
		}
		if (newIndices.length / 3 !== numberOfTriangles) {
			console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.')
		}
		// build final geometry
		const newGeometry = geometry.clone()
		newGeometry.setIndex(newIndices)
		return newGeometry
	}

	// o object_name | g group_name
	const _object_pattern = /^[og]\s*(.+)?/
	// mtllib file_reference
	const _material_library_pattern = /^mtllib /
	// usemtl material_name
	const _material_use_pattern = /^usemtl /
	// usemap map_name
	const _map_use_pattern = /^usemap /

	const _vA = new Vector3()
	const _vB = new Vector3()
	const _vC = new Vector3()

	const _ab = new Vector3()
	const _cb = new Vector3()

	function ParserState () {

		const state = {
			objects: [],
			object: {},

			vertices: [],
			normals: [],
			colors: [],
			uvs: [],

			materials: {},
			materialLibraries: [],

			startObject: function (name, fromDeclaration) {

				// If the current object (initial from reset) is not from a g/o declaration in the parsed
				// file. We need to use it for the first parsed g/o to keep things in sync.
				if (this.object && this.object.fromDeclaration === false) {

					this.object.name = name
					this.object.fromDeclaration = (fromDeclaration !== false)
					return

				}

				const previousMaterial = (this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined)

				if (this.object && typeof this.object._finalize === 'function') {

					this.object._finalize(true)

				}

				this.object = {
					name: name || '',
					fromDeclaration: (fromDeclaration !== false),

					geometry: {
						vertices: [],
						normals: [],
						colors: [],
						uvs: [],
						hasUVIndices: false
					},
					materials: [],
					smooth: true,

					startMaterial: function (name, libraries) {

						const previous = this._finalize(false)

						// New usemtl declaration overwrites an inherited material, except if faces were declared
						// after the material, then it must be preserved for proper MultiMaterial continuation.
						if (previous && (previous.inherited || previous.groupCount <= 0)) {

							this.materials.splice(previous.index, 1)

						}

						const material = {
							index: this.materials.length,
							name: name || '',
							mtllib: (Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : ''),
							smooth: (previous !== undefined ? previous.smooth : this.smooth),
							groupStart: (previous !== undefined ? previous.groupEnd : 0),
							groupEnd: - 1,
							groupCount: - 1,
							inherited: false,

							clone: function (index) {

								const cloned = {
									index: (typeof index === 'number' ? index : this.index),
									name: this.name,
									mtllib: this.mtllib,
									smooth: this.smooth,
									groupStart: 0,
									groupEnd: - 1,
									groupCount: - 1,
									inherited: false
								}
								cloned.clone = this.clone.bind(cloned)
								return cloned

							}
						}

						this.materials.push(material)

						return material

					},

					currentMaterial: function () {

						if (this.materials.length > 0) {

							return this.materials[this.materials.length - 1]

						}

						return undefined

					},

					_finalize: function (end) {

						const lastMultiMaterial = this.currentMaterial()
						if (lastMultiMaterial && lastMultiMaterial.groupEnd === - 1) {

							lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3
							lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart
							lastMultiMaterial.inherited = false

						}

						// Ignore objects tail materials if no face declarations followed them before a new o/g started.
						if (end && this.materials.length > 1) {

							for (let mi = this.materials.length - 1; mi >= 0; mi--) {

								if (this.materials[mi].groupCount <= 0) {

									this.materials.splice(mi, 1)

								}

							}

						}

						// Guarantee at least one empty material, this makes the creation later more straight forward.
						if (end && this.materials.length === 0) {

							this.materials.push({
								name: '',
								smooth: this.smooth
							})

						}

						return lastMultiMaterial

					}
				}

				// Inherit previous objects material.
				// Spec tells us that a declared material must be set to all objects until a new material is declared.
				// If a usemtl declaration is encountered while this new object is being parsed, it will
				// overwrite the inherited material. Exception being that there was already face declarations
				// to the inherited material, then it will be preserved for proper MultiMaterial continuation.

				if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {

					const declared = previousMaterial.clone(0)
					declared.inherited = true
					this.object.materials.push(declared)

				}

				this.objects.push(this.object)

			},

			finalize: function () {

				if (this.object && typeof this.object._finalize === 'function') {

					this.object._finalize(true)

				}

			},

			parseVertexIndex: function (value, len) {

				const index = parseInt(value, 10)
				return (index >= 0 ? index - 1 : index + len / 3) * 3

			},

			parseNormalIndex: function (value, len) {

				const index = parseInt(value, 10)
				return (index >= 0 ? index - 1 : index + len / 3) * 3

			},

			parseUVIndex: function (value, len) {

				const index = parseInt(value, 10)
				return (index >= 0 ? index - 1 : index + len / 2) * 2

			},

			addVertex: function (a, b, c) {

				const src = this.vertices
				const dst = this.object.geometry.vertices

				dst.push(src[a + 0], src[a + 1], src[a + 2])
				dst.push(src[b + 0], src[b + 1], src[b + 2])
				dst.push(src[c + 0], src[c + 1], src[c + 2])

			},

			addVertexPoint: function (a) {

				const src = this.vertices
				const dst = this.object.geometry.vertices

				dst.push(src[a + 0], src[a + 1], src[a + 2])

			},

			addVertexLine: function (a) {

				const src = this.vertices
				const dst = this.object.geometry.vertices

				dst.push(src[a + 0], src[a + 1], src[a + 2])

			},

			addNormal: function (a, b, c) {

				const src = this.normals
				const dst = this.object.geometry.normals

				dst.push(src[a + 0], src[a + 1], src[a + 2])
				dst.push(src[b + 0], src[b + 1], src[b + 2])
				dst.push(src[c + 0], src[c + 1], src[c + 2])

			},

			addFaceNormal: function (a, b, c) {

				const src = this.vertices
				const dst = this.object.geometry.normals

				_vA.fromArray(src, a)
				_vB.fromArray(src, b)
				_vC.fromArray(src, c)

				_cb.subVectors(_vC, _vB)
				_ab.subVectors(_vA, _vB)
				_cb.cross(_ab)

				_cb.normalize()

				dst.push(_cb.x, _cb.y, _cb.z)
				dst.push(_cb.x, _cb.y, _cb.z)
				dst.push(_cb.x, _cb.y, _cb.z)

			},

			addColor: function (a, b, c) {

				const src = this.colors
				const dst = this.object.geometry.colors

				if (src[a] !== undefined) dst.push(src[a + 0], src[a + 1], src[a + 2])
				if (src[b] !== undefined) dst.push(src[b + 0], src[b + 1], src[b + 2])
				if (src[c] !== undefined) dst.push(src[c + 0], src[c + 1], src[c + 2])

			},

			addUV: function (a, b, c) {

				const src = this.uvs
				const dst = this.object.geometry.uvs

				dst.push(src[a + 0], src[a + 1])
				dst.push(src[b + 0], src[b + 1])
				dst.push(src[c + 0], src[c + 1])

			},

			addDefaultUV: function () {

				const dst = this.object.geometry.uvs

				dst.push(0, 0)
				dst.push(0, 0)
				dst.push(0, 0)

			},

			addUVLine: function (a) {

				const src = this.uvs
				const dst = this.object.geometry.uvs

				dst.push(src[a + 0], src[a + 1])

			},

			addFace: function (a, b, c, ua, ub, uc, na, nb, nc) {

				const vLen = this.vertices.length

				let ia = this.parseVertexIndex(a, vLen)
				let ib = this.parseVertexIndex(b, vLen)
				let ic = this.parseVertexIndex(c, vLen)

				this.addVertex(ia, ib, ic)
				this.addColor(ia, ib, ic)

				// normals

				if (na !== undefined && na !== '') {

					const nLen = this.normals.length

					ia = this.parseNormalIndex(na, nLen)
					ib = this.parseNormalIndex(nb, nLen)
					ic = this.parseNormalIndex(nc, nLen)

					this.addNormal(ia, ib, ic)

				} else {

					this.addFaceNormal(ia, ib, ic)

				}

				// uvs

				if (ua !== undefined && ua !== '') {

					const uvLen = this.uvs.length

					ia = this.parseUVIndex(ua, uvLen)
					ib = this.parseUVIndex(ub, uvLen)
					ic = this.parseUVIndex(uc, uvLen)

					this.addUV(ia, ib, ic)

					this.object.geometry.hasUVIndices = true

				} else {

					// add placeholder values (for inconsistent face definitions)

					this.addDefaultUV()

				}

			},

			addPointGeometry: function (vertices) {

				this.object.geometry.type = 'Points'

				const vLen = this.vertices.length

				for (let vi = 0, l = vertices.length; vi < l; vi++) {

					const index = this.parseVertexIndex(vertices[vi], vLen)

					this.addVertexPoint(index)
					this.addColor(index)

				}

			},

			addLineGeometry: function (vertices, uvs) {

				this.object.geometry.type = 'Line'

				const vLen = this.vertices.length
				const uvLen = this.uvs.length

				for (let vi = 0, l = vertices.length; vi < l; vi++) {

					this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen))

				}

				for (let uvi = 0, l = uvs.length; uvi < l; uvi++) {

					this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen))

				}

			}

		}

		state.startObject('', false)

		return state

	}

	//

	class OBJLoader extends Loader {

		constructor(manager) {

			super(manager)

			this.materials = null

		}

		load (url, onLoad, onProgress, onError) {

			const scope = this

			const loader = new FileLoader(this.manager)
			loader.setPath(this.path)
			loader.setRequestHeader(this.requestHeader)
			loader.setWithCredentials(this.withCredentials)
			loader.load(url, function (text) {

				try {

					onLoad(scope.parse(text))

				} catch (e) {

					if (onError) {

						onError(e)

					} else {

						console.error(e)

					}

					scope.manager.itemError(url)

				}

			}, onProgress, onError)

		}

		setMaterials (materials) {

			this.materials = materials

			return this

		}

		parse (text) {

			const state = new ParserState()

			if (text.indexOf('\r\n') !== - 1) {

				// This is faster than String.split with regex that splits on both
				text = text.replace(/\r\n/g, '\n')

			}

			if (text.indexOf('\\\n') !== - 1) {

				// join lines separated by a line continuation character (\)
				text = text.replace(/\\\n/g, '')

			}

			const lines = text.split('\n')
			let line = '', lineFirstChar = ''
			let lineLength = 0
			let result = []

			// Faster to just trim left side of the line. Use if available.
			const trimLeft = (typeof ''.trimLeft === 'function')

			for (let i = 0, l = lines.length; i < l; i++) {

				line = lines[i]

				line = trimLeft ? line.trimLeft() : line.trim()

				lineLength = line.length

				if (lineLength === 0) continue

				lineFirstChar = line.charAt(0)

				// @todo invoke passed in handler if any
				if (lineFirstChar === '#') continue

				if (lineFirstChar === 'v') {

					const data = line.split(/\s+/)

					switch (data[0]) {

						case 'v':
							state.vertices.push(
								parseFloat(data[1]),
								parseFloat(data[2]),
								parseFloat(data[3])
							)
							if (data.length >= 7) {

								state.colors.push(
									parseFloat(data[4]),
									parseFloat(data[5]),
									parseFloat(data[6])

								)

							} else {

								// if no colors are defined, add placeholders so color and vertex indices match

								state.colors.push(undefined, undefined, undefined)

							}

							break
						case 'vn':
							state.normals.push(
								parseFloat(data[1]),
								parseFloat(data[2]),
								parseFloat(data[3])
							)
							break
						case 'vt':
							state.uvs.push(
								parseFloat(data[1]),
								parseFloat(data[2])
							)
							break

					}

				} else if (lineFirstChar === 'f') {

					const lineData = line.substr(1).trim()
					const vertexData = lineData.split(/\s+/)
					const faceVertices = []

					// Parse the face vertex data into an easy to work with format

					for (let j = 0, jl = vertexData.length; j < jl; j++) {

						const vertex = vertexData[j]

						if (vertex.length > 0) {

							const vertexParts = vertex.split('/')
							faceVertices.push(vertexParts)

						}

					}

					// Draw an edge between the first vertex and all subsequent vertices to form an n-gon

					const v1 = faceVertices[0]

					for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {

						const v2 = faceVertices[j]
						const v3 = faceVertices[j + 1]

						state.addFace(
							v1[0], v2[0], v3[0],
							v1[1], v2[1], v3[1],
							v1[2], v2[2], v3[2]
						)

					}

				} else if (lineFirstChar === 'l') {

					const lineParts = line.substring(1).trim().split(' ')
					let lineVertices = []
					const lineUVs = []

					if (line.indexOf('/') === - 1) {

						lineVertices = lineParts

					} else {

						for (let li = 0, llen = lineParts.length; li < llen; li++) {

							const parts = lineParts[li].split('/')

							if (parts[0] !== '') lineVertices.push(parts[0])
							if (parts[1] !== '') lineUVs.push(parts[1])

						}

					}

					state.addLineGeometry(lineVertices, lineUVs)

				} else if (lineFirstChar === 'p') {

					const lineData = line.substr(1).trim()
					const pointData = lineData.split(' ')

					state.addPointGeometry(pointData)

				} else if ((result = _object_pattern.exec(line)) !== null) {

					// o object_name
					// or
					// g group_name

					// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
					// let name = result[ 0 ].substr( 1 ).trim();
					const name = (' ' + result[0].substr(1).trim()).substr(1)

					state.startObject(name)

				} else if (_material_use_pattern.test(line)) {

					// material

					state.object.startMaterial(line.substring(7).trim(), state.materialLibraries)

				} else if (_material_library_pattern.test(line)) {

					// mtl file

					state.materialLibraries.push(line.substring(7).trim())

				} else if (_map_use_pattern.test(line)) {

					// the line is parsed but ignored since the loader assumes textures are defined MTL files
					// (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)

					console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.')

				} else if (lineFirstChar === 's') {

					result = line.split(' ')

					// smooth shading

					// @todo Handle files that have varying smooth values for a set of faces inside one geometry,
					// but does not define a usemtl for each face set.
					// This should be detected and a dummy material created (later MultiMaterial and geometry groups).
					// This requires some care to not create extra material on each smooth value for "normal" obj files.
					// where explicit usemtl defines geometry groups.
					// Example asset: examples/models/obj/cerberus/Cerberus.obj

					/*
						 * http://paulbourke.net/dataformats/obj/
						 * or
						 * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf
						 *
						 * From chapter "Grouping" Syntax explanation "s group_number":
						 * "group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.
						 * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form
						 * surfaces, smoothing groups are either turned on or off; there is no difference between values greater
						 * than 0."
						 */
					if (result.length > 1) {

						const value = result[1].trim().toLowerCase()
						state.object.smooth = (value !== '0' && value !== 'off')

					} else {

						// ZBrush can produce "s" lines #11707
						state.object.smooth = true

					}

					const material = state.object.currentMaterial()
					if (material) material.smooth = state.object.smooth

				} else {

					// Handle null terminated files without exception
					if (line === '\0') continue

					console.warn('THREE.OBJLoader: Unexpected line: "' + line + '"')

				}

			}

			state.finalize()

			const container = new Group$1()
			container.materialLibraries = [].concat(state.materialLibraries)

			const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0)

			if (hasPrimitives === true) {

				for (let i = 0, l = state.objects.length; i < l; i++) {

					const object = state.objects[i]
					const geometry = object.geometry
					const materials = object.materials
					const isLine = (geometry.type === 'Line')
					const isPoints = (geometry.type === 'Points')
					let hasVertexColors = false

					// Skip o/g line declarations that did not follow with any faces
					if (geometry.vertices.length === 0) continue

					const buffergeometry = new BufferGeometry()

					buffergeometry.setAttribute('position', new Float32BufferAttribute(geometry.vertices, 3))

					if (geometry.normals.length > 0) {

						buffergeometry.setAttribute('normal', new Float32BufferAttribute(geometry.normals, 3))

					}

					if (geometry.colors.length > 0) {

						hasVertexColors = true
						buffergeometry.setAttribute('color', new Float32BufferAttribute(geometry.colors, 3))

					}

					if (geometry.hasUVIndices === true) {

						buffergeometry.setAttribute('uv', new Float32BufferAttribute(geometry.uvs, 2))

					}

					// Create materials

					const createdMaterials = []

					for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {

						const sourceMaterial = materials[mi]
						const materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors
						let material = state.materials[materialHash]

						if (this.materials !== null) {

							material = this.materials.create(sourceMaterial.name)

							// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
							if (isLine && material && !(material instanceof LineBasicMaterial)) {

								const materialLine = new LineBasicMaterial()
								Material.prototype.copy.call(materialLine, material)
								materialLine.color.copy(material.color)
								material = materialLine

							} else if (isPoints && material && !(material instanceof PointsMaterial)) {

								const materialPoints = new PointsMaterial({ size: 10, sizeAttenuation: false })
								Material.prototype.copy.call(materialPoints, material)
								materialPoints.color.copy(material.color)
								materialPoints.map = material.map
								material = materialPoints

							}

						}

						if (material === undefined) {

							if (isLine) {

								material = new LineBasicMaterial()

							} else if (isPoints) {

								material = new PointsMaterial({ size: 1, sizeAttenuation: false })

							} else {

								material = new MeshPhongMaterial()

							}

							material.name = sourceMaterial.name
							material.flatShading = sourceMaterial.smooth ? false : true
							material.vertexColors = hasVertexColors

							state.materials[materialHash] = material

						}

						createdMaterials.push(material)

					}

					// Create mesh

					let mesh

					if (createdMaterials.length > 1) {

						for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {

							const sourceMaterial = materials[mi]
							buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi)

						}

						if (isLine) {

							mesh = new LineSegments(buffergeometry, createdMaterials)

						} else if (isPoints) {

							mesh = new Points(buffergeometry, createdMaterials)

						} else {

							mesh = new Mesh(buffergeometry, createdMaterials)

						}

					} else {

						if (isLine) {

							mesh = new LineSegments(buffergeometry, createdMaterials[0])

						} else if (isPoints) {

							mesh = new Points(buffergeometry, createdMaterials[0])

						} else {

							mesh = new Mesh(buffergeometry, createdMaterials[0])

						}

					}

					mesh.name = object.name

					container.add(mesh)

				}

			} else {

				// if there is only the default parser state object with no geometry data, interpret data as point cloud

				if (state.vertices.length > 0) {

					const material = new PointsMaterial({ size: 1, sizeAttenuation: false })

					const buffergeometry = new BufferGeometry()

					buffergeometry.setAttribute('position', new Float32BufferAttribute(state.vertices, 3))

					if (state.colors.length > 0 && state.colors[0] !== undefined) {

						buffergeometry.setAttribute('color', new Float32BufferAttribute(state.colors, 3))
						material.vertexColors = true

					}

					const points = new Points(buffergeometry, material)
					container.add(points)

				}

			}

			return container

		}

	}

	/**
	 * Loads a Wavefront .mtl file specifying materials
	 */

	class MTLLoader extends Loader {

		constructor(manager) {

			super(manager)

		}

		/**
		 * Loads and parses a MTL asset from a URL.
		 *
		 * @param {String} url - URL to the MTL file.
		 * @param {Function} [onLoad] - Callback invoked with the loaded object.
		 * @param {Function} [onProgress] - Callback for download progress.
		 * @param {Function} [onError] - Callback for download errors.
		 *
		 * @see setPath setResourcePath
		 *
		 * @note In order for relative texture references to resolve correctly
		 * you must call setResourcePath() explicitly prior to load.
		 */
		load (url, onLoad, onProgress, onError) {

			const scope = this

			const path = (this.path === '') ? LoaderUtils.extractUrlBase(url) : this.path

			const loader = new FileLoader(this.manager)
			loader.setPath(this.path)
			loader.setRequestHeader(this.requestHeader)
			loader.setWithCredentials(this.withCredentials)
			loader.load(url, function (text) {

				try {

					onLoad(scope.parse(text, path))

				} catch (e) {

					if (onError) {

						onError(e)

					} else {

						console.error(e)

					}

					scope.manager.itemError(url)

				}

			}, onProgress, onError)

		}

		setMaterialOptions (value) {

			this.materialOptions = value
			return this

		}

		/**
		 * Parses a MTL file.
		 *
		 * @param {String} text - Content of MTL file
		 * @return {MaterialCreator}
		 *
		 * @see setPath setResourcePath
		 *
		 * @note In order for relative texture references to resolve correctly
		 * you must call setResourcePath() explicitly prior to parse.
		 */
		parse (text, path) {

			const lines = text.split('\n')
			let info = {}
			const delimiter_pattern = /\s+/
			const materialsInfo = {}

			for (let i = 0; i < lines.length; i++) {

				let line = lines[i]
				line = line.trim()

				if (line.length === 0 || line.charAt(0) === '#') {

					// Blank line or comment ignore
					continue

				}

				const pos = line.indexOf(' ')

				let key = (pos >= 0) ? line.substring(0, pos) : line
				key = key.toLowerCase()

				let value = (pos >= 0) ? line.substring(pos + 1) : ''
				value = value.trim()

				if (key === 'newmtl') {

					// New material

					info = { name: value }
					materialsInfo[value] = info

				} else {

					if (key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke') {

						const ss = value.split(delimiter_pattern, 3)
						info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])]

					} else {

						info[key] = value

					}

				}

			}

			const materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions)
			materialCreator.setCrossOrigin(this.crossOrigin)
			materialCreator.setManager(this.manager)
			materialCreator.setMaterials(materialsInfo)
			return materialCreator

		}

	}

	/**
	 * Create a new MTLLoader.MaterialCreator
	 * @param baseUrl - Url relative to which textures are loaded
	 * @param options - Set of options on how to construct the materials
	 *                  side: Which side to apply the material
	 *                        FrontSide (default), THREE.BackSide, THREE.DoubleSide
	 *                  wrap: What type of wrapping to apply for textures
	 *                        RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping
	 *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255
	 *                                Default: false, assumed to be already normalized
	 *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's
	 *                                  Default: false
	 * @constructor
	 */

	class MaterialCreator {

		constructor(baseUrl = '', options = {}) {

			this.baseUrl = baseUrl
			this.options = options
			this.materialsInfo = {}
			this.materials = {}
			this.materialsArray = []
			this.nameLookup = {}

			this.crossOrigin = 'anonymous'

			this.side = (this.options.side !== undefined) ? this.options.side : FrontSide
			this.wrap = (this.options.wrap !== undefined) ? this.options.wrap : RepeatWrapping

		}

		setCrossOrigin (value) {

			this.crossOrigin = value
			return this

		}

		setManager (value) {

			this.manager = value

		}

		setMaterials (materialsInfo) {

			this.materialsInfo = this.convert(materialsInfo)
			this.materials = {}
			this.materialsArray = []
			this.nameLookup = {}

		}

		convert (materialsInfo) {

			if (!this.options) return materialsInfo

			const converted = {}

			for (const mn in materialsInfo) {

				// Convert materials info into normalized form based on options

				const mat = materialsInfo[mn]

				const covmat = {}

				converted[mn] = covmat

				for (const prop in mat) {

					let save = true
					let value = mat[prop]
					const lprop = prop.toLowerCase()

					switch (lprop) {

						case 'kd':
						case 'ka':
						case 'ks':

							// Diffuse color (color under white light) using RGB values

							if (this.options && this.options.normalizeRGB) {

								value = [value[0] / 255, value[1] / 255, value[2] / 255]

							}

							if (this.options && this.options.ignoreZeroRGBs) {

								if (value[0] === 0 && value[1] === 0 && value[2] === 0) {

									// ignore

									save = false

								}

							}

							break

					}

					if (save) {

						covmat[lprop] = value

					}

				}

			}

			return converted

		}

		preload () {

			for (const mn in this.materialsInfo) {

				this.create(mn)

			}

		}

		getIndex (materialName) {

			return this.nameLookup[materialName]

		}

		getAsArray () {

			let index = 0

			for (const mn in this.materialsInfo) {

				this.materialsArray[index] = this.create(mn)
				this.nameLookup[mn] = index
				index++

			}

			return this.materialsArray

		}

		create (materialName) {

			if (this.materials[materialName] === undefined) {

				this.createMaterial_(materialName)

			}

			return this.materials[materialName]

		}

		createMaterial_ (materialName) {

			// Create material

			const scope = this
			const mat = this.materialsInfo[materialName]
			const params = {

				name: materialName,
				side: this.side

			}

			function resolveURL (baseUrl, url) {

				if (typeof url !== 'string' || url === '')
					return ''

				// Absolute URL
				if (/^https?:\/\//i.test(url)) return url

				return baseUrl + url

			}

			function setMapForType (mapType, value) {

				if (params[mapType]) return // Keep the first encountered texture

				const texParams = scope.getTextureParams(value, params)
				const map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url))

				map.repeat.copy(texParams.scale)
				map.offset.copy(texParams.offset)

				map.wrapS = scope.wrap
				map.wrapT = scope.wrap

				params[mapType] = map

			}

			for (const prop in mat) {

				const value = mat[prop]
				let n

				if (value === '') continue

				switch (prop.toLowerCase()) {

					// Ns is material specular exponent

					case 'kd':

						// Diffuse color (color under white light) using RGB values

						params.color = new Color().fromArray(value)

						break

					case 'ks':

						// Specular color (color when light is reflected from shiny surface) using RGB values
						params.specular = new Color().fromArray(value)

						break

					case 'ke':

						// Emissive using RGB values
						params.emissive = new Color().fromArray(value)

						break

					case 'map_kd':

						// Diffuse texture map

						setMapForType('map', value)

						break

					case 'map_ks':

						// Specular map

						setMapForType('specularMap', value)

						break

					case 'map_ke':

						// Emissive map

						setMapForType('emissiveMap', value)

						break

					case 'norm':

						setMapForType('normalMap', value)

						break

					case 'map_bump':
					case 'bump':

						// Bump texture map

						setMapForType('bumpMap', value)

						break

					case 'map_d':

						// Alpha map

						setMapForType('alphaMap', value)
						params.transparent = true

						break

					case 'ns':

						// The specular exponent (defines the focus of the specular highlight)
						// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.

						params.shininess = parseFloat(value)

						break

					case 'd':
						n = parseFloat(value)

						if (n < 1) {

							params.opacity = n
							params.transparent = true

						}

						break

					case 'tr':
						n = parseFloat(value)

						if (this.options && this.options.invertTrProperty) n = 1 - n

						if (n > 0) {

							params.opacity = 1 - n
							params.transparent = true

						}

						break

				}

			}

			this.materials[materialName] = new MeshPhongMaterial(params)
			return this.materials[materialName]

		}

		getTextureParams (value, matParams) {

			const texParams = {

				scale: new Vector2(1, 1),
				offset: new Vector2(0, 0)

			}

			const items = value.split(/\s+/)
			let pos

			pos = items.indexOf('-bm')

			if (pos >= 0) {

				matParams.bumpScale = parseFloat(items[pos + 1])
				items.splice(pos, 2)

			}

			pos = items.indexOf('-s')

			if (pos >= 0) {

				texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]))
				items.splice(pos, 4) // we expect 3 parameters here!

			}

			pos = items.indexOf('-o')

			if (pos >= 0) {

				texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]))
				items.splice(pos, 4) // we expect 3 parameters here!

			}

			texParams.url = items.join(' ').trim()
			return texParams

		}

		loadTexture (url, mapping, onLoad, onProgress, onError) {

			const manager = (this.manager !== undefined) ? this.manager : DefaultLoadingManager
			let loader = manager.getHandler(url)

			if (loader === null) {

				loader = new TextureLoader(manager)

			}

			if (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin)

			const texture = loader.load(url, onLoad, onProgress, onError)

			if (mapping !== undefined) texture.mapping = mapping

			return texture

		}

	}

	/*!
	fflate - fast JavaScript compression/decompression
	<https://101arrowz.github.io/fflate>
	Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
	version 0.6.9
	*/

	// DEFLATE is a complex format; to read this code, you should probably check the RFC first:
	// https://tools.ietf.org/html/rfc1951
	// You may also wish to take a look at the guide I made about this program:
	// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad
	// Some of the following code is similar to that of UZIP.js:
	// https://github.com/photopea/UZIP.js
	// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.
	// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint
	// is better for memory in most engines (I *think*).
	var ch2 = {}
	var durl = function (c) { return URL.createObjectURL(new Blob([c], { type: 'text/javascript' })) }
	var cwk = function (u) { return new Worker(u) }
	try {
		URL.revokeObjectURL(durl(''))
	}
	catch (e) {
		// We're in Deno or a very old browser
		durl = function (c) { return 'data:application/javascript;charset=UTF-8,' + encodeURI(c) }
		// If Deno, this is necessary; if not, this changes nothing
		cwk = function (u) { return new Worker(u, { type: 'module' }) }
	}
	var wk = (function (c, id, msg, transfer, cb) {
		var w = cwk(ch2[id] || (ch2[id] = durl(c)))
		w.onerror = function (e) { return cb(e.error, null) }
		w.onmessage = function (e) { return cb(null, e.data) }
		w.postMessage(msg, transfer)
		return w
	})

	// aliases for shorter compressed code (most minifers don't do this)
	var u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array
	// fixed length extra bits
	var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0])
	// fixed distance extra bits
	// see fleb note
	var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0])
	// code length index map
	var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
	// get base, reverse index map from extra bits
	var freb = function (eb, start) {
		var b = new u16(31)
		for (var i = 0; i < 31; ++i) {
			b[i] = start += 1 << eb[i - 1]
		}
		// numbers here are at max 18 bits
		var r = new u32(b[30])
		for (var i = 1; i < 30; ++i) {
			for (var j = b[i]; j < b[i + 1]; ++j) {
				r[j] = ((j - b[i]) << 5) | i
			}
		}
		return [b, r]
	}
	var _a$1 = freb(fleb, 2), fl = _a$1[0], revfl = _a$1[1]
	// we can ignore the fact that the other numbers are wrong; they never happen anyway
	fl[28] = 258, revfl[258] = 28
	var _b$1 = freb(fdeb, 0), fd = _b$1[0], revfd = _b$1[1]
	// map of value to reverse (assuming 16 bits)
	var rev = new u16(32768)
	for (var i = 0; i < 32768; ++i) {
		// reverse table algorithm from SO
		var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1)
		x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2)
		x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4)
		rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1
	}
	// create huffman tree from u8 "map": index -> code length for code index
	// mb (max bits) must be at most 15
	// TODO: optimize/split up?
	var hMap = (function (cd, mb, r) {
		var s = cd.length
		// index
		var i = 0
		// u16 "map": index -> # of codes with bit length = index
		var l = new u16(mb)
		// length of cd must be 288 (total # of codes)
		for (; i < s; ++i)
			++l[cd[i] - 1]
		// u16 "map": index -> minimum code for bit length = index
		var le = new u16(mb)
		for (i = 0; i < mb; ++i) {
			le[i] = (le[i - 1] + l[i - 1]) << 1
		}
		var co
		if (r) {
			// u16 "map": index -> number of actual bits, symbol for code
			co = new u16(1 << mb)
			// bits to remove for reverser
			var rvb = 15 - mb
			for (i = 0; i < s; ++i) {
				// ignore 0 lengths
				if (cd[i]) {
					// num encoding both symbol and bits read
					var sv = (i << 4) | cd[i]
					// free bits
					var r_1 = mb - cd[i]
					// start value
					var v = le[cd[i] - 1]++ << r_1
					// m is end value
					for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {
						// every 16 bit value starting with the code yields the same result
						co[rev[v] >>> rvb] = sv
					}
				}
			}
		}
		else {
			co = new u16(s)
			for (i = 0; i < s; ++i) {
				if (cd[i]) {
					co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i])
				}
			}
		}
		return co
	})
	// fixed length tree
	var flt = new u8(288)
	for (var i = 0; i < 144; ++i)
		flt[i] = 8
	for (var i = 144; i < 256; ++i)
		flt[i] = 9
	for (var i = 256; i < 280; ++i)
		flt[i] = 7
	for (var i = 280; i < 288; ++i)
		flt[i] = 8
	// fixed distance tree
	var fdt = new u8(32)
	for (var i = 0; i < 32; ++i)
		fdt[i] = 5
	// fixed length map
	var flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1)
	// fixed distance map
	var fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1)
	// find max of array
	var max = function (a) {
		var m = a[0]
		for (var i = 1; i < a.length; ++i) {
			if (a[i] > m)
				m = a[i]
		}
		return m
	}
	// read d, starting at bit p and mask with m
	var bits = function (d, p, m) {
		var o = (p / 8) | 0
		return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m
	}
	// read d, starting at bit p continuing for at least 16 bits
	var bits16 = function (d, p) {
		var o = (p / 8) | 0
		return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7))
	}
	// get end of byte
	var shft = function (p) { return ((p / 8) | 0) + (p & 7 && 1) }
	// typed array slice - allows garbage collector to free original reference,
	// while being more compatible than .slice
	var slc = function (v, s, e) {
		if (s == null || s < 0)
			s = 0
		if (e == null || e > v.length)
			e = v.length
		// can't use .constructor in case user-supplied
		var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s)
		n.set(v.subarray(s, e))
		return n
	}
	// expands raw DEFLATE data
	var inflt = function (dat, buf, st) {
		// source length
		var sl = dat.length
		if (!sl || (st && !st.l && sl < 5))
			return buf || new u8(0)
		// have to estimate size
		var noBuf = !buf || st
		// no state
		var noSt = !st || st.i
		if (!st)
			st = {}
		// Assumes roughly 33% compression ratio average
		if (!buf)
			buf = new u8(sl * 3)
		// ensure buffer can fit at least l elements
		var cbuf = function (l) {
			var bl = buf.length
			// need to increase size to fit
			if (l > bl) {
				// Double or set to necessary, whichever is greater
				var nbuf = new u8(Math.max(bl * 2, l))
				nbuf.set(buf)
				buf = nbuf
			}
		}
		//  last chunk         bitpos           bytes
		var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n
		// total bits
		var tbts = sl * 8
		do {
			if (!lm) {
				// BFINAL - this is only 1 when last chunk is next
				st.f = final = bits(dat, pos, 1)
				// type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman
				var type = bits(dat, pos + 1, 3)
				pos += 3
				if (!type) {
					// go to end of byte boundary
					var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l
					if (t > sl) {
						if (noSt)
							throw 'unexpected EOF'
						break
					}
					// ensure size
					if (noBuf)
						cbuf(bt + l)
					// Copy over uncompressed data
					buf.set(dat.subarray(s, t), bt)
					// Get new bitpos, update byte count
					st.b = bt += l, st.p = pos = t * 8
					continue
				}
				else if (type == 1)
					lm = flrm, dm = fdrm, lbt = 9, dbt = 5
				else if (type == 2) {
					//  literal                            lengths
					var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4
					var tl = hLit + bits(dat, pos + 5, 31) + 1
					pos += 14
					// length+distance tree
					var ldt = new u8(tl)
					// code length tree
					var clt = new u8(19)
					for (var i = 0; i < hcLen; ++i) {
						// use index map to get real code
						clt[clim[i]] = bits(dat, pos + i * 3, 7)
					}
					pos += hcLen * 3
					// code lengths bits
					var clb = max(clt), clbmsk = (1 << clb) - 1
					// code lengths map
					var clm = hMap(clt, clb, 1)
					for (var i = 0; i < tl;) {
						var r = clm[bits(dat, pos, clbmsk)]
						// bits read
						pos += r & 15
						// symbol
						var s = r >>> 4
						// code length to copy
						if (s < 16) {
							ldt[i++] = s
						}
						else {
							//  copy   count
							var c = 0, n = 0
							if (s == 16)
								n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1]
							else if (s == 17)
								n = 3 + bits(dat, pos, 7), pos += 3
							else if (s == 18)
								n = 11 + bits(dat, pos, 127), pos += 7
							while (n--)
								ldt[i++] = c
						}
					}
					//    length tree                 distance tree
					var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit)
					// max length bits
					lbt = max(lt)
					// max dist bits
					dbt = max(dt)
					lm = hMap(lt, lbt, 1)
					dm = hMap(dt, dbt, 1)
				}
				else
					throw 'invalid block type'
				if (pos > tbts) {
					if (noSt)
						throw 'unexpected EOF'
					break
				}
			}
			// Make sure the buffer can hold this + the largest possible addition
			// Maximum chunk size (practically, theoretically infinite) is 2^17;
			if (noBuf)
				cbuf(bt + 131072)
			var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1
			var lpos = pos
			for (; ; lpos = pos) {
				// bits read, code
				var c = lm[bits16(dat, pos) & lms], sym = c >>> 4
				pos += c & 15
				if (pos > tbts) {
					if (noSt)
						throw 'unexpected EOF'
					break
				}
				if (!c)
					throw 'invalid length/literal'
				if (sym < 256)
					buf[bt++] = sym
				else if (sym == 256) {
					lpos = pos, lm = null
					break
				}
				else {
					var add = sym - 254
					// no extra bits needed if less
					if (sym > 264) {
						// index
						var i = sym - 257, b = fleb[i]
						add = bits(dat, pos, (1 << b) - 1) + fl[i]
						pos += b
					}
					// dist
					var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4
					if (!d)
						throw 'invalid distance'
					pos += d & 15
					var dt = fd[dsym]
					if (dsym > 3) {
						var b = fdeb[dsym]
						dt += bits16(dat, pos) & ((1 << b) - 1), pos += b
					}
					if (pos > tbts) {
						if (noSt)
							throw 'unexpected EOF'
						break
					}
					if (noBuf)
						cbuf(bt + 131072)
					var end = bt + add
					for (; bt < end; bt += 4) {
						buf[bt] = buf[bt - dt]
						buf[bt + 1] = buf[bt + 1 - dt]
						buf[bt + 2] = buf[bt + 2 - dt]
						buf[bt + 3] = buf[bt + 3 - dt]
					}
					bt = end
				}
			}
			st.l = lm, st.p = lpos, st.b = bt
			if (lm)
				final = 1, st.m = lbt, st.d = dm, st.n = dbt
		} while (!final)
		return bt == buf.length ? buf : slc(buf, 0, bt)
	}
	// starting at p, write the minimum number of bits that can hold v to d
	var wbits = function (d, p, v) {
		v <<= p & 7
		var o = (p / 8) | 0
		d[o] |= v
		d[o + 1] |= v >>> 8
	}
	// starting at p, write the minimum number of bits (>8) that can hold v to d
	var wbits16 = function (d, p, v) {
		v <<= p & 7
		var o = (p / 8) | 0
		d[o] |= v
		d[o + 1] |= v >>> 8
		d[o + 2] |= v >>> 16
	}
	// creates code lengths from a frequency table
	var hTree = function (d, mb) {
		// Need extra info to make a tree
		var t = []
		for (var i = 0; i < d.length; ++i) {
			if (d[i])
				t.push({ s: i, f: d[i] })
		}
		var s = t.length
		var t2 = t.slice()
		if (!s)
			return [et, 0]
		if (s == 1) {
			var v = new u8(t[0].s + 1)
			v[t[0].s] = 1
			return [v, 1]
		}
		t.sort(function (a, b) { return a.f - b.f })
		// after i2 reaches last ind, will be stopped
		// freq must be greater than largest possible number of symbols
		t.push({ s: -1, f: 25001 })
		var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2
		t[0] = { s: -1, f: l.f + r.f, l: l, r: r }
		// efficient algorithm from UZIP.js
		// i0 is lookbehind, i2 is lookahead - after processing two low-freq
		// symbols that combined have high freq, will start processing i2 (high-freq,
		// non-composite) symbols instead
		// see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/
		while (i1 != s - 1) {
			l = t[t[i0].f < t[i2].f ? i0++ : i2++]
			r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++]
			t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r }
		}
		var maxSym = t2[0].s
		for (var i = 1; i < s; ++i) {
			if (t2[i].s > maxSym)
				maxSym = t2[i].s
		}
		// code lengths
		var tr = new u16(maxSym + 1)
		// max bits in tree
		var mbt = ln(t[i1 - 1], tr, 0)
		if (mbt > mb) {
			// more algorithms from UZIP.js
			// TODO: find out how this code works (debt)
			//  ind    debt
			var i = 0, dt = 0
			//    left            cost
			var lft = mbt - mb, cst = 1 << lft
			t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f })
			for (; i < s; ++i) {
				var i2_1 = t2[i].s
				if (tr[i2_1] > mb) {
					dt += cst - (1 << (mbt - tr[i2_1]))
					tr[i2_1] = mb
				}
				else
					break
			}
			dt >>>= lft
			while (dt > 0) {
				var i2_2 = t2[i].s
				if (tr[i2_2] < mb)
					dt -= 1 << (mb - tr[i2_2]++ - 1)
				else
					++i
			}
			for (; i >= 0 && dt; --i) {
				var i2_3 = t2[i].s
				if (tr[i2_3] == mb) {
					--tr[i2_3]
					++dt
				}
			}
			mbt = mb
		}
		return [new u8(tr), mbt]
	}
	// get the max length and assign length codes
	var ln = function (n, l, d) {
		return n.s == -1
			? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))
			: (l[n.s] = d)
	}
	// length codes generation
	var lc = function (c) {
		var s = c.length
		// Note that the semicolon was intentional
		while (s && !c[--s])
			;
		var cl = new u16(++s)
		//  ind      num         streak
		var cli = 0, cln = c[0], cls = 1
		var w = function (v) { cl[cli++] = v }
		for (var i = 1; i <= s; ++i) {
			if (c[i] == cln && i != s)
				++cls
			else {
				if (!cln && cls > 2) {
					for (; cls > 138; cls -= 138)
						w(32754)
					if (cls > 2) {
						w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305)
						cls = 0
					}
				}
				else if (cls > 3) {
					w(cln), --cls
					for (; cls > 6; cls -= 6)
						w(8304)
					if (cls > 2)
						w(((cls - 3) << 5) | 8208), cls = 0
				}
				while (cls--)
					w(cln)
				cls = 1
				cln = c[i]
			}
		}
		return [cl.subarray(0, cli), s]
	}
	// calculate the length of output from tree, code lengths
	var clen = function (cf, cl) {
		var l = 0
		for (var i = 0; i < cl.length; ++i)
			l += cf[i] * cl[i]
		return l
	}
	// writes a fixed block
	// returns the new bit pos
	var wfblk = function (out, pos, dat) {
		// no need to write 00 as type: TypedArray defaults to 0
		var s = dat.length
		var o = shft(pos + 2)
		out[o] = s & 255
		out[o + 1] = s >>> 8
		out[o + 2] = out[o] ^ 255
		out[o + 3] = out[o + 1] ^ 255
		for (var i = 0; i < s; ++i)
			out[o + i + 4] = dat[i]
		return (o + 4 + s) * 8
	}
	// writes a block
	var wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
		wbits(out, p++, final)
		++lf[256]
		var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1]
		var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1]
		var _c = lc(dlt), lclt = _c[0], nlc = _c[1]
		var _d = lc(ddt), lcdt = _d[0], ndc = _d[1]
		var lcfreq = new u16(19)
		for (var i = 0; i < lclt.length; ++i)
			lcfreq[lclt[i] & 31]++
		for (var i = 0; i < lcdt.length; ++i)
			lcfreq[lcdt[i] & 31]++
		var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1]
		var nlcc = 19
		for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
			;
		var flen = (bl + 5) << 3
		var ftlen = clen(lf, flt) + clen(df, fdt) + eb
		var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18])
		if (flen <= ftlen && flen <= dtlen)
			return wfblk(out, p, dat.subarray(bs, bs + bl))
		var lm, ll, dm, dl
		wbits(out, p, 1 + (dtlen < ftlen)), p += 2
		if (dtlen < ftlen) {
			lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt
			var llm = hMap(lct, mlcb, 0)
			wbits(out, p, nlc - 257)
			wbits(out, p + 5, ndc - 1)
			wbits(out, p + 10, nlcc - 4)
			p += 14
			for (var i = 0; i < nlcc; ++i)
				wbits(out, p + 3 * i, lct[clim[i]])
			p += 3 * nlcc
			var lcts = [lclt, lcdt]
			for (var it = 0; it < 2; ++it) {
				var clct = lcts[it]
				for (var i = 0; i < clct.length; ++i) {
					var len = clct[i] & 31
					wbits(out, p, llm[len]), p += lct[len]
					if (len > 15)
						wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12
				}
			}
		}
		else {
			lm = flm, ll = flt, dm = fdm, dl = fdt
		}
		for (var i = 0; i < li; ++i) {
			if (syms[i] > 255) {
				var len = (syms[i] >>> 18) & 31
				wbits16(out, p, lm[len + 257]), p += ll[len + 257]
				if (len > 7)
					wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len]
				var dst = syms[i] & 31
				wbits16(out, p, dm[dst]), p += dl[dst]
				if (dst > 3)
					wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst]
			}
			else {
				wbits16(out, p, lm[syms[i]]), p += ll[syms[i]]
			}
		}
		wbits16(out, p, lm[256])
		return p + ll[256]
	}
	// deflate options (nice << 13) | chain
	var deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632])
	// empty
	var et = /*#__PURE__*/ new u8(0)
	// compresses data into a raw DEFLATE buffer
	var dflt = function (dat, lvl, plvl, pre, post, lst) {
		var s = dat.length
		var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post)
		// writing to this writes to the output buffer
		var w = o.subarray(pre, o.length - post)
		var pos = 0
		if (!lvl || s < 8) {
			for (var i = 0; i <= s; i += 65535) {
				// end
				var e = i + 65535
				if (e < s) {
					// write full block
					pos = wfblk(w, pos, dat.subarray(i, e))
				}
				else {
					// write final block
					w[i] = lst
					pos = wfblk(w, pos, dat.subarray(i, s))
				}
			}
		}
		else {
			var opt = deo[lvl - 1]
			var n = opt >>> 13, c = opt & 8191
			var msk_1 = (1 << plvl) - 1
			//    prev 2-byte val map    curr 2-byte val map
			var prev = new u16(32768), head = new u16(msk_1 + 1)
			var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1
			var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1 }
			// 24576 is an arbitrary number of maximum symbols per block
			// 424 buffer for last block
			var syms = new u32(25000)
			// length/literal freq   distance freq
			var lf = new u16(288), df = new u16(32)
			//  l/lcnt  exbits  index  l/lind  waitdx  bitpos
			var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0
			for (; i < s; ++i) {
				// hash value
				// deopt when i > s - 3 - at end, deopt acceptable
				var hv = hsh(i)
				// index mod 32768    previous index mod
				var imod = i & 32767, pimod = head[hv]
				prev[imod] = pimod
				head[hv] = imod
				// We always should modify head and prev, but only add symbols if
				// this data is not yet processed ("wait" for wait index)
				if (wi <= i) {
					// bytes remaining
					var rem = s - i
					if ((lc_1 > 7000 || li > 24576) && rem > 423) {
						pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos)
						li = lc_1 = eb = 0, bs = i
						for (var j = 0; j < 286; ++j)
							lf[j] = 0
						for (var j = 0; j < 30; ++j)
							df[j] = 0
					}
					//  len    dist   chain
					var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767
					if (rem > 2 && hv == hsh(i - dif)) {
						var maxn = Math.min(n, rem) - 1
						var maxd = Math.min(32767, i)
						// max possible length
						// not capped at dif because decompressors implement "rolling" index population
						var ml = Math.min(258, rem)
						while (dif <= maxd && --ch_1 && imod != pimod) {
							if (dat[i + l] == dat[i + l - dif]) {
								var nl = 0
								for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
									;
								if (nl > l) {
									l = nl, d = dif
									// break out early when we reach "nice" (we are satisfied enough)
									if (nl > maxn)
										break
									// now, find the rarest 2-byte sequence within this
									// length of literals and search for that instead.
									// Much faster than just using the start
									var mmd = Math.min(dif, nl - 2)
									var md = 0
									for (var j = 0; j < mmd; ++j) {
										var ti = (i - dif + j + 32768) & 32767
										var pti = prev[ti]
										var cd = (ti - pti + 32768) & 32767
										if (cd > md)
											md = cd, pimod = ti
									}
								}
							}
							// check the previous match
							imod = pimod, pimod = prev[imod]
							dif += (imod - pimod + 32768) & 32767
						}
					}
					// d will be nonzero only when a match was found
					if (d) {
						// store both dist and len data in one Uint32
						// Make sure this is recognized as a len/dist with 28th bit (2^28)
						syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d]
						var lin = revfl[l] & 31, din = revfd[d] & 31
						eb += fleb[lin] + fdeb[din]
						++lf[257 + lin]
						++df[din]
						wi = i + l
						++lc_1
					}
					else {
						syms[li++] = dat[i]
						++lf[dat[i]]
					}
				}
			}
			pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos)
			// this is the easiest way to avoid needing to maintain state
			if (!lst && pos & 7)
				pos = wfblk(w, pos + 1, et)
		}
		return slc(o, 0, pre + shft(pos) + post)
	}
	// CRC32 table
	var crct = /*#__PURE__*/ (function () {
		var t = new u32(256)
		for (var i = 0; i < 256; ++i) {
			var c = i, k = 9
			while (--k)
				c = ((c & 1) && 0xEDB88320) ^ (c >>> 1)
			t[i] = c
		}
		return t
	})()
	// CRC32
	var crc = function () {
		var c = -1
		return {
			p: function (d) {
				// closures have awful performance
				var cr = c
				for (var i = 0; i < d.length; ++i)
					cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8)
				c = cr
			},
			d: function () { return ~c }
		}
	}
	// Alder32
	var adler = function () {
		var a = 1, b = 0
		return {
			p: function (d) {
				// closures have awful performance
				var n = a, m = b
				var l = d.length
				for (var i = 0; i != l;) {
					var e = Math.min(i + 2655, l)
					for (; i < e; ++i)
						m += n += d[i]
					n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16)
				}
				a = n, b = m
			},
			d: function () {
				a %= 65521, b %= 65521
				return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8)
			}
		}
	}
	// deflate with opts
	var dopt = function (dat, opt, pre, post, st) {
		return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st)
	}
	// Walmart object spread
	var mrg = function (a, b) {
		var o = {}
		for (var k in a)
			o[k] = a[k]
		for (var k in b)
			o[k] = b[k]
		return o
	}
	// worker clone
	// This is possibly the craziest part of the entire codebase, despite how simple it may seem.
	// The only parameter to this function is a closure that returns an array of variables outside of the function scope.
	// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.
	// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).
	// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.
	// This took me three weeks to figure out how to do.
	var wcln = function (fn, fnStr, td) {
		var dt = fn()
		var st = fn.toString()
		var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/ /g, '').split(',')
		for (var i = 0; i < dt.length; ++i) {
			var v = dt[i], k = ks[i]
			if (typeof v == 'function') {
				fnStr += ';' + k + '='
				var st_1 = v.toString()
				if (v.prototype) {
					// for global objects
					if (st_1.indexOf('[native code]') != -1) {
						var spInd = st_1.indexOf(' ', 8) + 1
						fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd))
					}
					else {
						fnStr += st_1
						for (var t in v.prototype)
							fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString()
					}
				}
				else
					fnStr += st_1
			}
			else
				td[k] = v
		}
		return [fnStr, td]
	}
	var ch = []
	// clone bufs
	var cbfs = function (v) {
		var tl = []
		for (var k in v) {
			if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32)
				tl.push((v[k] = new v[k].constructor(v[k])).buffer)
		}
		return tl
	}
	// use a worker to execute code
	var wrkr = function (fns, init, id, cb) {
		var _a
		if (!ch[id]) {
			var fnStr = '', td_1 = {}, m = fns.length - 1
			for (var i = 0; i < m; ++i)
				_a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1]
			ch[id] = wcln(fns[m], fnStr, td_1)
		}
		var td = mrg({}, ch[id][1])
		return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb)
	}
	// base async inflate fn
	var bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, hMap, max, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8] }
	var bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf] }
	// gzip extra
	var gze = function () { return [gzh, gzhl, wbytes, crc, crct] }
	// gunzip extra
	var guze = function () { return [gzs, gzl] }
	// zlib extra
	var zle = function () { return [zlh, wbytes, adler] }
	// unzlib extra
	var zule = function () { return [zlv] }
	// post buf
	var pbf = function (msg) { return postMessage(msg, [msg.buffer]) }
	// get u8
	var gu8 = function (o) { return o && o.size && new u8(o.size) }
	// async helper
	var cbify = function (dat, opts, fns, init, id, cb) {
		var w = wrkr(fns, init, id, function (err, dat) {
			w.terminate()
			cb(err, dat)
		})
		w.postMessage([dat, opts], opts.consume ? [dat.buffer] : [])
		return function () { w.terminate() }
	}
	// auto stream
	var astrm = function (strm) {
		strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]) }
		return function (ev) { return strm.push(ev.data[0], ev.data[1]) }
	}
	// async stream attach
	var astrmify = function (fns, strm, opts, init, id) {
		var t
		var w = wrkr(fns, init, id, function (err, dat) {
			if (err)
				w.terminate(), strm.ondata.call(strm, err)
			else {
				if (dat[1])
					w.terminate()
				strm.ondata.call(strm, err, dat[0], dat[1])
			}
		})
		w.postMessage(opts)
		strm.push = function (d, f) {
			if (t)
				throw 'stream finished'
			if (!strm.ondata)
				throw 'no stream handler'
			w.postMessage([d, t = f], [d.buffer])
		}
		strm.terminate = function () { w.terminate() }
	}
	// read 2 bytes
	var b2 = function (d, b) { return d[b] | (d[b + 1] << 8) }
	// read 4 bytes
	var b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0 }
	var b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296) }
	// write bytes
	var wbytes = function (d, b, v) {
		for (; v; ++b)
			d[b] = v, v >>>= 8
	}
	// gzip header
	var gzh = function (c, o) {
		var fn = o.filename
		c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3 // assume Unix
		if (o.mtime != 0)
			wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000))
		if (fn) {
			c[3] = 8
			for (var i = 0; i <= fn.length; ++i)
				c[i + 10] = fn.charCodeAt(i)
		}
	}
	// gzip footer: -8 to -4 = CRC, -4 to -0 is length
	// gzip start
	var gzs = function (d) {
		if (d[0] != 31 || d[1] != 139 || d[2] != 8)
			throw 'invalid gzip data'
		var flg = d[3]
		var st = 10
		if (flg & 4)
			st += d[10] | (d[11] << 8) + 2
		for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
			;
		return st + (flg & 2)
	}
	// gzip length
	var gzl = function (d) {
		var l = d.length
		return ((d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) | (d[l - 1] << 24)) >>> 0
	}
	// gzip header length
	var gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0) }
	// zlib header
	var zlh = function (c, o) {
		var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2
		c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1)
	}
	// zlib valid
	var zlv = function (d) {
		if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))
			throw 'invalid zlib data'
		if (d[1] & 32)
			throw 'invalid zlib data: preset dictionaries not supported'
	}
	function AsyncCmpStrm (opts, cb) {
		if (!cb && typeof opts == 'function')
			cb = opts, opts = {}
		this.ondata = cb
		return opts
	}
	// zlib footer: -4 to -0 is Adler32
	/**
	 * Streaming DEFLATE compression
	 */
	var Deflate = /*#__PURE__*/ (function () {
		function Deflate (opts, cb) {
			if (!cb && typeof opts == 'function')
				cb = opts, opts = {}
			this.ondata = cb
			this.o = opts || {}
		}
		Deflate.prototype.p = function (c, f) {
			this.ondata(dopt(c, this.o, 0, 0, !f), f)
		}
		/**
		 * Pushes a chunk to be deflated
		 * @param chunk The chunk to push
		 * @param final Whether this is the last chunk
		 */
		Deflate.prototype.push = function (chunk, final) {
			if (this.d)
				throw 'stream finished'
			if (!this.ondata)
				throw 'no stream handler'
			this.d = final
			this.p(chunk, final || false)
		}
		return Deflate
	}())
	/**
	 * Asynchronous streaming DEFLATE compression
	 */
	var AsyncDeflate = /*#__PURE__*/ (function () {
		function AsyncDeflate (opts, cb) {
			astrmify([
				bDflt,
				function () { return [astrm, Deflate] }
			], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {
				var strm = new Deflate(ev.data)
				onmessage = astrm(strm)
			}, 6)
		}
		return AsyncDeflate
	}())
	function deflate (data, opts, cb) {
		if (!cb)
			cb = opts, opts = {}
		if (typeof cb != 'function')
			throw 'no callback'
		return cbify(data, opts, [
			bDflt,
		], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])) }, 0, cb)
	}
	/**
	 * Compresses data with DEFLATE without any wrapper
	 * @param data The data to compress
	 * @param opts The compression options
	 * @returns The deflated version of the data
	 */
	function deflateSync (data, opts) {
		return dopt(data, opts || {}, 0, 0)
	}
	/**
	 * Streaming DEFLATE decompression
	 */
	var Inflate = /*#__PURE__*/ (function () {
		/**
		 * Creates an inflation stream
		 * @param cb The callback to call whenever data is inflated
		 */
		function Inflate (cb) {
			this.s = {}
			this.p = new u8(0)
			this.ondata = cb
		}
		Inflate.prototype.e = function (c) {
			if (this.d)
				throw 'stream finished'
			if (!this.ondata)
				throw 'no stream handler'
			var l = this.p.length
			var n = new u8(l + c.length)
			n.set(this.p), n.set(c, l), this.p = n
		}
		Inflate.prototype.c = function (final) {
			this.d = this.s.i = final || false
			var bts = this.s.b
			var dt = inflt(this.p, this.o, this.s)
			this.ondata(slc(dt, bts, this.s.b), this.d)
			this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length
			this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7
		}
		/**
		 * Pushes a chunk to be inflated
		 * @param chunk The chunk to push
		 * @param final Whether this is the final chunk
		 */
		Inflate.prototype.push = function (chunk, final) {
			this.e(chunk), this.c(final)
		}
		return Inflate
	}())
	/**
	 * Asynchronous streaming DEFLATE decompression
	 */
	var AsyncInflate = /*#__PURE__*/ (function () {
		/**
		 * Creates an asynchronous inflation stream
		 * @param cb The callback to call whenever data is deflated
		 */
		function AsyncInflate (cb) {
			this.ondata = cb
			astrmify([
				bInflt,
				function () { return [astrm, Inflate] }
			], this, 0, function () {
				var strm = new Inflate()
				onmessage = astrm(strm)
			}, 7)
		}
		return AsyncInflate
	}())
	function inflate (data, opts, cb) {
		if (!cb)
			cb = opts, opts = {}
		if (typeof cb != 'function')
			throw 'no callback'
		return cbify(data, opts, [
			bInflt
		], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))) }, 1, cb)
	}
	/**
	 * Expands DEFLATE data with no wrapper
	 * @param data The data to decompress
	 * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
	 * @returns The decompressed version of the data
	 */
	function inflateSync (data, out) {
		return inflt(data, out)
	}
	// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.
	/**
	 * Streaming GZIP compression
	 */
	var Gzip = /*#__PURE__*/ (function () {
		function Gzip (opts, cb) {
			this.c = crc()
			this.l = 0
			this.v = 1
			Deflate.call(this, opts, cb)
		}
		/**
		 * Pushes a chunk to be GZIPped
		 * @param chunk The chunk to push
		 * @param final Whether this is the last chunk
		 */
		Gzip.prototype.push = function (chunk, final) {
			Deflate.prototype.push.call(this, chunk, final)
		}
		Gzip.prototype.p = function (c, f) {
			this.c.p(c)
			this.l += c.length
			var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f)
			if (this.v)
				gzh(raw, this.o), this.v = 0
			if (f)
				wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l)
			this.ondata(raw, f)
		}
		return Gzip
	}())
	/**
	 * Asynchronous streaming GZIP compression
	 */
	var AsyncGzip = /*#__PURE__*/ (function () {
		function AsyncGzip (opts, cb) {
			astrmify([
				bDflt,
				gze,
				function () { return [astrm, Deflate, Gzip] }
			], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {
				var strm = new Gzip(ev.data)
				onmessage = astrm(strm)
			}, 8)
		}
		return AsyncGzip
	}())
	function gzip (data, opts, cb) {
		if (!cb)
			cb = opts, opts = {}
		if (typeof cb != 'function')
			throw 'no callback'
		return cbify(data, opts, [
			bDflt,
			gze,
			function () { return [gzipSync] }
		], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])) }, 2, cb)
	}
	/**
	 * Compresses data with GZIP
	 * @param data The data to compress
	 * @param opts The compression options
	 * @returns The gzipped version of the data
	 */
	function gzipSync (data, opts) {
		if (!opts)
			opts = {}
		var c = crc(), l = data.length
		c.p(data)
		var d = dopt(data, opts, gzhl(opts), 8), s = d.length
		return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d
	}
	/**
	 * Streaming GZIP decompression
	 */
	var Gunzip = /*#__PURE__*/ (function () {
		/**
		 * Creates a GUNZIP stream
		 * @param cb The callback to call whenever data is inflated
		 */
		function Gunzip (cb) {
			this.v = 1
			Inflate.call(this, cb)
		}
		/**
		 * Pushes a chunk to be GUNZIPped
		 * @param chunk The chunk to push
		 * @param final Whether this is the last chunk
		 */
		Gunzip.prototype.push = function (chunk, final) {
			Inflate.prototype.e.call(this, chunk)
			if (this.v) {
				var s = this.p.length > 3 ? gzs(this.p) : 4
				if (s >= this.p.length && !final)
					return
				this.p = this.p.subarray(s), this.v = 0
			}
			if (final) {
				if (this.p.length < 8)
					throw 'invalid gzip stream'
				this.p = this.p.subarray(0, -8)
			}
			// necessary to prevent TS from using the closure value
			// This allows for workerization to function correctly
			Inflate.prototype.c.call(this, final)
		}
		return Gunzip
	}())
	/**
	 * Asynchronous streaming GZIP decompression
	 */
	var AsyncGunzip = /*#__PURE__*/ (function () {
		/**
		 * Creates an asynchronous GUNZIP stream
		 * @param cb The callback to call whenever data is deflated
		 */
		function AsyncGunzip (cb) {
			this.ondata = cb
			astrmify([
				bInflt,
				guze,
				function () { return [astrm, Inflate, Gunzip] }
			], this, 0, function () {
				var strm = new Gunzip()
				onmessage = astrm(strm)
			}, 9)
		}
		return AsyncGunzip
	}())
	function gunzip (data, opts, cb) {
		if (!cb)
			cb = opts, opts = {}
		if (typeof cb != 'function')
			throw 'no callback'
		return cbify(data, opts, [
			bInflt,
			guze,
			function () { return [gunzipSync] }
		], function (ev) { return pbf(gunzipSync(ev.data[0])) }, 3, cb)
	}
	/**
	 * Expands GZIP data
	 * @param data The data to decompress
	 * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.
	 * @returns The decompressed version of the data
	 */
	function gunzipSync (data, out) {
		return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)))
	}
	/**
	 * Streaming Zlib compression
	 */
	var Zlib = /*#__PURE__*/ (function () {
		function Zlib (opts, cb) {
			this.c = adler()
			this.v = 1
			Deflate.call(this, opts, cb)
		}
		/**
		 * Pushes a chunk to be zlibbed
		 * @param chunk The chunk to push
		 * @param final Whether this is the last chunk
		 */
		Zlib.prototype.push = function (chunk, final) {
			Deflate.prototype.push.call(this, chunk, final)
		}
		Zlib.prototype.p = function (c, f) {
			this.c.p(c)
			var raw = dopt(c, this.o, this.v && 2, f && 4, !f)
			if (this.v)
				zlh(raw, this.o), this.v = 0
			if (f)
				wbytes(raw, raw.length - 4, this.c.d())
			this.ondata(raw, f)
		}
		return Zlib
	}())
	/**
	 * Asynchronous streaming Zlib compression
	 */
	var AsyncZlib = /*#__PURE__*/ (function () {
		function AsyncZlib (opts, cb) {
			astrmify([
				bDflt,
				zle,
				function () { return [astrm, Deflate, Zlib] }
			], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {
				var strm = new Zlib(ev.data)
				onmessage = astrm(strm)
			}, 10)
		}
		return AsyncZlib
	}())
	function zlib (data, opts, cb) {
		if (!cb)
			cb = opts, opts = {}
		if (typeof cb != 'function')
			throw 'no callback'
		return cbify(data, opts, [
			bDflt,
			zle,
			function () { return [zlibSync] }
		], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])) }, 4, cb)
	}
	/**
	 * Compress data with Zlib
	 * @param data The data to compress
	 * @param opts The compression options
	 * @returns The zlib-compressed version of the data
	 */
	function zlibSync (data, opts) {
		if (!opts)
			opts = {}
		var a = adler()
		a.p(data)
		var d = dopt(data, opts, 2, 4)
		return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d
	}
	/**
	 * Streaming Zlib decompression
	 */
	var Unzlib = /*#__PURE__*/ (function () {
		/**
		 * Creates a Zlib decompression stream
		 * @param cb The callback to call whenever data is inflated
		 */
		function Unzlib (cb) {
			this.v = 1
			Inflate.call(this, cb)
		}
		/**
		 * Pushes a chunk to be unzlibbed
		 * @param chunk The chunk to push
		 * @param final Whether this is the last chunk
		 */
		Unzlib.prototype.push = function (chunk, final) {
			Inflate.prototype.e.call(this, chunk)
			if (this.v) {
				if (this.p.length < 2 && !final)
					return
				this.p = this.p.subarray(2), this.v = 0
			}
			if (final) {
				if (this.p.length < 4)
					throw 'invalid zlib stream'
				this.p = this.p.subarray(0, -4)
			}
			// necessary to prevent TS from using the closure value
			// This allows for workerization to function correctly
			Inflate.prototype.c.call(this, final)
		}
		return Unzlib
	}())
	/**
	 * Asynchronous streaming Zlib decompression
	 */
	var AsyncUnzlib = /*#__PURE__*/ (function () {
		/**
		 * Creates an asynchronous Zlib decompression stream
		 * @param cb The callback to call whenever data is deflated
		 */
		function AsyncUnzlib (cb) {
			this.ondata = cb
			astrmify([
				bInflt,
				zule,
				function () { return [astrm, Inflate, Unzlib] }
			], this, 0, function () {
				var strm = new Unzlib()
				onmessage = astrm(strm)
			}, 11)
		}
		return AsyncUnzlib
	}())
	function unzlib (data, opts, cb) {
		if (!cb)
			cb = opts, opts = {}
		if (typeof cb != 'function')
			throw 'no callback'
		return cbify(data, opts, [
			bInflt,
			zule,
			function () { return [unzlibSync] }
		], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))) }, 5, cb)
	}
	/**
	 * Expands Zlib data
	 * @param data The data to decompress
	 * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
	 * @returns The decompressed version of the data
	 */
	function unzlibSync (data, out) {
		return inflt((zlv(data), data.subarray(2, -4)), out)
	}
	/**
	 * Streaming GZIP, Zlib, or raw DEFLATE decompression
	 */
	var Decompress = /*#__PURE__*/ (function () {
		/**
		 * Creates a decompression stream
		 * @param cb The callback to call whenever data is decompressed
		 */
		function Decompress (cb) {
			this.G = Gunzip
			this.I = Inflate
			this.Z = Unzlib
			this.ondata = cb
		}
		/**
		 * Pushes a chunk to be decompressed
		 * @param chunk The chunk to push
		 * @param final Whether this is the last chunk
		 */
		Decompress.prototype.push = function (chunk, final) {
			if (!this.ondata)
				throw 'no stream handler'
			if (!this.s) {
				if (this.p && this.p.length) {
					var n = new u8(this.p.length + chunk.length)
					n.set(this.p), n.set(chunk, this.p.length)
				}
				else
					this.p = chunk
				if (this.p.length > 2) {
					var _this_1 = this
					var cb = function () { _this_1.ondata.apply(_this_1, arguments) }
					this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)
						? new this.G(cb)
						: ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))
							? new this.I(cb)
							: new this.Z(cb)
					this.s.push(this.p, final)
					this.p = null
				}
			}
			else
				this.s.push(chunk, final)
		}
		return Decompress
	}())
	/**
	 * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression
	 */
	var AsyncDecompress = /*#__PURE__*/ (function () {
		/**
	 * Creates an asynchronous decompression stream
	 * @param cb The callback to call whenever data is decompressed
	 */
		function AsyncDecompress (cb) {
			this.G = AsyncGunzip
			this.I = AsyncInflate
			this.Z = AsyncUnzlib
			this.ondata = cb
		}
		/**
		 * Pushes a chunk to be decompressed
		 * @param chunk The chunk to push
		 * @param final Whether this is the last chunk
		 */
		AsyncDecompress.prototype.push = function (chunk, final) {
			Decompress.prototype.push.call(this, chunk, final)
		}
		return AsyncDecompress
	}())
	function decompress (data, opts, cb) {
		if (!cb)
			cb = opts, opts = {}
		if (typeof cb != 'function')
			throw 'no callback'
		return (data[0] == 31 && data[1] == 139 && data[2] == 8)
			? gunzip(data, opts, cb)
			: ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))
				? inflate(data, opts, cb)
				: unzlib(data, opts, cb)
	}
	/**
	 * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format
	 * @param data The data to decompress
	 * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
	 * @returns The decompressed version of the data
	 */
	function decompressSync (data, out) {
		return (data[0] == 31 && data[1] == 139 && data[2] == 8)
			? gunzipSync(data, out)
			: ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))
				? inflateSync(data, out)
				: unzlibSync(data, out)
	}
	// flatten a directory structure
	var fltn = function (d, p, t, o) {
		for (var k in d) {
			var val = d[k], n = p + k
			if (val instanceof u8)
				t[n] = [val, o]
			else if (Array.isArray(val))
				t[n] = [val[0], mrg(o, val[1])]
			else
				fltn(val, n + '/', t, o)
		}
	}
	// text encoder
	var te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder()
	// text decoder
	var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder()
	// text decoder stream
	var tds = 0
	try {
		td.decode(et, { stream: true })
		tds = 1
	}
	catch (e) { }
	// decode UTF8
	var dutf8 = function (d) {
		for (var r = '', i = 0; ;) {
			var c = d[i++]
			var eb = (c > 127) + (c > 223) + (c > 239)
			if (i + eb > d.length)
				return [r, slc(d, i - 1)]
			if (!eb)
				r += String.fromCharCode(c)
			else if (eb == 3) {
				c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,
					r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023))
			}
			else if (eb & 1)
				r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63))
			else
				r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63))
		}
	}
	/**
	 * Streaming UTF-8 decoding
	 */
	var DecodeUTF8 = /*#__PURE__*/ (function () {
		/**
		 * Creates a UTF-8 decoding stream
		 * @param cb The callback to call whenever data is decoded
		 */
		function DecodeUTF8 (cb) {
			this.ondata = cb
			if (tds)
				this.t = new TextDecoder()
			else
				this.p = et
		}
		/**
		 * Pushes a chunk to be decoded from UTF-8 binary
		 * @param chunk The chunk to push
		 * @param final Whether this is the last chunk
		 */
		DecodeUTF8.prototype.push = function (chunk, final) {
			if (!this.ondata)
				throw 'no callback'
			final = !!final
			if (this.t) {
				this.ondata(this.t.decode(chunk, { stream: true }), final)
				if (final) {
					if (this.t.decode().length)
						throw 'invalid utf-8 data'
					this.t = null
				}
				return
			}
			if (!this.p)
				throw 'stream finished'
			var dat = new u8(this.p.length + chunk.length)
			dat.set(this.p)
			dat.set(chunk, this.p.length)
			var _a = dutf8(dat), ch = _a[0], np = _a[1]
			if (final) {
				if (np.length)
					throw 'invalid utf-8 data'
				this.p = null
			}
			else
				this.p = np
			this.ondata(ch, final)
		}
		return DecodeUTF8
	}())
	/**
	 * Streaming UTF-8 encoding
	 */
	var EncodeUTF8 = /*#__PURE__*/ (function () {
		/**
		 * Creates a UTF-8 decoding stream
		 * @param cb The callback to call whenever data is encoded
		 */
		function EncodeUTF8 (cb) {
			this.ondata = cb
		}
		/**
		 * Pushes a chunk to be encoded to UTF-8
		 * @param chunk The string data to push
		 * @param final Whether this is the last chunk
		 */
		EncodeUTF8.prototype.push = function (chunk, final) {
			if (!this.ondata)
				throw 'no callback'
			if (this.d)
				throw 'stream finished'
			this.ondata(strToU8(chunk), this.d = final || false)
		}
		return EncodeUTF8
	}())
	/**
	 * Converts a string into a Uint8Array for use with compression/decompression methods
	 * @param str The string to encode
	 * @param latin1 Whether or not to interpret the data as Latin-1. This should
	 *               not need to be true unless decoding a binary string.
	 * @returns The string encoded in UTF-8/Latin-1 binary
	 */
	function strToU8 (str, latin1) {
		if (latin1) {
			var ar_1 = new u8(str.length)
			for (var i = 0; i < str.length; ++i)
				ar_1[i] = str.charCodeAt(i)
			return ar_1
		}
		if (te)
			return te.encode(str)
		var l = str.length
		var ar = new u8(str.length + (str.length >> 1))
		var ai = 0
		var w = function (v) { ar[ai++] = v }
		for (var i = 0; i < l; ++i) {
			if (ai + 5 > ar.length) {
				var n = new u8(ai + 8 + ((l - i) << 1))
				n.set(ar)
				ar = n
			}
			var c = str.charCodeAt(i)
			if (c < 128 || latin1)
				w(c)
			else if (c < 2048)
				w(192 | (c >> 6)), w(128 | (c & 63))
			else if (c > 55295 && c < 57344)
				c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),
					w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63))
			else
				w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63))
		}
		return slc(ar, 0, ai)
	}
	/**
	 * Converts a Uint8Array to a string
	 * @param dat The data to decode to string
	 * @param latin1 Whether or not to interpret the data as Latin-1. This should
	 *               not need to be true unless encoding to binary string.
	 * @returns The original UTF-8/Latin-1 string
	 */
	function strFromU8 (dat, latin1) {
		if (latin1) {
			var r = ''
			for (var i = 0; i < dat.length; i += 16384)
				r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384))
			return r
		}
		else if (td)
			return td.decode(dat)
		else {
			var _a = dutf8(dat), out = _a[0], ext = _a[1]
			if (ext.length)
				throw 'invalid utf-8 data'
			return out
		}
	}
	// deflate bit flag
	var dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0 }
	// skip local zip header
	var slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28) }
	// read zip header
	var zh = function (d, b, z) {
		var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20)
		var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2]
		return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off]
	}
	// read zip64 extra field
	var z64e = function (d, b) {
		for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
			;
		return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)]
	}
	// extra field length
	var exfl = function (ex) {
		var le = 0
		if (ex) {
			for (var k in ex) {
				var l = ex[k].length
				if (l > 65535)
					throw 'extra field too long'
				le += l + 4
			}
		}
		return le
	}
	// write zip header
	var wzh = function (d, b, f, fn, u, c, ce, co) {
		var fl = fn.length, ex = f.extra, col = co && co.length
		var exl = exfl(ex)
		wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4
		if (ce != null)
			d[b++] = 20, d[b++] = f.os
		d[b] = 20, b += 2 // spec compliance? what's that?
		d[b++] = (f.flag << 1) | (c == null && 8), d[b++] = u && 8
		d[b++] = f.compression & 255, d[b++] = f.compression >> 8
		var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980
		if (y < 0 || y > 119)
			throw 'date not in range 1980-2099'
		wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4
		if (c != null) {
			wbytes(d, b, f.crc)
			wbytes(d, b + 4, c)
			wbytes(d, b + 8, f.size)
		}
		wbytes(d, b + 12, fl)
		wbytes(d, b + 14, exl), b += 16
		if (ce != null) {
			wbytes(d, b, col)
			wbytes(d, b + 6, f.attrs)
			wbytes(d, b + 10, ce), b += 14
		}
		d.set(fn, b)
		b += fl
		if (exl) {
			for (var k in ex) {
				var exf = ex[k], l = exf.length
				wbytes(d, b, +k)
				wbytes(d, b + 2, l)
				d.set(exf, b + 4), b += 4 + l
			}
		}
		if (col)
			d.set(co, b), b += col
		return b
	}
	// write zip footer (end of central directory)
	var wzf = function (o, b, c, d, e) {
		wbytes(o, b, 0x6054B50) // skip disk
		wbytes(o, b + 8, c)
		wbytes(o, b + 10, c)
		wbytes(o, b + 12, d)
		wbytes(o, b + 16, e)
	}
	/**
	 * A pass-through stream to keep data uncompressed in a ZIP archive.
	 */
	var ZipPassThrough = /*#__PURE__*/ (function () {
		/**
		 * Creates a pass-through stream that can be added to ZIP archives
		 * @param filename The filename to associate with this data stream
		 */
		function ZipPassThrough (filename) {
			this.filename = filename
			this.c = crc()
			this.size = 0
			this.compression = 0
		}
		/**
		 * Processes a chunk and pushes to the output stream. You can override this
		 * method in a subclass for custom behavior, but by default this passes
		 * the data through. You must call this.ondata(err, chunk, final) at some
		 * point in this method.
		 * @param chunk The chunk to process
		 * @param final Whether this is the last chunk
		 */
		ZipPassThrough.prototype.process = function (chunk, final) {
			this.ondata(null, chunk, final)
		}
		/**
		 * Pushes a chunk to be added. If you are subclassing this with a custom
		 * compression algorithm, note that you must push data from the source
		 * file only, pre-compression.
		 * @param chunk The chunk to push
		 * @param final Whether this is the last chunk
		 */
		ZipPassThrough.prototype.push = function (chunk, final) {
			if (!this.ondata)
				throw 'no callback - add to ZIP archive before pushing'
			this.c.p(chunk)
			this.size += chunk.length
			if (final)
				this.crc = this.c.d()
			this.process(chunk, final || false)
		}
		return ZipPassThrough
	}())
	// I don't extend because TypeScript extension adds 1kB of runtime bloat
	/**
	 * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate
	 * for better performance
	 */
	var ZipDeflate = /*#__PURE__*/ (function () {
		/**
		 * Creates a DEFLATE stream that can be added to ZIP archives
		 * @param filename The filename to associate with this data stream
		 * @param opts The compression options
		 */
		function ZipDeflate (filename, opts) {
			var _this_1 = this
			if (!opts)
				opts = {}
			ZipPassThrough.call(this, filename)
			this.d = new Deflate(opts, function (dat, final) {
				_this_1.ondata(null, dat, final)
			})
			this.compression = 8
			this.flag = dbf(opts.level)
		}
		ZipDeflate.prototype.process = function (chunk, final) {
			try {
				this.d.push(chunk, final)
			}
			catch (e) {
				this.ondata(e, null, final)
			}
		}
		/**
		 * Pushes a chunk to be deflated
		 * @param chunk The chunk to push
		 * @param final Whether this is the last chunk
		 */
		ZipDeflate.prototype.push = function (chunk, final) {
			ZipPassThrough.prototype.push.call(this, chunk, final)
		}
		return ZipDeflate
	}())
	/**
	 * Asynchronous streaming DEFLATE compression for ZIP archives
	 */
	var AsyncZipDeflate = /*#__PURE__*/ (function () {
		/**
		 * Creates a DEFLATE stream that can be added to ZIP archives
		 * @param filename The filename to associate with this data stream
		 * @param opts The compression options
		 */
		function AsyncZipDeflate (filename, opts) {
			var _this_1 = this
			if (!opts)
				opts = {}
			ZipPassThrough.call(this, filename)
			this.d = new AsyncDeflate(opts, function (err, dat, final) {
				_this_1.ondata(err, dat, final)
			})
			this.compression = 8
			this.flag = dbf(opts.level)
			this.terminate = this.d.terminate
		}
		AsyncZipDeflate.prototype.process = function (chunk, final) {
			this.d.push(chunk, final)
		}
		/**
		 * Pushes a chunk to be deflated
		 * @param chunk The chunk to push
		 * @param final Whether this is the last chunk
		 */
		AsyncZipDeflate.prototype.push = function (chunk, final) {
			ZipPassThrough.prototype.push.call(this, chunk, final)
		}
		return AsyncZipDeflate
	}())
	// TODO: Better tree shaking
	/**
	 * A zippable archive to which files can incrementally be added
	 */
	var Zip = /*#__PURE__*/ (function () {
		/**
		 * Creates an empty ZIP archive to which files can be added
		 * @param cb The callback to call whenever data for the generated ZIP archive
		 *           is available
		 */
		function Zip (cb) {
			this.ondata = cb
			this.u = []
			this.d = 1
		}
		/**
		 * Adds a file to the ZIP archive
		 * @param file The file stream to add
		 */
		Zip.prototype.add = function (file) {
			var _this_1 = this
			if (this.d & 2)
				throw 'stream finished'
			var f = strToU8(file.filename), fl = f.length
			var com = file.comment, o = com && strToU8(com)
			var u = fl != file.filename.length || (o && (com.length != o.length))
			var hl = fl + exfl(file.extra) + 30
			if (fl > 65535)
				throw 'filename too long'
			var header = new u8(hl)
			wzh(header, 0, file, f, u)
			var chks = [header]
			var pAll = function () {
				for (var _i = 0, chks_1 = chks; _i < chks_1.length; _i++) {
					var chk = chks_1[_i]
					_this_1.ondata(null, chk, false)
				}
				chks = []
			}
			var tr = this.d
			this.d = 0
			var ind = this.u.length
			var uf = mrg(file, {
				f: f,
				u: u,
				o: o,
				t: function () {
					if (file.terminate)
						file.terminate()
				},
				r: function () {
					pAll()
					if (tr) {
						var nxt = _this_1.u[ind + 1]
						if (nxt)
							nxt.r()
						else
							_this_1.d = 1
					}
					tr = 1
				}
			})
			var cl = 0
			file.ondata = function (err, dat, final) {
				if (err) {
					_this_1.ondata(err, dat, final)
					_this_1.terminate()
				}
				else {
					cl += dat.length
					chks.push(dat)
					if (final) {
						var dd = new u8(16)
						wbytes(dd, 0, 0x8074B50)
						wbytes(dd, 4, file.crc)
						wbytes(dd, 8, cl)
						wbytes(dd, 12, file.size)
						chks.push(dd)
						uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size
						if (tr)
							uf.r()
						tr = 1
					}
					else if (tr)
						pAll()
				}
			}
			this.u.push(uf)
		}
		/**
		 * Ends the process of adding files and prepares to emit the final chunks.
		 * This *must* be called after adding all desired files for the resulting
		 * ZIP file to work properly.
		 */
		Zip.prototype.end = function () {
			var _this_1 = this
			if (this.d & 2) {
				if (this.d & 1)
					throw 'stream finishing'
				throw 'stream finished'
			}
			if (this.d)
				this.e()
			else
				this.u.push({
					r: function () {
						if (!(_this_1.d & 1))
							return
						_this_1.u.splice(-1, 1)
						_this_1.e()
					},
					t: function () { }
				})
			this.d = 3
		}
		Zip.prototype.e = function () {
			var bt = 0, l = 0, tl = 0
			for (var _i = 0, _a = this.u; _i < _a.length; _i++) {
				var f = _a[_i]
				tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0)
			}
			var out = new u8(tl + 22)
			for (var _b = 0, _c = this.u; _b < _c.length; _b++) {
				var f = _c[_b]
				wzh(out, bt, f, f.f, f.u, f.c, l, f.o)
				bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b
			}
			wzf(out, bt, this.u.length, tl, l)
			this.ondata(null, out, true)
			this.d = 2
		}
		/**
		 * A method to terminate any internal workers used by the stream. Subsequent
		 * calls to add() will fail.
		 */
		Zip.prototype.terminate = function () {
			for (var _i = 0, _a = this.u; _i < _a.length; _i++) {
				var f = _a[_i]
				f.t()
			}
			this.d = 2
		}
		return Zip
	}())
	function zip (data, opts, cb) {
		if (!cb)
			cb = opts, opts = {}
		if (typeof cb != 'function')
			throw 'no callback'
		var r = {}
		fltn(data, '', r, opts)
		var k = Object.keys(r)
		var lft = k.length, o = 0, tot = 0
		var slft = lft, files = new Array(lft)
		var term = []
		var tAll = function () {
			for (var i = 0; i < term.length; ++i)
				term[i]()
		}
		var cbf = function () {
			var out = new u8(tot + 22), oe = o, cdl = tot - o
			tot = 0
			for (var i = 0; i < slft; ++i) {
				var f = files[i]
				try {
					var l = f.c.length
					wzh(out, tot, f, f.f, f.u, l)
					var badd = 30 + f.f.length + exfl(f.extra)
					var loc = tot + badd
					out.set(f.c, loc)
					wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l
				}
				catch (e) {
					return cb(e, null)
				}
			}
			wzf(out, o, files.length, cdl, oe)
			cb(null, out)
		}
		if (!lft)
			cbf()
		var _loop_1 = function (i) {
			var fn = k[i]
			var _a = r[fn], file = _a[0], p = _a[1]
			var c = crc(), size = file.length
			c.p(file)
			var f = strToU8(fn), s = f.length
			var com = p.comment, m = com && strToU8(com), ms = m && m.length
			var exl = exfl(p.extra)
			var compression = p.level == 0 ? 0 : 8
			var cbl = function (e, d) {
				if (e) {
					tAll()
					cb(e, null)
				}
				else {
					var l = d.length
					files[i] = mrg(p, {
						size: size,
						crc: c.d(),
						c: d,
						f: f,
						m: m,
						u: s != fn.length || (m && (com.length != ms)),
						compression: compression
					})
					o += 30 + s + exl + l
					tot += 76 + 2 * (s + exl) + (ms || 0) + l
					if (!--lft)
						cbf()
				}
			}
			if (s > 65535)
				cbl('filename too long', null)
			if (!compression)
				cbl(null, file)
			else if (size < 160000) {
				try {
					cbl(null, deflateSync(file, p))
				}
				catch (e) {
					cbl(e, null)
				}
			}
			else
				term.push(deflate(file, p, cbl))
		}
		// Cannot use lft because it can decrease
		for (var i = 0; i < slft; ++i) {
			_loop_1(i)
		}
		return tAll
	}
	/**
	 * Synchronously creates a ZIP file. Prefer using `zip` for better performance
	 * with more than one file.
	 * @param data The directory structure for the ZIP archive
	 * @param opts The main options, merged with per-file options
	 * @returns The generated ZIP archive
	 */
	function zipSync (data, opts) {
		if (!opts)
			opts = {}
		var r = {}
		var files = []
		fltn(data, '', r, opts)
		var o = 0
		var tot = 0
		for (var fn in r) {
			var _a = r[fn], file = _a[0], p = _a[1]
			var compression = p.level == 0 ? 0 : 8
			var f = strToU8(fn), s = f.length
			var com = p.comment, m = com && strToU8(com), ms = m && m.length
			var exl = exfl(p.extra)
			if (s > 65535)
				throw 'filename too long'
			var d = compression ? deflateSync(file, p) : file, l = d.length
			var c = crc()
			c.p(file)
			files.push(mrg(p, {
				size: file.length,
				crc: c.d(),
				c: d,
				f: f,
				m: m,
				u: s != fn.length || (m && (com.length != ms)),
				o: o,
				compression: compression
			}))
			o += 30 + s + exl + l
			tot += 76 + 2 * (s + exl) + (ms || 0) + l
		}
		var out = new u8(tot + 22), oe = o, cdl = tot - o
		for (var i = 0; i < files.length; ++i) {
			var f = files[i]
			wzh(out, f.o, f, f.f, f.u, f.c.length)
			var badd = 30 + f.f.length + exfl(f.extra)
			out.set(f.c, f.o + badd)
			wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0)
		}
		wzf(out, o, files.length, cdl, oe)
		return out
	}
	/**
	 * Streaming pass-through decompression for ZIP archives
	 */
	var UnzipPassThrough = /*#__PURE__*/ (function () {
		function UnzipPassThrough () {
		}
		UnzipPassThrough.prototype.push = function (data, final) {
			this.ondata(null, data, final)
		}
		UnzipPassThrough.compression = 0
		return UnzipPassThrough
	}())
	/**
	 * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for
	 * better performance.
	 */
	var UnzipInflate = /*#__PURE__*/ (function () {
		/**
		 * Creates a DEFLATE decompression that can be used in ZIP archives
		 */
		function UnzipInflate () {
			var _this_1 = this
			this.i = new Inflate(function (dat, final) {
				_this_1.ondata(null, dat, final)
			})
		}
		UnzipInflate.prototype.push = function (data, final) {
			try {
				this.i.push(data, final)
			}
			catch (e) {
				this.ondata(e, data, final)
			}
		}
		UnzipInflate.compression = 8
		return UnzipInflate
	}())
	/**
	 * Asynchronous streaming DEFLATE decompression for ZIP archives
	 */
	var AsyncUnzipInflate = /*#__PURE__*/ (function () {
		/**
		 * Creates a DEFLATE decompression that can be used in ZIP archives
		 */
		function AsyncUnzipInflate (_, sz) {
			var _this_1 = this
			if (sz < 320000) {
				this.i = new Inflate(function (dat, final) {
					_this_1.ondata(null, dat, final)
				})
			}
			else {
				this.i = new AsyncInflate(function (err, dat, final) {
					_this_1.ondata(err, dat, final)
				})
				this.terminate = this.i.terminate
			}
		}
		AsyncUnzipInflate.prototype.push = function (data, final) {
			if (this.i.terminate)
				data = slc(data, 0)
			this.i.push(data, final)
		}
		AsyncUnzipInflate.compression = 8
		return AsyncUnzipInflate
	}())
	/**
	 * A ZIP archive decompression stream that emits files as they are discovered
	 */
	var Unzip = /*#__PURE__*/ (function () {
		/**
		 * Creates a ZIP decompression stream
		 * @param cb The callback to call whenever a file in the ZIP archive is found
		 */
		function Unzip (cb) {
			this.onfile = cb
			this.k = []
			this.o = {
				0: UnzipPassThrough
			}
			this.p = et
		}
		/**
		 * Pushes a chunk to be unzipped
		 * @param chunk The chunk to push
		 * @param final Whether this is the last chunk
		 */
		Unzip.prototype.push = function (chunk, final) {
			var _this_1 = this
			if (!this.onfile)
				throw 'no callback'
			if (!this.p)
				throw 'stream finished'
			if (this.c > 0) {
				var len = Math.min(this.c, chunk.length)
				var toAdd = chunk.subarray(0, len)
				this.c -= len
				if (this.d)
					this.d.push(toAdd, !this.c)
				else
					this.k[0].push(toAdd)
				chunk = chunk.subarray(len)
				if (chunk.length)
					return this.push(chunk, final)
			}
			else {
				var f = 0, i = 0, is = void 0, buf = void 0
				if (!this.p.length)
					buf = chunk
				else if (!chunk.length)
					buf = this.p
				else {
					buf = new u8(this.p.length + chunk.length)
					buf.set(this.p), buf.set(chunk, this.p.length)
				}
				var l = buf.length, oc = this.c, add = oc && this.d
				var _loop_2 = function () {
					var _a
					var sig = b4(buf, i)
					if (sig == 0x4034B50) {
						f = 1, is = i
						this_1.d = null
						this_1.c = 0
						var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28)
						if (l > i + 30 + fnl + es) {
							var chks_2 = []
							this_1.k.unshift(chks_2)
							f = 2
							var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22)
							var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u)
							if (sc_1 == 4294967295) {
								_a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1]
							}
							else if (dd)
								sc_1 = -1
							i += es
							this_1.c = sc_1
							var d_1
							var file_1 = {
								name: fn_1,
								compression: cmp_1,
								start: function () {
									if (!file_1.ondata)
										throw 'no callback'
									if (!sc_1)
										file_1.ondata(null, et, true)
									else {
										var ctr = _this_1.o[cmp_1]
										if (!ctr)
											throw 'unknown compression type ' + cmp_1
										d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1)
										d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final) }
										for (var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++) {
											var dat = chks_3[_i]
											d_1.push(dat, false)
										}
										if (_this_1.k[0] == chks_2 && _this_1.c)
											_this_1.d = d_1
										else
											d_1.push(et, true)
									}
								},
								terminate: function () {
									if (d_1 && d_1.terminate)
										d_1.terminate()
								}
							}
							if (sc_1 >= 0)
								file_1.size = sc_1, file_1.originalSize = su_1
							this_1.onfile(file_1)
						}
						return "break"
					}
					else if (oc) {
						if (sig == 0x8074B50) {
							is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0
							return "break"
						}
						else if (sig == 0x2014B50) {
							is = i -= 4, f = 3, this_1.c = 0
							return "break"
						}
					}
				}
				var this_1 = this
				for (; i < l - 4; ++i) {
					var state_1 = _loop_2()
					if (state_1 === "break")
						break
				}
				this.p = et
				if (oc < 0) {
					var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i)
					if (add)
						add.push(dat, !!f)
					else
						this.k[+(f == 2)].push(dat)
				}
				if (f & 2)
					return this.push(buf.subarray(i), final)
				this.p = buf.subarray(i)
			}
			if (final) {
				if (this.c)
					throw 'invalid zip file'
				this.p = null
			}
		}
		/**
		 * Registers a decoder with the stream, allowing for files compressed with
		 * the compression type provided to be expanded correctly
		 * @param decoder The decoder constructor
		 */
		Unzip.prototype.register = function (decoder) {
			this.o[decoder.compression] = decoder
		}
		return Unzip
	}())
	/**
	 * Asynchronously decompresses a ZIP archive
	 * @param data The raw compressed ZIP file
	 * @param cb The callback to call with the decompressed files
	 * @returns A function that can be used to immediately terminate the unzipping
	 */
	function unzip (data, cb) {
		if (typeof cb != 'function')
			throw 'no callback'
		var term = []
		var tAll = function () {
			for (var i = 0; i < term.length; ++i)
				term[i]()
		}
		var files = {}
		var e = data.length - 22
		for (; b4(data, e) != 0x6054B50; --e) {
			if (!e || data.length - e > 65558) {
				cb('invalid zip file', null)
				return
			}
		}
		var lft = b2(data, e + 8)
		if (!lft)
			cb(null, {})
		var c = lft
		var o = b4(data, e + 16)
		var z = o == 4294967295
		if (z) {
			e = b4(data, e - 12)
			if (b4(data, e) != 0x6064B50) {
				cb('invalid zip file', null)
				return
			}
			c = lft = b4(data, e + 32)
			o = b4(data, e + 48)
		}
		var _loop_3 = function (i) {
			var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off)
			o = no
			var cbl = function (e, d) {
				if (e) {
					tAll()
					cb(e, null)
				}
				else {
					files[fn] = d
					if (!--lft)
						cb(null, files)
				}
			}
			if (!c_1)
				cbl(null, slc(data, b, b + sc))
			else if (c_1 == 8) {
				var infl = data.subarray(b, b + sc)
				if (sc < 320000) {
					try {
						cbl(null, inflateSync(infl, new u8(su)))
					}
					catch (e) {
						cbl(e, null)
					}
				}
				else
					term.push(inflate(infl, { size: su }, cbl))
			}
			else
				cbl('unknown compression type ' + c_1, null)
		}
		for (var i = 0; i < c; ++i) {
			_loop_3()
		}
		return tAll
	}
	/**
	 * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better
	 * performance with more than one file.
	 * @param data The raw compressed ZIP file
	 * @returns The decompressed files
	 */
	function unzipSync (data) {
		var files = {}
		var e = data.length - 22
		for (; b4(data, e) != 0x6054B50; --e) {
			if (!e || data.length - e > 65558)
				throw 'invalid zip file'
		}
		var c = b2(data, e + 8)
		if (!c)
			return {}
		var o = b4(data, e + 16)
		var z = o == 4294967295
		if (z) {
			e = b4(data, e - 12)
			if (b4(data, e) != 0x6064B50)
				throw 'invalid zip file'
			c = b4(data, e + 32)
			o = b4(data, e + 48)
		}
		for (var i = 0; i < c; ++i) {
			var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off)
			o = no
			if (!c_2)
				files[fn] = slc(data, b, b + sc)
			else if (c_2 == 8)
				files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su))
			else
				throw 'unknown compression type ' + c_2
		}
		return files
	}

	var fflate = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Deflate: Deflate,
		AsyncDeflate: AsyncDeflate,
		deflate: deflate,
		deflateSync: deflateSync,
		Inflate: Inflate,
		AsyncInflate: AsyncInflate,
		inflate: inflate,
		inflateSync: inflateSync,
		Gzip: Gzip,
		AsyncGzip: AsyncGzip,
		gzip: gzip,
		gzipSync: gzipSync,
		Gunzip: Gunzip,
		AsyncGunzip: AsyncGunzip,
		gunzip: gunzip,
		gunzipSync: gunzipSync,
		Zlib: Zlib,
		AsyncZlib: AsyncZlib,
		zlib: zlib,
		zlibSync: zlibSync,
		Unzlib: Unzlib,
		AsyncUnzlib: AsyncUnzlib,
		unzlib: unzlib,
		unzlibSync: unzlibSync,
		compress: gzip,
		AsyncCompress: AsyncGzip,
		compressSync: gzipSync,
		Compress: Gzip,
		Decompress: Decompress,
		AsyncDecompress: AsyncDecompress,
		decompress: decompress,
		decompressSync: decompressSync,
		DecodeUTF8: DecodeUTF8,
		EncodeUTF8: EncodeUTF8,
		strToU8: strToU8,
		strFromU8: strFromU8,
		ZipPassThrough: ZipPassThrough,
		ZipDeflate: ZipDeflate,
		AsyncZipDeflate: AsyncZipDeflate,
		Zip: Zip,
		zip: zip,
		zipSync: zipSync,
		UnzipPassThrough: UnzipPassThrough,
		UnzipInflate: UnzipInflate,
		AsyncUnzipInflate: AsyncUnzipInflate,
		Unzip: Unzip,
		unzip: unzip,
		unzipSync: unzipSync
	})

	/**
	 * NURBS utils
	 *
	 * See NURBSCurve and NURBSSurface.
	 **/


	/**************************************************************
	 *	NURBS Utils
	 **************************************************************/

	class NURBSUtils {

		/*
		Finds knot vector span.

		p : degree
		u : parametric value
		U : knot vector

		returns the span
		*/
		static findSpan (p, u, U) {

			const n = U.length - p - 1

			if (u >= U[n]) {

				return n - 1

			}

			if (u <= U[p]) {

				return p

			}

			let low = p
			let high = n
			let mid = Math.floor((low + high) / 2)

			while (u < U[mid] || u >= U[mid + 1]) {

				if (u < U[mid]) {

					high = mid

				} else {

					low = mid

				}

				mid = Math.floor((low + high) / 2)

			}

			return mid

		}


		/*
		Calculate basis functions. See The NURBS Book, page 70, algorithm A2.2

		span : span in which u lies
		u    : parametric point
		p    : degree
		U    : knot vector

		returns array[p+1] with basis functions values.
		*/
		static calcBasisFunctions (span, u, p, U) {

			const N = []
			const left = []
			const right = []
			N[0] = 1.0

			for (let j = 1; j <= p; ++j) {

				left[j] = u - U[span + 1 - j]
				right[j] = U[span + j] - u

				let saved = 0.0

				for (let r = 0; r < j; ++r) {

					const rv = right[r + 1]
					const lv = left[j - r]
					const temp = N[r] / (rv + lv)
					N[r] = saved + rv * temp
					saved = lv * temp

				}

				N[j] = saved

			}

			return N

		}


		/*
		Calculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.

		p : degree of B-Spline
		U : knot vector
		P : control points (x, y, z, w)
		u : parametric point

		returns point for given u
		*/
		static calcBSplinePoint (p, U, P, u) {

			const span = this.findSpan(p, u, U)
			const N = this.calcBasisFunctions(span, u, p, U)
			const C = new Vector4(0, 0, 0, 0)

			for (let j = 0; j <= p; ++j) {

				const point = P[span - p + j]
				const Nj = N[j]
				const wNj = point.w * Nj
				C.x += point.x * wNj
				C.y += point.y * wNj
				C.z += point.z * wNj
				C.w += point.w * Nj

			}

			return C

		}


		/*
		Calculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.

		span : span in which u lies
		u    : parametric point
		p    : degree
		n    : number of derivatives to calculate
		U    : knot vector

		returns array[n+1][p+1] with basis functions derivatives
		*/
		static calcBasisFunctionDerivatives (span, u, p, n, U) {

			const zeroArr = []
			for (let i = 0; i <= p; ++i)
				zeroArr[i] = 0.0

			const ders = []

			for (let i = 0; i <= n; ++i)
				ders[i] = zeroArr.slice(0)

			const ndu = []

			for (let i = 0; i <= p; ++i)
				ndu[i] = zeroArr.slice(0)

			ndu[0][0] = 1.0

			const left = zeroArr.slice(0)
			const right = zeroArr.slice(0)

			for (let j = 1; j <= p; ++j) {

				left[j] = u - U[span + 1 - j]
				right[j] = U[span + j] - u

				let saved = 0.0

				for (let r = 0; r < j; ++r) {

					const rv = right[r + 1]
					const lv = left[j - r]
					ndu[j][r] = rv + lv

					const temp = ndu[r][j - 1] / ndu[j][r]
					ndu[r][j] = saved + rv * temp
					saved = lv * temp

				}

				ndu[j][j] = saved

			}

			for (let j = 0; j <= p; ++j) {

				ders[0][j] = ndu[j][p]

			}

			for (let r = 0; r <= p; ++r) {

				let s1 = 0
				let s2 = 1

				const a = []
				for (let i = 0; i <= p; ++i) {

					a[i] = zeroArr.slice(0)

				}

				a[0][0] = 1.0

				for (let k = 1; k <= n; ++k) {

					let d = 0.0
					const rk = r - k
					const pk = p - k

					if (r >= k) {

						a[s2][0] = a[s1][0] / ndu[pk + 1][rk]
						d = a[s2][0] * ndu[rk][pk]

					}

					const j1 = (rk >= - 1) ? 1 : - rk
					const j2 = (r - 1 <= pk) ? k - 1 : p - r

					for (let j = j1; j <= j2; ++j) {

						a[s2][j] = (a[s1][j] - a[s1][j - 1]) / ndu[pk + 1][rk + j]
						d += a[s2][j] * ndu[rk + j][pk]

					}

					if (r <= pk) {

						a[s2][k] = - a[s1][k - 1] / ndu[pk + 1][r]
						d += a[s2][k] * ndu[r][pk]

					}

					ders[k][r] = d

					const j = s1
					s1 = s2
					s2 = j

				}

			}

			let r = p

			for (let k = 1; k <= n; ++k) {

				for (let j = 0; j <= p; ++j) {

					ders[k][j] *= r

				}

				r *= p - k

			}

			return ders

		}


		/*
			Calculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.

			p  : degree
			U  : knot vector
			P  : control points
			u  : Parametric points
			nd : number of derivatives

			returns array[d+1] with derivatives
			*/
		static calcBSplineDerivatives (p, U, P, u, nd) {

			const du = nd < p ? nd : p
			const CK = []
			const span = this.findSpan(p, u, U)
			const nders = this.calcBasisFunctionDerivatives(span, u, p, du, U)
			const Pw = []

			for (let i = 0; i < P.length; ++i) {

				const point = P[i].clone()
				const w = point.w

				point.x *= w
				point.y *= w
				point.z *= w

				Pw[i] = point

			}

			for (let k = 0; k <= du; ++k) {

				const point = Pw[span - p].clone().multiplyScalar(nders[k][0])

				for (let j = 1; j <= p; ++j) {

					point.add(Pw[span - p + j].clone().multiplyScalar(nders[k][j]))

				}

				CK[k] = point

			}

			for (let k = du + 1; k <= nd + 1; ++k) {

				CK[k] = new Vector4(0, 0, 0)

			}

			return CK

		}


		/*
		Calculate "K over I"

		returns k!/(i!(k-i)!)
		*/
		static calcKoverI (k, i) {

			let nom = 1

			for (let j = 2; j <= k; ++j) {

				nom *= j

			}

			let denom = 1

			for (let j = 2; j <= i; ++j) {

				denom *= j

			}

			for (let j = 2; j <= k - i; ++j) {

				denom *= j

			}

			return nom / denom

		}


		/*
		Calculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.

		Pders : result of function calcBSplineDerivatives

		returns array with derivatives for rational curve.
		*/
		static calcRationalCurveDerivatives (Pders) {

			const nd = Pders.length
			const Aders = []
			const wders = []

			for (let i = 0; i < nd; ++i) {

				const point = Pders[i]
				Aders[i] = new Vector3(point.x, point.y, point.z)
				wders[i] = point.w

			}

			const CK = []

			for (let k = 0; k < nd; ++k) {

				const v = Aders[k].clone()

				for (let i = 1; i <= k; ++i) {

					v.sub(CK[k - i].clone().multiplyScalar(this.calcKoverI(k, i) * wders[i]))

				}

				CK[k] = v.divideScalar(wders[0])

			}

			return CK

		}


		/*
		Calculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.

		p  : degree
		U  : knot vector
		P  : control points in homogeneous space
		u  : parametric points
		nd : number of derivatives

		returns array with derivatives.
		*/
		static calcNURBSDerivatives (p, U, P, u, nd) {

			const Pders = this.calcBSplineDerivatives(p, U, P, u, nd)
			return this.calcRationalCurveDerivatives(Pders)

		}


		/*
		Calculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.

		p1, p2 : degrees of B-Spline surface
		U1, U2 : knot vectors
		P      : control points (x, y, z, w)
		u, v   : parametric values

		returns point for given (u, v)
		*/
		static calcSurfacePoint (p, q, U, V, P, u, v, target) {

			const uspan = this.findSpan(p, u, U)
			const vspan = this.findSpan(q, v, V)
			const Nu = this.calcBasisFunctions(uspan, u, p, U)
			const Nv = this.calcBasisFunctions(vspan, v, q, V)
			const temp = []

			for (let l = 0; l <= q; ++l) {

				temp[l] = new Vector4(0, 0, 0, 0)
				for (let k = 0; k <= p; ++k) {

					const point = P[uspan - p + k][vspan - q + l].clone()
					const w = point.w
					point.x *= w
					point.y *= w
					point.z *= w
					temp[l].add(point.multiplyScalar(Nu[k]))

				}

			}

			const Sw = new Vector4(0, 0, 0, 0)
			for (let l = 0; l <= q; ++l) {

				Sw.add(temp[l].multiplyScalar(Nv[l]))

			}

			Sw.divideScalar(Sw.w)
			target.set(Sw.x, Sw.y, Sw.z)

		}

	}

	/**
	 * NURBS curve object
	 *
	 * Derives from Curve, overriding getPoint and getTangent.
	 *
	 * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.
	 *
	 **/

	class NURBSCurve extends Curve {

		constructor(
			degree,
			knots /* array of reals */,
			controlPoints /* array of Vector(2|3|4) */,
			startKnot /* index in knots */,
			endKnot /* index in knots */
		) {

			super()

			this.degree = degree
			this.knots = knots
			this.controlPoints = []
			// Used by periodic NURBS to remove hidden spans
			this.startKnot = startKnot || 0
			this.endKnot = endKnot || (this.knots.length - 1)

			for (let i = 0; i < controlPoints.length; ++i) {

				// ensure Vector4 for control points
				const point = controlPoints[i]
				this.controlPoints[i] = new Vector4(point.x, point.y, point.z, point.w)

			}

		}

		getPoint (t, optionalTarget = new Vector3()) {

			const point = optionalTarget

			const u = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]) // linear mapping t->u

			// following results in (wx, wy, wz, w) homogeneous point
			const hpoint = NURBSUtils.calcBSplinePoint(this.degree, this.knots, this.controlPoints, u)

			if (hpoint.w !== 1.0) {

				// project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)
				hpoint.divideScalar(hpoint.w)

			}

			return point.set(hpoint.x, hpoint.y, hpoint.z)

		}

		getTangent (t, optionalTarget = new Vector3()) {

			const tangent = optionalTarget

			const u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0])
			const ders = NURBSUtils.calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1)
			tangent.copy(ders[1]).normalize()

			return tangent

		}

	}

	/**
	 * Loader loads FBX file and generates Group representing FBX scene.
	 * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format
	 * Versions lower than this may load but will probably have errors
	 *
	 * Needs Support:
	 *  Morph normals / blend shape normals
	 *
	 * FBX format references:
	 * 	https://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure
	 * 	http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)
	 *
	 * 	Binary format specification:
	 *		https://code.blender.org/2013/08/fbx-binary-file-format-specification/
	 */

	let fbxTree
	let connections
	let sceneGraph

	class FBXLoader extends Loader {
		constructor(manager) {
			super(manager)
		}

		load (url, onLoad, onProgress, onError) {
			const scope = this

			const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path

			const loader = new FileLoader(this.manager)
			loader.setPath(scope.path)
			loader.setResponseType('arraybuffer')
			loader.setRequestHeader(scope.requestHeader)
			loader.setWithCredentials(scope.withCredentials)

			loader.load(
				url,
				function (buffer) {
					try {
						onLoad(scope.parse(buffer, path))
					} catch (e) {
						if (onError) {
							onError(e)
						} else {
							console.error(e)
						}

						scope.manager.itemError(url)
					}
				},
				onProgress,
				onError
			)
		}

		parse (FBXBuffer, path) {
			if (isFbxFormatBinary(FBXBuffer)) {
				fbxTree = new BinaryParser().parse(FBXBuffer)
			} else {
				const FBXText = convertArrayBufferToString(FBXBuffer)

				if (!isFbxFormatASCII(FBXText)) {
					throw new Error('THREE.FBXLoader: Unknown format.')
				}

				if (getFbxVersion(FBXText) < 7000) {
					throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion(FBXText))
				}

				fbxTree = new TextParser().parse(FBXText)
			}

			// console.log( fbxTree );

			const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin)

			return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree)
		}
	}

	// Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group
	class FBXTreeParser {
		constructor(textureLoader, manager) {
			this.textureLoader = textureLoader
			this.manager = manager
		}

		parse () {
			connections = this.parseConnections()

			const images = this.parseImages()
			const textures = this.parseTextures(images)
			const materials = this.parseMaterials(textures)
			const deformers = this.parseDeformers()
			const geometryMap = new GeometryParser().parse(deformers)

			this.parseScene(deformers, geometryMap, materials)

			return sceneGraph
		}

		// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
		// and details the connection type
		parseConnections () {
			const connectionMap = new Map()

			if ('Connections' in fbxTree) {
				const rawConnections = fbxTree.Connections.connections

				rawConnections.forEach(function (rawConnection) {
					const fromID = rawConnection[0]
					const toID = rawConnection[1]
					const relationship = rawConnection[2]

					if (!connectionMap.has(fromID)) {
						connectionMap.set(fromID, {
							parents: [],
							children: []
						})
					}

					const parentRelationship = { ID: toID, relationship: relationship }
					connectionMap.get(fromID).parents.push(parentRelationship)

					if (!connectionMap.has(toID)) {
						connectionMap.set(toID, {
							parents: [],
							children: []
						})
					}

					const childRelationship = { ID: fromID, relationship: relationship }
					connectionMap.get(toID).children.push(childRelationship)
				})
			}

			return connectionMap
		}

		// Parse FBXTree.Objects.Video for embedded image data
		// These images are connected to textures in FBXTree.Objects.Textures
		// via FBXTree.Connections.
		parseImages () {
			const images = {}
			const blobs = {}

			if ('Video' in fbxTree.Objects) {
				const videoNodes = fbxTree.Objects.Video

				for (const nodeID in videoNodes) {
					const videoNode = videoNodes[nodeID]

					const id = parseInt(nodeID)

					images[id] = videoNode.RelativeFilename || videoNode.Filename

					// raw image data is in videoNode.Content
					if ('Content' in videoNode) {
						const arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0
						const base64Content = typeof videoNode.Content === 'string' && videoNode.Content !== ''

						if (arrayBufferContent || base64Content) {
							const image = this.parseImage(videoNodes[nodeID])

							blobs[videoNode.RelativeFilename || videoNode.Filename] = image
						}
					}
				}
			}

			for (const id in images) {
				const filename = images[id]

				if (blobs[filename] !== undefined) images[id] = blobs[filename]
				else images[id] = images[id].split('\\').pop()
			}

			return images
		}

		// Parse embedded image data in FBXTree.Video.Content
		parseImage (videoNode) {
			const content = videoNode.Content
			const fileName = videoNode.RelativeFilename || videoNode.Filename
			const extension = fileName.slice(fileName.lastIndexOf('.') + 1).toLowerCase()

			let type

			switch (extension) {
				case 'bmp':
					type = 'image/bmp'
					break

				case 'jpg':
				case 'jpeg':
					type = 'image/jpeg'
					break

				case 'png':
					type = 'image/png'
					break

				case 'tif':
					type = 'image/tiff'
					break

				case 'tga':
					if (this.manager.getHandler('.tga') === null) {
						console.warn('FBXLoader: TGA loader not found, skipping ', fileName)
					}

					type = 'image/tga'
					break

				default:
					console.warn('FBXLoader: Image type "' + extension + '" is not supported.')
					return
			}

			if (typeof content === 'string') {
				// ASCII format

				return 'data:' + type + ';base64,' + content
			} else {
				// Binary Format

				const array = new Uint8Array(content)
				return window.URL.createObjectURL(new Blob([array], { type: type }))
			}
		}

		// Parse nodes in FBXTree.Objects.Texture
		// These contain details such as UV scaling, cropping, rotation etc and are connected
		// to images in FBXTree.Objects.Video
		parseTextures (images) {
			const textureMap = new Map()

			if ('Texture' in fbxTree.Objects) {
				const textureNodes = fbxTree.Objects.Texture
				for (const nodeID in textureNodes) {
					const texture = this.parseTexture(textureNodes[nodeID], images)
					textureMap.set(parseInt(nodeID), texture)
				}
			}

			return textureMap
		}

		// Parse individual node in FBXTree.Objects.Texture
		parseTexture (textureNode, images) {
			const texture = this.loadTexture(textureNode, images)

			texture.ID = textureNode.id

			texture.name = textureNode.attrName

			const wrapModeU = textureNode.WrapModeU
			const wrapModeV = textureNode.WrapModeV

			const valueU = wrapModeU !== undefined ? wrapModeU.value : 0
			const valueV = wrapModeV !== undefined ? wrapModeV.value : 0

			// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a
			// 0: repeat(default), 1: clamp

			texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping
			texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping

			if ('Scaling' in textureNode) {
				const values = textureNode.Scaling.value

				texture.repeat.x = values[0]
				texture.repeat.y = values[1]
			}

			return texture
		}

		// load a texture specified as a blob or data URI, or via an external URL using TextureLoader
		loadTexture (textureNode, images) {
			// console.log('textureNode, images', textureNode, images)

			let fileName

			const currentPath = this.textureLoader.path

			const children = connections.get(textureNode.id).children

			if (children !== undefined && children.length > 0 && images[children[0].ID] !== undefined) {
				fileName = images[children[0].ID]

				if (fileName.indexOf('blob:') === 0 || fileName.indexOf('data:') === 0) {
					this.textureLoader.setPath(undefined)
				}
			}

			let texture

			const extension = textureNode.FileName.slice(-3).toLowerCase()

			if (extension === 'tga') {
				const loader = this.manager.getHandler('.tga')

				if (loader === null) {
					console.warn('FBXLoader: TGA loader not found, creating placeholder texture for', textureNode.RelativeFilename)
					texture = new Texture()
				} else {
					loader.setPath(this.textureLoader.path)
					texture = loader.load(fileName)
				}
			} else if (extension === 'psd') {
				console.warn('FBXLoader: PSD textures are not supported, creating placeholder texture for', textureNode.RelativeFilename)
				texture = new Texture()
			} else {
				texture = this.textureLoader.load(fileName)
			}

			this.textureLoader.setPath(currentPath)

			return texture
		}

		// Parse nodes in FBXTree.Objects.Material
		parseMaterials (textureMap) {
			const materialMap = new Map()

			if ('Material' in fbxTree.Objects) {
				const materialNodes = fbxTree.Objects.Material

				for (const nodeID in materialNodes) {
					const material = this.parseMaterial(materialNodes[nodeID], textureMap)

					if (material !== null) materialMap.set(parseInt(nodeID), material)
				}
			}

			return materialMap
		}

		// Parse single node in FBXTree.Objects.Material
		// Materials are connected to texture maps in FBXTree.Objects.Textures
		// FBX format currently only supports Lambert and Phong shading models
		parseMaterial (materialNode, textureMap) {
			const ID = materialNode.id
			const name = materialNode.attrName
			let type = materialNode.ShadingModel

			// Case where FBX wraps shading model in property object.
			if (typeof type === 'object') {
				type = type.value
			}

			// Ignore unused materials which don't have any connections.
			if (!connections.has(ID)) return null

			const parameters = this.parseParameters(materialNode, textureMap, ID)

			let material

			switch (type.toLowerCase()) {
				case 'phong':
					material = new MeshPhongMaterial()
					break
				case 'lambert':
					material = new MeshLambertMaterial()
					break
				default:
					console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', type)
					material = new MeshPhongMaterial()
					break
			}

			material.setValues(parameters)
			material.name = name

			return material
		}

		// Parse FBX material and return parameters suitable for a three.js material
		// Also parse the texture map and return any textures associated with the material
		parseParameters (materialNode, textureMap, ID) {
			const parameters = {}

			if (materialNode.BumpFactor) {
				parameters.bumpScale = materialNode.BumpFactor.value
			}

			if (materialNode.Diffuse) {
				parameters.color = new Color().fromArray(materialNode.Diffuse.value)
			} else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB')) {
				// The blender exporter exports diffuse here instead of in materialNode.Diffuse
				parameters.color = new Color().fromArray(materialNode.DiffuseColor.value)
			}

			if (materialNode.DisplacementFactor) {
				parameters.displacementScale = materialNode.DisplacementFactor.value
			}

			if (materialNode.Emissive) {
				parameters.emissive = new Color().fromArray(materialNode.Emissive.value)
			} else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB')) {
				// The blender exporter exports emissive color here instead of in materialNode.Emissive
				parameters.emissive = new Color().fromArray(materialNode.EmissiveColor.value)
			}

			if (materialNode.EmissiveFactor) {
				parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value)
			}

			if (materialNode.Opacity) {
				parameters.opacity = parseFloat(materialNode.Opacity.value)
			}

			if (parameters.opacity < 1.0) {
				parameters.transparent = true
			}

			if (materialNode.ReflectionFactor) {
				parameters.reflectivity = materialNode.ReflectionFactor.value
			}

			if (materialNode.Shininess) {
				parameters.shininess = materialNode.Shininess.value
			}

			if (materialNode.Specular) {
				parameters.specular = new Color().fromArray(materialNode.Specular.value)
			} else if (materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color') {
				// The blender exporter exports specular color here instead of in materialNode.Specular
				parameters.specular = new Color().fromArray(materialNode.SpecularColor.value)
			}

			const scope = this
			connections.get(ID).children.forEach(function (child) {
				const type = child.relationship

				switch (type) {
					case 'Bump':
						parameters.bumpMap = scope.getTexture(textureMap, child.ID)
						break

					case 'Maya|TEX_ao_map':
						parameters.aoMap = scope.getTexture(textureMap, child.ID)
						break

					case 'DiffuseColor':
					case 'Maya|TEX_color_map':
						parameters.map = scope.getTexture(textureMap, child.ID)
						if (parameters.map !== undefined) {
							parameters.map.encoding = sRGBEncoding
						}
						break

					case 'DisplacementColor':
						parameters.displacementMap = scope.getTexture(textureMap, child.ID)
						break

					case 'EmissiveColor':
						parameters.emissiveMap = scope.getTexture(textureMap, child.ID)
						if (parameters.emissiveMap !== undefined) {
							parameters.emissiveMap.encoding = sRGBEncoding
						}
						break

					case 'NormalMap':
					case 'Maya|TEX_normal_map':
						parameters.normalMap = scope.getTexture(textureMap, child.ID)
						break

					case 'ReflectionColor':
						parameters.envMap = scope.getTexture(textureMap, child.ID)
						if (parameters.envMap !== undefined) {
							parameters.envMap.mapping = EquirectangularReflectionMapping
							parameters.envMap.encoding = sRGBEncoding
						}
						break

					case 'SpecularColor':
						parameters.specularMap = scope.getTexture(textureMap, child.ID)
						if (parameters.specularMap !== undefined) {
							parameters.specularMap.encoding = sRGBEncoding
						}
						break

					case 'TransparentColor':
					case 'TransparencyFactor':
						parameters.alphaMap = scope.getTexture(textureMap, child.ID)
						parameters.transparent = true
						break

					case 'AmbientColor':
					case 'ShininessExponent': // AKA glossiness map
					case 'SpecularFactor': // AKA specularLevel
					case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor
					default:
						console.warn('THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type)
						break
				}
			})

			return parameters
		}

		// get a texture from the textureMap for use by a material.
		getTexture (textureMap, id) {
			// if the texture is a layered texture, just use the first layer and issue a warning
			if ('LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture) {
				console.warn('THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.')
				id = connections.get(id).children[0].ID
			}

			const texture = textureMap.get(id)

			return texture
			// if (texture.image !== undefined) {
			// } else {
			//   return undefined
			// }
		}

		// Parse nodes in FBXTree.Objects.Deformer
		// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
		// Generates map of Skeleton-like objects for use later when generating and binding skeletons.
		parseDeformers () {
			const skeletons = {}
			const morphTargets = {}

			if ('Deformer' in fbxTree.Objects) {
				const DeformerNodes = fbxTree.Objects.Deformer

				for (const nodeID in DeformerNodes) {
					const deformerNode = DeformerNodes[nodeID]

					const relationships = connections.get(parseInt(nodeID))

					if (deformerNode.attrType === 'Skin') {
						const skeleton = this.parseSkeleton(relationships, DeformerNodes)
						skeleton.ID = nodeID

						if (relationships.parents.length > 1) console.warn('THREE.FBXLoader: skeleton attached to more than one geometry is not supported.')
						skeleton.geometryID = relationships.parents[0].ID

						skeletons[nodeID] = skeleton
					} else if (deformerNode.attrType === 'BlendShape') {
						const morphTarget = {
							id: nodeID
						}

						morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes)
						morphTarget.id = nodeID

						if (relationships.parents.length > 1) console.warn('THREE.FBXLoader: morph target attached to more than one geometry is not supported.')

						morphTargets[nodeID] = morphTarget
					}
				}
			}

			return {
				skeletons: skeletons,
				morphTargets: morphTargets
			}
		}

		// Parse single nodes in FBXTree.Objects.Deformer
		// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
		// Each skin node represents a skeleton and each cluster node represents a bone
		parseSkeleton (relationships, deformerNodes) {
			const rawBones = []

			relationships.children.forEach(function (child) {
				const boneNode = deformerNodes[child.ID]

				if (boneNode.attrType !== 'Cluster') return

				const rawBone = {
					ID: child.ID,
					indices: [],
					weights: [],
					transformLink: new Matrix4().fromArray(boneNode.TransformLink.a)
					// transform: new Matrix4().fromArray( boneNode.Transform.a ),
					// linkMode: boneNode.Mode,
				}

				if ('Indexes' in boneNode) {
					rawBone.indices = boneNode.Indexes.a
					rawBone.weights = boneNode.Weights.a
				}

				rawBones.push(rawBone)
			})

			return {
				rawBones: rawBones,
				bones: []
			}
		}

		// The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
		parseMorphTargets (relationships, deformerNodes) {
			const rawMorphTargets = []

			for (let i = 0; i < relationships.children.length; i++) {
				const child = relationships.children[i]

				const morphTargetNode = deformerNodes[child.ID]

				const rawMorphTarget = {
					name: morphTargetNode.attrName,
					initialWeight: morphTargetNode.DeformPercent,
					id: morphTargetNode.id,
					fullWeights: morphTargetNode.FullWeights.a
				}

				if (morphTargetNode.attrType !== 'BlendShapeChannel') return

				rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function (child) {
					return child.relationship === undefined
				})[0].ID

				rawMorphTargets.push(rawMorphTarget)
			}

			return rawMorphTargets
		}

		// create the main Group() to be returned by the loader
		parseScene (deformers, geometryMap, materialMap) {
			sceneGraph = new Group$1()

			const modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap)

			const modelNodes = fbxTree.Objects.Model

			const scope = this
			modelMap.forEach(function (model) {
				const modelNode = modelNodes[model.ID]
				scope.setLookAtProperties(model, modelNode)

				const parentConnections = connections.get(model.ID).parents

				parentConnections.forEach(function (connection) {
					const parent = modelMap.get(connection.ID)
					if (parent !== undefined) parent.add(model)
				})

				if (model.parent === null) {
					sceneGraph.add(model)
				}
			})

			this.bindSkeleton(deformers.skeletons, geometryMap, modelMap)

			this.createAmbientLight()

			sceneGraph.traverse(function (node) {
				if (node.userData.transformData) {
					if (node.parent) {
						node.userData.transformData.parentMatrix = node.parent.matrix
						node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld
					}

					const transform = generateTransform(node.userData.transformData)

					node.applyMatrix4(transform)
					node.updateWorldMatrix()
				}
			})

			const animations = new AnimationParser().parse()

			// if all the models where already combined in a single group, just return that
			if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {
				sceneGraph.children[0].animations = animations
				sceneGraph = sceneGraph.children[0]
			}

			sceneGraph.animations = animations
		}

		// parse nodes in FBXTree.Objects.Model
		parseModels (skeletons, geometryMap, materialMap) {
			const modelMap = new Map()
			const modelNodes = fbxTree.Objects.Model

			for (const nodeID in modelNodes) {
				const id = parseInt(nodeID)
				const node = modelNodes[nodeID]
				const relationships = connections.get(id)

				let model = this.buildSkeleton(relationships, skeletons, id, node.attrName)

				if (!model) {
					switch (node.attrType) {
						case 'Camera':
							model = this.createCamera(relationships)
							break
						case 'Light':
							model = this.createLight(relationships)
							break
						case 'Mesh':
							model = this.createMesh(relationships, geometryMap, materialMap)
							break
						case 'NurbsCurve':
							model = this.createCurve(relationships, geometryMap)
							break
						case 'LimbNode':
						case 'Root':
							model = new Bone()
							break
						case 'Null':
						default:
							model = new Group$1()
							break
					}

					model.name = node.attrName ? PropertyBinding.sanitizeNodeName(node.attrName) : ''

					model.ID = id
				}

				this.getTransformData(model, node)
				modelMap.set(id, model)
			}

			return modelMap
		}

		buildSkeleton (relationships, skeletons, id, name) {
			let bone = null

			relationships.parents.forEach(function (parent) {
				for (const ID in skeletons) {
					const skeleton = skeletons[ID]

					skeleton.rawBones.forEach(function (rawBone, i) {
						if (rawBone.ID === parent.ID) {
							const subBone = bone
							bone = new Bone()

							bone.matrixWorld.copy(rawBone.transformLink)

							// set name and id here - otherwise in cases where "subBone" is created it will not have a name / id

							bone.name = name ? PropertyBinding.sanitizeNodeName(name) : ''
							bone.ID = id

							skeleton.bones[i] = bone

							// In cases where a bone is shared between multiple meshes
							// duplicate the bone here and and it as a child of the first bone
							if (subBone !== null) {
								bone.add(subBone)
							}
						}
					})
				}
			})

			return bone
		}

		// create a PerspectiveCamera or OrthographicCamera
		createCamera (relationships) {
			let model
			let cameraAttribute

			relationships.children.forEach(function (child) {
				const attr = fbxTree.Objects.NodeAttribute[child.ID]

				if (attr !== undefined) {
					cameraAttribute = attr
				}
			})

			if (cameraAttribute === undefined) {
				model = new Object3D()
			} else {
				let type = 0
				if (cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1) {
					type = 1
				}

				let nearClippingPlane = 1
				if (cameraAttribute.NearPlane !== undefined) {
					nearClippingPlane = cameraAttribute.NearPlane.value / 1000
				}

				let farClippingPlane = 1000
				if (cameraAttribute.FarPlane !== undefined) {
					farClippingPlane = cameraAttribute.FarPlane.value / 1000
				}

				let width = window.innerWidth
				let height = window.innerHeight

				if (cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined) {
					width = cameraAttribute.AspectWidth.value
					height = cameraAttribute.AspectHeight.value
				}

				const aspect = width / height

				let fov = 45
				if (cameraAttribute.FieldOfView !== undefined) {
					fov = cameraAttribute.FieldOfView.value
				}

				const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null

				switch (type) {
					case 0: // Perspective
						model = new PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane)
						if (focalLength !== null) model.setFocalLength(focalLength)
						break

					case 1: // Orthographic
						model = new OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane)
						break

					default:
						console.warn('THREE.FBXLoader: Unknown camera type ' + type + '.')
						model = new Object3D()
						break
				}
			}

			return model
		}

		// Create a DirectionalLight, PointLight or SpotLight
		createLight (relationships) {
			let model
			let lightAttribute

			relationships.children.forEach(function (child) {
				const attr = fbxTree.Objects.NodeAttribute[child.ID]

				if (attr !== undefined) {
					lightAttribute = attr
				}
			})

			if (lightAttribute === undefined) {
				model = new Object3D()
			} else {
				let type

				// LightType can be undefined for Point lights
				if (lightAttribute.LightType === undefined) {
					type = 0
				} else {
					type = lightAttribute.LightType.value
				}

				let color = 0xffffff

				if (lightAttribute.Color !== undefined) {
					color = new Color().fromArray(lightAttribute.Color.value)
				}

				let intensity = lightAttribute.Intensity === undefined ? 1 : lightAttribute.Intensity.value / 100

				// light disabled
				if (lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0) {
					intensity = 0
				}

				let distance = 0
				if (lightAttribute.FarAttenuationEnd !== undefined) {
					if (lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0) {
						distance = 0
					} else {
						distance = lightAttribute.FarAttenuationEnd.value
					}
				}

				// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?
				const decay = 1

				switch (type) {
					case 0: // Point
						model = new PointLight(color, intensity, distance, decay)
						break

					case 1: // Directional
						model = new DirectionalLight(color, intensity)
						break

					case 2: // Spot
						let angle = Math.PI / 3

						if (lightAttribute.InnerAngle !== undefined) {
							angle = MathUtils.degToRad(lightAttribute.InnerAngle.value)
						}

						let penumbra = 0
						if (lightAttribute.OuterAngle !== undefined) {
							// TODO: this is not correct - FBX calculates outer and inner angle in degrees
							// with OuterAngle > InnerAngle && OuterAngle <= Math.PI
							// while three.js uses a penumbra between (0, 1) to attenuate the inner angle
							penumbra = MathUtils.degToRad(lightAttribute.OuterAngle.value)
							penumbra = Math.max(penumbra, 1)
						}

						model = new SpotLight(color, intensity, distance, angle, penumbra, decay)
						break

					default:
						console.warn('THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.')
						model = new PointLight(color, intensity)
						break
				}

				if (lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1) {
					model.castShadow = true
				}
			}

			return model
		}

		createMesh (relationships, geometryMap, materialMap) {
			let model
			let geometry = null
			let material = null
			const materials = []

			// get geometry and materials(s) from connections
			relationships.children.forEach(function (child) {
				if (geometryMap.has(child.ID)) {
					geometry = geometryMap.get(child.ID)
				}

				if (materialMap.has(child.ID)) {
					materials.push(materialMap.get(child.ID))
				}
			})

			if (materials.length > 1) {
				material = materials
			} else if (materials.length > 0) {
				material = materials[0]
			} else {
				material = new MeshPhongMaterial({ color: 0xcccccc })
				materials.push(material)
			}

			if ('color' in geometry.attributes) {
				materials.forEach(function (material) {
					material.vertexColors = true
				})
			}

			if (geometry.FBX_Deformer) {
				model = new SkinnedMesh(geometry, material)
				model.normalizeSkinWeights()
			} else {
				model = new Mesh(geometry, material)
			}

			return model
		}

		createCurve (relationships, geometryMap) {
			const geometry = relationships.children.reduce(function (geo, child) {
				if (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID)

				return geo
			}, null)

			// FBX does not list materials for Nurbs lines, so we'll just put our own in here.
			const material = new LineBasicMaterial({ color: 0x3300ff, linewidth: 1 })
			return new Line(geometry, material)
		}

		// parse the model node for transform data
		getTransformData (model, modelNode) {
			const transformData = {}

			if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value)

			if ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value)
			else transformData.eulerOrder = 'ZYX'

			if ('Lcl_Translation' in modelNode) transformData.translation = modelNode.Lcl_Translation.value

			if ('PreRotation' in modelNode) transformData.preRotation = modelNode.PreRotation.value
			if ('Lcl_Rotation' in modelNode) transformData.rotation = modelNode.Lcl_Rotation.value
			if ('PostRotation' in modelNode) transformData.postRotation = modelNode.PostRotation.value

			if ('Lcl_Scaling' in modelNode) transformData.scale = modelNode.Lcl_Scaling.value

			if ('ScalingOffset' in modelNode) transformData.scalingOffset = modelNode.ScalingOffset.value
			if ('ScalingPivot' in modelNode) transformData.scalingPivot = modelNode.ScalingPivot.value

			if ('RotationOffset' in modelNode) transformData.rotationOffset = modelNode.RotationOffset.value
			if ('RotationPivot' in modelNode) transformData.rotationPivot = modelNode.RotationPivot.value

			model.userData.transformData = transformData
		}

		setLookAtProperties (model, modelNode) {
			if ('LookAtProperty' in modelNode) {
				const children = connections.get(model.ID).children

				children.forEach(function (child) {
					if (child.relationship === 'LookAtProperty') {
						const lookAtTarget = fbxTree.Objects.Model[child.ID]

						if ('Lcl_Translation' in lookAtTarget) {
							const pos = lookAtTarget.Lcl_Translation.value

							// DirectionalLight, SpotLight
							if (model.target !== undefined) {
								model.target.position.fromArray(pos)
								sceneGraph.add(model.target)
							} else {
								// Cameras and other Object3Ds

								model.lookAt(new Vector3().fromArray(pos))
							}
						}
					}
				})
			}
		}

		bindSkeleton (skeletons, geometryMap, modelMap) {
			const bindMatrices = this.parsePoseNodes()

			for (const ID in skeletons) {
				const skeleton = skeletons[ID]

				const parents = connections.get(parseInt(skeleton.ID)).parents

				parents.forEach(function (parent) {
					if (geometryMap.has(parent.ID)) {
						const geoID = parent.ID
						const geoRelationships = connections.get(geoID)

						geoRelationships.parents.forEach(function (geoConnParent) {
							if (modelMap.has(geoConnParent.ID)) {
								const model = modelMap.get(geoConnParent.ID)

								model.bind(new Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID])
							}
						})
					}
				})
			}
		}

		parsePoseNodes () {
			const bindMatrices = {}

			if ('Pose' in fbxTree.Objects) {
				const BindPoseNode = fbxTree.Objects.Pose

				for (const nodeID in BindPoseNode) {
					if (BindPoseNode[nodeID].attrType === 'BindPose') {
						const poseNodes = BindPoseNode[nodeID].PoseNode

						if (Array.isArray(poseNodes)) {
							poseNodes.forEach(function (poseNode) {
								bindMatrices[poseNode.Node] = new Matrix4().fromArray(poseNode.Matrix.a)
							})
						} else {
							bindMatrices[poseNodes.Node] = new Matrix4().fromArray(poseNodes.Matrix.a)
						}
					}
				}
			}

			return bindMatrices
		}

		// Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
		createAmbientLight () {
			if ('GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings) {
				const ambientColor = fbxTree.GlobalSettings.AmbientColor.value
				const r = ambientColor[0]
				const g = ambientColor[1]
				const b = ambientColor[2]

				if (r !== 0 || g !== 0 || b !== 0) {
					const color = new Color(r, g, b)
					sceneGraph.add(new AmbientLight(color, 1))
				}
			}
		}
	}

	// parse Geometry data from FBXTree and return map of BufferGeometries
	class GeometryParser {
		// Parse nodes in FBXTree.Objects.Geometry
		parse (deformers) {
			const geometryMap = new Map()

			if ('Geometry' in fbxTree.Objects) {
				const geoNodes = fbxTree.Objects.Geometry

				for (const nodeID in geoNodes) {
					const relationships = connections.get(parseInt(nodeID))
					const geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers)

					geometryMap.set(parseInt(nodeID), geo)
				}
			}

			return geometryMap
		}

		// Parse single node in FBXTree.Objects.Geometry
		parseGeometry (relationships, geoNode, deformers) {
			switch (geoNode.attrType) {
				case 'Mesh':
					return this.parseMeshGeometry(relationships, geoNode, deformers)

				case 'NurbsCurve':
					return this.parseNurbsGeometry(geoNode)
			}
		}

		// Parse single node mesh geometry in FBXTree.Objects.Geometry
		parseMeshGeometry (relationships, geoNode, deformers) {
			const skeletons = deformers.skeletons
			const morphTargets = []

			const modelNodes = relationships.parents.map(function (parent) {
				return fbxTree.Objects.Model[parent.ID]
			})

			// don't create geometry if it is not associated with any models
			if (modelNodes.length === 0) return

			const skeleton = relationships.children.reduce(function (skeleton, child) {
				if (skeletons[child.ID] !== undefined) skeleton = skeletons[child.ID]

				return skeleton
			}, null)

			relationships.children.forEach(function (child) {
				if (deformers.morphTargets[child.ID] !== undefined) {
					morphTargets.push(deformers.morphTargets[child.ID])
				}
			})

			// Assume one model and get the preRotation from that
			// if there is more than one model associated with the geometry this may cause problems
			const modelNode = modelNodes[0]

			const transformData = {}

			if ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value)
			if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value)

			if ('GeometricTranslation' in modelNode) transformData.translation = modelNode.GeometricTranslation.value
			if ('GeometricRotation' in modelNode) transformData.rotation = modelNode.GeometricRotation.value
			if ('GeometricScaling' in modelNode) transformData.scale = modelNode.GeometricScaling.value

			const transform = generateTransform(transformData)

			return this.genGeometry(geoNode, skeleton, morphTargets, transform)
		}

		// Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
		genGeometry (geoNode, skeleton, morphTargets, preTransform) {
			const geo = new BufferGeometry()
			if (geoNode.attrName) geo.name = geoNode.attrName

			const geoInfo = this.parseGeoNode(geoNode, skeleton)
			const buffers = this.genBuffers(geoInfo)

			const positionAttribute = new Float32BufferAttribute(buffers.vertex, 3)

			positionAttribute.applyMatrix4(preTransform)

			geo.setAttribute('position', positionAttribute)

			if (buffers.colors.length > 0) {
				geo.setAttribute('color', new Float32BufferAttribute(buffers.colors, 3))
			}

			if (skeleton) {
				geo.setAttribute('skinIndex', new Uint16BufferAttribute(buffers.weightsIndices, 4))

				geo.setAttribute('skinWeight', new Float32BufferAttribute(buffers.vertexWeights, 4))

				// used later to bind the skeleton to the model
				geo.FBX_Deformer = skeleton
			}

			if (buffers.normal.length > 0) {
				const normalMatrix = new Matrix3().getNormalMatrix(preTransform)

				const normalAttribute = new Float32BufferAttribute(buffers.normal, 3)
				normalAttribute.applyNormalMatrix(normalMatrix)

				geo.setAttribute('normal', normalAttribute)
			}

			buffers.uvs.forEach(function (uvBuffer, i) {
				// subsequent uv buffers are called 'uv1', 'uv2', ...
				let name = 'uv' + (i + 1).toString()

				// the first uv buffer is just called 'uv'
				if (i === 0) {
					name = 'uv'
				}

				geo.setAttribute(name, new Float32BufferAttribute(buffers.uvs[i], 2))
			})

			if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {
				// Convert the material indices of each vertex into rendering groups on the geometry.
				let prevMaterialIndex = buffers.materialIndex[0]
				let startIndex = 0

				buffers.materialIndex.forEach(function (currentIndex, i) {
					if (currentIndex !== prevMaterialIndex) {
						geo.addGroup(startIndex, i - startIndex, prevMaterialIndex)

						prevMaterialIndex = currentIndex
						startIndex = i
					}
				})

				// the loop above doesn't add the last group, do that here.
				if (geo.groups.length > 0) {
					const lastGroup = geo.groups[geo.groups.length - 1]
					const lastIndex = lastGroup.start + lastGroup.count

					if (lastIndex !== buffers.materialIndex.length) {
						geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex)
					}
				}

				// case where there are multiple materials but the whole geometry is only
				// using one of them
				if (geo.groups.length === 0) {
					geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0])
				}
			}

			this.addMorphTargets(geo, geoNode, morphTargets, preTransform)

			return geo
		}

		parseGeoNode (geoNode, skeleton) {
			const geoInfo = {}

			geoInfo.vertexPositions = geoNode.Vertices !== undefined ? geoNode.Vertices.a : []
			geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== undefined ? geoNode.PolygonVertexIndex.a : []

			if (geoNode.LayerElementColor) {
				geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0])
			}

			if (geoNode.LayerElementMaterial) {
				geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0])
			}

			if (geoNode.LayerElementNormal) {
				geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0])
			}

			if (geoNode.LayerElementUV) {
				geoInfo.uv = []

				let i = 0
				while (geoNode.LayerElementUV[i]) {
					if (geoNode.LayerElementUV[i].UV) {
						geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]))
					}

					i++
				}
			}

			geoInfo.weightTable = {}

			if (skeleton !== null) {
				geoInfo.skeleton = skeleton

				skeleton.rawBones.forEach(function (rawBone, i) {
					// loop over the bone's vertex indices and weights
					rawBone.indices.forEach(function (index, j) {
						if (geoInfo.weightTable[index] === undefined) geoInfo.weightTable[index] = []

						geoInfo.weightTable[index].push({
							id: i,
							weight: rawBone.weights[j]
						})
					})
				})
			}

			return geoInfo
		}

		genBuffers (geoInfo) {
			const buffers = {
				vertex: [],
				normal: [],
				colors: [],
				uvs: [],
				materialIndex: [],
				vertexWeights: [],
				weightsIndices: []
			}

			let polygonIndex = 0
			let faceLength = 0
			let displayedWeightsWarning = false

			// these will hold data for a single face
			let facePositionIndexes = []
			let faceNormals = []
			let faceColors = []
			let faceUVs = []
			let faceWeights = []
			let faceWeightIndices = []

			const scope = this
			geoInfo.vertexIndices.forEach(function (vertexIndex, polygonVertexIndex) {
				let materialIndex
				let endOfFace = false

				// Face index and vertex index arrays are combined in a single array
				// A cube with quad faces looks like this:
				// PolygonVertexIndex: *24 {
				//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5
				//  }
				// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3
				// to find index of last vertex bit shift the index: ^ - 1
				if (vertexIndex < 0) {
					vertexIndex = vertexIndex ^ -1 // equivalent to ( x * -1 ) - 1
					endOfFace = true
				}

				let weightIndices = []
				let weights = []

				facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2)

				if (geoInfo.color) {
					const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color)

					faceColors.push(data[0], data[1], data[2])
				}

				if (geoInfo.skeleton) {
					if (geoInfo.weightTable[vertexIndex] !== undefined) {
						geoInfo.weightTable[vertexIndex].forEach(function (wt) {
							weights.push(wt.weight)
							weightIndices.push(wt.id)
						})
					}

					if (weights.length > 4) {
						if (!displayedWeightsWarning) {
							console.warn('THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.')
							displayedWeightsWarning = true
						}

						const wIndex = [0, 0, 0, 0]
						const Weight = [0, 0, 0, 0]

						weights.forEach(function (weight, weightIndex) {
							let currentWeight = weight
							let currentIndex = weightIndices[weightIndex]

							Weight.forEach(function (comparedWeight, comparedWeightIndex, comparedWeightArray) {
								if (currentWeight > comparedWeight) {
									comparedWeightArray[comparedWeightIndex] = currentWeight
									currentWeight = comparedWeight

									const tmp = wIndex[comparedWeightIndex]
									wIndex[comparedWeightIndex] = currentIndex
									currentIndex = tmp
								}
							})
						})

						weightIndices = wIndex
						weights = Weight
					}

					// if the weight array is shorter than 4 pad with 0s
					while (weights.length < 4) {
						weights.push(0)
						weightIndices.push(0)
					}

					for (let i = 0; i < 4; ++i) {
						faceWeights.push(weights[i])
						faceWeightIndices.push(weightIndices[i])
					}
				}

				if (geoInfo.normal) {
					const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal)

					faceNormals.push(data[0], data[1], data[2])
				}

				if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {
					materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0]
				}

				if (geoInfo.uv) {
					geoInfo.uv.forEach(function (uv, i) {
						const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv)

						if (faceUVs[i] === undefined) {
							faceUVs[i] = []
						}

						faceUVs[i].push(data[0])
						faceUVs[i].push(data[1])
					})
				}

				faceLength++

				if (endOfFace) {
					scope.genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength)

					polygonIndex++
					faceLength = 0

					// reset arrays for the next face
					facePositionIndexes = []
					faceNormals = []
					faceColors = []
					faceUVs = []
					faceWeights = []
					faceWeightIndices = []
				}
			})

			return buffers
		}

		// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
		genFace (buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {
			for (let i = 2; i < faceLength; i++) {
				buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]])
				buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]])
				buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]])

				buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]])
				buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]])
				buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]])

				buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]])
				buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]])
				buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]])

				if (geoInfo.skeleton) {
					buffers.vertexWeights.push(faceWeights[0])
					buffers.vertexWeights.push(faceWeights[1])
					buffers.vertexWeights.push(faceWeights[2])
					buffers.vertexWeights.push(faceWeights[3])

					buffers.vertexWeights.push(faceWeights[(i - 1) * 4])
					buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1])
					buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2])
					buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3])

					buffers.vertexWeights.push(faceWeights[i * 4])
					buffers.vertexWeights.push(faceWeights[i * 4 + 1])
					buffers.vertexWeights.push(faceWeights[i * 4 + 2])
					buffers.vertexWeights.push(faceWeights[i * 4 + 3])

					buffers.weightsIndices.push(faceWeightIndices[0])
					buffers.weightsIndices.push(faceWeightIndices[1])
					buffers.weightsIndices.push(faceWeightIndices[2])
					buffers.weightsIndices.push(faceWeightIndices[3])

					buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4])
					buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1])
					buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2])
					buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3])

					buffers.weightsIndices.push(faceWeightIndices[i * 4])
					buffers.weightsIndices.push(faceWeightIndices[i * 4 + 1])
					buffers.weightsIndices.push(faceWeightIndices[i * 4 + 2])
					buffers.weightsIndices.push(faceWeightIndices[i * 4 + 3])
				}

				if (geoInfo.color) {
					buffers.colors.push(faceColors[0])
					buffers.colors.push(faceColors[1])
					buffers.colors.push(faceColors[2])

					buffers.colors.push(faceColors[(i - 1) * 3])
					buffers.colors.push(faceColors[(i - 1) * 3 + 1])
					buffers.colors.push(faceColors[(i - 1) * 3 + 2])

					buffers.colors.push(faceColors[i * 3])
					buffers.colors.push(faceColors[i * 3 + 1])
					buffers.colors.push(faceColors[i * 3 + 2])
				}

				if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {
					buffers.materialIndex.push(materialIndex)
					buffers.materialIndex.push(materialIndex)
					buffers.materialIndex.push(materialIndex)
				}

				if (geoInfo.normal) {
					buffers.normal.push(faceNormals[0])
					buffers.normal.push(faceNormals[1])
					buffers.normal.push(faceNormals[2])

					buffers.normal.push(faceNormals[(i - 1) * 3])
					buffers.normal.push(faceNormals[(i - 1) * 3 + 1])
					buffers.normal.push(faceNormals[(i - 1) * 3 + 2])

					buffers.normal.push(faceNormals[i * 3])
					buffers.normal.push(faceNormals[i * 3 + 1])
					buffers.normal.push(faceNormals[i * 3 + 2])
				}

				if (geoInfo.uv) {
					geoInfo.uv.forEach(function (uv, j) {
						if (buffers.uvs[j] === undefined) buffers.uvs[j] = []

						buffers.uvs[j].push(faceUVs[j][0])
						buffers.uvs[j].push(faceUVs[j][1])

						buffers.uvs[j].push(faceUVs[j][(i - 1) * 2])
						buffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1])

						buffers.uvs[j].push(faceUVs[j][i * 2])
						buffers.uvs[j].push(faceUVs[j][i * 2 + 1])
					})
				}
			}
		}

		addMorphTargets (parentGeo, parentGeoNode, morphTargets, preTransform) {
			if (morphTargets.length === 0) return

			parentGeo.morphTargetsRelative = true

			parentGeo.morphAttributes.position = []
			// parentGeo.morphAttributes.normal = []; // not implemented

			const scope = this
			morphTargets.forEach(function (morphTarget) {
				morphTarget.rawTargets.forEach(function (rawTarget) {
					const morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID]

					if (morphGeoNode !== undefined) {
						scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name)
					}
				})
			})
		}

		// a morph geometry node is similar to a standard  node, and the node is also contained
		// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
		// and a special attribute Index defining which vertices of the original geometry are affected
		// Normal and position attributes only have data for the vertices that are affected by the morph
		genMorphGeometry (parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {
			const vertexIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : []

			const morphPositionsSparse = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : []
			const indices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : []

			const length = parentGeo.attributes.position.count * 3
			const morphPositions = new Float32Array(length)

			for (let i = 0; i < indices.length; i++) {
				const morphIndex = indices[i] * 3

				morphPositions[morphIndex] = morphPositionsSparse[i * 3]
				morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1]
				morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2]
			}

			// TODO: add morph normal support
			const morphGeoInfo = {
				vertexIndices: vertexIndices,
				vertexPositions: morphPositions
			}

			const morphBuffers = this.genBuffers(morphGeoInfo)

			const positionAttribute = new Float32BufferAttribute(morphBuffers.vertex, 3)
			positionAttribute.name = name || morphGeoNode.attrName

			positionAttribute.applyMatrix4(preTransform)

			parentGeo.morphAttributes.position.push(positionAttribute)
		}

		// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
		parseNormals (NormalNode) {
			const mappingType = NormalNode.MappingInformationType
			const referenceType = NormalNode.ReferenceInformationType
			const buffer = NormalNode.Normals.a
			let indexBuffer = []
			if (referenceType === 'IndexToDirect') {
				if ('NormalIndex' in NormalNode) {
					indexBuffer = NormalNode.NormalIndex.a
				} else if ('NormalsIndex' in NormalNode) {
					indexBuffer = NormalNode.NormalsIndex.a
				}
			}

			return {
				dataSize: 3,
				buffer: buffer,
				indices: indexBuffer,
				mappingType: mappingType,
				referenceType: referenceType
			}
		}

		// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
		parseUVs (UVNode) {
			const mappingType = UVNode.MappingInformationType
			const referenceType = UVNode.ReferenceInformationType
			const buffer = UVNode.UV.a
			let indexBuffer = []
			if (referenceType === 'IndexToDirect') {
				indexBuffer = UVNode.UVIndex.a
			}

			return {
				dataSize: 2,
				buffer: buffer,
				indices: indexBuffer,
				mappingType: mappingType,
				referenceType: referenceType
			}
		}

		// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
		parseVertexColors (ColorNode) {
			const mappingType = ColorNode.MappingInformationType
			const referenceType = ColorNode.ReferenceInformationType
			const buffer = ColorNode.Colors.a
			let indexBuffer = []
			if (referenceType === 'IndexToDirect') {
				indexBuffer = ColorNode.ColorIndex.a
			}

			return {
				dataSize: 4,
				buffer: buffer,
				indices: indexBuffer,
				mappingType: mappingType,
				referenceType: referenceType
			}
		}

		// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
		parseMaterialIndices (MaterialNode) {
			const mappingType = MaterialNode.MappingInformationType
			const referenceType = MaterialNode.ReferenceInformationType

			if (mappingType === 'NoMappingInformation') {
				return {
					dataSize: 1,
					buffer: [0],
					indices: [0],
					mappingType: 'AllSame',
					referenceType: referenceType
				}
			}

			const materialIndexBuffer = MaterialNode.Materials.a

			// Since materials are stored as indices, there's a bit of a mismatch between FBX and what
			// we expect.So we create an intermediate buffer that points to the index in the buffer,
			// for conforming with the other functions we've written for other data.
			const materialIndices = []

			for (let i = 0; i < materialIndexBuffer.length; ++i) {
				materialIndices.push(i)
			}

			return {
				dataSize: 1,
				buffer: materialIndexBuffer,
				indices: materialIndices,
				mappingType: mappingType,
				referenceType: referenceType
			}
		}

		// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
		parseNurbsGeometry (geoNode) {
			if (NURBSCurve === undefined) {
				console.error('THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.')
				return new BufferGeometry()
			}

			const order = parseInt(geoNode.Order)

			if (isNaN(order)) {
				console.error('THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id)
				return new BufferGeometry()
			}

			const degree = order - 1

			const knots = geoNode.KnotVector.a
			const controlPoints = []
			const pointsValues = geoNode.Points.a

			for (let i = 0, l = pointsValues.length; i < l; i += 4) {
				controlPoints.push(new Vector4().fromArray(pointsValues, i))
			}

			let startKnot, endKnot

			if (geoNode.Form === 'Closed') {
				controlPoints.push(controlPoints[0])
			} else if (geoNode.Form === 'Periodic') {
				startKnot = degree
				endKnot = knots.length - 1 - startKnot

				for (let i = 0; i < degree; ++i) {
					controlPoints.push(controlPoints[i])
				}
			}

			const curve = new NURBSCurve(degree, knots, controlPoints, startKnot, endKnot)
			const points = curve.getPoints(controlPoints.length * 12)

			return new BufferGeometry().setFromPoints(points)
		}
	}

	// parse animation data from FBXTree
	class AnimationParser {
		// take raw animation clips and turn them into three.js animation clips
		parse () {
			const animationClips = []

			const rawClips = this.parseClips()

			if (rawClips !== undefined) {
				for (const key in rawClips) {
					const rawClip = rawClips[key]

					const clip = this.addClip(rawClip)

					animationClips.push(clip)
				}
			}

			return animationClips
		}

		parseClips () {
			// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,
			// if this is undefined we can safely assume there are no animations
			if (fbxTree.Objects.AnimationCurve === undefined) return undefined

			const curveNodesMap = this.parseAnimationCurveNodes()

			this.parseAnimationCurves(curveNodesMap)

			const layersMap = this.parseAnimationLayers(curveNodesMap)
			const rawClips = this.parseAnimStacks(layersMap)

			return rawClips
		}

		// parse nodes in FBXTree.Objects.AnimationCurveNode
		// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
		// and is referenced by an AnimationLayer
		parseAnimationCurveNodes () {
			const rawCurveNodes = fbxTree.Objects.AnimationCurveNode

			const curveNodesMap = new Map()

			for (const nodeID in rawCurveNodes) {
				const rawCurveNode = rawCurveNodes[nodeID]

				if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {
					const curveNode = {
						id: rawCurveNode.id,
						attr: rawCurveNode.attrName,
						curves: {}
					}

					curveNodesMap.set(curveNode.id, curveNode)
				}
			}

			return curveNodesMap
		}

		// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
		// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
		// axis ( e.g. times and values of x rotation)
		parseAnimationCurves (curveNodesMap) {
			const rawCurves = fbxTree.Objects.AnimationCurve

			// TODO: Many values are identical up to roundoff error, but won't be optimised
			// e.g. position times: [0, 0.4, 0. 8]
			// position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]
			// clearly, this should be optimised to
			// times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]
			// this shows up in nearly every FBX file, and generally time array is length > 100

			for (const nodeID in rawCurves) {
				const animationCurve = {
					id: rawCurves[nodeID].id,
					times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),
					values: rawCurves[nodeID].KeyValueFloat.a
				}

				const relationships = connections.get(animationCurve.id)

				if (relationships !== undefined) {
					const animationCurveID = relationships.parents[0].ID
					const animationCurveRelationship = relationships.parents[0].relationship

					if (animationCurveRelationship.match(/X/)) {
						curveNodesMap.get(animationCurveID).curves['x'] = animationCurve
					} else if (animationCurveRelationship.match(/Y/)) {
						curveNodesMap.get(animationCurveID).curves['y'] = animationCurve
					} else if (animationCurveRelationship.match(/Z/)) {
						curveNodesMap.get(animationCurveID).curves['z'] = animationCurve
					} else if (animationCurveRelationship.match(/d|DeformPercent/) && curveNodesMap.has(animationCurveID)) {
						curveNodesMap.get(animationCurveID).curves['morph'] = animationCurve
					}
				}
			}
		}

		// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
		// to various AnimationCurveNodes and is referenced by an AnimationStack node
		// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
		parseAnimationLayers (curveNodesMap) {
			const rawLayers = fbxTree.Objects.AnimationLayer

			const layersMap = new Map()

			for (const nodeID in rawLayers) {
				const layerCurveNodes = []

				const connection = connections.get(parseInt(nodeID))

				if (connection !== undefined) {
					// all the animationCurveNodes used in the layer
					const children = connection.children

					children.forEach(function (child, i) {
						if (curveNodesMap.has(child.ID)) {
							const curveNode = curveNodesMap.get(child.ID)

							// check that the curves are defined for at least one axis, otherwise ignore the curveNode
							if (curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined) {
								if (layerCurveNodes[i] === undefined) {
									const modelID = connections.get(child.ID).parents.filter(function (parent) {
										return parent.relationship !== undefined
									})[0].ID

									if (modelID !== undefined) {
										const rawModel = fbxTree.Objects.Model[modelID.toString()]

										if (rawModel === undefined) {
											console.warn('THREE.FBXLoader: Encountered a unused curve.', child)
											return
										}

										const node = {
											modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : '',
											ID: rawModel.id,
											initialPosition: [0, 0, 0],
											initialRotation: [0, 0, 0],
											initialScale: [1, 1, 1]
										}

										sceneGraph.traverse(function (child) {
											if (child.ID === rawModel.id) {
												node.transform = child.matrix

												if (child.userData.transformData) node.eulerOrder = child.userData.transformData.eulerOrder
											}
										})

										if (!node.transform) node.transform = new Matrix4()

										// if the animated model is pre rotated, we'll have to apply the pre rotations to every
										// animation value as well
										if ('PreRotation' in rawModel) node.preRotation = rawModel.PreRotation.value
										if ('PostRotation' in rawModel) node.postRotation = rawModel.PostRotation.value

										layerCurveNodes[i] = node
									}
								}

								if (layerCurveNodes[i]) layerCurveNodes[i][curveNode.attr] = curveNode
							} else if (curveNode.curves.morph !== undefined) {
								if (layerCurveNodes[i] === undefined) {
									const deformerID = connections.get(child.ID).parents.filter(function (parent) {
										return parent.relationship !== undefined
									})[0].ID

									const morpherID = connections.get(deformerID).parents[0].ID
									const geoID = connections.get(morpherID).parents[0].ID

									// assuming geometry is not used in more than one model
									const modelID = connections.get(geoID).parents[0].ID

									const rawModel = fbxTree.Objects.Model[modelID]

									const node = {
										modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : '',
										morphName: fbxTree.Objects.Deformer[deformerID].attrName
									}

									layerCurveNodes[i] = node
								}

								layerCurveNodes[i][curveNode.attr] = curveNode
							}
						}
					})

					layersMap.set(parseInt(nodeID), layerCurveNodes)
				}
			}

			return layersMap
		}

		// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
		// hierarchy. Each Stack node will be used to create a AnimationClip
		parseAnimStacks (layersMap) {
			const rawStacks = fbxTree.Objects.AnimationStack

			// connect the stacks (clips) up to the layers
			const rawClips = {}

			for (const nodeID in rawStacks) {
				const children = connections.get(parseInt(nodeID)).children

				if (children.length > 1) {
					// it seems like stacks will always be associated with a single layer. But just in case there are files
					// where there are multiple layers per stack, we'll display a warning
					console.warn('THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.')
				}

				const layer = layersMap.get(children[0].ID)

				rawClips[nodeID] = {
					name: rawStacks[nodeID].attrName,
					layer: layer
				}
			}

			return rawClips
		}

		addClip (rawClip) {
			let tracks = []

			const scope = this
			rawClip.layer.forEach(function (rawTracks) {
				tracks = tracks.concat(scope.generateTracks(rawTracks))
			})

			return new AnimationClip(rawClip.name, -1, tracks)
		}

		generateTracks (rawTracks) {
			const tracks = []

			let initialPosition = new Vector3()
			let initialRotation = new Quaternion()
			let initialScale = new Vector3()

			if (rawTracks.transform) rawTracks.transform.decompose(initialPosition, initialRotation, initialScale)

			initialPosition = initialPosition.toArray()
			initialRotation = new Euler().setFromQuaternion(initialRotation, rawTracks.eulerOrder).toArray()
			initialScale = initialScale.toArray()

			if (rawTracks.T !== undefined && Object.keys(rawTracks.T.curves).length > 0) {
				const positionTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position')
				if (positionTrack !== undefined) tracks.push(positionTrack)
			}

			if (rawTracks.R !== undefined && Object.keys(rawTracks.R.curves).length > 0) {
				const rotationTrack = this.generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder)
				if (rotationTrack !== undefined) tracks.push(rotationTrack)
			}

			if (rawTracks.S !== undefined && Object.keys(rawTracks.S.curves).length > 0) {
				const scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale')
				if (scaleTrack !== undefined) tracks.push(scaleTrack)
			}

			if (rawTracks.DeformPercent !== undefined) {
				const morphTrack = this.generateMorphTrack(rawTracks)
				if (morphTrack !== undefined) tracks.push(morphTrack)
			}

			return tracks
		}

		generateVectorTrack (modelName, curves, initialValue, type) {
			const times = this.getTimesForAllAxes(curves)
			const values = this.getKeyframeTrackValues(times, curves, initialValue)

			return new VectorKeyframeTrack(modelName + '.' + type, times, values)
		}

		generateRotationTrack (modelName, curves, initialValue, preRotation, postRotation, eulerOrder) {
			if (curves.x !== undefined) {
				this.interpolateRotations(curves.x)
				curves.x.values = curves.x.values.map(MathUtils.degToRad)
			}

			if (curves.y !== undefined) {
				this.interpolateRotations(curves.y)
				curves.y.values = curves.y.values.map(MathUtils.degToRad)
			}

			if (curves.z !== undefined) {
				this.interpolateRotations(curves.z)
				curves.z.values = curves.z.values.map(MathUtils.degToRad)
			}

			const times = this.getTimesForAllAxes(curves)
			const values = this.getKeyframeTrackValues(times, curves, initialValue)

			if (preRotation !== undefined) {
				preRotation = preRotation.map(MathUtils.degToRad)
				preRotation.push(eulerOrder)

				preRotation = new Euler().fromArray(preRotation)
				preRotation = new Quaternion().setFromEuler(preRotation)
			}

			if (postRotation !== undefined) {
				postRotation = postRotation.map(MathUtils.degToRad)
				postRotation.push(eulerOrder)

				postRotation = new Euler().fromArray(postRotation)
				postRotation = new Quaternion().setFromEuler(postRotation).invert()
			}

			const quaternion = new Quaternion()
			const euler = new Euler()

			const quaternionValues = []

			for (let i = 0; i < values.length; i += 3) {
				euler.set(values[i], values[i + 1], values[i + 2], eulerOrder)

				quaternion.setFromEuler(euler)

				if (preRotation !== undefined) quaternion.premultiply(preRotation)
				if (postRotation !== undefined) quaternion.multiply(postRotation)

				quaternion.toArray(quaternionValues, (i / 3) * 4)
			}

			return new QuaternionKeyframeTrack(modelName + '.quaternion', times, quaternionValues)
		}

		generateMorphTrack (rawTracks) {
			const curves = rawTracks.DeformPercent.curves.morph
			const values = curves.values.map(function (val) {
				return val / 100
			})

			const morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName]

			return new NumberKeyframeTrack(rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values)
		}

		// For all animated objects, times are defined separately for each axis
		// Here we'll combine the times into one sorted array without duplicates
		getTimesForAllAxes (curves) {
			let times = []

			// first join together the times for each axis, if defined
			if (curves.x !== undefined) times = times.concat(curves.x.times)
			if (curves.y !== undefined) times = times.concat(curves.y.times)
			if (curves.z !== undefined) times = times.concat(curves.z.times)

			// then sort them
			times = times.sort(function (a, b) {
				return a - b
			})

			// and remove duplicates
			if (times.length > 1) {
				let targetIndex = 1
				let lastValue = times[0]
				for (let i = 1; i < times.length; i++) {
					const currentValue = times[i]
					if (currentValue !== lastValue) {
						times[targetIndex] = currentValue
						lastValue = currentValue
						targetIndex++
					}
				}

				times = times.slice(0, targetIndex)
			}

			return times
		}

		getKeyframeTrackValues (times, curves, initialValue) {
			const prevValue = initialValue

			const values = []

			let xIndex = -1
			let yIndex = -1
			let zIndex = -1

			times.forEach(function (time) {
				if (curves.x) xIndex = curves.x.times.indexOf(time)
				if (curves.y) yIndex = curves.y.times.indexOf(time)
				if (curves.z) zIndex = curves.z.times.indexOf(time)

				// if there is an x value defined for this frame, use that
				if (xIndex !== -1) {
					const xValue = curves.x.values[xIndex]
					values.push(xValue)
					prevValue[0] = xValue
				} else {
					// otherwise use the x value from the previous frame
					values.push(prevValue[0])
				}

				if (yIndex !== -1) {
					const yValue = curves.y.values[yIndex]
					values.push(yValue)
					prevValue[1] = yValue
				} else {
					values.push(prevValue[1])
				}

				if (zIndex !== -1) {
					const zValue = curves.z.values[zIndex]
					values.push(zValue)
					prevValue[2] = zValue
				} else {
					values.push(prevValue[2])
				}
			})

			return values
		}

		// Rotations are defined as Euler angles which can have values  of any size
		// These will be converted to quaternions which don't support values greater than
		// PI, so we'll interpolate large rotations
		interpolateRotations (curve) {
			for (let i = 1; i < curve.values.length; i++) {
				const initialValue = curve.values[i - 1]
				const valuesSpan = curve.values[i] - initialValue

				const absoluteSpan = Math.abs(valuesSpan)

				if (absoluteSpan >= 180) {
					const numSubIntervals = absoluteSpan / 180

					const step = valuesSpan / numSubIntervals
					let nextValue = initialValue + step

					const initialTime = curve.times[i - 1]
					const timeSpan = curve.times[i] - initialTime
					const interval = timeSpan / numSubIntervals
					let nextTime = initialTime + interval

					const interpolatedTimes = []
					const interpolatedValues = []

					while (nextTime < curve.times[i]) {
						interpolatedTimes.push(nextTime)
						nextTime += interval

						interpolatedValues.push(nextValue)
						nextValue += step
					}

					curve.times = inject(curve.times, i, interpolatedTimes)
					curve.values = inject(curve.values, i, interpolatedValues)
				}
			}
		}
	}

	// parse an FBX file in ASCII format
	class TextParser {
		getPrevNode () {
			return this.nodeStack[this.currentIndent - 2]
		}

		getCurrentNode () {
			return this.nodeStack[this.currentIndent - 1]
		}

		getCurrentProp () {
			return this.currentProp
		}

		pushStack (node) {
			this.nodeStack.push(node)
			this.currentIndent += 1
		}

		popStack () {
			this.nodeStack.pop()
			this.currentIndent -= 1
		}

		setCurrentProp (val, name) {
			this.currentProp = val
			this.currentPropName = name
		}

		parse (text) {
			this.currentIndent = 0

			this.allNodes = new FBXTree()
			this.nodeStack = []
			this.currentProp = []
			this.currentPropName = ''

			const scope = this

			const split = text.split(/[\r\n]+/)

			split.forEach(function (line, i) {
				const matchComment = line.match(/^[\s\t]*;/)
				const matchEmpty = line.match(/^[\s\t]*$/)

				if (matchComment || matchEmpty) return

				const matchBeginning = line.match('^\\t{' + scope.currentIndent + '}(\\w+):(.*){', '')
				const matchProperty = line.match('^\\t{' + scope.currentIndent + '}(\\w+):[\\s\\t\\r\\n](.*)')
				const matchEnd = line.match('^\\t{' + (scope.currentIndent - 1) + '}}')

				if (matchBeginning) {
					scope.parseNodeBegin(line, matchBeginning)
				} else if (matchProperty) {
					scope.parseNodeProperty(line, matchProperty, split[++i])
				} else if (matchEnd) {
					scope.popStack()
				} else if (line.match(/^[^\s\t}]/)) {
					// large arrays are split over multiple lines terminated with a ',' character
					// if this is encountered the line needs to be joined to the previous line
					scope.parseNodePropertyContinued(line)
				}
			})

			return this.allNodes
		}

		parseNodeBegin (line, property) {
			const nodeName = property[1].trim().replace(/^"/, '').replace(/"$/, '')

			const nodeAttrs = property[2].split(',').map(function (attr) {
				return attr.trim().replace(/^"/, '').replace(/"$/, '')
			})

			const node = { name: nodeName }
			const attrs = this.parseNodeAttr(nodeAttrs)

			const currentNode = this.getCurrentNode()

			// a top node
			if (this.currentIndent === 0) {
				this.allNodes.add(nodeName, node)
			} else {
				// a subnode

				// if the subnode already exists, append it
				if (nodeName in currentNode) {
					// special case Pose needs PoseNodes as an array
					if (nodeName === 'PoseNode') {
						currentNode.PoseNode.push(node)
					} else if (currentNode[nodeName].id !== undefined) {
						currentNode[nodeName] = {}
						currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName]
					}

					if (attrs.id !== '') currentNode[nodeName][attrs.id] = node
				} else if (typeof attrs.id === 'number') {
					currentNode[nodeName] = {}
					currentNode[nodeName][attrs.id] = node
				} else if (nodeName !== 'Properties70') {
					if (nodeName === 'PoseNode') currentNode[nodeName] = [node]
					else currentNode[nodeName] = node
				}
			}

			if (typeof attrs.id === 'number') node.id = attrs.id
			if (attrs.name !== '') node.attrName = attrs.name
			if (attrs.type !== '') node.attrType = attrs.type

			this.pushStack(node)
		}

		parseNodeAttr (attrs) {
			let id = attrs[0]

			if (attrs[0] !== '') {
				id = parseInt(attrs[0])

				if (isNaN(id)) {
					id = attrs[0]
				}
			}

			let name = '',
				type = ''

			if (attrs.length > 1) {
				name = attrs[1].replace(/^(\w+)::/, '')
				type = attrs[2]
			}

			return { id: id, name: name, type: type }
		}

		parseNodeProperty (line, property, contentLine) {
			let propName = property[1].replace(/^"/, '').replace(/"$/, '').trim()
			let propValue = property[2].replace(/^"/, '').replace(/"$/, '').trim()

			// for special case: base64 image data follows "Content: ," line
			//	Content: ,
			//	 "/9j/4RDaRXhpZgAATU0A..."
			if (propName === 'Content' && propValue === ',') {
				propValue = contentLine.replace(/"/g, '').replace(/,$/, '').trim()
			}

			const currentNode = this.getCurrentNode()
			const parentName = currentNode.name

			if (parentName === 'Properties70') {
				this.parseNodeSpecialProperty(line, propName, propValue)
				return
			}

			// Connections
			if (propName === 'C') {
				const connProps = propValue.split(',').slice(1)
				const from = parseInt(connProps[0])
				const to = parseInt(connProps[1])

				let rest = propValue.split(',').slice(3)

				rest = rest.map(function (elem) {
					return elem.trim().replace(/^"/, '')
				})

				propName = 'connections'
				propValue = [from, to]
				append(propValue, rest)

				if (currentNode[propName] === undefined) {
					currentNode[propName] = []
				}
			}

			// Node
			if (propName === 'Node') currentNode.id = propValue

			// connections
			if (propName in currentNode && Array.isArray(currentNode[propName])) {
				currentNode[propName].push(propValue)
			} else {
				if (propName !== 'a') currentNode[propName] = propValue
				else currentNode.a = propValue
			}

			this.setCurrentProp(currentNode, propName)

			// convert string to array, unless it ends in ',' in which case more will be added to it
			if (propName === 'a' && propValue.slice(-1) !== ',') {
				currentNode.a = parseNumberArray(propValue)
			}
		}

		parseNodePropertyContinued (line) {
			const currentNode = this.getCurrentNode()

			currentNode.a += line

			// if the line doesn't end in ',' we have reached the end of the property value
			// so convert the string to an array
			if (line.slice(-1) !== ',') {
				currentNode.a = parseNumberArray(currentNode.a)
			}
		}

		// parse "Property70"
		parseNodeSpecialProperty (line, propName, propValue) {
			// split this
			// P: "Lcl Scaling", "Lcl Scaling", "", "A",1,1,1
			// into array like below
			// ["Lcl Scaling", "Lcl Scaling", "", "A", "1,1,1" ]
			const props = propValue.split('",').map(function (prop) {
				return prop.trim().replace(/^\"/, '').replace(/\s/, '_')
			})

			const innerPropName = props[0]
			const innerPropType1 = props[1]
			const innerPropType2 = props[2]
			const innerPropFlag = props[3]
			let innerPropValue = props[4]

			// cast values where needed, otherwise leave as strings
			switch (innerPropType1) {
				case 'int':
				case 'enum':
				case 'bool':
				case 'ULongLong':
				case 'double':
				case 'Number':
				case 'FieldOfView':
					innerPropValue = parseFloat(innerPropValue)
					break

				case 'Color':
				case 'ColorRGB':
				case 'Vector3D':
				case 'Lcl_Translation':
				case 'Lcl_Rotation':
				case 'Lcl_Scaling':
					innerPropValue = parseNumberArray(innerPropValue)
					break
			}

			// CAUTION: these props must append to parent's parent
			this.getPrevNode()[innerPropName] = {
				type: innerPropType1,
				type2: innerPropType2,
				flag: innerPropFlag,
				value: innerPropValue
			}

			this.setCurrentProp(this.getPrevNode(), innerPropName)
		}
	}

	// Parse an FBX file in Binary format
	class BinaryParser {
		parse (buffer) {
			const reader = new BinaryReader(buffer)
			reader.skip(23) // skip magic 23 bytes

			const version = reader.getUint32()

			if (version < 6400) {
				throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + version)
			}

			const allNodes = new FBXTree()

			while (!this.endOfContent(reader)) {
				const node = this.parseNode(reader, version)
				if (node !== null) allNodes.add(node.name, node)
			}

			return allNodes
		}

		// Check if reader has reached the end of content.
		endOfContent (reader) {
			// footer size: 160bytes + 16-byte alignment padding
			// - 16bytes: magic
			// - padding til 16-byte alignment (at least 1byte?)
			//	(seems like some exporters embed fixed 15 or 16bytes?)
			// - 4bytes: magic
			// - 4bytes: version
			// - 120bytes: zero
			// - 16bytes: magic
			if (reader.size() % 16 === 0) {
				return ((reader.getOffset() + 160 + 16) & ~0xf) >= reader.size()
			} else {
				return reader.getOffset() + 160 + 16 >= reader.size()
			}
		}

		// recursively parse nodes until the end of the file is reached
		parseNode (reader, version) {
			const node = {}

			// The first three data sizes depends on version.
			const endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32()
			const numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32()

			version >= 7500 ? reader.getUint64() : reader.getUint32() // the returned propertyListLen is not used

			const nameLen = reader.getUint8()
			const name = reader.getString(nameLen)

			// Regards this node as NULL-record if endOffset is zero
			if (endOffset === 0) return null

			const propertyList = []

			for (let i = 0; i < numProperties; i++) {
				propertyList.push(this.parseProperty(reader))
			}

			// Regards the first three elements in propertyList as id, attrName, and attrType
			const id = propertyList.length > 0 ? propertyList[0] : ''
			const attrName = propertyList.length > 1 ? propertyList[1] : ''
			const attrType = propertyList.length > 2 ? propertyList[2] : ''

			// check if this node represents just a single property
			// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}
			node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false

			while (endOffset > reader.getOffset()) {
				const subNode = this.parseNode(reader, version)

				if (subNode !== null) this.parseSubNode(name, node, subNode)
			}

			node.propertyList = propertyList // raw property list used by parent

			if (typeof id === 'number') node.id = id
			if (attrName !== '') node.attrName = attrName
			if (attrType !== '') node.attrType = attrType
			if (name !== '') node.name = name

			return node
		}

		parseSubNode (name, node, subNode) {
			// special case: child node is single property
			if (subNode.singleProperty === true) {
				const value = subNode.propertyList[0]

				if (Array.isArray(value)) {
					node[subNode.name] = subNode

					subNode.a = value
				} else {
					node[subNode.name] = value
				}
			} else if (name === 'Connections' && subNode.name === 'C') {
				const array = []

				subNode.propertyList.forEach(function (property, i) {
					// first Connection is FBX type (OO, OP, etc.). We'll discard these
					if (i !== 0) array.push(property)
				})

				if (node.connections === undefined) {
					node.connections = []
				}

				node.connections.push(array)
			} else if (subNode.name === 'Properties70') {
				const keys = Object.keys(subNode)

				keys.forEach(function (key) {
					node[key] = subNode[key]
				})
			} else if (name === 'Properties70' && subNode.name === 'P') {
				let innerPropName = subNode.propertyList[0]
				let innerPropType1 = subNode.propertyList[1]
				const innerPropType2 = subNode.propertyList[2]
				const innerPropFlag = subNode.propertyList[3]
				let innerPropValue

				if (innerPropName.indexOf('Lcl ') === 0) innerPropName = innerPropName.replace('Lcl ', 'Lcl_')
				if (innerPropType1.indexOf('Lcl ') === 0) innerPropType1 = innerPropType1.replace('Lcl ', 'Lcl_')

				if (innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf('Lcl_') === 0) {
					innerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]]
				} else {
					innerPropValue = subNode.propertyList[4]
				}

				// this will be copied to parent, see above
				node[innerPropName] = {
					type: innerPropType1,
					type2: innerPropType2,
					flag: innerPropFlag,
					value: innerPropValue
				}
			} else if (node[subNode.name] === undefined) {
				if (typeof subNode.id === 'number') {
					node[subNode.name] = {}
					node[subNode.name][subNode.id] = subNode
				} else {
					node[subNode.name] = subNode
				}
			} else {
				if (subNode.name === 'PoseNode') {
					if (!Array.isArray(node[subNode.name])) {
						node[subNode.name] = [node[subNode.name]]
					}

					node[subNode.name].push(subNode)
				} else if (node[subNode.name][subNode.id] === undefined) {
					node[subNode.name][subNode.id] = subNode
				}
			}
		}

		parseProperty (reader) {
			const type = reader.getString(1)
			let length

			switch (type) {
				case 'C':
					return reader.getBoolean()

				case 'D':
					return reader.getFloat64()

				case 'F':
					return reader.getFloat32()

				case 'I':
					return reader.getInt32()

				case 'L':
					return reader.getInt64()

				case 'R':
					length = reader.getUint32()
					return reader.getArrayBuffer(length)

				case 'S':
					length = reader.getUint32()
					return reader.getString(length)

				case 'Y':
					return reader.getInt16()

				case 'b':
				case 'c':
				case 'd':
				case 'f':
				case 'i':
				case 'l':
					const arrayLength = reader.getUint32()
					const encoding = reader.getUint32() // 0: non-compressed, 1: compressed
					const compressedLength = reader.getUint32()

					if (encoding === 0) {
						switch (type) {
							case 'b':
							case 'c':
								return reader.getBooleanArray(arrayLength)

							case 'd':
								return reader.getFloat64Array(arrayLength)

							case 'f':
								return reader.getFloat32Array(arrayLength)

							case 'i':
								return reader.getInt32Array(arrayLength)

							case 'l':
								return reader.getInt64Array(arrayLength)
						}
					}

					if (typeof fflate === 'undefined') {
						console.error('THREE.FBXLoader: External library fflate.min.js required.')
					}

					const data = unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength))) // eslint-disable-line no-undef
					const reader2 = new BinaryReader(data.buffer)

					switch (type) {
						case 'b':
						case 'c':
							return reader2.getBooleanArray(arrayLength)

						case 'd':
							return reader2.getFloat64Array(arrayLength)

						case 'f':
							return reader2.getFloat32Array(arrayLength)

						case 'i':
							return reader2.getInt32Array(arrayLength)

						case 'l':
							return reader2.getInt64Array(arrayLength)
					}

				default:
					throw new Error('THREE.FBXLoader: Unknown property type ' + type)
			}
		}
	}

	class BinaryReader {
		constructor(buffer, littleEndian) {
			this.dv = new DataView(buffer)
			this.offset = 0
			this.littleEndian = littleEndian !== undefined ? littleEndian : true
		}

		getOffset () {
			return this.offset
		}

		size () {
			return this.dv.buffer.byteLength
		}

		skip (length) {
			this.offset += length
		}

		// seems like true/false representation depends on exporter.
		// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
		// then sees LSB.
		getBoolean () {
			return (this.getUint8() & 1) === 1
		}

		getBooleanArray (size) {
			const a = []

			for (let i = 0; i < size; i++) {
				a.push(this.getBoolean())
			}

			return a
		}

		getUint8 () {
			const value = this.dv.getUint8(this.offset)
			this.offset += 1
			return value
		}

		getInt16 () {
			const value = this.dv.getInt16(this.offset, this.littleEndian)
			this.offset += 2
			return value
		}

		getInt32 () {
			const value = this.dv.getInt32(this.offset, this.littleEndian)
			this.offset += 4
			return value
		}

		getInt32Array (size) {
			const a = []

			for (let i = 0; i < size; i++) {
				a.push(this.getInt32())
			}

			return a
		}

		getUint32 () {
			const value = this.dv.getUint32(this.offset, this.littleEndian)
			this.offset += 4
			return value
		}

		// JavaScript doesn't support 64-bit integer so calculate this here
		// 1 << 32 will return 1 so using multiply operation instead here.
		// There's a possibility that this method returns wrong value if the value
		// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
		// TODO: safely handle 64-bit integer
		getInt64 () {
			let low, high

			if (this.littleEndian) {
				low = this.getUint32()
				high = this.getUint32()
			} else {
				high = this.getUint32()
				low = this.getUint32()
			}

			// calculate negative value
			if (high & 0x80000000) {
				high = ~high & 0xffffffff
				low = ~low & 0xffffffff

				if (low === 0xffffffff) high = (high + 1) & 0xffffffff

				low = (low + 1) & 0xffffffff

				return -(high * 0x100000000 + low)
			}

			return high * 0x100000000 + low
		}

		getInt64Array (size) {
			const a = []

			for (let i = 0; i < size; i++) {
				a.push(this.getInt64())
			}

			return a
		}

		// Note: see getInt64() comment
		getUint64 () {
			let low, high

			if (this.littleEndian) {
				low = this.getUint32()
				high = this.getUint32()
			} else {
				high = this.getUint32()
				low = this.getUint32()
			}

			return high * 0x100000000 + low
		}

		getFloat32 () {
			const value = this.dv.getFloat32(this.offset, this.littleEndian)
			this.offset += 4
			return value
		}

		getFloat32Array (size) {
			const a = []

			for (let i = 0; i < size; i++) {
				a.push(this.getFloat32())
			}

			return a
		}

		getFloat64 () {
			const value = this.dv.getFloat64(this.offset, this.littleEndian)
			this.offset += 8
			return value
		}

		getFloat64Array (size) {
			const a = []

			for (let i = 0; i < size; i++) {
				a.push(this.getFloat64())
			}

			return a
		}

		getArrayBuffer (size) {
			const value = this.dv.buffer.slice(this.offset, this.offset + size)
			this.offset += size
			return value
		}

		getString (size) {
			// note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead
			let a = []

			for (let i = 0; i < size; i++) {
				a[i] = this.getUint8()
			}

			const nullByte = a.indexOf(0)
			if (nullByte >= 0) a = a.slice(0, nullByte)

			return LoaderUtils.decodeText(new Uint8Array(a))
		}
	}

	// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)
	// and BinaryParser( FBX Binary format)
	class FBXTree {
		add (key, val) {
			this[key] = val
		}
	}

	// ************** UTILITY FUNCTIONS **************

	function isFbxFormatBinary (buffer) {
		const CORRECT = 'Kaydara\u0020FBX\u0020Binary\u0020\u0020\0'

		return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length)
	}

	function isFbxFormatASCII (text) {
		const CORRECT = ['K', 'a', 'y', 'd', 'a', 'r', 'a', '\\', 'F', 'B', 'X', '\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\', '\\']

		let cursor = 0

		function read (offset) {
			const result = text[offset - 1]
			text = text.slice(cursor + offset)
			cursor++
			return result
		}

		for (let i = 0; i < CORRECT.length; ++i) {
			const num = read(1)
			if (num === CORRECT[i]) {
				return false
			}
		}

		return true
	}

	function getFbxVersion (text) {
		const versionRegExp = /FBXVersion: (\d+)/
		const match = text.match(versionRegExp)

		if (match) {
			const version = parseInt(match[1])
			return version
		}

		throw new Error('THREE.FBXLoader: Cannot find the version number for the file given.')
	}

	// Converts FBX ticks into real time seconds.
	function convertFBXTimeToSeconds (time) {
		return time / 46186158000
	}

	const dataArray = []

	// extracts the data from the correct position in the FBX array based on indexing type
	function getData (polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {
		let index

		switch (infoObject.mappingType) {
			case 'ByPolygonVertex':
				index = polygonVertexIndex
				break
			case 'ByPolygon':
				index = polygonIndex
				break
			case 'ByVertice':
				index = vertexIndex
				break
			case 'AllSame':
				index = infoObject.indices[0]
				break
			default:
				console.warn('THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType)
		}

		if (infoObject.referenceType === 'IndexToDirect') index = infoObject.indices[index]

		const from = index * infoObject.dataSize
		const to = from + infoObject.dataSize

		return slice(dataArray, infoObject.buffer, from, to)
	}

	const tempEuler = new Euler()
	const tempVec = new Vector3()

	// generate transformation from FBX transform data
	// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm
	// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e
	function generateTransform (transformData) {
		const lTranslationM = new Matrix4()
		const lPreRotationM = new Matrix4()
		const lRotationM = new Matrix4()
		const lPostRotationM = new Matrix4()

		const lScalingM = new Matrix4()
		const lScalingPivotM = new Matrix4()
		const lScalingOffsetM = new Matrix4()
		const lRotationOffsetM = new Matrix4()
		const lRotationPivotM = new Matrix4()

		const lParentGX = new Matrix4()
		const lParentLX = new Matrix4()
		const lGlobalT = new Matrix4()

		const inheritType = transformData.inheritType ? transformData.inheritType : 0

		if (transformData.translation) lTranslationM.setPosition(tempVec.fromArray(transformData.translation))

		if (transformData.preRotation) {
			const array = transformData.preRotation.map(MathUtils.degToRad)
			array.push(transformData.eulerOrder)
			lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array))
		}

		if (transformData.rotation) {
			const array = transformData.rotation.map(MathUtils.degToRad)
			array.push(transformData.eulerOrder)
			lRotationM.makeRotationFromEuler(tempEuler.fromArray(array))
		}

		if (transformData.postRotation) {
			const array = transformData.postRotation.map(MathUtils.degToRad)
			array.push(transformData.eulerOrder)
			lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array))
			lPostRotationM.invert()
		}

		if (transformData.scale) lScalingM.scale(tempVec.fromArray(transformData.scale))

		// Pivots and offsets
		if (transformData.scalingOffset) lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset))
		if (transformData.scalingPivot) lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot))
		if (transformData.rotationOffset) lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset))
		if (transformData.rotationPivot) lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot))

		// parent transform
		if (transformData.parentMatrixWorld) {
			lParentLX.copy(transformData.parentMatrix)
			lParentGX.copy(transformData.parentMatrixWorld)
		}

		const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM)
		// Global Rotation
		const lParentGRM = new Matrix4()
		lParentGRM.extractRotation(lParentGX)

		// Global Shear*Scaling
		const lParentTM = new Matrix4()
		lParentTM.copyPosition(lParentGX)

		const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX)
		const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM)
		const lLSM = lScalingM

		const lGlobalRS = new Matrix4()

		if (inheritType === 0) {
			lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM)
		} else if (inheritType === 1) {
			lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM)
		} else {
			const lParentLSM = new Matrix4().scale(new Vector3().setFromMatrixScale(lParentLX))
			const lParentLSM_inv = lParentLSM.clone().invert()
			const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv)

			lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM)
		}

		const lRotationPivotM_inv = lRotationPivotM.clone().invert()
		const lScalingPivotM_inv = lScalingPivotM.clone().invert()
		// Calculate the local transform matrix
		let lTransform = lTranslationM
			.clone()
			.multiply(lRotationOffsetM)
			.multiply(lRotationPivotM)
			.multiply(lPreRotationM)
			.multiply(lRotationM)
			.multiply(lPostRotationM)
			.multiply(lRotationPivotM_inv)
			.multiply(lScalingOffsetM)
			.multiply(lScalingPivotM)
			.multiply(lScalingM)
			.multiply(lScalingPivotM_inv)

		const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition(lTransform)

		const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo)
		lGlobalT.copyPosition(lGlobalTranslation)

		lTransform = lGlobalT.clone().multiply(lGlobalRS)

		// from global to local
		lTransform.premultiply(lParentGX.invert())

		return lTransform
	}

	// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order
	// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html
	function getEulerOrder (order) {
		order = order || 0

		const enums = [
			'ZYX', // -> XYZ extrinsic
			'YZX', // -> XZY extrinsic
			'XZY', // -> YZX extrinsic
			'ZXY', // -> YXZ extrinsic
			'YXZ', // -> ZXY extrinsic
			'XYZ' // -> ZYX extrinsic
			//'SphericXYZ', // not possible to support
		]

		if (order === 6) {
			console.warn('THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.')
			return enums[0]
		}

		return enums[order]
	}

	// Parses comma separated list of numbers and returns them an array.
	// Used internally by the TextParser
	function parseNumberArray (value) {
		const array = value.split(',').map(function (val) {
			return parseFloat(val)
		})

		return array
	}

	function convertArrayBufferToString (buffer, from, to) {
		if (from === undefined) from = 0
		if (to === undefined) to = buffer.byteLength

		return LoaderUtils.decodeText(new Uint8Array(buffer, from, to))
	}

	function append (a, b) {
		for (let i = 0, j = a.length, l = b.length; i < l; i++, j++) {
			a[j] = b[i]
		}
	}

	function slice (a, b, from, to) {
		for (let i = from, j = 0; i < to; i++, j++) {
			a[j] = b[i]
		}

		return a
	}

	// inject array a2 into array a1 at index
	function inject (a1, index, a2) {
		return a1.slice(0, index).concat(a2).concat(a1.slice(index))
	}

	// https://github.com/mrdoob/three.js/issues/5552
	// http://en.wikipedia.org/wiki/RGBE_image_format

	class RGBELoader extends DataTextureLoader {

		constructor(manager) {

			super(manager)

			this.type = HalfFloatType

		}

		// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html

		parse (buffer) {

			const
				/* return codes for rgbe routines */
				//RGBE_RETURN_SUCCESS = 0,
				RGBE_RETURN_FAILURE = - 1,

				/* default error routine.  change this to change error handling */
				rgbe_read_error = 1,
				rgbe_write_error = 2,
				rgbe_format_error = 3,
				rgbe_memory_error = 4,
				rgbe_error = function (rgbe_error_code, msg) {

					switch (rgbe_error_code) {

						case rgbe_read_error: console.error('THREE.RGBELoader Read Error: ' + (msg || ''))
							break
						case rgbe_write_error: console.error('THREE.RGBELoader Write Error: ' + (msg || ''))
							break
						case rgbe_format_error: console.error('THREE.RGBELoader Bad File Format: ' + (msg || ''))
							break
						default:
						case rgbe_memory_error: console.error('THREE.RGBELoader: Error: ' + (msg || ''))

					}

					return RGBE_RETURN_FAILURE

				},

				/* offsets to red, green, and blue components in a data (float) pixel */
				//RGBE_DATA_RED = 0,
				//RGBE_DATA_GREEN = 1,
				//RGBE_DATA_BLUE = 2,

				/* number of floats per pixel, use 4 since stored in rgba image format */
				//RGBE_DATA_SIZE = 4,

				/* flags indicating which fields in an rgbe_header_info are valid */
				RGBE_VALID_PROGRAMTYPE = 1,
				RGBE_VALID_FORMAT = 2,
				RGBE_VALID_DIMENSIONS = 4,

				NEWLINE = '\n',

				fgets = function (buffer, lineLimit, consume) {

					const chunkSize = 128

					lineLimit = !lineLimit ? 1024 : lineLimit
					let p = buffer.pos,
						i = - 1, len = 0, s = '',
						chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)))

					while ((0 > (i = chunk.indexOf(NEWLINE))) && (len < lineLimit) && (p < buffer.byteLength)) {

						s += chunk; len += chunk.length
						p += chunkSize
						chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)))

					}

					if (- 1 < i) {

						/*for (i=l-1; i>=0; i--) {
							byteCode = m.charCodeAt(i);
							if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;
							else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;
							if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate
						}*/
						if (false !== consume) buffer.pos += len + i + 1
						return s + chunk.slice(0, i)

					}

					return false

				},

				/* minimal header reading.  modify if you want to parse more information */
				RGBE_ReadHeader = function (buffer) {


					// regexes to parse header info fields
					const magic_token_re = /^#\?(\S+)/,
						gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
						exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
						format_re = /^\s*FORMAT=(\S+)\s*$/,
						dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,

						// RGBE format header struct
						header = {

							valid: 0, /* indicate which fields are valid */

							string: '', /* the actual header string */

							comments: '', /* comments found in header */

							programtype: 'RGBE', /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */

							format: '', /* RGBE format, default 32-bit_rle_rgbe */

							gamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */

							exposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */

							width: 0, height: 0 /* image dimensions, width/height */

						}

					let line, match

					if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {

						return rgbe_error(rgbe_read_error, 'no header found')

					}

					/* if you want to require the magic token then uncomment the next line */
					if (!(match = line.match(magic_token_re))) {

						return rgbe_error(rgbe_format_error, 'bad initial token')

					}

					header.valid |= RGBE_VALID_PROGRAMTYPE
					header.programtype = match[1]
					header.string += line + '\n'

					while (true) {

						line = fgets(buffer)
						if (false === line) break
						header.string += line + '\n'

						if ('#' === line.charAt(0)) {

							header.comments += line + '\n'
							continue // comment line

						}

						if (match = line.match(gamma_re)) {

							header.gamma = parseFloat(match[1], 10)

						}

						if (match = line.match(exposure_re)) {

							header.exposure = parseFloat(match[1], 10)

						}

						if (match = line.match(format_re)) {

							header.valid |= RGBE_VALID_FORMAT
							header.format = match[1]//'32-bit_rle_rgbe';

						}

						if (match = line.match(dimensions_re)) {

							header.valid |= RGBE_VALID_DIMENSIONS
							header.height = parseInt(match[1], 10)
							header.width = parseInt(match[2], 10)

						}

						if ((header.valid & RGBE_VALID_FORMAT) && (header.valid & RGBE_VALID_DIMENSIONS)) break

					}

					if (!(header.valid & RGBE_VALID_FORMAT)) {

						return rgbe_error(rgbe_format_error, 'missing format specifier')

					}

					if (!(header.valid & RGBE_VALID_DIMENSIONS)) {

						return rgbe_error(rgbe_format_error, 'missing image size specifier')

					}

					return header

				},

				RGBE_ReadPixels_RLE = function (buffer, w, h) {

					const scanline_width = w

					if (
						// run length encoding is not allowed so read flat
						((scanline_width < 8) || (scanline_width > 0x7fff)) ||
						// this file is not run length encoded
						((2 !== buffer[0]) || (2 !== buffer[1]) || (buffer[2] & 0x80))
					) {

						// return the flat buffer
						return new Uint8Array(buffer)

					}

					if (scanline_width !== ((buffer[2] << 8) | buffer[3])) {

						return rgbe_error(rgbe_format_error, 'wrong scanline width')

					}

					const data_rgba = new Uint8Array(4 * w * h)

					if (!data_rgba.length) {

						return rgbe_error(rgbe_memory_error, 'unable to allocate buffer space')

					}

					let offset = 0, pos = 0

					const ptr_end = 4 * scanline_width
					const rgbeStart = new Uint8Array(4)
					const scanline_buffer = new Uint8Array(ptr_end)
					let num_scanlines = h

					// read in each successive scanline
					while ((num_scanlines > 0) && (pos < buffer.byteLength)) {

						if (pos + 4 > buffer.byteLength) {

							return rgbe_error(rgbe_read_error)

						}

						rgbeStart[0] = buffer[pos++]
						rgbeStart[1] = buffer[pos++]
						rgbeStart[2] = buffer[pos++]
						rgbeStart[3] = buffer[pos++]

						if ((2 != rgbeStart[0]) || (2 != rgbeStart[1]) || (((rgbeStart[2] << 8) | rgbeStart[3]) != scanline_width)) {

							return rgbe_error(rgbe_format_error, 'bad rgbe scanline format')

						}

						// read each of the four channels for the scanline into the buffer
						// first red, then green, then blue, then exponent
						let ptr = 0, count

						while ((ptr < ptr_end) && (pos < buffer.byteLength)) {

							count = buffer[pos++]
							const isEncodedRun = count > 128
							if (isEncodedRun) count -= 128

							if ((0 === count) || (ptr + count > ptr_end)) {

								return rgbe_error(rgbe_format_error, 'bad scanline data')

							}

							if (isEncodedRun) {

								// a (encoded) run of the same value
								const byteValue = buffer[pos++]
								for (let i = 0; i < count; i++) {

									scanline_buffer[ptr++] = byteValue

								}
								//ptr += count;

							} else {

								// a literal-run
								scanline_buffer.set(buffer.subarray(pos, pos + count), ptr)
								ptr += count; pos += count

							}

						}


						// now convert data from buffer into rgba
						// first red, then green, then blue, then exponent (alpha)
						const l = scanline_width //scanline_buffer.byteLength;
						for (let i = 0; i < l; i++) {

							let off = 0
							data_rgba[offset] = scanline_buffer[i + off]
							off += scanline_width //1;
							data_rgba[offset + 1] = scanline_buffer[i + off]
							off += scanline_width //1;
							data_rgba[offset + 2] = scanline_buffer[i + off]
							off += scanline_width //1;
							data_rgba[offset + 3] = scanline_buffer[i + off]
							offset += 4

						}

						num_scanlines--

					}

					return data_rgba

				}

			const RGBEByteToRGBFloat = function (sourceArray, sourceOffset, destArray, destOffset) {

				const e = sourceArray[sourceOffset + 3]
				const scale = Math.pow(2.0, e - 128.0) / 255.0

				destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale
				destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale
				destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale

			}

			const RGBEByteToRGBHalf = function (sourceArray, sourceOffset, destArray, destOffset) {

				const e = sourceArray[sourceOffset + 3]
				const scale = Math.pow(2.0, e - 128.0) / 255.0

				destArray[destOffset + 0] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 0] * scale)
				destArray[destOffset + 1] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 1] * scale)
				destArray[destOffset + 2] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 2] * scale)

			}

			const byteArray = new Uint8Array(buffer)
			byteArray.pos = 0
			const rgbe_header_info = RGBE_ReadHeader(byteArray)

			if (RGBE_RETURN_FAILURE !== rgbe_header_info) {

				const w = rgbe_header_info.width,
					h = rgbe_header_info.height,
					image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h)

				if (RGBE_RETURN_FAILURE !== image_rgba_data) {

					let data, format, type
					let numElements

					switch (this.type) {

						case UnsignedByteType:

							data = image_rgba_data
							format = RGBEFormat // handled as THREE.RGBAFormat in shaders
							type = UnsignedByteType
							break

						case FloatType:

							numElements = (image_rgba_data.length / 4) * 3
							const floatArray = new Float32Array(numElements)

							for (let j = 0; j < numElements; j++) {

								RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 3)

							}

							data = floatArray
							format = RGBFormat
							type = FloatType
							break

						case HalfFloatType:

							numElements = (image_rgba_data.length / 4) * 3
							const halfArray = new Uint16Array(numElements)

							for (let j = 0; j < numElements; j++) {

								RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 3)

							}

							data = halfArray
							format = RGBFormat
							type = HalfFloatType
							break

						default:

							console.error('THREE.RGBELoader: unsupported type: ', this.type)
							break

					}

					return {
						width: w, height: h,
						data: data,
						header: rgbe_header_info.string,
						gamma: rgbe_header_info.gamma,
						exposure: rgbe_header_info.exposure,
						format: format,
						type: type
					}

				}

			}

			return null

		}

		setDataType (value) {

			this.type = value
			return this

		}

		load (url, onLoad, onProgress, onError) {

			function onLoadCallback (texture, texData) {

				switch (texture.type) {

					case UnsignedByteType:

						texture.encoding = RGBEEncoding
						texture.minFilter = NearestFilter
						texture.magFilter = NearestFilter
						texture.generateMipmaps = false
						texture.flipY = true
						break

					case FloatType:

						texture.encoding = LinearEncoding
						texture.minFilter = LinearFilter
						texture.magFilter = LinearFilter
						texture.generateMipmaps = false
						texture.flipY = true
						break

					case HalfFloatType:

						texture.encoding = LinearEncoding
						texture.minFilter = LinearFilter
						texture.magFilter = LinearFilter
						texture.generateMipmaps = false
						texture.flipY = true
						break

				}

				if (onLoad) onLoad(texture, texData)

			}

			return super.load(url, onLoadCallback, onProgress, onError)

		}

	}

	// This set of controls performs orbiting, dollying (zooming), and panning.
	// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
	//
	//    Orbit - left mouse / touch: one-finger move
	//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
	//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move
	const _changeEvent$1 = { type: 'change' }
	const _startEvent = { type: 'start' }
	const _endEvent = { type: 'end' }
	class OrbitControls extends EventDispatcher {
		object
		domElement
		enabled
		target
		minDistance
		maxDistance
		minZoom
		maxZoom
		minPolarAngle
		maxPolarAngle
		minAzimuthAngle
		maxAzimuthAngle
		enableDamping
		dampingFactor
		enableZoom
		zoomSpeed
		enableRotate
		rotateSpeed
		enablePan
		panSpeed
		screenSpacePanning
		keyPanSpeed
		autoRotate
		autoRotateSpeed
		keys
		// Mouse buttons
		mouseButtons
		// Touch fingers
		touches
		// for reset
		target0
		position0
		zoom0
		// the target DOM element for key events
		_domElementKeyEvents
		//
		STATE
		EPS
		spherical
		sphericalDelta
		scale
		panOffset
		zoomChanged
		rotateStart
		rotateEnd
		rotateDelta
		panStart
		panEnd
		panDelta
		dollyStart
		dollyEnd
		dollyDelta
		pointers
		pointerPositions
		state
		container
		constructor(object, domElement, container) {
			super()
			if (domElement === undefined)
				console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.')
			if (domElement instanceof HTMLDocument)
				console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.')
			this.object = object
			this.domElement = domElement
			this.container = container
			this.domElement.style.touchAction = 'none' // disable touch scroll
			// Set to false to disable this control
			this.enabled = true
			// "target" sets the location of focus, where the object orbits around
			this.target = new Vector3()
			// How far you can dolly in and out ( PerspectiveCamera only )
			this.minDistance = 0
			this.maxDistance = Infinity
			// How far you can zoom in and out ( OrthographicCamera only )
			this.minZoom = 0
			this.maxZoom = Infinity
			// How far you can orbit vertically, upper and lower limits.
			// Range is 0 to Math.PI radians.
			this.minPolarAngle = 0 // radians
			this.maxPolarAngle = Math.PI // radians
			// How far you can orbit horizontally, upper and lower limits.
			// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
			this.minAzimuthAngle = -Infinity // radians
			this.maxAzimuthAngle = Infinity // radians
			// Set to true to enable damping (inertia)
			// If damping is enabled, you must call controls.update() in your animation loop
			this.enableDamping = false
			this.dampingFactor = 0.05
			// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
			// Set to false to disable zooming
			this.enableZoom = true
			this.zoomSpeed = 1.0
			// Set to false to disable rotating
			this.enableRotate = true
			this.rotateSpeed = 1.0
			// Set to false to disable panning
			this.enablePan = true
			this.panSpeed = 1.0
			this.screenSpacePanning = true // if false, pan orthogonal to world-space direction camera.up
			this.keyPanSpeed = 7.0 // pixels moved per arrow key push
			// Set to true to automatically rotate around the target
			// If auto-rotate is enabled, you must call controls.update() in your animation loop
			this.autoRotate = false
			this.autoRotateSpeed = 2.0 // 30 seconds per orbit when fps is 60
			// The four arrow keys
			this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' }
			// Mouse buttons
			this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN }
			// Touch fingers
			this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN }
			// for reset
			this.target0 = this.target.clone()
			this.position0 = this.object.position.clone()
			this.zoom0 = this.object.zoom
			// the target DOM element for key events
			this._domElementKeyEvents = null
			//
			// internals
			//
			this.STATE = {
				NONE: -1,
				ROTATE: 0,
				DOLLY: 1,
				PAN: 2,
				TOUCH_ROTATE: 3,
				TOUCH_PAN: 4,
				TOUCH_DOLLY_PAN: 5,
				TOUCH_DOLLY_ROTATE: 6
			}
			this.EPS = 0.000001
			// current position in spherical coordinates
			this.spherical = new Spherical()
			this.sphericalDelta = new Spherical()
			this.scale = 1
			this.panOffset = new Vector3()
			this.zoomChanged = false
			this.rotateStart = new Vector2()
			this.rotateEnd = new Vector2()
			this.rotateDelta = new Vector2()
			this.panStart = new Vector2()
			this.panEnd = new Vector2()
			this.panDelta = new Vector2()
			this.dollyStart = new Vector2()
			this.dollyEnd = new Vector2()
			this.dollyDelta = new Vector2()
			this.pointers = []
			this.pointerPositions = {}
			//
			this.domElement.addEventListener('contextmenu', this.onContextMenu.bind(this))
			this.domElement.addEventListener('pointerdown', this.onPointerDown.bind(this))
			this.domElement.addEventListener('pointercancel', this.onPointerCancel.bind(this))
			this.domElement.addEventListener('wheel', this.onMouseWheel.bind(this))
			// force an update at start
			this.state = this.STATE.NONE
			this.update()
		}
		//
		// public methods
		//
		getPolarAngle () {
			return this.spherical.phi
		}
		getAzimuthalAngle () {
			return this.spherical.theta
		}
		getDistance () {
			return this.object.position.distanceTo(this.target)
		}
		listenToKeyEvents (domElement) {
			domElement.addEventListener('keydown', this.onKeyDown)
			this._domElementKeyEvents = domElement
		}
		saveState () {
			this.target0.copy(this.target)
			this.position0.copy(this.object.position)
			this.zoom0 = this.object.zoom
		}
		reset () {
			this.target.copy(this.target0)
			this.object.position.copy(this.position0)
			this.object.zoom = this.zoom0
			this.object.updateProjectionMatrix()
			this.dispatchEvent(_changeEvent$1)
			this.update()
			this.state = this.STATE.NONE
		}
		// this method is exposed, but perhaps it would be better if we can make it private...
		update () {
			const offset = new Vector3()
			// so camera.up is the orbit axis
			const quat = new Quaternion().setFromUnitVectors(this.object.up, new Vector3(0, 1, 0))
			const quatInverse = quat.clone().invert()
			const lastPosition = new Vector3()
			const lastQuaternion = new Quaternion()
			const twoPI = 2 * Math.PI
			const position = this.object.position.clone()
			offset.copy(position).sub(this.target)
			// rotate offset to "y-axis-is-up" space
			offset.applyQuaternion(quat)
			// angle from z-axis around y-axis
			const spherical = new Spherical().setFromVector3(offset)
			if (this.autoRotate && this.state === this.STATE.NONE) {
				this.rotateLeft(this.getAutoRotationAngle())
			}
			if (this.enableDamping) {
				spherical.theta += this.sphericalDelta.theta * this.dampingFactor
				spherical.phi += this.sphericalDelta.phi * this.dampingFactor
			}
			else {
				spherical.theta += this.sphericalDelta.theta
				spherical.phi += this.sphericalDelta.phi
			}
			// restrict theta to be between desired limits
			let min = this.minAzimuthAngle
			let max = this.maxAzimuthAngle
			if (isFinite(min) && isFinite(max)) {
				if (min < -Math.PI)
					min += twoPI
				else if (min > Math.PI)
					min -= twoPI
				if (max < -Math.PI)
					max += twoPI
				else if (max > Math.PI)
					max -= twoPI
				if (min <= max) {
					spherical.theta = Math.max(min, Math.min(max, spherical.theta))
				}
				else {
					spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta)
				}
			}
			// restrict phi to be between desired limits
			spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, spherical.phi))
			spherical.makeSafe()
			spherical.radius *= this.scale
			// restrict radius to be between desired limits
			// this.spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this.spherical.radius))
			spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, spherical.radius))
			// move target to panned location
			if (this.enableDamping === true) {
				this.target.addScaledVector(this.panOffset, this.dampingFactor)
			}
			else {
				this.target.add(this.panOffset)
			}
			// offset.setFromSpherical(this.spherical)
			offset.setFromSpherical(spherical)
			// rotate offset back to "camera-up-vector-is-up" space
			offset.applyQuaternion(quatInverse)
			position.copy(this.target).add(offset)
			if (this.container.bounds.boundingSphere?.containsPoint(position)) {
				this.object.lookAt(this.target)
				this.object.position.copy(position)
				this.spherical.copy(spherical)
			}
			else {
				if (this.enableDamping === true) {
					this.target.sub(this.panOffset.clone().multiplyScalar(this.dampingFactor))
				}
				else {
					this.target.sub(this.panOffset)
				}
			}
			if (this.enableDamping === true) {
				this.sphericalDelta.theta *= 1 - this.dampingFactor
				this.sphericalDelta.phi *= 1 - this.dampingFactor
				this.panOffset.multiplyScalar(1 - this.dampingFactor)
			}
			else {
				this.sphericalDelta.set(0, 0, 0)
				this.panOffset.set(0, 0, 0)
			}
			this.scale = 1
			// update condition is:
			// min(camera displacement, camera rotation in radians)^2 > EPS
			// using small-angle approximation cos(x/2) = 1 - x^2 / 8
			if (this.zoomChanged || lastPosition.distanceToSquared(this.object.position) > this.EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > this.EPS) {
				this.dispatchEvent(_changeEvent$1)
				lastPosition.copy(this.object.position)
				lastQuaternion.copy(this.object.quaternion)
				this.zoomChanged = false
				return true
			}
			return false
		}
		dispose () {
			this.domElement.removeEventListener('contextmenu', this.onContextMenu)
			this.domElement.removeEventListener('pointerdown', this.onPointerDown)
			this.domElement.removeEventListener('pointercancel', this.onPointerCancel)
			this.domElement.removeEventListener('wheel', this.onMouseWheel)
			this.domElement.removeEventListener('pointermove', this.onPointerMove)
			this.domElement.removeEventListener('pointerup', this.onPointerUp)
			if (this._domElementKeyEvents !== null) {
				this._domElementKeyEvents.removeEventListener('keydown', this.onKeyDown)
			}
			//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
		}
		getAutoRotationAngle () {
			return ((2 * Math.PI) / 60 / 60) * this.autoRotateSpeed
		}
		getZoomScale () {
			return Math.pow(0.95, this.zoomSpeed)
		}
		rotateLeft (angle) {
			this.sphericalDelta.theta -= angle
		}
		rotateUp (angle) {
			this.sphericalDelta.phi -= angle
		}
		panLeft (distance, objectMatrix) {
			const v = new Vector3()
			v.setFromMatrixColumn(objectMatrix, 0) // get X column of objectMatrix
			v.multiplyScalar(-distance)
			this.panOffset.add(v)
		}
		panUp (distance, objectMatrix) {
			const v = new Vector3()
			v.setFromMatrixColumn(objectMatrix, 0)
			v.crossVectors(this.object.up, v)
			v.multiplyScalar(distance)
			this.panOffset.add(v)
		}
		// deltaX and deltaY are in pixels; right and down are positive
		pan (deltaX, deltaY) {
			const offset = new Vector3()
			const element = this.domElement
			if (this.object instanceof PerspectiveCamera) {
				// perspective
				const position = this.object.position
				offset.copy(position).sub(this.target)
				let targetDistance = offset.length()
				// half of the fov is center to top of screen
				targetDistance *= Math.tan(((this.object.fov / 2) * Math.PI) / 180.0)
				// we use only clientHeight here so aspect ratio does not distort speed
				this.panLeft((2 * deltaX * targetDistance) / element.clientHeight, this.object.matrix)
				this.panUp((2 * deltaY * targetDistance) / element.clientHeight, this.object.matrix)
			}
			else if (this.object instanceof OrthographicCamera) {
				// orthographic
				this.panLeft((deltaX * (this.object.right - this.object.left)) / this.object.zoom / element.clientWidth, this.object.matrix)
				this.panUp((deltaY * (this.object.top - this.object.bottom)) / this.object.zoom / element.clientHeight, this.object.matrix)
			}
			else {
				// camera neither orthographic nor perspective
				console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.')
				this.enablePan = false
			}
		}
		dollyOut (dollyScale) {
			if (this.object instanceof PerspectiveCamera) {
				this.scale /= dollyScale
			}
			else if (this.object instanceof OrthographicCamera) {
				this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom * dollyScale))
				this.object.updateProjectionMatrix()
				this.zoomChanged = true
			}
			else {
				console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.')
				this.enableZoom = false
			}
		}
		dollyIn (dollyScale) {
			if (this.object instanceof PerspectiveCamera) {
				this.scale *= dollyScale
			}
			else if (this.object instanceof OrthographicCamera) {
				this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / dollyScale))
				this.object.updateProjectionMatrix()
				this.zoomChanged = true
			}
			else {
				console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.')
				this.enableZoom = false
			}
		}
		//
		// event callbacks - update the object state
		//
		handleMouseDownRotate (event) {
			this.rotateStart.set(event.clientX, event.clientY)
		}
		handleMouseDownDolly (event) {
			this.dollyStart.set(event.clientX, event.clientY)
		}
		handleMouseDownPan (event) {
			this.panStart.set(event.clientX, event.clientY)
		}
		handleMouseMoveRotate (event) {
			this.rotateEnd.set(event.clientX, event.clientY)
			this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(this.rotateSpeed)
			const element = this.domElement
			this.rotateLeft((2 * Math.PI * this.rotateDelta.x) / element.clientHeight) // yes, height
			this.rotateUp((2 * Math.PI * this.rotateDelta.y) / element.clientHeight)
			this.rotateStart.copy(this.rotateEnd)
			this.update()
		}
		handleMouseMoveDolly (event) {
			this.dollyEnd.set(event.clientX, event.clientY)
			this.dollyDelta.subVectors(this.dollyEnd, this.dollyStart)
			if (this.dollyDelta.y > 0) {
				this.dollyOut(this.getZoomScale())
			}
			else if (this.dollyDelta.y < 0) {
				this.dollyIn(this.getZoomScale())
			}
			this.dollyStart.copy(this.dollyEnd)
			this.update()
		}
		handleMouseMovePan (event) {
			this.panEnd.set(event.clientX, event.clientY)
			this.panDelta.subVectors(this.panEnd, this.panStart).multiplyScalar(this.panSpeed)
			this.pan(this.panDelta.x, this.panDelta.y)
			this.panStart.copy(this.panEnd)
			this.update()
		}
		handleMouseUp (event) {
			// no-op
		}
		handleMouseWheel (event) {
			if (event.deltaY < 0) {
				this.dollyIn(this.getZoomScale())
			}
			else if (event.deltaY > 0) {
				this.dollyOut(this.getZoomScale())
			}
			this.update()
		}
		handleKeyDown (event) {
			let needsUpdate = false
			switch (event.code) {
				case this.keys.UP:
					this.pan(0, this.keyPanSpeed)
					needsUpdate = true
					break
				case this.keys.BOTTOM:
					this.pan(0, -this.keyPanSpeed)
					needsUpdate = true
					break
				case this.keys.LEFT:
					this.pan(this.keyPanSpeed, 0)
					needsUpdate = true
					break
				case this.keys.RIGHT:
					this.pan(-this.keyPanSpeed, 0)
					needsUpdate = true
					break
			}
			if (needsUpdate) {
				// prevent the browser from scrolling on cursor keys
				event.preventDefault()
				this.update()
			}
		}
		handleTouchStartRotate () {
			if (this.pointers.length === 1) {
				this.rotateStart.set(this.pointers[0].pageX, this.pointers[0].pageY)
			}
			else {
				const x = 0.5 * (this.pointers[0].pageX + this.pointers[1].pageX)
				const y = 0.5 * (this.pointers[0].pageY + this.pointers[1].pageY)
				this.rotateStart.set(x, y)
			}
		}
		handleTouchStartPan () {
			if (this.pointers.length === 1) {
				this.panStart.set(this.pointers[0].pageX, this.pointers[0].pageY)
			}
			else {
				const x = 0.5 * (this.pointers[0].pageX + this.pointers[1].pageX)
				const y = 0.5 * (this.pointers[0].pageY + this.pointers[1].pageY)
				this.panStart.set(x, y)
			}
		}
		handleTouchStartDolly () {
			const dx = this.pointers[0].pageX - this.pointers[1].pageX
			const dy = this.pointers[0].pageY - this.pointers[1].pageY
			const distance = Math.sqrt(dx * dx + dy * dy)
			this.dollyStart.set(0, distance)
		}
		handleTouchStartDollyPan () {
			if (this.enableZoom)
				this.handleTouchStartDolly()
			if (this.enablePan)
				this.handleTouchStartPan()
		}
		handleTouchStartDollyRotate () {
			if (this.enableZoom)
				this.handleTouchStartDolly()
			if (this.enableRotate)
				this.handleTouchStartRotate()
		}
		handleTouchMoveRotate (event) {
			if (this.pointers.length == 1) {
				this.rotateEnd.set(event.pageX, event.pageY)
			}
			else {
				const position = this.getSecondPointerPosition(event)
				const x = 0.5 * (event.pageX + position.x)
				const y = 0.5 * (event.pageY + position.y)
				this.rotateEnd.set(x, y)
			}
			this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(this.rotateSpeed)
			const element = this.domElement
			this.rotateLeft((2 * Math.PI * this.rotateDelta.x) / element.clientHeight) // yes, height
			this.rotateUp((2 * Math.PI * this.rotateDelta.y) / element.clientHeight)
			this.rotateStart.copy(this.rotateEnd)
		}
		handleTouchMovePan (event) {
			if (this.pointers.length === 1) {
				this.panEnd.set(event.pageX, event.pageY)
			}
			else {
				const position = this.getSecondPointerPosition(event)
				const x = 0.5 * (event.pageX + position.x)
				const y = 0.5 * (event.pageY + position.y)
				this.panEnd.set(x, y)
			}
			this.panDelta.subVectors(this.panEnd, this.panStart).multiplyScalar(this.panSpeed)
			this.pan(this.panDelta.x, this.panDelta.y)
			this.panStart.copy(this.panEnd)
		}
		handleTouchMoveDolly (event) {
			const position = this.getSecondPointerPosition(event)
			const dx = event.pageX - position.x
			const dy = event.pageY - position.y
			const distance = Math.sqrt(dx * dx + dy * dy)
			this.dollyEnd.set(0, distance)
			this.dollyDelta.set(0, Math.pow(this.dollyEnd.y / this.dollyStart.y, this.zoomSpeed))
			this.dollyOut(this.dollyDelta.y)
			this.dollyStart.copy(this.dollyEnd)
		}
		handleTouchMoveDollyPan (event) {
			if (this.enableZoom)
				this.handleTouchMoveDolly(event)
			if (this.enablePan)
				this.handleTouchMovePan(event)
		}
		handleTouchMoveDollyRotate (event) {
			if (this.enableZoom)
				this.handleTouchMoveDolly(event)
			if (this.enableRotate)
				this.handleTouchMoveRotate(event)
		}
		handleTouchEnd (event) {
			// no-op
		}
		//
		// event handlers - FSM: listen for events and reset state
		//
		onPointerDown (event) {
			if (this.enabled === false)
				return
			if (this.pointers.length === 0) {
				this.domElement.setPointerCapture(event.pointerId)
				this.domElement.addEventListener('pointermove', this.onPointerMove.bind(this))
				this.domElement.addEventListener('pointerup', this.onPointerUp.bind(this))
			}
			//
			this.addPointer(event)
			if (event.pointerType === 'touch') {
				this.onTouchStart(event)
			}
			else {
				this.onMouseDown(event)
			}
		}
		onPointerMove (event) {
			if (this.enabled === false)
				return
			if (event.pointerType === 'touch') {
				this.onTouchMove(event)
			}
			else {
				this.onMouseMove(event)
			}
		}
		onPointerUp (event) {
			if (this.enabled === false)
				return
			if (event.pointerType === 'touch') {
				this.onTouchEnd(event)
			}
			else {
				this.onMouseUp(event)
			}
			this.removePointer(event)
			//
			if (this.pointers.length === 0) {
				this.domElement.releasePointerCapture(event.pointerId)
				this.domElement.removeEventListener('pointermove', this.onPointerMove)
				this.domElement.removeEventListener('pointerup', this.onPointerUp)
			}
		}
		onPointerCancel (event) {
			this.removePointer(event)
		}
		onMouseDown (event) {
			let mouseAction
			switch (event.button) {
				case 0:
					mouseAction = this.mouseButtons.LEFT
					break
				case 1:
					mouseAction = this.mouseButtons.MIDDLE
					break
				case 2:
					mouseAction = this.mouseButtons.RIGHT
					break
				default:
					mouseAction = -1
			}
			switch (mouseAction) {
				case MOUSE.DOLLY:
					if (this.enableZoom === false)
						return
					this.handleMouseDownDolly(event)
					this.state = this.STATE.DOLLY
					break
				case MOUSE.ROTATE:
					if (event.ctrlKey || event.metaKey || event.shiftKey) {
						if (this.enablePan === false)
							return
						this.handleMouseDownPan(event)
						this.state = this.STATE.PAN
					}
					else {
						if (this.enableRotate === false)
							return
						this.handleMouseDownRotate(event)
						this.state = this.STATE.ROTATE
					}
					break
				case MOUSE.PAN:
					if (event.ctrlKey || event.metaKey || event.shiftKey) {
						if (this.enableRotate === false)
							return
						this.handleMouseDownRotate(event)
						this.state = this.STATE.ROTATE
					}
					else {
						if (this.enablePan === false)
							return
						this.handleMouseDownPan(event)
						this.state = this.STATE.PAN
					}
					break
				default:
					this.state = this.STATE.NONE
			}
			if (this.state !== this.STATE.NONE) {
				this.dispatchEvent(_startEvent)
			}
		}
		onMouseMove (event) {
			if (this.enabled === false)
				return
			switch (this.state) {
				case this.STATE.ROTATE:
					if (this.enableRotate === false)
						return
					this.handleMouseMoveRotate(event)
					break
				case this.STATE.DOLLY:
					if (this.enableZoom === false)
						return
					this.handleMouseMoveDolly(event)
					break
				case this.STATE.PAN:
					if (this.enablePan === false)
						return
					this.handleMouseMovePan(event)
					break
			}
		}
		onMouseUp (event) {
			this.handleMouseUp(event)
			this.dispatchEvent(_endEvent)
			this.state = this.STATE.NONE
		}
		onMouseWheel (event) {
			if (this.enabled === false || this.enableZoom === false || (this.state !== this.STATE.NONE && this.state !== this.STATE.ROTATE))
				return
			event.preventDefault()
			this.dispatchEvent(_startEvent)
			this.handleMouseWheel(event)
			this.dispatchEvent(_endEvent)
		}
		onKeyDown (event) {
			if (this.enabled === false || this.enablePan === false)
				return
			this.handleKeyDown(event)
		}
		onTouchStart (event) {
			this.trackPointer(event)
			switch (this.pointers.length) {
				case 1:
					switch (this.touches.ONE) {
						case TOUCH.ROTATE:
							if (this.enableRotate === false)
								return
							this.handleTouchStartRotate()
							this.state = this.STATE.TOUCH_ROTATE
							break
						case TOUCH.PAN:
							if (this.enablePan === false)
								return
							this.handleTouchStartPan()
							this.state = this.STATE.TOUCH_PAN
							break
						default:
							this.state = this.STATE.NONE
					}
					break
				case 2:
					switch (this.touches.TWO) {
						case TOUCH.DOLLY_PAN:
							if (this.enableZoom === false && this.enablePan === false)
								return
							this.handleTouchStartDollyPan()
							this.state = this.STATE.TOUCH_DOLLY_PAN
							break
						case TOUCH.DOLLY_ROTATE:
							if (this.enableZoom === false && this.enableRotate === false)
								return
							this.handleTouchStartDollyRotate()
							this.state = this.STATE.TOUCH_DOLLY_ROTATE
							break
						default:
							this.state = this.STATE.NONE
					}
					break
				default:
					this.state = this.STATE.NONE
			}
			if (this.state !== this.STATE.NONE) {
				this.dispatchEvent(_startEvent)
			}
		}
		onTouchMove (event) {
			this.trackPointer(event)
			switch (this.state) {
				case this.STATE.TOUCH_ROTATE:
					if (this.enableRotate === false)
						return
					this.handleTouchMoveRotate(event)
					this.update()
					break
				case this.STATE.TOUCH_PAN:
					if (this.enablePan === false)
						return
					this.handleTouchMovePan(event)
					this.update()
					break
				case this.STATE.TOUCH_DOLLY_PAN:
					if (this.enableZoom === false && this.enablePan === false)
						return
					this.handleTouchMoveDollyPan(event)
					this.update()
					break
				case this.STATE.TOUCH_DOLLY_ROTATE:
					if (this.enableZoom === false && this.enableRotate === false)
						return
					this.handleTouchMoveDollyRotate(event)
					this.update()
					break
				default:
					this.state = this.STATE.NONE
			}
		}
		onTouchEnd (event) {
			this.handleTouchEnd(event)
			this.dispatchEvent(_endEvent)
			this.state = this.STATE.NONE
		}
		onContextMenu (event) {
			if (this.enabled === false)
				return
			event.preventDefault()
		}
		addPointer (event) {
			this.pointers.push(event)
		}
		removePointer (event) {
			delete this.pointerPositions[event.pointerId]
			for (let i = 0; i < this.pointers.length; i++) {
				if (this.pointers[i].pointerId == event.pointerId) {
					this.pointers.splice(i, 1)
					return
				}
			}
		}
		trackPointer (event) {
			let position = this.pointerPositions[event.pointerId]
			if (position === undefined) {
				position = new Vector2()
				this.pointerPositions[event.pointerId] = position
			}
			position.set(event.pageX, event.pageY)
		}
		getSecondPointerPosition (event) {
			const pointer = event.pointerId === this.pointers[0].pointerId ? this.pointers[1] : this.pointers[0]
			return this.pointerPositions[pointer.pointerId]
		}
	}

	const _taskCache = new WeakMap()

	class DRACOLoader extends Loader {

		constructor(manager) {

			super(manager)

			this.decoderPath = ''
			this.decoderConfig = {}
			this.decoderBinary = null
			this.decoderPending = null

			this.workerLimit = 4
			this.workerPool = []
			this.workerNextTaskID = 1
			this.workerSourceURL = ''

			this.defaultAttributeIDs = {
				position: 'POSITION',
				normal: 'NORMAL',
				color: 'COLOR',
				uv: 'TEX_COORD'
			}
			this.defaultAttributeTypes = {
				position: 'Float32Array',
				normal: 'Float32Array',
				color: 'Float32Array',
				uv: 'Float32Array'
			}

		}

		setDecoderPath (path) {

			this.decoderPath = path

			return this

		}

		setDecoderConfig (config) {

			this.decoderConfig = config

			return this

		}

		setWorkerLimit (workerLimit) {

			this.workerLimit = workerLimit

			return this

		}

		load (url, onLoad, onProgress, onError) {

			const loader = new FileLoader(this.manager)

			loader.setPath(this.path)
			loader.setResponseType('arraybuffer')
			loader.setRequestHeader(this.requestHeader)
			loader.setWithCredentials(this.withCredentials)

			loader.load(url, (buffer) => {

				const taskConfig = {
					attributeIDs: this.defaultAttributeIDs,
					attributeTypes: this.defaultAttributeTypes,
					useUniqueIDs: false
				}

				this.decodeGeometry(buffer, taskConfig)
					.then(onLoad)
					.catch(onError)

			}, onProgress, onError)

		}

		/** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */
		decodeDracoFile (buffer, callback, attributeIDs, attributeTypes) {

			const taskConfig = {
				attributeIDs: attributeIDs || this.defaultAttributeIDs,
				attributeTypes: attributeTypes || this.defaultAttributeTypes,
				useUniqueIDs: !!attributeIDs
			}

			this.decodeGeometry(buffer, taskConfig).then(callback)

		}

		decodeGeometry (buffer, taskConfig) {

			// TODO: For backward-compatibility, support 'attributeTypes' objects containing
			// references (rather than names) to typed array constructors. These must be
			// serialized before sending them to the worker.
			for (const attribute in taskConfig.attributeTypes) {

				const type = taskConfig.attributeTypes[attribute]

				if (type.BYTES_PER_ELEMENT !== undefined) {

					taskConfig.attributeTypes[attribute] = type.name

				}

			}

			//

			const taskKey = JSON.stringify(taskConfig)

			// Check for an existing task using this buffer. A transferred buffer cannot be transferred
			// again from this thread.
			if (_taskCache.has(buffer)) {

				const cachedTask = _taskCache.get(buffer)

				if (cachedTask.key === taskKey) {

					return cachedTask.promise

				} else if (buffer.byteLength === 0) {

					// Technically, it would be possible to wait for the previous task to complete,
					// transfer the buffer back, and decode again with the second configuration. That
					// is complex, and I don't know of any reason to decode a Draco buffer twice in
					// different ways, so this is left unimplemented.
					throw new Error(

						'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +
						'settings. Buffer has already been transferred.'

					)

				}

			}

			//

			let worker
			const taskID = this.workerNextTaskID++
			const taskCost = buffer.byteLength

			// Obtain a worker and assign a task, and construct a geometry instance
			// when the task completes.
			const geometryPending = this._getWorker(taskID, taskCost)
				.then((_worker) => {

					worker = _worker

					return new Promise((resolve, reject) => {

						worker._callbacks[taskID] = { resolve, reject }

						worker.postMessage({ type: 'decode', id: taskID, taskConfig, buffer }, [buffer])

						// this.debug();

					})

				})
				.then((message) => this._createGeometry(message.geometry))

			// Remove task from the task list.
			// Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)
			geometryPending
				.catch(() => true)
				.then(() => {

					if (worker && taskID) {

						this._releaseTask(worker, taskID)

						// this.debug();

					}

				})

			// Cache the task result.
			_taskCache.set(buffer, {

				key: taskKey,
				promise: geometryPending

			})

			return geometryPending

		}

		_createGeometry (geometryData) {

			const geometry = new BufferGeometry()

			if (geometryData.index) {

				geometry.setIndex(new BufferAttribute(geometryData.index.array, 1))

			}

			for (let i = 0; i < geometryData.attributes.length; i++) {

				const attribute = geometryData.attributes[i]
				const name = attribute.name
				const array = attribute.array
				const itemSize = attribute.itemSize

				geometry.setAttribute(name, new BufferAttribute(array, itemSize))

			}

			return geometry

		}

		_loadLibrary (url, responseType) {

			const loader = new FileLoader(this.manager)
			loader.setPath(this.decoderPath)
			loader.setResponseType(responseType)
			loader.setWithCredentials(this.withCredentials)

			return new Promise((resolve, reject) => {

				loader.load(url, resolve, undefined, reject)

			})

		}

		preload () {

			this._initDecoder()

			return this

		}

		_initDecoder () {

			if (this.decoderPending) return this.decoderPending

			const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js'
			const librariesPending = []

			if (useJS) {

				librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'))

			} else {

				librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'))
				librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'))

			}

			this.decoderPending = Promise.all(librariesPending)
				.then((libraries) => {

					const jsContent = libraries[0]

					if (!useJS) {

						this.decoderConfig.wasmBinary = libraries[1]

					}

					const fn = DRACOWorker.toString()

					const body = [
						'/* draco decoder */',
						jsContent,
						'',
						'/* worker */',
						fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))
					].join('\n')

					this.workerSourceURL = URL.createObjectURL(new Blob([body]))

				})

			return this.decoderPending

		}

		_getWorker (taskID, taskCost) {

			return this._initDecoder().then(() => {

				if (this.workerPool.length < this.workerLimit) {

					const worker = new Worker(this.workerSourceURL)

					worker._callbacks = {}
					worker._taskCosts = {}
					worker._taskLoad = 0

					worker.postMessage({ type: 'init', decoderConfig: this.decoderConfig })

					worker.onmessage = function (e) {

						const message = e.data

						switch (message.type) {

							case 'decode':
								worker._callbacks[message.id].resolve(message)
								break

							case 'error':
								worker._callbacks[message.id].reject(message)
								break

							default:
								console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"')

						}

					}

					this.workerPool.push(worker)

				} else {

					this.workerPool.sort(function (a, b) {

						return a._taskLoad > b._taskLoad ? - 1 : 1

					})

				}

				const worker = this.workerPool[this.workerPool.length - 1]
				worker._taskCosts[taskID] = taskCost
				worker._taskLoad += taskCost
				return worker

			})

		}

		_releaseTask (worker, taskID) {

			worker._taskLoad -= worker._taskCosts[taskID]
			delete worker._callbacks[taskID]
			delete worker._taskCosts[taskID]

		}

		debug () {

			console.log('Task load: ', this.workerPool.map((worker) => worker._taskLoad))

		}

		dispose () {

			for (let i = 0; i < this.workerPool.length; ++i) {

				this.workerPool[i].terminate()

			}

			this.workerPool.length = 0

			return this

		}

	}

	/* WEB WORKER */

	function DRACOWorker () {

		let decoderConfig
		let decoderPending

		onmessage = function (e) {

			const message = e.data

			switch (message.type) {

				case 'init':
					decoderConfig = message.decoderConfig
					decoderPending = new Promise(function (resolve/*, reject*/) {

						decoderConfig.onModuleLoaded = function (draco) {

							// Module is Promise-like. Wrap before resolving to avoid loop.
							resolve({ draco: draco })

						}

						DracoDecoderModule(decoderConfig) // eslint-disable-line no-undef

					})
					break

				case 'decode':
					const buffer = message.buffer
					const taskConfig = message.taskConfig
					decoderPending.then((module) => {

						const draco = module.draco
						const decoder = new draco.Decoder()
						const decoderBuffer = new draco.DecoderBuffer()
						decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength)

						try {

							const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig)

							const buffers = geometry.attributes.map((attr) => attr.array.buffer)

							if (geometry.index) buffers.push(geometry.index.array.buffer)

							self.postMessage({ type: 'decode', id: message.id, geometry }, buffers)

						} catch (error) {

							console.error(error)

							self.postMessage({ type: 'error', id: message.id, error: error.message })

						} finally {

							draco.destroy(decoderBuffer)
							draco.destroy(decoder)

						}

					})
					break

			}

		}

		function decodeGeometry (draco, decoder, decoderBuffer, taskConfig) {

			const attributeIDs = taskConfig.attributeIDs
			const attributeTypes = taskConfig.attributeTypes

			let dracoGeometry
			let decodingStatus

			const geometryType = decoder.GetEncodedGeometryType(decoderBuffer)

			if (geometryType === draco.TRIANGULAR_MESH) {

				dracoGeometry = new draco.Mesh()
				decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry)

			} else if (geometryType === draco.POINT_CLOUD) {

				dracoGeometry = new draco.PointCloud()
				decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry)

			} else {

				throw new Error('THREE.DRACOLoader: Unexpected geometry type.')

			}

			if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {

				throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg())

			}

			const geometry = { index: null, attributes: [] }

			// Gather all vertex attributes.
			for (const attributeName in attributeIDs) {

				const attributeType = self[attributeTypes[attributeName]]

				let attribute
				let attributeID

				// A Draco file may be created with default vertex attributes, whose attribute IDs
				// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,
				// a Draco file may contain a custom set of attributes, identified by known unique
				// IDs. glTF files always do the latter, and `.drc` files typically do the former.
				if (taskConfig.useUniqueIDs) {

					attributeID = attributeIDs[attributeName]
					attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID)

				} else {

					attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]])

					if (attributeID === - 1) continue

					attribute = decoder.GetAttribute(dracoGeometry, attributeID)

				}

				geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute))

			}

			// Add index.
			if (geometryType === draco.TRIANGULAR_MESH) {

				geometry.index = decodeIndex(draco, decoder, dracoGeometry)

			}

			draco.destroy(dracoGeometry)

			return geometry

		}

		function decodeIndex (draco, decoder, dracoGeometry) {

			const numFaces = dracoGeometry.num_faces()
			const numIndices = numFaces * 3
			const byteLength = numIndices * 4

			const ptr = draco._malloc(byteLength)
			decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr)
			const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice()
			draco._free(ptr)

			return { array: index, itemSize: 1 }

		}

		function decodeAttribute (draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {

			const numComponents = attribute.num_components()
			const numPoints = dracoGeometry.num_points()
			const numValues = numPoints * numComponents
			const byteLength = numValues * attributeType.BYTES_PER_ELEMENT
			const dataType = getDracoDataType(draco, attributeType)

			const ptr = draco._malloc(byteLength)
			decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr)
			const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice()
			draco._free(ptr)

			return {
				name: attributeName,
				array: array,
				itemSize: numComponents
			}

		}

		function getDracoDataType (draco, attributeType) {

			switch (attributeType) {

				case Float32Array: return draco.DT_FLOAT32
				case Int8Array: return draco.DT_INT8
				case Int16Array: return draco.DT_INT16
				case Int32Array: return draco.DT_INT32
				case Uint8Array: return draco.DT_UINT8
				case Uint16Array: return draco.DT_UINT16
				case Uint32Array: return draco.DT_UINT32

			}

		}

	}

	class FirstPersonControls {
		object
		domElement
		enabled
		movementSpeed
		lookSpeed
		lookVertical
		autoForward
		heightSpeed
		heightCoef
		heightMin
		heightMax
		constrainVertical
		verticalMin
		verticalMax
		autoSpeedFactor
		moveForward
		moveBackward
		moveLeft
		moveRight
		moveUp
		moveDown
		viewHalfX
		viewHalfY
		lat
		lon
		_lookDirection
		_spherical
		_target
		_onMouseMove
		_onMouseDown
		_onMouseUp
		_onKeyDown
		_onKeyUp
		_contextmenu
		start
		end
		delta
		rotate
		constructor(object, domElement) {
			if (domElement === undefined) {
				console.warn('THREE.FirstPersonControls: The second parameter "domElement" is now mandatory.')
				domElement = document
			}
			this.object = object
			this.domElement = domElement
			// API
			this.enabled = true
			this.movementSpeed = 1.0
			this.lookSpeed = 0.005
			this.lookVertical = true
			this.autoForward = false
			this.heightSpeed = false
			this.heightCoef = 1.0
			this.heightMin = 0.0
			this.heightMax = 1.0
			this.constrainVertical = false
			this.verticalMin = 0
			this.verticalMax = Math.PI
			// internals
			this.autoSpeedFactor = 0.0
			this.moveForward = false
			this.moveBackward = false
			this.moveLeft = false
			this.moveRight = false
			this.moveUp = false
			this.moveDown = false
			this.viewHalfX = 0
			this.viewHalfY = 0
			// private variables
			this.lat = 0
			this.lon = 0
			this._lookDirection = new Vector3()
			this._spherical = new Spherical()
			this._target = new Vector3()
			this.start = new Vector2()
			this.end = new Vector2()
			this.delta = new Vector2()
			this.rotate = false
			this._onMouseMove = this.onMouseMove.bind(this)
			this._onMouseDown = this.onMouseDown.bind(this)
			this._onMouseUp = this.onMouseUp.bind(this)
			this._onKeyDown = this.onKeyDown.bind(this)
			this._onKeyUp = this.onKeyUp.bind(this)
			this._contextmenu = this.contextmenu.bind(this)
			this.domElement.addEventListener('contextmenu', this._contextmenu)
			this.domElement.addEventListener('mousemove', this._onMouseMove)
			this.domElement.addEventListener('mousedown', this._onMouseDown)
			this.domElement.addEventListener('mouseup', this._onMouseUp)
			window.addEventListener('keydown', this._onKeyDown)
			window.addEventListener('keyup', this._onKeyUp)
			this.handleResize()
			this.setOrientation()
		}
		handleResize () {
			if (this.domElement instanceof HTMLDocument) {
				this.viewHalfX = window.innerWidth / 2
				this.viewHalfY = window.innerHeight / 2
			}
			else if (this.domElement instanceof HTMLElement) {
				this.viewHalfX = this.domElement.offsetWidth / 2
				this.viewHalfY = this.domElement.offsetHeight / 2
			}
		}
		onMouseDown (event) {
			if (event.button == 0 || event.button == 2) {
				this.rotate = true
				this.start.set(event.clientX, event.clientY)
				this.end.set(event.clientX, event.clientY)
				this.delta.set(0, 0)
			}
		}
		onMouseUp (event) {
			if (event.button == 0 || event.button == 2) {
				this.rotate = false
				this.end.set(event.clientX, event.clientY)
			}
		}
		onMouseMove (event) {
			if (!this.rotate)
				return
			this.end.set(event.clientX, event.clientY)
			this.delta = new Vector2().subVectors(this.start, this.end)
			this.start.set(event.clientX, event.clientY)
		}
		onKeyDown (event) {
			switch (event.code) {
				case 'ArrowUp':
				case 'KeyW':
					this.moveForward = true
					break
				case 'ArrowLeft':
				case 'KeyA':
					this.moveLeft = true
					break
				case 'ArrowDown':
				case 'KeyS':
					this.moveBackward = true
					break
				case 'ArrowRight':
				case 'KeyD':
					this.moveRight = true
					break
				case 'KeyR':
					this.moveUp = true
					break
				case 'KeyF':
					this.moveDown = true
					break
			}
		}
		onKeyUp (event) {
			switch (event.code) {
				case 'ArrowUp':
				case 'KeyW':
					this.moveForward = false
					break
				case 'ArrowLeft':
				case 'KeyA':
					this.moveLeft = false
					break
				case 'ArrowDown':
				case 'KeyS':
					this.moveBackward = false
					break
				case 'ArrowRight':
				case 'KeyD':
					this.moveRight = false
					break
				case 'KeyR':
					this.moveUp = false
					break
				case 'KeyF':
					this.moveDown = false
					break
			}
		}
		contextmenu (event) {
			event.preventDefault()
		}
		update (delta) {
			const targetPosition = new Vector3()
			if (this.enabled === false)
				return
			if (this.heightSpeed) {
				const y = MathUtils.clamp(this.object.position.y, this.heightMin, this.heightMax)
				const heightDelta = y - this.heightMin
				this.autoSpeedFactor = delta * (heightDelta * this.heightCoef)
			}
			else {
				this.autoSpeedFactor = 0.0
			}
			const actualMoveSpeed = delta * this.movementSpeed
			if (this.moveForward || (this.autoForward && !this.moveBackward))
				this.object.translateZ(-(actualMoveSpeed + this.autoSpeedFactor))
			if (this.moveBackward)
				this.object.translateZ(actualMoveSpeed)
			if (this.moveLeft)
				this.object.translateX(-actualMoveSpeed)
			if (this.moveRight)
				this.object.translateX(actualMoveSpeed)
			if (this.moveUp)
				this.object.translateY(actualMoveSpeed)
			if (this.moveDown)
				this.object.translateY(-actualMoveSpeed)
			let actualLookSpeed = delta * this.lookSpeed
			let verticalLookRatio = 1
			if (this.constrainVertical) {
				verticalLookRatio = Math.PI / (this.verticalMax - this.verticalMin)
			}
			this.lon -= this.delta.x * actualLookSpeed
			if (this.lookVertical)
				this.lat -= this.delta.y * actualLookSpeed * verticalLookRatio
			this.lat = Math.max(-85, Math.min(85, this.lat))
			let phi = MathUtils.degToRad(90 - this.lat)
			const theta = MathUtils.degToRad(this.lon)
			if (this.constrainVertical) {
				phi = MathUtils.mapLinear(phi, 0, Math.PI, this.verticalMin, this.verticalMax)
			}
			const position = this.object.position
			targetPosition.setFromSphericalCoords(1, phi, theta).add(position)
			this.object.lookAt(targetPosition)
			this.delta.set(0, 0)
		}
		setOrientation () {
			const quaternion = this.object.quaternion
			this._lookDirection.set(0, 0, -1).applyQuaternion(quaternion)
			this._spherical.setFromVector3(this._lookDirection)
			this.lat = 90 - MathUtils.radToDeg(this._spherical.phi)
			this.lon = MathUtils.radToDeg(this._spherical.theta)
		}
		dispose () {
			this.domElement.removeEventListener('contextmenu', this._contextmenu)
			this.domElement.removeEventListener('mousedown', this._onMouseDown)
			this.domElement.removeEventListener('mousemove', this._onMouseMove)
			this.domElement.removeEventListener('mouseup', this._onMouseUp)
			window.removeEventListener('keydown', this._onKeyDown)
			window.removeEventListener('keyup', this._onKeyUp)
		}
	}

	/**
	 * The Ease class provides a collection of easing functions for use with tween.js.
	 */
	var Easing = {
		Linear: {
			None: function (amount) {
				return amount
			},
		},
		Quadratic: {
			In: function (amount) {
				return amount * amount
			},
			Out: function (amount) {
				return amount * (2 - amount)
			},
			InOut: function (amount) {
				if ((amount *= 2) < 1) {
					return 0.5 * amount * amount
				}
				return -0.5 * (--amount * (amount - 2) - 1)
			},
		},
		Cubic: {
			In: function (amount) {
				return amount * amount * amount
			},
			Out: function (amount) {
				return --amount * amount * amount + 1
			},
			InOut: function (amount) {
				if ((amount *= 2) < 1) {
					return 0.5 * amount * amount * amount
				}
				return 0.5 * ((amount -= 2) * amount * amount + 2)
			},
		},
		Quartic: {
			In: function (amount) {
				return amount * amount * amount * amount
			},
			Out: function (amount) {
				return 1 - --amount * amount * amount * amount
			},
			InOut: function (amount) {
				if ((amount *= 2) < 1) {
					return 0.5 * amount * amount * amount * amount
				}
				return -0.5 * ((amount -= 2) * amount * amount * amount - 2)
			},
		},
		Quintic: {
			In: function (amount) {
				return amount * amount * amount * amount * amount
			},
			Out: function (amount) {
				return --amount * amount * amount * amount * amount + 1
			},
			InOut: function (amount) {
				if ((amount *= 2) < 1) {
					return 0.5 * amount * amount * amount * amount * amount
				}
				return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2)
			},
		},
		Sinusoidal: {
			In: function (amount) {
				return 1 - Math.cos((amount * Math.PI) / 2)
			},
			Out: function (amount) {
				return Math.sin((amount * Math.PI) / 2)
			},
			InOut: function (amount) {
				return 0.5 * (1 - Math.cos(Math.PI * amount))
			},
		},
		Exponential: {
			In: function (amount) {
				return amount === 0 ? 0 : Math.pow(1024, amount - 1)
			},
			Out: function (amount) {
				return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount)
			},
			InOut: function (amount) {
				if (amount === 0) {
					return 0
				}
				if (amount === 1) {
					return 1
				}
				if ((amount *= 2) < 1) {
					return 0.5 * Math.pow(1024, amount - 1)
				}
				return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2)
			},
		},
		Circular: {
			In: function (amount) {
				return 1 - Math.sqrt(1 - amount * amount)
			},
			Out: function (amount) {
				return Math.sqrt(1 - --amount * amount)
			},
			InOut: function (amount) {
				if ((amount *= 2) < 1) {
					return -0.5 * (Math.sqrt(1 - amount * amount) - 1)
				}
				return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1)
			},
		},
		Elastic: {
			In: function (amount) {
				if (amount === 0) {
					return 0
				}
				if (amount === 1) {
					return 1
				}
				return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI)
			},
			Out: function (amount) {
				if (amount === 0) {
					return 0
				}
				if (amount === 1) {
					return 1
				}
				return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1
			},
			InOut: function (amount) {
				if (amount === 0) {
					return 0
				}
				if (amount === 1) {
					return 1
				}
				amount *= 2
				if (amount < 1) {
					return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI)
				}
				return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1
			},
		},
		Back: {
			In: function (amount) {
				var s = 1.70158
				return amount * amount * ((s + 1) * amount - s)
			},
			Out: function (amount) {
				var s = 1.70158
				return --amount * amount * ((s + 1) * amount + s) + 1
			},
			InOut: function (amount) {
				var s = 1.70158 * 1.525
				if ((amount *= 2) < 1) {
					return 0.5 * (amount * amount * ((s + 1) * amount - s))
				}
				return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2)
			},
		},
		Bounce: {
			In: function (amount) {
				return 1 - Easing.Bounce.Out(1 - amount)
			},
			Out: function (amount) {
				if (amount < 1 / 2.75) {
					return 7.5625 * amount * amount
				}
				else if (amount < 2 / 2.75) {
					return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75
				}
				else if (amount < 2.5 / 2.75) {
					return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375
				}
				else {
					return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375
				}
			},
			InOut: function (amount) {
				if (amount < 0.5) {
					return Easing.Bounce.In(amount * 2) * 0.5
				}
				return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5
			},
		},
	}

	var now
	// Include a performance.now polyfill.
	// In node.js, use process.hrtime.
	// eslint-disable-next-line
	// @ts-ignore
	if (typeof self === 'undefined' && typeof process !== 'undefined' && process.hrtime) {
		now = function () {
			// eslint-disable-next-line
			// @ts-ignore
			var time = process.hrtime()
			// Convert [seconds, nanoseconds] to milliseconds.
			return time[0] * 1000 + time[1] / 1000000
		}
	}
	// In a browser, use self.performance.now if it is available.
	else if (typeof self !== 'undefined' && self.performance !== undefined && self.performance.now !== undefined) {
		// This must be bound, because directly assigning this function
		// leads to an invocation exception in Chrome.
		now = self.performance.now.bind(self.performance)
	}
	// Use Date.now if it is available.
	else if (Date.now !== undefined) {
		now = Date.now
	}
	// Otherwise, use 'new Date().getTime()'.
	else {
		now = function () {
			return new Date().getTime()
		}
	}
	var now$1 = now

	/**
	 * Controlling groups of tweens
	 *
	 * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
	 * In these cases, you may want to create your own smaller groups of tween
	 */
	var Group = /** @class */ (function () {
		function Group () {
			this._tweens = {}
			this._tweensAddedDuringUpdate = {}
		}
		Group.prototype.getAll = function () {
			var _this = this
			return Object.keys(this._tweens).map(function (tweenId) {
				return _this._tweens[tweenId]
			})
		}
		Group.prototype.removeAll = function () {
			this._tweens = {}
		}
		Group.prototype.add = function (tween) {
			this._tweens[tween.getId()] = tween
			this._tweensAddedDuringUpdate[tween.getId()] = tween
		}
		Group.prototype.remove = function (tween) {
			delete this._tweens[tween.getId()]
			delete this._tweensAddedDuringUpdate[tween.getId()]
		}
		Group.prototype.update = function (time, preserve) {
			if (time === void 0) { time = now$1() }
			if (preserve === void 0) { preserve = false }
			var tweenIds = Object.keys(this._tweens)
			if (tweenIds.length === 0) {
				return false
			}
			// Tweens are updated in "batches". If you add a new tween during an
			// update, then the new tween will be updated in the next batch.
			// If you remove a tween during an update, it may or may not be updated.
			// However, if the removed tween was added during the current batch,
			// then it will not be updated.
			while (tweenIds.length > 0) {
				this._tweensAddedDuringUpdate = {}
				for (var i = 0; i < tweenIds.length; i++) {
					var tween = this._tweens[tweenIds[i]]
					var autoStart = !preserve
					if (tween && tween.update(time, autoStart) === false && !preserve) {
						delete this._tweens[tweenIds[i]]
					}
				}
				tweenIds = Object.keys(this._tweensAddedDuringUpdate)
			}
			return true
		}
		return Group
	}())

	/**
	 *
	 */
	var Interpolation = {
		Linear: function (v, k) {
			var m = v.length - 1
			var f = m * k
			var i = Math.floor(f)
			var fn = Interpolation.Utils.Linear
			if (k < 0) {
				return fn(v[0], v[1], f)
			}
			if (k > 1) {
				return fn(v[m], v[m - 1], m - f)
			}
			return fn(v[i], v[i + 1 > m ? m : i + 1], f - i)
		},
		Bezier: function (v, k) {
			var b = 0
			var n = v.length - 1
			var pw = Math.pow
			var bn = Interpolation.Utils.Bernstein
			for (var i = 0; i <= n; i++) {
				b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i)
			}
			return b
		},
		CatmullRom: function (v, k) {
			var m = v.length - 1
			var f = m * k
			var i = Math.floor(f)
			var fn = Interpolation.Utils.CatmullRom
			if (v[0] === v[m]) {
				if (k < 0) {
					i = Math.floor((f = m * (1 + k)))
				}
				return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i)
			}
			else {
				if (k < 0) {
					return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0])
				}
				if (k > 1) {
					return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m])
				}
				return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i)
			}
		},
		Utils: {
			Linear: function (p0, p1, t) {
				return (p1 - p0) * t + p0
			},
			Bernstein: function (n, i) {
				var fc = Interpolation.Utils.Factorial
				return fc(n) / fc(i) / fc(n - i)
			},
			Factorial: (function () {
				var a = [1]
				return function (n) {
					var s = 1
					if (a[n]) {
						return a[n]
					}
					for (var i = n; i > 1; i--) {
						s *= i
					}
					a[n] = s
					return s
				}
			})(),
			CatmullRom: function (p0, p1, p2, p3, t) {
				var v0 = (p2 - p0) * 0.5
				var v1 = (p3 - p1) * 0.5
				var t2 = t * t
				var t3 = t * t2
				return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1
			},
		},
	}

	/**
	 * Utils
	 */
	var Sequence = /** @class */ (function () {
		function Sequence () {
		}
		Sequence.nextId = function () {
			return Sequence._nextId++
		}
		Sequence._nextId = 0
		return Sequence
	}())

	var mainGroup = new Group()

	/**
	 * Tween.js - Licensed under the MIT license
	 * https://github.com/tweenjs/tween.js
	 * ----------------------------------------------
	 *
	 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
	 * Thank you all, you're awesome!
	 */
	var Tween = /** @class */ (function () {
		function Tween (_object, _group) {
			if (_group === void 0) { _group = mainGroup }
			this._object = _object
			this._group = _group
			this._isPaused = false
			this._pauseStart = 0
			this._valuesStart = {}
			this._valuesEnd = {}
			this._valuesStartRepeat = {}
			this._duration = 1000
			this._initialRepeat = 0
			this._repeat = 0
			this._yoyo = false
			this._isPlaying = false
			this._reversed = false
			this._delayTime = 0
			this._startTime = 0
			this._easingFunction = Easing.Linear.None
			this._interpolationFunction = Interpolation.Linear
			this._chainedTweens = []
			this._onStartCallbackFired = false
			this._id = Sequence.nextId()
			this._isChainStopped = false
			this._goToEnd = false
		}
		Tween.prototype.getId = function () {
			return this._id
		}
		Tween.prototype.isPlaying = function () {
			return this._isPlaying
		}
		Tween.prototype.isPaused = function () {
			return this._isPaused
		}
		Tween.prototype.to = function (properties, duration) {
			// TODO? restore this, then update the 07_dynamic_to example to set fox
			// tween's to on each update. That way the behavior is opt-in (there's
			// currently no opt-out).
			// for (const prop in properties) this._valuesEnd[prop] = properties[prop]
			this._valuesEnd = Object.create(properties)
			if (duration !== undefined) {
				this._duration = duration
			}
			return this
		}
		Tween.prototype.duration = function (d) {
			this._duration = d
			return this
		}
		Tween.prototype.start = function (time) {
			if (this._isPlaying) {
				return this
			}
			// eslint-disable-next-line
			this._group && this._group.add(this)
			this._repeat = this._initialRepeat
			if (this._reversed) {
				// If we were reversed (f.e. using the yoyo feature) then we need to
				// flip the tween direction back to forward.
				this._reversed = false
				for (var property in this._valuesStartRepeat) {
					this._swapEndStartRepeatValues(property)
					this._valuesStart[property] = this._valuesStartRepeat[property]
				}
			}
			this._isPlaying = true
			this._isPaused = false
			this._onStartCallbackFired = false
			this._isChainStopped = false
			this._startTime = time !== undefined ? (typeof time === 'string' ? now$1() + parseFloat(time) : time) : now$1()
			this._startTime += this._delayTime
			this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat)
			return this
		}
		Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat) {
			for (var property in _valuesEnd) {
				var startValue = _object[property]
				var startValueIsArray = Array.isArray(startValue)
				var propType = startValueIsArray ? 'array' : typeof startValue
				var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property])
				// If `to()` specifies a property that doesn't exist in the source object,
				// we should not set that property in the object
				if (propType === 'undefined' || propType === 'function') {
					continue
				}
				// Check if an Array was provided as property value
				if (isInterpolationList) {
					var endValues = _valuesEnd[property]
					if (endValues.length === 0) {
						continue
					}
					// handle an array of relative values
					endValues = endValues.map(this._handleRelativeValue.bind(this, startValue))
					// Create a local copy of the Array with the start value at the front
					_valuesEnd[property] = [startValue].concat(endValues)
				}
				// handle the deepness of the values
				if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {
					_valuesStart[property] = startValueIsArray ? [] : {}
					// eslint-disable-next-line
					for (var prop in startValue) {
						// eslint-disable-next-line
						// @ts-ignore FIXME?
						_valuesStart[property][prop] = startValue[prop]
					}
					_valuesStartRepeat[property] = startValueIsArray ? [] : {} // TODO? repeat nested values? And yoyo? And array values?
					// eslint-disable-next-line
					// @ts-ignore FIXME?
					this._setupProperties(startValue, _valuesStart[property], _valuesEnd[property], _valuesStartRepeat[property])
				}
				else {
					// Save the starting value, but only once.
					if (typeof _valuesStart[property] === 'undefined') {
						_valuesStart[property] = startValue
					}
					if (!startValueIsArray) {
						// eslint-disable-next-line
						// @ts-ignore FIXME?
						_valuesStart[property] *= 1.0 // Ensures we're using numbers, not strings
					}
					if (isInterpolationList) {
						// eslint-disable-next-line
						// @ts-ignore FIXME?
						_valuesStartRepeat[property] = _valuesEnd[property].slice().reverse()
					}
					else {
						_valuesStartRepeat[property] = _valuesStart[property] || 0
					}
				}
			}
		}
		Tween.prototype.stop = function () {
			if (!this._isChainStopped) {
				this._isChainStopped = true
				this.stopChainedTweens()
			}
			if (!this._isPlaying) {
				return this
			}
			// eslint-disable-next-line
			this._group && this._group.remove(this)
			this._isPlaying = false
			this._isPaused = false
			if (this._onStopCallback) {
				this._onStopCallback(this._object)
			}
			return this
		}
		Tween.prototype.end = function () {
			this._goToEnd = true
			this.update(Infinity)
			return this
		}
		Tween.prototype.pause = function (time) {
			if (time === void 0) { time = now$1() }
			if (this._isPaused || !this._isPlaying) {
				return this
			}
			this._isPaused = true
			this._pauseStart = time
			// eslint-disable-next-line
			this._group && this._group.remove(this)
			return this
		}
		Tween.prototype.resume = function (time) {
			if (time === void 0) { time = now$1() }
			if (!this._isPaused || !this._isPlaying) {
				return this
			}
			this._isPaused = false
			this._startTime += time - this._pauseStart
			this._pauseStart = 0
			// eslint-disable-next-line
			this._group && this._group.add(this)
			return this
		}
		Tween.prototype.stopChainedTweens = function () {
			for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
				this._chainedTweens[i].stop()
			}
			return this
		}
		Tween.prototype.group = function (group) {
			this._group = group
			return this
		}
		Tween.prototype.delay = function (amount) {
			this._delayTime = amount
			return this
		}
		Tween.prototype.repeat = function (times) {
			this._initialRepeat = times
			this._repeat = times
			return this
		}
		Tween.prototype.repeatDelay = function (amount) {
			this._repeatDelayTime = amount
			return this
		}
		Tween.prototype.yoyo = function (yoyo) {
			this._yoyo = yoyo
			return this
		}
		Tween.prototype.easing = function (easingFunction) {
			this._easingFunction = easingFunction
			return this
		}
		Tween.prototype.interpolation = function (interpolationFunction) {
			this._interpolationFunction = interpolationFunction
			return this
		}
		Tween.prototype.chain = function () {
			var tweens = []
			for (var _i = 0; _i < arguments.length; _i++) {
				tweens[_i] = arguments[_i]
			}
			this._chainedTweens = tweens
			return this
		}
		Tween.prototype.onStart = function (callback) {
			this._onStartCallback = callback
			return this
		}
		Tween.prototype.onUpdate = function (callback) {
			this._onUpdateCallback = callback
			return this
		}
		Tween.prototype.onRepeat = function (callback) {
			this._onRepeatCallback = callback
			return this
		}
		Tween.prototype.onComplete = function (callback) {
			this._onCompleteCallback = callback
			return this
		}
		Tween.prototype.onStop = function (callback) {
			this._onStopCallback = callback
			return this
		}
		/**
		 * @returns true if the tween is still playing after the update, false
		 * otherwise (calling update on a paused tween still returns true because
		 * it is still playing, just paused).
		 */
		Tween.prototype.update = function (time, autoStart) {
			if (time === void 0) { time = now$1() }
			if (autoStart === void 0) { autoStart = true }
			if (this._isPaused)
				return true
			var property
			var elapsed
			var endTime = this._startTime + this._duration
			if (!this._goToEnd && !this._isPlaying) {
				if (time > endTime)
					return false
				if (autoStart)
					this.start(time)
			}
			this._goToEnd = false
			if (time < this._startTime) {
				return true
			}
			if (this._onStartCallbackFired === false) {
				if (this._onStartCallback) {
					this._onStartCallback(this._object)
				}
				this._onStartCallbackFired = true
			}
			elapsed = (time - this._startTime) / this._duration
			elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed
			var value = this._easingFunction(elapsed)
			// properties transformations
			this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value)
			if (this._onUpdateCallback) {
				this._onUpdateCallback(this._object, elapsed)
			}
			if (elapsed === 1) {
				if (this._repeat > 0) {
					if (isFinite(this._repeat)) {
						this._repeat--
					}
					// Reassign starting values, restart by making startTime = now
					for (property in this._valuesStartRepeat) {
						if (!this._yoyo && typeof this._valuesEnd[property] === 'string') {
							this._valuesStartRepeat[property] =
								// eslint-disable-next-line
								// @ts-ignore FIXME?
								this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property])
						}
						if (this._yoyo) {
							this._swapEndStartRepeatValues(property)
						}
						this._valuesStart[property] = this._valuesStartRepeat[property]
					}
					if (this._yoyo) {
						this._reversed = !this._reversed
					}
					if (this._repeatDelayTime !== undefined) {
						this._startTime = time + this._repeatDelayTime
					}
					else {
						this._startTime = time + this._delayTime
					}
					if (this._onRepeatCallback) {
						this._onRepeatCallback(this._object)
					}
					return true
				}
				else {
					if (this._onCompleteCallback) {
						this._onCompleteCallback(this._object)
					}
					for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
						// Make the chained tweens start exactly at the time they should,
						// even if the `update()` method was called way past the duration of the tween
						this._chainedTweens[i].start(this._startTime + this._duration)
					}
					this._isPlaying = false
					return false
				}
			}
			return true
		}
		Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {
			for (var property in _valuesEnd) {
				// Don't update properties that do not exist in the source object
				if (_valuesStart[property] === undefined) {
					continue
				}
				var start = _valuesStart[property] || 0
				var end = _valuesEnd[property]
				var startIsArray = Array.isArray(_object[property])
				var endIsArray = Array.isArray(end)
				var isInterpolationList = !startIsArray && endIsArray
				if (isInterpolationList) {
					_object[property] = this._interpolationFunction(end, value)
				}
				else if (typeof end === 'object' && end) {
					// eslint-disable-next-line
					// @ts-ignore FIXME?
					this._updateProperties(_object[property], start, end, value)
				}
				else {
					// Parses relative end values with start as base (e.g.: +10, -3)
					end = this._handleRelativeValue(start, end)
					// Protect against non numeric properties.
					if (typeof end === 'number') {
						// eslint-disable-next-line
						// @ts-ignore FIXME?
						_object[property] = start + (end - start) * value
					}
				}
			}
		}
		Tween.prototype._handleRelativeValue = function (start, end) {
			if (typeof end !== 'string') {
				return end
			}
			if (end.charAt(0) === '+' || end.charAt(0) === '-') {
				return start + parseFloat(end)
			}
			else {
				return parseFloat(end)
			}
		}
		Tween.prototype._swapEndStartRepeatValues = function (property) {
			var tmp = this._valuesStartRepeat[property]
			var endValue = this._valuesEnd[property]
			if (typeof endValue === 'string') {
				this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue)
			}
			else {
				this._valuesStartRepeat[property] = this._valuesEnd[property]
			}
			this._valuesEnd[property] = tmp
		}
		return Tween
	}())

	var VERSION = '18.6.4'

	/**
	 * Tween.js - Licensed under the MIT license
	 * https://github.com/tweenjs/tween.js
	 * ----------------------------------------------
	 *
	 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
	 * Thank you all, you're awesome!
	 */
	var nextId = Sequence.nextId
	/**
	 * Controlling groups of tweens
	 *
	 * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
	 * In these cases, you may want to create your own smaller groups of tweens.
	 */
	var TWEEN = mainGroup
	// This is the best way to export things in a way that's compatible with both ES
	// Modules and CommonJS, without build hacks, and so as not to break the
	// existing API.
	// https://github.com/rollup/rollup/issues/1961#issuecomment-423037881
	var getAll = TWEEN.getAll.bind(TWEEN)
	var removeAll = TWEEN.removeAll.bind(TWEEN)
	var add = TWEEN.add.bind(TWEEN)
	var remove = TWEEN.remove.bind(TWEEN)
	var update = TWEEN.update.bind(TWEEN)
	var exports$1 = {
		Easing: Easing,
		Group: Group,
		Interpolation: Interpolation,
		now: now$1,
		Sequence: Sequence,
		nextId: nextId,
		Tween: Tween,
		VERSION: VERSION,
		getAll: getAll,
		removeAll: removeAll,
		add: add,
		remove: remove,
		update: update,
	}

	var tween_esm = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': exports$1,
		Easing: Easing,
		Group: Group,
		Interpolation: Interpolation,
		Sequence: Sequence,
		Tween: Tween,
		VERSION: VERSION,
		add: add,
		getAll: getAll,
		nextId: nextId,
		now: now$1,
		remove: remove,
		removeAll: removeAll,
		update: update
	})

	/**
	 * Full-screen textured quad shader
	 */

	var CopyShader$1 = {

		uniforms: {

			'tDiffuse': { value: null },
			'opacity': { value: 1.0 }

		},

		vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

		fragmentShader: /* glsl */`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;

		}`

	}

	class Pass$1 {

		constructor() {

			// if set to true, the pass is processed by the composer
			this.enabled = true

			// if set to true, the pass indicates to swap read and write buffer after rendering
			this.needsSwap = true

			// if set to true, the pass clears its buffer before rendering
			this.clear = false

			// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
			this.renderToScreen = false

		}

		setSize ( /* width, height */) { }

		render ( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */) {

			console.error('THREE.Pass: .render() must be implemented in derived pass.')

		}

	}

	// Helper for passes that need to fill the viewport with a single quad.

	const _camera$1 = new OrthographicCamera(- 1, 1, 1, - 1, 0, 1)

	// https://github.com/mrdoob/three.js/pull/21358

	const _geometry$2 = new BufferGeometry()
	_geometry$2.setAttribute('position', new Float32BufferAttribute([- 1, 3, 0, - 1, - 1, 0, 3, - 1, 0], 3))
	_geometry$2.setAttribute('uv', new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2))

	class FullScreenQuad$1 {

		constructor(material) {

			this._mesh = new Mesh(_geometry$2, material)

		}

		dispose () {

			this._mesh.geometry.dispose()

		}

		render (renderer) {

			renderer.render(this._mesh, _camera$1)

		}

		get material () {

			return this._mesh.material

		}

		set material (value) {

			this._mesh.material = value

		}

	}

	class ShaderPass extends Pass$1 {

		constructor(shader, textureID) {

			super()

			this.textureID = (textureID !== undefined) ? textureID : 'tDiffuse'

			if (shader instanceof ShaderMaterial) {

				this.uniforms = shader.uniforms

				this.material = shader

			} else if (shader) {

				this.uniforms = UniformsUtils$1.clone(shader.uniforms)

				this.material = new ShaderMaterial({

					defines: Object.assign({}, shader.defines),
					uniforms: this.uniforms,
					vertexShader: shader.vertexShader,
					fragmentShader: shader.fragmentShader

				})

			}

			this.fsQuad = new FullScreenQuad$1(this.material)

		}

		render (renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {

			if (this.uniforms[this.textureID]) {

				this.uniforms[this.textureID].value = readBuffer.texture

			}

			this.fsQuad.material = this.material

			if (this.renderToScreen) {

				renderer.setRenderTarget(null)
				this.fsQuad.render(renderer)

			} else {

				renderer.setRenderTarget(writeBuffer)
				// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
				if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil)
				this.fsQuad.render(renderer)

			}

		}

	}

	class MaskPass extends Pass$1 {

		constructor(scene, camera) {

			super()

			this.scene = scene
			this.camera = camera

			this.clear = true
			this.needsSwap = false

			this.inverse = false

		}

		render (renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {

			const context = renderer.getContext()
			const state = renderer.state

			// don't update color or depth

			state.buffers.color.setMask(false)
			state.buffers.depth.setMask(false)

			// lock buffers

			state.buffers.color.setLocked(true)
			state.buffers.depth.setLocked(true)

			// set up stencil

			let writeValue, clearValue

			if (this.inverse) {

				writeValue = 0
				clearValue = 1

			} else {

				writeValue = 1
				clearValue = 0

			}

			state.buffers.stencil.setTest(true)
			state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE)
			state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff)
			state.buffers.stencil.setClear(clearValue)
			state.buffers.stencil.setLocked(true)

			// draw into the stencil buffer

			renderer.setRenderTarget(readBuffer)
			if (this.clear) renderer.clear()
			renderer.render(this.scene, this.camera)

			renderer.setRenderTarget(writeBuffer)
			if (this.clear) renderer.clear()
			renderer.render(this.scene, this.camera)

			// unlock color and depth buffer for subsequent rendering

			state.buffers.color.setLocked(false)
			state.buffers.depth.setLocked(false)

			// only render where stencil is set to 1

			state.buffers.stencil.setLocked(false)
			state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff) // draw if == 1
			state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP)
			state.buffers.stencil.setLocked(true)

		}

	}

	class ClearMaskPass extends Pass$1 {

		constructor() {

			super()

			this.needsSwap = false

		}

		render (renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */) {

			renderer.state.buffers.stencil.setLocked(false)
			renderer.state.buffers.stencil.setTest(false)

		}

	}

	class EffectComposer {

		constructor(renderer, renderTarget) {

			this.renderer = renderer

			if (renderTarget === undefined) {

				const parameters = {
					minFilter: LinearFilter,
					magFilter: LinearFilter,
					format: RGBAFormat
				}

				const size = renderer.getSize(new Vector2())
				this._pixelRatio = renderer.getPixelRatio()
				this._width = size.width
				this._height = size.height

				renderTarget = new WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, parameters)
				renderTarget.texture.name = 'EffectComposer.rt1'

			} else {

				this._pixelRatio = 1
				this._width = renderTarget.width
				this._height = renderTarget.height

			}

			this.renderTarget1 = renderTarget
			this.renderTarget2 = renderTarget.clone()
			this.renderTarget2.texture.name = 'EffectComposer.rt2'

			this.writeBuffer = this.renderTarget1
			this.readBuffer = this.renderTarget2

			this.renderToScreen = true

			this.passes = []

			// dependencies

			if (CopyShader$1 === undefined) {

				console.error('THREE.EffectComposer relies on CopyShader')

			}

			if (ShaderPass === undefined) {

				console.error('THREE.EffectComposer relies on ShaderPass')

			}

			this.copyPass = new ShaderPass(CopyShader$1)

			this.clock = new Clock()

		}

		swapBuffers () {

			const tmp = this.readBuffer
			this.readBuffer = this.writeBuffer
			this.writeBuffer = tmp

		}

		addPass (pass) {

			this.passes.push(pass)
			pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)

		}

		insertPass (pass, index) {

			this.passes.splice(index, 0, pass)
			pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)

		}

		removePass (pass) {

			const index = this.passes.indexOf(pass)

			if (index !== - 1) {

				this.passes.splice(index, 1)

			}

		}

		isLastEnabledPass (passIndex) {

			for (let i = passIndex + 1; i < this.passes.length; i++) {

				if (this.passes[i].enabled) {

					return false

				}

			}

			return true

		}

		render (deltaTime) {

			// deltaTime value is in seconds

			if (deltaTime === undefined) {

				deltaTime = this.clock.getDelta()

			}

			const currentRenderTarget = this.renderer.getRenderTarget()

			let maskActive = false

			for (let i = 0, il = this.passes.length; i < il; i++) {

				const pass = this.passes[i]

				if (pass.enabled === false) continue

				pass.renderToScreen = (this.renderToScreen && this.isLastEnabledPass(i))
				pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive)

				if (pass.needsSwap) {

					if (maskActive) {

						const context = this.renderer.getContext()
						const stencil = this.renderer.state.buffers.stencil

						//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );
						stencil.setFunc(context.NOTEQUAL, 1, 0xffffffff)

						this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime)

						//context.stencilFunc( context.EQUAL, 1, 0xffffffff );
						stencil.setFunc(context.EQUAL, 1, 0xffffffff)

					}

					this.swapBuffers()

				}

				if (MaskPass !== undefined) {

					if (pass instanceof MaskPass) {

						maskActive = true

					} else if (pass instanceof ClearMaskPass) {

						maskActive = false

					}

				}

			}

			this.renderer.setRenderTarget(currentRenderTarget)

		}

		reset (renderTarget) {

			if (renderTarget === undefined) {

				const size = this.renderer.getSize(new Vector2())
				this._pixelRatio = this.renderer.getPixelRatio()
				this._width = size.width
				this._height = size.height

				renderTarget = this.renderTarget1.clone()
				renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)

			}

			this.renderTarget1.dispose()
			this.renderTarget2.dispose()
			this.renderTarget1 = renderTarget
			this.renderTarget2 = renderTarget.clone()

			this.writeBuffer = this.renderTarget1
			this.readBuffer = this.renderTarget2

		}

		setSize (width, height) {

			this._width = width
			this._height = height

			const effectiveWidth = this._width * this._pixelRatio
			const effectiveHeight = this._height * this._pixelRatio

			this.renderTarget1.setSize(effectiveWidth, effectiveHeight)
			this.renderTarget2.setSize(effectiveWidth, effectiveHeight)

			for (let i = 0; i < this.passes.length; i++) {

				this.passes[i].setSize(effectiveWidth, effectiveHeight)

			}

		}

		setPixelRatio (pixelRatio) {

			this._pixelRatio = pixelRatio

			this.setSize(this._width, this._height)

		}

	}

	// Helper for passes that need to fill the viewport with a single quad.

	new OrthographicCamera(- 1, 1, 1, - 1, 0, 1)

	// https://github.com/mrdoob/three.js/pull/21358

	const _geometry$1 = new BufferGeometry()
	_geometry$1.setAttribute('position', new Float32BufferAttribute([- 1, 3, 0, - 1, - 1, 0, 3, - 1, 0], 3))
	_geometry$1.setAttribute('uv', new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2))

	class RenderPass extends Pass$1 {

		constructor(scene, camera, overrideMaterial, clearColor, clearAlpha) {

			super()

			this.scene = scene
			this.camera = camera

			this.overrideMaterial = overrideMaterial

			this.clearColor = clearColor
			this.clearAlpha = (clearAlpha !== undefined) ? clearAlpha : 0

			this.clear = true
			this.clearDepth = false
			this.needsSwap = false
			this._oldClearColor = new Color()

		}

		render (renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {

			const oldAutoClear = renderer.autoClear
			renderer.autoClear = false

			let oldClearAlpha, oldOverrideMaterial

			if (this.overrideMaterial !== undefined) {

				oldOverrideMaterial = this.scene.overrideMaterial

				this.scene.overrideMaterial = this.overrideMaterial

			}

			if (this.clearColor) {

				renderer.getClearColor(this._oldClearColor)
				oldClearAlpha = renderer.getClearAlpha()

				renderer.setClearColor(this.clearColor, this.clearAlpha)

			}

			if (this.clearDepth) {

				renderer.clearDepth()

			}

			renderer.setRenderTarget(this.renderToScreen ? null : readBuffer)

			// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
			if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil)
			renderer.render(this.scene, this.camera)

			if (this.clearColor) {

				renderer.setClearColor(this._oldClearColor, oldClearAlpha)

			}

			if (this.overrideMaterial !== undefined) {

				this.scene.overrideMaterial = oldOverrideMaterial

			}

			renderer.autoClear = oldAutoClear

		}

	}

	/**
	 * Depth-of-field shader with bokeh
	 * ported from GLSL shader by Martins Upitis
	 * http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html
	 */

	const BokehShader = {

		defines: {
			'DEPTH_PACKING': 1,
			'PERSPECTIVE_CAMERA': 1,
		},

		uniforms: {

			'tColor': { value: null },
			'tDepth': { value: null },
			'focus': { value: 1.0 },
			'aspect': { value: 1.0 },
			'aperture': { value: 0.025 },
			'maxblur': { value: 0.01 },
			'nearClip': { value: 1.0 },
			'farClip': { value: 1000.0 },

		},

		vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

		fragmentShader: /* glsl */`

		#include <common>

		varying vec2 vUv;

		uniform sampler2D tColor;
		uniform sampler2D tDepth;

		uniform float maxblur; // max blur amount
		uniform float aperture; // aperture - bigger values for shallower depth of field

		uniform float nearClip;
		uniform float farClip;

		uniform float focus;
		uniform float aspect;

		#include <packing>

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, nearClip, farClip );
			#else
			return orthographicDepthToViewZ( depth, nearClip, farClip );
			#endif
		}


		void main() {

			vec2 aspectcorrect = vec2( 1.0, aspect );

			float viewZ = getViewZ( getDepth( vUv ) );

			float factor = ( focus + viewZ ); // viewZ is <= 0, so this is a difference equation

			vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );

			vec2 dofblur9 = dofblur * 0.9;
			vec2 dofblur7 = dofblur * 0.7;
			vec2 dofblur4 = dofblur * 0.4;

			vec4 col = vec4( 0.0 );

			col += texture2D( tColor, vUv.xy );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );

			gl_FragColor = col / 41.0;
			gl_FragColor.a = 1.0;

		}`

	}

	/**
	 * Depth-of-field post-process with bokeh shader
	 */

	class BokehPass extends Pass$1 {

		constructor(scene, camera, params) {

			super()

			this.scene = scene
			this.camera = camera

			const focus = (params.focus !== undefined) ? params.focus : 1.0
			const aspect = (params.aspect !== undefined) ? params.aspect : camera.aspect
			const aperture = (params.aperture !== undefined) ? params.aperture : 0.025
			const maxblur = (params.maxblur !== undefined) ? params.maxblur : 1.0

			// render targets

			const width = params.width || window.innerWidth || 1
			const height = params.height || window.innerHeight || 1

			this.renderTargetDepth = new WebGLRenderTarget(width, height, {
				minFilter: NearestFilter,
				magFilter: NearestFilter
			})

			this.renderTargetDepth.texture.name = 'BokehPass.depth'

			// depth material

			this.materialDepth = new MeshDepthMaterial()
			this.materialDepth.depthPacking = RGBADepthPacking
			this.materialDepth.blending = NoBlending

			// bokeh material

			if (BokehShader === undefined) {

				console.error('THREE.BokehPass relies on BokehShader')

			}

			const bokehShader = BokehShader
			const bokehUniforms = UniformsUtils$1.clone(bokehShader.uniforms)

			bokehUniforms['tDepth'].value = this.renderTargetDepth.texture

			bokehUniforms['focus'].value = focus
			bokehUniforms['aspect'].value = aspect
			bokehUniforms['aperture'].value = aperture
			bokehUniforms['maxblur'].value = maxblur
			bokehUniforms['nearClip'].value = camera.near
			bokehUniforms['farClip'].value = camera.far

			this.materialBokeh = new ShaderMaterial({
				defines: Object.assign({}, bokehShader.defines),
				uniforms: bokehUniforms,
				vertexShader: bokehShader.vertexShader,
				fragmentShader: bokehShader.fragmentShader
			})

			this.uniforms = bokehUniforms
			this.needsSwap = false

			this.fsQuad = new FullScreenQuad$1(this.materialBokeh)

			this._oldClearColor = new Color()

		}

		render (renderer, writeBuffer, readBuffer/*, deltaTime, maskActive*/) {

			// Render depth into texture

			this.scene.overrideMaterial = this.materialDepth

			renderer.getClearColor(this._oldClearColor)
			const oldClearAlpha = renderer.getClearAlpha()
			const oldAutoClear = renderer.autoClear
			renderer.autoClear = false

			renderer.setClearColor(0xffffff)
			renderer.setClearAlpha(1.0)
			renderer.setRenderTarget(this.renderTargetDepth)
			renderer.clear()
			renderer.render(this.scene, this.camera)

			// Render bokeh composite

			this.uniforms['tColor'].value = readBuffer.texture
			this.uniforms['nearClip'].value = this.camera.near
			this.uniforms['farClip'].value = this.camera.far

			if (this.renderToScreen) {

				renderer.setRenderTarget(null)
				this.fsQuad.render(renderer)

			} else {

				renderer.setRenderTarget(writeBuffer)
				renderer.clear()
				this.fsQuad.render(renderer)

			}

			this.scene.overrideMaterial = null
			renderer.setClearColor(this._oldClearColor)
			renderer.setClearAlpha(oldClearAlpha)
			renderer.autoClear = oldAutoClear

		}

	}

	/**
	 * Luminosity
	 * http://en.wikipedia.org/wiki/Luminosity
	 */

	const LuminosityHighPassShader = {

		shaderID: 'luminosityHighPass',

		uniforms: {

			'tDiffuse': { value: null },
			'luminosityThreshold': { value: 1.0 },
			'smoothWidth': { value: 1.0 },
			'defaultColor': { value: new Color(0x000000) },
			'defaultOpacity': { value: 0.0 }

		},

		vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

		fragmentShader: /* glsl */`

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`

	}

	/**
	 * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a
	 * mip map chain of bloom textures and blurs them with different radii. Because
	 * of the weighted combination of mips, and because larger blurs are done on
	 * higher mips, this effect provides good quality and performance.
	 *
	 * Reference:
	 * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/
	 */
	class UnrealBloomPass extends Pass$1 {

		constructor(resolution, strength, radius, threshold) {

			super()

			this.strength = (strength !== undefined) ? strength : 1
			this.radius = radius
			this.threshold = threshold
			this.resolution = (resolution !== undefined) ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256)

			// create color only once here, reuse it later inside the render function
			this.clearColor = new Color(0, 0, 0)

			// render targets
			const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat }
			this.renderTargetsHorizontal = []
			this.renderTargetsVertical = []
			this.nMips = 5
			let resx = Math.round(this.resolution.x / 2)
			let resy = Math.round(this.resolution.y / 2)

			this.renderTargetBright = new WebGLRenderTarget(resx, resy, pars)
			this.renderTargetBright.texture.name = 'UnrealBloomPass.bright'
			this.renderTargetBright.texture.generateMipmaps = false

			for (let i = 0; i < this.nMips; i++) {

				const renderTargetHorizonal = new WebGLRenderTarget(resx, resy, pars)

				renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i
				renderTargetHorizonal.texture.generateMipmaps = false

				this.renderTargetsHorizontal.push(renderTargetHorizonal)

				const renderTargetVertical = new WebGLRenderTarget(resx, resy, pars)

				renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i
				renderTargetVertical.texture.generateMipmaps = false

				this.renderTargetsVertical.push(renderTargetVertical)

				resx = Math.round(resx / 2)

				resy = Math.round(resy / 2)

			}

			// luminosity high pass material

			if (LuminosityHighPassShader === undefined)
				console.error('THREE.UnrealBloomPass relies on LuminosityHighPassShader')

			const highPassShader = LuminosityHighPassShader
			this.highPassUniforms = UniformsUtils$1.clone(highPassShader.uniforms)

			this.highPassUniforms['luminosityThreshold'].value = threshold
			this.highPassUniforms['smoothWidth'].value = 0.01

			this.materialHighPassFilter = new ShaderMaterial({
				uniforms: this.highPassUniforms,
				vertexShader: highPassShader.vertexShader,
				fragmentShader: highPassShader.fragmentShader,
				defines: {}
			})

			// Gaussian Blur Materials
			this.separableBlurMaterials = []
			const kernelSizeArray = [3, 5, 7, 9, 11]
			resx = Math.round(this.resolution.x / 2)
			resy = Math.round(this.resolution.y / 2)

			for (let i = 0; i < this.nMips; i++) {

				this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]))

				this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy)

				resx = Math.round(resx / 2)

				resy = Math.round(resy / 2)

			}

			// Composite material
			this.compositeMaterial = this.getCompositeMaterial(this.nMips)
			this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture
			this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture
			this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture
			this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture
			this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture
			this.compositeMaterial.uniforms['bloomStrength'].value = strength
			this.compositeMaterial.uniforms['bloomRadius'].value = 0.1
			this.compositeMaterial.needsUpdate = true

			const bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2]
			this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors
			this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)]
			this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors

			// copy material
			if (CopyShader$1 === undefined) {

				console.error('THREE.UnrealBloomPass relies on CopyShader')

			}

			const copyShader = CopyShader$1

			this.copyUniforms = UniformsUtils$1.clone(copyShader.uniforms)
			this.copyUniforms['opacity'].value = 1.0

			this.materialCopy = new ShaderMaterial({
				uniforms: this.copyUniforms,
				vertexShader: copyShader.vertexShader,
				fragmentShader: copyShader.fragmentShader,
				blending: AdditiveBlending,
				depthTest: false,
				depthWrite: false,
				transparent: true
			})

			this.enabled = true
			this.needsSwap = false

			this._oldClearColor = new Color()
			this.oldClearAlpha = 1

			this.basic = new MeshBasicMaterial()

			this.fsQuad = new FullScreenQuad$1(null)

		}

		dispose () {

			for (let i = 0; i < this.renderTargetsHorizontal.length; i++) {

				this.renderTargetsHorizontal[i].dispose()

			}

			for (let i = 0; i < this.renderTargetsVertical.length; i++) {

				this.renderTargetsVertical[i].dispose()

			}

			this.renderTargetBright.dispose()

		}

		setSize (width, height) {

			let resx = Math.round(width / 2)
			let resy = Math.round(height / 2)

			this.renderTargetBright.setSize(resx, resy)

			for (let i = 0; i < this.nMips; i++) {

				this.renderTargetsHorizontal[i].setSize(resx, resy)
				this.renderTargetsVertical[i].setSize(resx, resy)

				this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy)

				resx = Math.round(resx / 2)
				resy = Math.round(resy / 2)

			}

		}

		render (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {

			renderer.getClearColor(this._oldClearColor)
			this.oldClearAlpha = renderer.getClearAlpha()
			const oldAutoClear = renderer.autoClear
			renderer.autoClear = false

			renderer.setClearColor(this.clearColor, 0)

			if (maskActive) renderer.state.buffers.stencil.setTest(false)

			// Render input to screen

			if (this.renderToScreen) {

				this.fsQuad.material = this.basic
				this.basic.map = readBuffer.texture

				renderer.setRenderTarget(null)
				renderer.clear()
				this.fsQuad.render(renderer)

			}

			// 1. Extract Bright Areas

			this.highPassUniforms['tDiffuse'].value = readBuffer.texture
			this.highPassUniforms['luminosityThreshold'].value = this.threshold
			this.fsQuad.material = this.materialHighPassFilter

			renderer.setRenderTarget(this.renderTargetBright)
			renderer.clear()
			this.fsQuad.render(renderer)

			// 2. Blur All the mips progressively

			let inputRenderTarget = this.renderTargetBright

			for (let i = 0; i < this.nMips; i++) {

				this.fsQuad.material = this.separableBlurMaterials[i]

				this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture
				this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX
				renderer.setRenderTarget(this.renderTargetsHorizontal[i])
				renderer.clear()
				this.fsQuad.render(renderer)

				this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture
				this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY
				renderer.setRenderTarget(this.renderTargetsVertical[i])
				renderer.clear()
				this.fsQuad.render(renderer)

				inputRenderTarget = this.renderTargetsVertical[i]

			}

			// Composite All the mips

			this.fsQuad.material = this.compositeMaterial
			this.compositeMaterial.uniforms['bloomStrength'].value = this.strength
			this.compositeMaterial.uniforms['bloomRadius'].value = this.radius
			this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors

			renderer.setRenderTarget(this.renderTargetsHorizontal[0])
			renderer.clear()
			this.fsQuad.render(renderer)

			// Blend it additively over the input texture

			this.fsQuad.material = this.materialCopy
			this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture

			if (maskActive) renderer.state.buffers.stencil.setTest(true)

			if (this.renderToScreen) {

				renderer.setRenderTarget(null)
				this.fsQuad.render(renderer)

			} else {

				renderer.setRenderTarget(readBuffer)
				this.fsQuad.render(renderer)

			}

			// Restore renderer settings

			renderer.setClearColor(this._oldClearColor, this.oldClearAlpha)
			renderer.autoClear = oldAutoClear

		}

		getSeperableBlurMaterial (kernelRadius) {

			return new ShaderMaterial({

				defines: {
					'KERNEL_RADIUS': kernelRadius,
					'SIGMA': kernelRadius
				},

				uniforms: {
					'colorTexture': { value: null },
					'texSize': { value: new Vector2(0.5, 0.5) },
					'direction': { value: new Vector2(0.5, 0.5) }
				},

				vertexShader:
					`varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,

				fragmentShader:
					`#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float fSigma = float(SIGMA);
					float weightSum = gaussianPdf(0.0, fSigma);
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianPdf(x, fSigma);
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`
			})

		}

		getCompositeMaterial (nMips) {

			return new ShaderMaterial({

				defines: {
					'NUM_MIPS': nMips
				},

				uniforms: {
					'blurTexture1': { value: null },
					'blurTexture2': { value: null },
					'blurTexture3': { value: null },
					'blurTexture4': { value: null },
					'blurTexture5': { value: null },
					'dirtTexture': { value: null },
					'bloomStrength': { value: 1.0 },
					'bloomFactors': { value: null },
					'bloomTintColors': { value: null },
					'bloomRadius': { value: 0.0 }
				},

				vertexShader:
					`varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,

				fragmentShader:
					`varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform sampler2D dirtTexture;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`
			})

		}

	}

	UnrealBloomPass.BlurDirectionX = new Vector2(1.0, 0.0)
	UnrealBloomPass.BlurDirectionY = new Vector2(0.0, 1.0)

	var bloomVertexShader = `
varying vec2 vUv;

void main() {

	vUv = uv;

	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

}

`

	var bloomFragShader = `
uniform sampler2D baseTexture;
uniform sampler2D bloomTexture;

varying vec2 vUv;

void main() {

    gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );

}

`

	/**
	*
	* Supersample Anti-Aliasing Render Pass
	*
	* This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.
	*
	* References: https://en.wikipedia.org/wiki/Supersampling
	*
	*/

	class SSAARenderPass extends Pass$1 {

		constructor(scene, camera, clearColor, clearAlpha) {

			super()

			this.scene = scene
			this.camera = camera

			this.sampleLevel = 4 // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.
			this.unbiased = true

			// as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.
			this.clearColor = (clearColor !== undefined) ? clearColor : 0x000000
			this.clearAlpha = (clearAlpha !== undefined) ? clearAlpha : 0
			this._oldClearColor = new Color()

			if (CopyShader$1 === undefined) console.error('THREE.SSAARenderPass relies on CopyShader')

			const copyShader = CopyShader$1
			this.copyUniforms = UniformsUtils$1.clone(copyShader.uniforms)

			this.copyMaterial = new ShaderMaterial({
				uniforms: this.copyUniforms,
				vertexShader: copyShader.vertexShader,
				fragmentShader: copyShader.fragmentShader,
				premultipliedAlpha: true,
				transparent: true,
				blending: AdditiveBlending,
				depthTest: false,
				depthWrite: false
			})

			this.fsQuad = new FullScreenQuad$1(this.copyMaterial)

		}

		dispose () {

			if (this.sampleRenderTarget) {

				this.sampleRenderTarget.dispose()
				this.sampleRenderTarget = null

			}

		}

		setSize (width, height) {

			if (this.sampleRenderTarget) this.sampleRenderTarget.setSize(width, height)

		}

		render (renderer, writeBuffer, readBuffer) {

			if (!this.sampleRenderTarget) {

				this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat })
				this.sampleRenderTarget.texture.name = 'SSAARenderPass.sample'

			}

			const jitterOffsets = _JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))]

			const autoClear = renderer.autoClear
			renderer.autoClear = false

			renderer.getClearColor(this._oldClearColor)
			const oldClearAlpha = renderer.getClearAlpha()

			const baseSampleWeight = 1.0 / jitterOffsets.length
			const roundingRange = 1 / 32
			this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture

			const viewOffset = {

				fullWidth: readBuffer.width,
				fullHeight: readBuffer.height,
				offsetX: 0,
				offsetY: 0,
				width: readBuffer.width,
				height: readBuffer.height

			}

			const originalViewOffset = Object.assign({}, this.camera.view)

			if (originalViewOffset.enabled) Object.assign(viewOffset, originalViewOffset)

			// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.
			for (let i = 0; i < jitterOffsets.length; i++) {

				const jitterOffset = jitterOffsets[i]

				if (this.camera.setViewOffset) {

					this.camera.setViewOffset(

						viewOffset.fullWidth, viewOffset.fullHeight,

						viewOffset.offsetX + jitterOffset[0] * 0.0625, viewOffset.offsetY + jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16

						viewOffset.width, viewOffset.height

					)

				}

				let sampleWeight = baseSampleWeight

				if (this.unbiased) {

					// the theory is that equal weights for each sample lead to an accumulation of rounding errors.
					// The following equation varies the sampleWeight per sample so that it is uniformly distributed
					// across a range of values whose rounding errors cancel each other out.

					const uniformCenteredDistribution = (- 0.5 + (i + 0.5) / jitterOffsets.length)
					sampleWeight += roundingRange * uniformCenteredDistribution

				}

				this.copyUniforms['opacity'].value = sampleWeight
				renderer.setClearColor(this.clearColor, this.clearAlpha)
				renderer.setRenderTarget(this.sampleRenderTarget)
				renderer.clear()
				renderer.render(this.scene, this.camera)

				renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer)

				if (i === 0) {

					renderer.setClearColor(0x000000, 0.0)
					renderer.clear()

				}

				this.fsQuad.render(renderer)

			}

			if (this.camera.setViewOffset && originalViewOffset.enabled) {

				this.camera.setViewOffset(

					originalViewOffset.fullWidth, originalViewOffset.fullHeight,

					originalViewOffset.offsetX, originalViewOffset.offsetY,

					originalViewOffset.width, originalViewOffset.height

				)

			} else if (this.camera.clearViewOffset) {

				this.camera.clearViewOffset()

			}

			renderer.autoClear = autoClear
			renderer.setClearColor(this._oldClearColor, oldClearAlpha)

		}

	}


	// These jitter vectors are specified in integers because it is easier.
	// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)
	// before being used, thus these integers need to be scaled by 1/16.
	//
	// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396
	const _JitterVectors = [
		[
			[0, 0]
		],
		[
			[4, 4], [- 4, - 4]
		],
		[
			[- 2, - 6], [6, - 2], [- 6, 2], [2, 6]
		],
		[
			[1, - 3], [- 1, 3], [5, 1], [- 3, - 5],
			[- 5, 5], [- 7, - 1], [3, 7], [7, - 7]
		],
		[
			[1, 1], [- 1, - 3], [- 3, 2], [4, - 1],
			[- 5, - 2], [2, 5], [5, 3], [3, - 5],
			[- 2, 6], [0, - 7], [- 4, - 6], [- 6, 4],
			[- 8, 0], [7, - 4], [6, 7], [- 7, - 8]
		],
		[
			[- 4, - 7], [- 7, - 5], [- 3, - 5], [- 5, - 4],
			[- 1, - 4], [- 2, - 2], [- 6, - 1], [- 4, 0],
			[- 7, 1], [- 1, 2], [- 6, 3], [- 3, 3],
			[- 7, 6], [- 3, 6], [- 5, 7], [- 1, 7],
			[5, - 7], [1, - 6], [6, - 5], [4, - 4],
			[2, - 3], [7, - 2], [1, - 1], [4, - 1],
			[2, 1], [6, 2], [0, 4], [4, 4],
			[2, 5], [7, 5], [5, 6], [3, 7]
		]
	]

	class Pass {
		constructor() {
			// if set to true, the pass is processed by the composer
			this.enabled = true

			// if set to true, the pass indicates to swap read and write buffer after rendering
			this.needsSwap = true

			// if set to true, the pass clears its buffer before rendering
			this.clear = false

			// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
			this.renderToScreen = false
		}

		setSize (/* width, height */) { }

		render (/* renderer, writeBuffer, readBuffer, deltaTime, maskActive */) {
			console.error('THREE.Pass: .render() must be implemented in derived pass.')
		}
	}

	// Helper for passes that need to fill the viewport with a single quad.

	const _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1)

	// https://github.com/mrdoob/three.js/pull/21358

	const _geometry = new BufferGeometry()
	_geometry.setAttribute('position', new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3))
	_geometry.setAttribute('uv', new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2))

	class FullScreenQuad {
		constructor(material) {
			this._mesh = new Mesh(_geometry, material)
		}

		dispose () {
			this._mesh.geometry.dispose()
		}

		render (renderer) {
			renderer.render(this._mesh, _camera)
		}

		get material () {
			return this._mesh.material
		}

		set material (value) {
			this._mesh.material = value
		}
	}

	/**
	 * References:
	 * https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html
	 */

	var SSRShader = {
		defines: {
			MAX_STEP: 0,
			PERSPECTIVE_CAMERA: true,
			DISTANCE_ATTENUATION: true,
			FRESNEL: true,
			INFINITE_THICK: false,
			SELECTIVE: false
		},

		uniforms: {
			tDiffuse: { value: null },
			tNormal: { value: null },
			tMetalness: { value: null },
			tDepth: { value: null },
			cameraNear: { value: null },
			cameraFar: { value: null },
			resolution: { value: new Vector2() },
			cameraProjectionMatrix: { value: new Matrix4() },
			cameraInverseProjectionMatrix: { value: new Matrix4() },
			opacity: { value: 0.5 },
			maxDistance: { value: 180 },
			cameraRange: { value: 0 },
			thickness: { value: 0.018 }
		},

		vertexShader: /* glsl */ `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`,

		fragmentShader: /* glsl */ `
		// precision highp float;
		precision highp sampler2D;
		varying vec2 vUv;
		uniform sampler2D tDepth;
		uniform sampler2D tNormal;
		uniform sampler2D tMetalness;
		uniform sampler2D tDiffuse;
		uniform float cameraRange;
		uniform vec2 resolution;
		uniform float opacity;
		uniform float cameraNear;
		uniform float cameraFar;
		uniform float maxDistance;
		uniform float thickness;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;
		#include <packing>
		float pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {
			//x0: point, x1: linePointA, x2: linePointB
			//https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html
			return length(cross(x0-x1,x0-x2))/length(x2-x1);
		}
		float pointPlaneDistance(vec3 point,vec3 planePoint,vec3 planeNormal){
			// https://mathworld.wolfram.com/Point-PlaneDistance.html
			//// https://en.wikipedia.org/wiki/Plane_(geometry)
			//// http://paulbourke.net/geometry/pointlineplane/
			float a=planeNormal.x,b=planeNormal.y,c=planeNormal.z;
			float x0=point.x,y0=point.y,z0=point.z;
			float x=planePoint.x,y=planePoint.y,z=planePoint.z;
			float d=-(a*x+b*y+c*z);
			float distance=(a*x0+b*y0+c*z0+d)/sqrt(a*a+b*b+c*c);
			return distance;
		}
		float getDepth( const in vec2 uv ) {
			return texture2D( tDepth, uv ).x;
		}
		float getViewZ( const in float depth ) {
			#ifdef PERSPECTIVE_CAMERA
				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}
		vec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {
			vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc
			clipPosition *= clipW; //clip
			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;//view
		}
		vec3 getViewNormal( const in vec2 uv ) {
			return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );
		}
		vec2 viewPositionToXY(vec3 viewPosition){
			vec2 xy;
			vec4 clip=cameraProjectionMatrix*vec4(viewPosition,1);
			xy=clip.xy;//clip
			float clipW=clip.w;
			xy/=clipW;//NDC
			xy=(xy+1.)/2.;//uv
			xy*=resolution;//screen
			return xy;
		}
		void main(){
			#ifdef SELECTIVE
				float metalness=texture2D(tMetalness,vUv).r;
				if(metalness==0.) return;
			#endif

			float depth = getDepth( vUv );
			float viewZ = getViewZ( depth );
			if(-viewZ>=cameraFar) return;

			float clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];
			vec3 viewPosition=getViewPosition( vUv, depth, clipW );

			vec2 d0=gl_FragCoord.xy;
			vec2 d1;

			vec3 viewNormal=getViewNormal( vUv );

			#ifdef PERSPECTIVE_CAMERA
				vec3 viewIncidentDir=normalize(viewPosition);
				vec3 viewReflectDir=reflect(viewIncidentDir,viewNormal);
			#else
				vec3 viewIncidentDir=vec3(0,0,-1);
				vec3 viewReflectDir=reflect(viewIncidentDir,viewNormal);
			#endif

			float maxReflectRayLen=maxDistance/dot(-viewIncidentDir,viewNormal);
			// dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html
			// if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)
			// maxDistance/maxReflectRayLen=cos(theta)
			// maxDistance/maxReflectRayLen==dot(a,b)
			// maxReflectRayLen==maxDistance/dot(a,b)

			vec3 d1viewPosition=viewPosition+viewReflectDir*maxReflectRayLen;
			#ifdef PERSPECTIVE_CAMERA
				if(d1viewPosition.z>-cameraNear){
					//https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx
					float t=(-cameraNear-viewPosition.z)/viewReflectDir.z;
					d1viewPosition=viewPosition+viewReflectDir*t;
				}
			#endif
			d1=viewPositionToXY(d1viewPosition);

			float totalLen=length(d1-d0);
			float xLen=d1.x-d0.x;
			float yLen=d1.y-d0.y;
			float totalStep=max(abs(xLen),abs(yLen));
			float xSpan=xLen/totalStep;
			float ySpan=yLen/totalStep;
			for(float i=0.;i<float(MAX_STEP);i++){
				if(i>=totalStep) break;
				vec2 xy=vec2(d0.x+i*xSpan,d0.y+i*ySpan);
				if(xy.x<0.||xy.x>resolution.x||xy.y<0.||xy.y>resolution.y) break;
				float s=length(xy-d0)/totalLen;
				vec2 uv=xy/resolution;

				float d = getDepth(uv);
				float vZ = getViewZ( d );
				if(-vZ>=cameraFar) continue;
				float cW = cameraProjectionMatrix[2][3] * vZ+cameraProjectionMatrix[3][3];
				vec3 vP=getViewPosition( uv, d, cW );

				#ifdef PERSPECTIVE_CAMERA
					// https://www.comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf
					float recipVPZ=1./viewPosition.z;
					float viewReflectRayZ=1./(recipVPZ+s*(1./d1viewPosition.z-recipVPZ));
				#else
					float viewReflectRayZ=viewPosition.z+s*(d1viewPosition.z-viewPosition.z);
				#endif

				// if(viewReflectRayZ>vZ) continue; // will cause "npm run make-screenshot webgl_postprocessing_ssr" high probability hang.
				// https://github.com/mrdoob/three.js/pull/21539#issuecomment-821061164
				if(viewReflectRayZ<=vZ){

					bool hit;
					#ifdef INFINITE_THICK
						hit=true;
					#else
						float away=pointToLineDistance(vP,viewPosition,d1viewPosition);

						float minThickness;
						vec2 xyNeighbor=xy;
						xyNeighbor.x+=1.;
						vec2 uvNeighbor=xyNeighbor/resolution;
						vec3 vPNeighbor=getViewPosition(uvNeighbor,d,cW);
						minThickness=vPNeighbor.x-vP.x;
						minThickness*=3.;
						float tk=max(minThickness,thickness);

						hit=away<=tk;
					#endif

					if(hit){
						vec3 vN=getViewNormal( uv );
						if(dot(viewReflectDir,vN)>=0.) continue;
						float distance=pointPlaneDistance(vP,viewPosition,viewNormal);
						if(distance>maxDistance) break;
						float op=opacity;
						#ifdef DISTANCE_ATTENUATION
							float ratio=1.-(distance/maxDistance);
							float attenuation=ratio*ratio;
							op=opacity*attenuation;
						#endif
						#ifdef FRESNEL
							float fresnelCoe=(dot(viewIncidentDir,viewReflectDir)+1.)/2.;
							op*=fresnelCoe;
						#endif
						vec4 reflectColor=texture2D(tDiffuse,uv);
						gl_FragColor.xyz=reflectColor.xyz;
						gl_FragColor.a=op;
						break;
					}
				}
			}
		}
	`
	}

	var SSRDepthShader = {
		defines: {
			PERSPECTIVE_CAMERA: 1
		},

		uniforms: {
			tDepth: { value: null },
			cameraNear: { value: null },
			cameraFar: { value: null }
		},

		vertexShader: /* glsl */ `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`,

		fragmentShader: /* glsl */ `

		uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;

		varying vec2 vUv;

		#include <packing>

		float getLinearDepth( const in vec2 uv ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, uv ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, uv ).x;

			#endif

		}

		void main() {

			float depth = getLinearDepth( vUv );
			float d = 1.0 - depth;
			// d=(d-.999)*1000.;
			gl_FragColor = vec4( vec3( d ), 1.0 );

		}

	`
	}

	var SSRBlurShader = {
		uniforms: {
			tDiffuse: { value: null },
			resolution: { value: new Vector2() },
			opacity: { value: 0.5 }
		},

		vertexShader: /* glsl */ `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`,

		fragmentShader: /* glsl */ `

		uniform sampler2D tDiffuse;
		uniform vec2 resolution;
		varying vec2 vUv;
		void main() {
			//reverse engineering from PhotoShop blur filter, then change coefficient

			vec2 texelSize = ( 1.0 / resolution );

			vec4 c=texture2D(tDiffuse,vUv);

			vec2 offset;

			offset=(vec2(-1,0))*texelSize;
			vec4 cl=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(1,0))*texelSize;
			vec4 cr=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,-1))*texelSize;
			vec4 cb=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,1))*texelSize;
			vec4 ct=texture2D(tDiffuse,vUv+offset);

			// float coeCenter=.5;
			// float coeSide=.125;
			float coeCenter=.2;
			float coeSide=.2;
			float a=c.a*coeCenter+cl.a*coeSide+cr.a*coeSide+cb.a*coeSide+ct.a*coeSide;
			vec3 rgb=(c.rgb*c.a*coeCenter+cl.rgb*cl.a*coeSide+cr.rgb*cr.a*coeSide+cb.rgb*cb.a*coeSide+ct.rgb*ct.a*coeSide)/a;
			gl_FragColor=vec4(rgb,a);

		}
	`
	}

	/**
	 * Full-screen textured quad shader
	 */

	var CopyShader = {
		uniforms: {
			tDiffuse: { value: null },
			opacity: { value: 1.0 }
		},

		vertexShader: /* glsl */ `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

		fragmentShader: /* glsl */ `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;

		}`
	}

	class SSRPass extends Pass {
		constructor({ renderer, scene, camera, width, height, selects, encoding, bouncing = false, groundReflector }) {
			super()

			this.width = width !== undefined ? width : 512
			this.height = height !== undefined ? height : 512

			this.clear = true

			this.renderer = renderer
			this.scene = scene
			this.camera = camera
			this.groundReflector = groundReflector

			this.opacity = SSRShader.uniforms.opacity.value
			this.output = 0

			this.maxDistance = SSRShader.uniforms.maxDistance.value
			this.thickness = SSRShader.uniforms.thickness.value

			this.encoding = encoding

			this.tempColor = new Color()

			this._selects = selects
			this.selective = Array.isArray(this._selects)
			Object.defineProperty(this, 'selects', {
				get () {
					return this._selects
				},
				set (val) {
					if (this._selects === val) return
					this._selects = val
					if (Array.isArray(val)) {
						this.selective = true
						this.ssrMaterial.defines.SELECTIVE = true
						this.ssrMaterial.needsUpdate = true
					} else {
						this.selective = false
						this.ssrMaterial.defines.SELECTIVE = false
						this.ssrMaterial.needsUpdate = true
					}
				}
			})

			this._bouncing = bouncing
			Object.defineProperty(this, 'bouncing', {
				get () {
					return this._bouncing
				},
				set (val) {
					if (this._bouncing === val) return
					this._bouncing = val
					if (val) {
						this.ssrMaterial.uniforms['tDiffuse'].value = this.prevRenderTarget.texture
					} else {
						this.ssrMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture
					}
				}
			})

			this.blur = true

			this._distanceAttenuation = SSRShader.defines.DISTANCE_ATTENUATION
			Object.defineProperty(this, 'distanceAttenuation', {
				get () {
					return this._distanceAttenuation
				},
				set (val) {
					if (this._distanceAttenuation === val) return
					this._distanceAttenuation = val
					this.ssrMaterial.defines.DISTANCE_ATTENUATION = val
					this.ssrMaterial.needsUpdate = true
				}
			})

			this._fresnel = SSRShader.defines.FRESNEL
			Object.defineProperty(this, 'fresnel', {
				get () {
					return this._fresnel
				},
				set (val) {
					if (this._fresnel === val) return
					this._fresnel = val
					this.ssrMaterial.defines.FRESNEL = val
					this.ssrMaterial.needsUpdate = true
				}
			})

			this._infiniteThick = SSRShader.defines.INFINITE_THICK
			Object.defineProperty(this, 'infiniteThick', {
				get () {
					return this._infiniteThick
				},
				set (val) {
					if (this._infiniteThick === val) return
					this._infiniteThick = val
					this.ssrMaterial.defines.INFINITE_THICK = val
					this.ssrMaterial.needsUpdate = true
				}
			})

			// beauty render target with depth buffer

			const depthTexture = new DepthTexture()
			depthTexture.type = UnsignedShortType
			depthTexture.minFilter = NearestFilter
			depthTexture.magFilter = NearestFilter

			this.beautyRenderTarget = new WebGLMultisampleRenderTarget(this.width, this.height, {
				minFilter: NearestFilter,
				magFilter: NearestFilter,
				format: RGBAFormat,
				depthTexture: depthTexture,
				depthBuffer: true
			})

			//for bouncing
			this.prevRenderTarget = new WebGLMultisampleRenderTarget(this.width, this.height, {
				minFilter: NearestFilter,
				magFilter: NearestFilter,
				format: RGBAFormat
			})

			// normal render target

			this.normalRenderTarget = new WebGLMultisampleRenderTarget(this.width, this.height, {
				minFilter: NearestFilter,
				magFilter: NearestFilter,
				format: RGBAFormat,
				type: HalfFloatType
			})

			// metalness render target

			this.metalnessRenderTarget = new WebGLMultisampleRenderTarget(this.width, this.height, {
				minFilter: NearestFilter,
				magFilter: NearestFilter,
				format: RGBAFormat
			})

			// ssr render target

			this.ssrRenderTarget = new WebGLMultisampleRenderTarget(this.width, this.height, {
				minFilter: NearestFilter,
				magFilter: NearestFilter,
				format: RGBAFormat
			})

			this.blurRenderTarget = this.ssrRenderTarget.clone()
			this.blurRenderTarget2 = this.ssrRenderTarget.clone()
			// this.blurRenderTarget3 = this.ssrRenderTarget.clone();

			// ssr material

			if (SSRShader === undefined) {
				console.error('THREE.SSRPass: The pass relies on SSRShader.')
			}

			this.ssrMaterial = new ShaderMaterial({
				defines: Object.assign({}, SSRShader.defines, {
					MAX_STEP: Math.sqrt(this.width * this.width + this.height * this.height)
				}),
				uniforms: UniformsUtils$1.clone(SSRShader.uniforms),
				vertexShader: SSRShader.vertexShader,
				fragmentShader: SSRShader.fragmentShader,
				blending: NoBlending
			})

			this.ssrMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture
			this.ssrMaterial.uniforms['tNormal'].value = this.normalRenderTarget.texture
			this.ssrMaterial.defines.SELECTIVE = this.selective
			this.ssrMaterial.needsUpdate = true
			this.ssrMaterial.uniforms['tMetalness'].value = this.metalnessRenderTarget.texture
			this.ssrMaterial.uniforms['tDepth'].value = this.beautyRenderTarget.depthTexture
			this.ssrMaterial.uniforms['cameraNear'].value = this.camera.near
			this.ssrMaterial.uniforms['cameraFar'].value = this.camera.far
			this.ssrMaterial.uniforms['thickness'].value = this.thickness
			this.ssrMaterial.uniforms['resolution'].value.set(this.width, this.height)
			this.ssrMaterial.uniforms['cameraProjectionMatrix'].value.copy(this.camera.projectionMatrix)
			this.ssrMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse)

			// normal material

			this.normalMaterial = new MeshNormalMaterial()
			this.normalMaterial.blending = NoBlending

			// metalnessOn material

			this.metalnessOnMaterial = new MeshBasicMaterial({
				color: 'white'
			})

			// metalnessOff material

			this.metalnessOffMaterial = new MeshBasicMaterial({
				color: 'black'
			})

			// blur material

			this.blurMaterial = new ShaderMaterial({
				defines: Object.assign({}, SSRBlurShader.defines),
				uniforms: UniformsUtils$1.clone(SSRBlurShader.uniforms),
				vertexShader: SSRBlurShader.vertexShader,
				fragmentShader: SSRBlurShader.fragmentShader
			})
			this.blurMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture
			this.blurMaterial.uniforms['resolution'].value.set(this.width, this.height)

			// blur material 2

			this.blurMaterial2 = new ShaderMaterial({
				defines: Object.assign({}, SSRBlurShader.defines),
				uniforms: UniformsUtils$1.clone(SSRBlurShader.uniforms),
				vertexShader: SSRBlurShader.vertexShader,
				fragmentShader: SSRBlurShader.fragmentShader
			})
			this.blurMaterial2.uniforms['tDiffuse'].value = this.blurRenderTarget.texture
			this.blurMaterial2.uniforms['resolution'].value.set(this.width, this.height)

			// // blur material 3

			// this.blurMaterial3 = new ShaderMaterial({
			//   defines: Object.assign({}, SSRBlurShader.defines),
			//   uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),
			//   vertexShader: SSRBlurShader.vertexShader,
			//   fragmentShader: SSRBlurShader.fragmentShader
			// });
			// this.blurMaterial3.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture;
			// this.blurMaterial3.uniforms['resolution'].value.set(this.width, this.height);

			// material for rendering the depth

			this.depthRenderMaterial = new ShaderMaterial({
				defines: Object.assign({}, SSRDepthShader.defines),
				uniforms: UniformsUtils$1.clone(SSRDepthShader.uniforms),
				vertexShader: SSRDepthShader.vertexShader,
				fragmentShader: SSRDepthShader.fragmentShader,
				blending: NoBlending
			})
			this.depthRenderMaterial.uniforms['tDepth'].value = this.beautyRenderTarget.depthTexture
			this.depthRenderMaterial.uniforms['cameraNear'].value = this.camera.near
			this.depthRenderMaterial.uniforms['cameraFar'].value = this.camera.far

			// material for rendering the content of a render target

			this.copyMaterial = new ShaderMaterial({
				uniforms: UniformsUtils$1.clone(CopyShader.uniforms),
				vertexShader: CopyShader.vertexShader,
				fragmentShader: CopyShader.fragmentShader,
				transparent: true,
				depthTest: false,
				depthWrite: false,
				blendSrc: SrcAlphaFactor,
				blendDst: OneMinusSrcAlphaFactor,
				blendEquation: AddEquation,
				blendSrcAlpha: SrcAlphaFactor,
				blendDstAlpha: OneMinusSrcAlphaFactor,
				blendEquationAlpha: AddEquation
				// premultipliedAlpha:true,
			})

			this.fsQuad = new FullScreenQuad(null)

			this.originalClearColor = new Color()
		}

		dispose () {
			// dispose render targets

			this.beautyRenderTarget.dispose()
			this.prevRenderTarget.dispose()
			this.normalRenderTarget.dispose()
			this.metalnessRenderTarget.dispose()
			this.ssrRenderTarget.dispose()
			this.blurRenderTarget.dispose()
			this.blurRenderTarget2.dispose()
			// this.blurRenderTarget3.dispose();

			// dispose materials

			this.normalMaterial.dispose()
			this.metalnessOnMaterial.dispose()
			this.metalnessOffMaterial.dispose()
			this.blurMaterial.dispose()
			this.blurMaterial2.dispose()
			this.copyMaterial.dispose()
			this.depthRenderMaterial.dispose()

			// dipsose full screen quad

			this.fsQuad.dispose()
		}

		render (renderer, writeBuffer /*, readBuffer, deltaTime, maskActive */) {
			// render beauty and depth

			if (this.encoding) this.beautyRenderTarget.texture.encoding = this.encoding
			renderer.setRenderTarget(this.beautyRenderTarget)
			renderer.clear()
			if (this.groundReflector) {
				this.groundReflector.visible = false
				this.groundReflector.doRender(this.renderer, this.scene, this.camera)
				this.groundReflector.visible = true
			}

			renderer.render(this.scene, this.camera)
			if (this.groundReflector) this.groundReflector.visible = false

			// render normals

			this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0, 0)

			// render metalnesses

			if (this.selective) {
				this.renderMetalness(renderer, this.metalnessOnMaterial, this.metalnessRenderTarget, 0, 0)
			}

			// render SSR

			this.ssrMaterial.uniforms['opacity'].value = this.opacity
			this.ssrMaterial.uniforms['maxDistance'].value = this.maxDistance
			this.ssrMaterial.uniforms['thickness'].value = this.thickness
			this.renderPass(renderer, this.ssrMaterial, this.ssrRenderTarget)

			// render blur

			if (this.blur) {
				this.renderPass(renderer, this.blurMaterial, this.blurRenderTarget)
				this.renderPass(renderer, this.blurMaterial2, this.blurRenderTarget2)
				// this.renderPass(renderer, this.blurMaterial3, this.blurRenderTarget3);
			}

			// output result to screen

			switch (this.output) {
				case SSRPass.OUTPUT.Default:
					if (this.bouncing) {
						this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture
						this.copyMaterial.blending = NoBlending
						this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget)

						if (this.blur) this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture
						else this.copyMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture
						this.copyMaterial.blending = NormalBlending
						this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget)

						this.copyMaterial.uniforms['tDiffuse'].value = this.prevRenderTarget.texture
						this.copyMaterial.blending = NoBlending
						this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer)
					} else {
						this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture
						this.copyMaterial.blending = NoBlending
						this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer)

						if (this.blur) this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture
						else this.copyMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture
						this.copyMaterial.blending = NormalBlending
						this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer)
					}

					break
				case SSRPass.OUTPUT.SSR:
					if (this.blur) this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture
					else this.copyMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture
					this.copyMaterial.blending = NoBlending
					this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer)

					if (this.bouncing) {
						if (this.blur) this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture
						else this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture
						this.copyMaterial.blending = NoBlending
						this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget)

						this.copyMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture
						this.copyMaterial.blending = NormalBlending
						this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget)
					}

					break

				case SSRPass.OUTPUT.Beauty:
					this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture
					this.copyMaterial.blending = NoBlending
					this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer)

					break

				case SSRPass.OUTPUT.Depth:
					this.renderPass(renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer)

					break

				case SSRPass.OUTPUT.Normal:
					this.copyMaterial.uniforms['tDiffuse'].value = this.normalRenderTarget.texture
					this.copyMaterial.blending = NoBlending
					this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer)

					break

				case SSRPass.OUTPUT.Metalness:
					this.copyMaterial.uniforms['tDiffuse'].value = this.metalnessRenderTarget.texture
					this.copyMaterial.blending = NoBlending
					this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer)

					break

				default:
					console.warn('THREE.SSRPass: Unknown output type.')
			}
		}

		renderPass (renderer, passMaterial, renderTarget, clearColor, clearAlpha) {
			// save original state
			this.originalClearColor.copy(renderer.getClearColor(this.tempColor))
			renderer.getClearAlpha(this.tempColor)
			const originalAutoClear = renderer.autoClear

			renderer.setRenderTarget(renderTarget)

			// setup pass state
			renderer.autoClear = false
			if (clearColor !== undefined && clearColor !== null) {
				renderer.setClearColor(clearColor)
				renderer.setClearAlpha(1)
				renderer.clear()
			}

			this.fsQuad.material = passMaterial
			this.fsQuad.render(renderer)

			// restore original state
			renderer.autoClear = originalAutoClear
			renderer.setClearColor(this.originalClearColor)
			renderer.setClearAlpha(1)
		}

		renderOverride (renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
			this.originalClearColor.copy(renderer.getClearColor(this.tempColor))
			renderer.getClearAlpha(this.tempColor)
			const originalAutoClear = renderer.autoClear

			renderer.setRenderTarget(renderTarget)
			renderer.autoClear = false

			clearColor = overrideMaterial.clearColor || clearColor
			clearAlpha = overrideMaterial.clearAlpha || clearAlpha

			if (clearColor !== undefined && clearColor !== null) {
				renderer.setClearColor(clearColor)
				renderer.setClearAlpha(1)
				renderer.clear()
			}

			this.scene.overrideMaterial = overrideMaterial
			renderer.render(this.scene, this.camera)
			this.scene.overrideMaterial = null

			// restore original state

			renderer.autoClear = originalAutoClear
			renderer.setClearColor(this.originalClearColor)
			renderer.setClearAlpha(1)
		}

		renderMetalness (renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
			this.originalClearColor.copy(renderer.getClearColor(this.tempColor))
			renderer.getClearAlpha(this.tempColor)
			const originalAutoClear = renderer.autoClear

			renderer.setRenderTarget(renderTarget)
			renderer.autoClear = false

			clearColor = overrideMaterial.clearColor || clearColor
			clearAlpha = overrideMaterial.clearAlpha || clearAlpha

			if (clearColor !== undefined && clearColor !== null) {
				renderer.setClearColor(clearColor)
				renderer.setClearAlpha(1)
				renderer.clear()
			}

			this.scene.traverseVisible((child) => {
				child._SSRPassBackupMaterial = child.material
				if (this._selects.includes(child)) {
					child.material = this.metalnessOnMaterial
				} else {
					child.material = this.metalnessOffMaterial
				}
			})
			renderer.render(this.scene, this.camera)
			this.scene.traverseVisible((child) => {
				child.material = child._SSRPassBackupMaterial
			})

			// restore original state

			renderer.autoClear = originalAutoClear
			renderer.setClearColor(this.originalClearColor)
			renderer.setClearAlpha(1)
		}

		setSize (width, height) {
			this.width = width
			this.height = height

			this.ssrMaterial.defines.MAX_STEP = Math.sqrt(width * width + height * height)
			this.ssrMaterial.needsUpdate = true
			this.beautyRenderTarget.setSize(width, height)
			this.prevRenderTarget.setSize(width, height)
			this.ssrRenderTarget.setSize(width, height)
			this.normalRenderTarget.setSize(width, height)
			this.metalnessRenderTarget.setSize(width, height)
			this.blurRenderTarget.setSize(width, height)
			this.blurRenderTarget2.setSize(width, height)
			// this.blurRenderTarget3.setSize(width, height);

			this.ssrMaterial.uniforms['resolution'].value.set(width, height)
			this.ssrMaterial.uniforms['cameraProjectionMatrix'].value.copy(this.camera.projectionMatrix)
			this.ssrMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse)

			this.blurMaterial.uniforms['resolution'].value.set(width, height)
			this.blurMaterial2.uniforms['resolution'].value.set(width, height)
		}
	}

	SSRPass.OUTPUT = {
		Default: 0,
		SSR: 1,
		Beauty: 3,
		Depth: 4,
		Normal: 5,
		Metalness: 7
	}

	class Blit {
		material
		mesh
		camera
		renderer
		scene
		constructor(renderer, customFragment) {
			this.material = new ShaderMaterial({
				uniforms: {
					uTexture: { value: null }
				},
				vertexShader: `
                varying vec2 vUv;

                void main() {
                    vUv = uv;
                    gl_Position = vec4(position.xy, 0.0, 1.0);    
                }`,
				fragmentShader: `
                uniform sampler2D uTexture;

                varying vec2 vUv;

                void main() {
                    ${customFragment ? customFragment : 'gl_FragColor = texture2D(uTexture, vUv);'}  
                }`,
				depthTest: false,
				depthWrite: false
			})
			this.mesh = new Mesh(new PlaneGeometry(2, 2), this.material)
			this.camera = new PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000)
			this.renderer = renderer
			this.scene = new Scene()
			this.scene.add(this.mesh)
		}
		blit (textureFrom, renderTargetDest) {
			this.renderer.setRenderTarget(renderTargetDest)
			this.material.uniforms.uTexture.value = textureFrom
			this.renderer.render(this.scene, this.camera)
			this.renderer.setRenderTarget(null)
		}
	}

	class DoubleDepthBufferPass extends Pass {
		camera
		renderer
		scene
		blitProgram
		ping
		pong
		frontFaceRT
		resultBuffer
		frontFaceMaterial
		material
		samples
		constructor(scene, camera, renderer) {
			super()
			// this.mesh = mesh
			this.samples = 6
			this.camera = camera
			this.renderer = renderer
			this.scene = scene
			this.blitProgram = new Blit(this.renderer)
			this.ping = new WebGLRenderTarget(innerWidth, innerHeight, {
				type: FloatType,
				depthBuffer: false,
				stencilBuffer: false
			})
			this.pong = new WebGLRenderTarget(innerWidth, innerHeight, {
				type: FloatType,
				depthBuffer: false,
				stencilBuffer: false
			})
			this.frontFaceRT = new WebGLRenderTarget(innerWidth, innerHeight, {
				type: FloatType
			})
			this.frontFaceMaterial = new ShaderMaterial({
				uniforms: {
					uCameraFarInverse: { value: 1 / this.camera.far }
				},
				vertexShader: `
                varying vec3 vCameraSpacePos;
                varying vec3 vWorldSpaceNormal;

                void main() {
                    vCameraSpacePos = (modelViewMatrix * vec4(position, 1.0)).xyz;
                    vWorldSpaceNormal = normal;

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);    
                }`,
				fragmentShader: `
                uniform float uCameraFarInverse;

                varying vec3 vWorldSpaceNormal;
                varying vec3 vCameraSpacePos;

                void main() {
                    float currentDepth = abs(vCameraSpacePos.z) * uCameraFarInverse;
                    gl_FragColor = vec4(vWorldSpaceNormal, currentDepth);    
                    // gl_FragColor = vec4(1.0);
                }`,
				depthTest: true,
				depthWrite: true,
				side: FrontSide
			})
			this.material = new ShaderMaterial({
				uniforms: {
					uScreenSize: { value: new Vector2(innerWidth, innerHeight) },
					uPrevDepth: { value: this.ping.texture },
					uCameraFarInverse: { value: 1 / this.camera.far },
					uSample: { value: 0 }
				},
				vertexShader: `
                varying vec3 vCameraSpacePos;
                varying vec3 vWorldSpaceNormal;

                void main() {
                    vCameraSpacePos = (modelViewMatrix * vec4(position, 1.0)).xyz;
                    vWorldSpaceNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);    
                }`,
				fragmentShader: `
                uniform sampler2D uPrevDepth;
                uniform float uCameraFarInverse;
                uniform float uSample;
                uniform vec2  uScreenSize;

                varying vec3 vWorldSpaceNormal;
                varying vec3 vCameraSpacePos;

                void main() {

                    vec2 uv = gl_FragCoord.xy / uScreenSize;
                    float prevRegisteredDepth = texture2D(uPrevDepth, uv).w;
                    float currentDepth        = abs(vCameraSpacePos.z) * uCameraFarInverse;

                    if(currentDepth <= prevRegisteredDepth) {
                        discard;
                    }

                    gl_FragColor = vec4(vWorldSpaceNormal, currentDepth);    
                    // gl_FragColor = vec4(1.0);
                }`,
				depthTest: false,
				depthWrite: false,
				side: DoubleSide
			})
		}
		render (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
			// *********** render back face material ***********
			this.renderer.setRenderTarget(this.ping)
			this.renderer.clear()
			this.renderer.setRenderTarget(this.pong)
			this.renderer.clear()
			this.scene.traverse((child) => {
				if (child instanceof Mesh) {
					child.material = this.material
				}
			})
			this.material.uniforms.uCameraFarInverse.value = 1 / this.camera.far
			for (let i = 0; i < this.samples; i++) {
				let p1 = i % 2 === 0 ? this.ping : this.pong
				let p2 = i % 2 === 0 ? this.pong : this.ping
				this.material.uniforms.uPrevDepth.value = p1.texture
				this.material.uniforms.uSample.value = i
				this.material.needsUpdate = true
				this.renderer.autoClear = false
				this.renderer.setRenderTarget(p2)
				this.renderer.render(this.scene, this.camera)
				this.renderer.autoClear = true
				// this will make sure that if all fragments fail the depth test and get discarded, we at least have the fallback texture computed
				this.blitProgram.blit(p2.texture, p1)
			}
			if (this.samples % 2 === 0) {
				this.resultBuffer = this.ping
			}
			else {
				this.resultBuffer = this.pong
			}
			// *********** render back face material ***********
			// *********** render front face material ***********
			this.scene.traverse((child) => {
				if (child instanceof Mesh) {
					child.material = this.frontFaceMaterial
				}
			})
			this.renderer.setRenderTarget(this.frontFaceRT)
			this.renderer.render(this.scene, this.camera)
			// *********** render front face material - END ***********
		}
		getBackFaceTexture () {
			return this.resultBuffer.texture
		}
		getFrontFaceTexture () {
			return this.frontFaceRT.texture
		}
	}

	class SSRSkyBox extends Pass {
		material
		mesh
		camera
		mainCamera
		renderer
		scene
		constructor(texture, camera, renderer, args) {
			super()
			this.material = new ShaderMaterial({
				uniforms: {
					uSkybox: { value: texture },
					uColor: { value: new Color('#333333') }
				},
				vertexShader: `
                varying vec3 vFragPos;

                void main() {
                    vFragPos = position.xyz;                                    //           v 0.0 v  <-- we don't want translations
                    // gl_Position = projectionMatrix * vec4((modelViewMatrix * vec4(position, 0.0)), 1.0);    

                    vec4 viewSpace = vec4(mat3(modelViewMatrix) * position, 0.0);
                    viewSpace.w = 1.0;
                    gl_Position = projectionMatrix * viewSpace;    
                }`,
				fragmentShader: `
                uniform sampler2D uSkybox;
                uniform vec3 uColor;

                varying vec3 vFragPos;

                const float PI = 3.14159265359;

                void main() {

                    vec3 dir = normalize(vFragPos);
                    float v = (asin(dir.y) + PI * 0.5) / (PI); 
                    float u = (atan(dir.x, dir.z) + PI) / (PI * 2.0);

                    vec4 bgColor = texture2D(uSkybox, vec2(u, v));

                    if(bgColor.a > 0.){
                        gl_FragColor = bgColor;
                    }else{
                        gl_FragColor = vec4(pow(uColor, vec3(1. / 2.2)), 1.);

                    }

                }`,
				side: BackSide,
				depthWrite: false
			})
			this.mesh = new Mesh(new BoxGeometry(10, 10, 10), this.material)
			this.camera = new PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 100)
			this.mainCamera = camera
			this.renderer = renderer
			this.scene = new Scene()
			this.scene.add(this.mesh)
		}
		render () {
			// I have to do it this way since camera.quaternion is read only
			var vector = new Vector3(0, 0, -1)
			vector.applyQuaternion(this.mainCamera.quaternion)
			this.camera.lookAt(vector)
			this.renderer.setRenderTarget(null)
			this.renderer.render(this.scene, this.camera)
		}
	}

	class SSRTPass extends Pass {
		material
		camera
		renderer
		scene
		planeMesh
		planeMeshMaterial
		ddbPass
		constructor(scene, ddbPass, camera, renderer) {
			super()
			this.ddbPass = ddbPass
			this.material = new ShaderMaterial({
				uniforms: {
					uSkybox: { value: null },
					uBackFaceBuffer: { value: null },
					uFrontFaceBuffer: { value: null },
					uCameraFarInverse: { value: 1 / camera.far },
					uScreenSizeInv: { value: new Vector2(1 / innerWidth, 1 / innerHeight) },
					uCameraPos: { value: new Vector3(0, 0, 0) },
					uTime: { value: 0 },
					uStep: { value: 0.00011 },
					// uExtintionColor1:  { value: new Vector3(0.25, 0.7,  0.9)  },
					uExtintionColor1: { value: new Vector3(1 - 192 / 255, 1 - 123 / 255, 1 - 25 / 255) },
					uExtintionColor2: { value: new Vector3(0.9, 0.35, 0.25) },
					uExtintionFactor: { value: 5 },
					uExposure: { value: 0 },
					uReflectionFactor: { value: 1 },
					uExtinctionFX1: { value: new Vector4(0, 0, 0, 1) }
				},
				vertexShader: `
                varying vec3 vWorldSpaceFragPos;
                varying vec3 vWorldSpaceNormal;
                // NOTE: we don't need the projViewModel matrix, because vWorldSpaceFragPos is already multiplied by the model matrix
                // I'm repeating this comment 5 times because I've lost 2 hours of my life debugging this thing
                varying mat4 vProjViewMatrix;
                varying mat4 vViewMatrix;

                void main() {
                    // NOTE: the multiplication with modelMatrix is required otherwise viewDir in the fragment shader would be incorrect
                    vWorldSpaceFragPos = (modelMatrix * vec4(position, 1.0)).xyz;
                    vWorldSpaceNormal  = normalize((modelMatrix * vec4(normal, 0.0)).xyz);

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);    
                    vProjViewMatrix = projectionMatrix * viewMatrix;
                    vViewMatrix = viewMatrix;
                }`,
				fragmentShader: `
                uniform sampler2D uSkybox;
                uniform sampler2D uBackFaceBuffer;
                uniform sampler2D uFrontFaceBuffer;

                uniform vec3  uExtintionColor1;
                uniform vec3  uExtintionColor2;
                uniform float uExtintionFactor;
                uniform float uExposure;
                uniform float uReflectionFactor;
                uniform vec4  uExtinctionFX1;

                uniform float uTime;
                uniform float uStep;

                uniform vec3 uCameraPos;
                uniform vec2 uScreenSizeInv;
                uniform float uCameraFarInverse;

                varying vec3 vWorldSpaceFragPos;
                varying vec3 vWorldSpaceNormal;
                varying mat4 vProjViewMatrix;
                varying mat4 vViewMatrix;

                const float PI = 3.14159265359;
                const float e  = 2.7182818284590;

                const float planeSize = 3.0;
                const vec3  planeColor = pow(vec3(202.0 / 255.0, 205.0 / 255.0, 185.0 / 255.0), vec3(3.0));

                float mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
                vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
                vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}

                float noise(vec3 p){
                    vec3 a = floor(p);
                    vec3 d = p - a;
                    d = d * d * (3.0 - 2.0 * d);
                
                    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
                    vec4 k1 = perm(b.xyxy);
                    vec4 k2 = perm(k1.xyxy + b.zzww);
                
                    vec4 c = k2 + a.zzzz;
                    vec4 k3 = perm(c);
                    vec4 k4 = perm(c + 1.0);
                
                    vec4 o1 = fract(k3 * (1.0 / 41.0));
                    vec4 o2 = fract(k4 * (1.0 / 41.0));
                
                    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
                    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);
                
                    return o4.y * d.y + o4.x * (1.0 - d.y);
                }

                vec3 acesFilm(const vec3 x) {
                    const float a = 2.51;
                    const float b = 0.03;
                    const float c = 2.43;
                    const float d = 0.59;
                    const float e = 0.14;
                    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);
                }


                // gets the skybox color from a given view direction
                vec3 getSkyboxColor(vec3 viewDir) {
                    // skybox coordinates
                    vec2 skyboxUV = vec2(
                        (atan(viewDir.x, viewDir.z) + PI) / (PI * 2.0),
                        (asin(viewDir.y) + PI * 0.5) / (PI)
                    );

                    vec3 col = texture2D(uSkybox, skyboxUV).xyz;
                    col = pow(col, vec3(2.2)); 
                    return col;
                }

                bool refract2(vec3 v, vec3 n, float ni_over_nt, inout vec3 refracted) {
                    vec3 uv = normalize(v);
                    float dt = dot(uv, n);
                    float discriminant = 1.0 - ni_over_nt * ni_over_nt * (1.0 - dt*dt);
                    if (discriminant > 0.0) {
                        refracted = ni_over_nt * (v - n * dt) - n * sqrt(discriminant);
                        return true;
                    }
                
                    return false;
                }



                vec3 binarySearchHitPoint(vec3 lastP, vec3 hitP, vec3 rayDir) {
                    
                    for(int i = 0; i < 10; i++) {
                        vec3 midP = (lastP + hitP) * 0.5;

                        // project midP in uv space
                        vec4 projCoord = vProjViewMatrix * vec4(midP, 1.0);
                        projCoord.xyz /= projCoord.w;

                        vec2 midpNDC = projCoord.xy;
                        vec2 midpUV  = midpNDC * 0.5 + 0.5;

                        // get depth at point
                        vec4 backBuffer = texture2D(uBackFaceBuffer, midpUV);
                        float depth = backBuffer.w;

                        float midpDepth = abs((vViewMatrix * vec4(midP, 1.0)).z) * uCameraFarInverse;
                        if(midpDepth > depth) {
                            hitP = midP;
                        } else {
                            lastP = midP;
                        }
                    }

                    return hitP;
                }



                vec3 getRefractedColor(vec3 refractionDir, vec3 hitPoint, float refractionIndex) {
                    // move the hitpoint inside the mesh with epsilon
                    hitPoint += refractionDir * 0.00001;

                    // raymarch!
                    float stepSize = uStep;  
                    float stepMult = 1.5;

                    vec3  lastP = hitPoint;
                    vec3  p = hitPoint;
                    vec3  hitPNormal;
                    float currStepSize = stepSize;
                    float transmissionDistance = 0.0;
                    for(int i = 0; i < 20; i++) {
                        p += currStepSize * refractionDir;

                        // project p in uv space
                        vec4 projCoord = vProjViewMatrix * vec4(p, 1.0);
                        projCoord.xyz /= projCoord.w;

                        vec2 pNDC = projCoord.xy;
                        vec2 pUV  = pNDC * 0.5 + 0.5;

                        // get depth at point
                        vec4 backBuffer = texture2D(uBackFaceBuffer, pUV);
                        float depth = backBuffer.w;
                        vec3 norm   = backBuffer.xyz;

                        // get p depth
                        float pDepth = abs((vViewMatrix * vec4(p,1.0)).z) * uCameraFarInverse;


                        if(pDepth > depth) {

                            vec3 hitp = binarySearchHitPoint(lastP, p, refractionDir);
                            p = hitp;

                            // ************ get the hitpoint normal
                            vec4 projCoord = vProjViewMatrix * vec4(p, 1.0);
                            projCoord.xyz /= projCoord.w;
    
                            vec2 pNDC = projCoord.xy;
                            vec2 pUV  = pNDC * 0.5 + 0.5;
    
                            // get depth at point
                            hitPNormal  = texture2D(uBackFaceBuffer, pUV).xyz;
                            // ************ get the hitpoint normal - END

                            break;
                        }

                        lastP = p;
                        currStepSize *= stepMult;
                    }

                    transmissionDistance = length(hitPoint - p);










                    // ******************** recalc directions 
                    vec3 outward_normal;
                    vec3 reflected = reflect(refractionDir, hitPNormal);
                    float ni_over_nt;
                    vec3 refracted;
                    float reflect_prob;
                    float cosine;
                
                    if (dot(refractionDir, hitPNormal) > 0.0) {
                        outward_normal = -hitPNormal;
                        ni_over_nt = refractionIndex;
                        cosine = refractionIndex * dot(refractionDir, hitPNormal);
                    } else {
                        outward_normal = hitPNormal;
                        ni_over_nt = 1.0 / refractionIndex;
                        cosine = -dot(refractionDir, hitPNormal);
                    }

                
                    if (refract2(refractionDir, outward_normal, ni_over_nt, refracted)) {
                        float r0 = (1.0 - refractionIndex) / (1.0 + refractionIndex);
                        r0 *= r0;
                        reflect_prob = r0 + (1.0 - r0) * pow((1.0 - cosine), 5.0);
                    } else {
                        reflect_prob = 1.0;
                    }
                    // ******************** recalc directions - END


                    // ******************** get colors 
                    vec3 col;
                    vec3 colrefl;
                    vec3 colrefr;
                    if(refracted.y < 0.0) {
                        float t = p.y / abs(refracted.y);
                        vec3 planeHitP = p + refracted * t;
                        if(abs(planeHitP.x) < planeSize && abs(planeHitP.z) < planeSize) {
                            colrefr = planeColor;
                        } else {
                            colrefr = getSkyboxColor(refracted);
                        }
                    } else {
                        colrefr = getSkyboxColor(refracted);
                    }

                    if(reflected.y < 0.0) {
                        float t = p.y / abs(reflected.y);
                        vec3 planeHitP = p + reflected * t;
                        if(abs(planeHitP.x) < planeSize && abs(planeHitP.z) < planeSize) {
                            colrefl = planeColor;
                        } else {
                            colrefl = getSkyboxColor(reflected);
                        }
                    } else {
                        colrefl = getSkyboxColor(reflected);
                    }

                    col = colrefl * (reflect_prob * uReflectionFactor) + colrefr * (1.0 - reflect_prob);
                    // ******************** get colors 




                    vec3 transm = vec3(1.0);
                    const int steps = 15;
                    float step = transmissionDistance / float(steps);
                    // raymarching transmission color
                    for(int i = 0; i < steps; i++) {
                        vec3 np = hitPoint + refractionDir * float(i) * step;

                        float noiseStrength = 0.8;
                        float noiseSpeed    = 1.0;
                        float noiseTimeSpeed = 1.5;

                        vec3 nnp = np;
                        vec3 w = normalize(np - vec3(0.75, 1.5, 0.0));
                        vec3 u = vec3(0.0,0.0,1.0);
                        // vec3 timeOffset = uTime * normalize(np - vec3(0.75, 1.5, 0.0));
                        vec3 timeOffset = cos(uTime) * w + sin(uTime) * u;
                        float colorNoiseX = noise(np * noiseSpeed + timeOffset * noiseTimeSpeed);
                        float colorNoiseY = noise(np * noiseSpeed + timeOffset * noiseTimeSpeed + vec3(15.3278, 125.19879, 0.0));
                        float colorNoiseZ = noise(np * noiseSpeed + timeOffset * noiseTimeSpeed + vec3(2.6008, 78.19879, 543.12993));

                        float targ = length(nnp * 0.8 * uExtinctionFX1.w - vec3(0.75, 1.5, 0.0));
                        float targAperture = 0.25;

                        // wave raymarch
                        if(uExtinctionFX1.z > 0.5) {
                            nnp = np + sin(np.x * 2.5 + uTime * 1.5) * 0.3;
                            targ = nnp.y - 0.85 * uExtinctionFX1.w;    
                        } else {
                            nnp = np + vec3(colorNoiseX, colorNoiseY, colorNoiseZ) * 1.05;
                            vec3 diff = nnp - vec3(3.3, 4.5, 0.0);
                            float angle = (atan(diff.x, diff.y) + PI) / (PI * 2.0);
                            targ = length(diff) + sin(angle * 32.0 * PI + uTime * 1.5) * 0.4;
                            targ *= 0.475;
                            targAperture = 0.5 + colorNoiseX * 0.75;
                        }
                        
                        // what's the color at np?
                        vec3 col1 = uExtintionColor1;
                        vec3 col2 = uExtintionColor2;
                        if(uExtinctionFX1.x > 0.5) {
                            col1 = vec3(colorNoiseX, colorNoiseY, colorNoiseZ) * 0.85;
                        }
                        if(uExtinctionFX1.y > 0.5) {
                            col2 = vec3(colorNoiseX, colorNoiseY, colorNoiseZ) * 0.85;
                        }
                        if(targ < 1.0) {
                            transm *= exp(-step * col2 * uExtintionFactor);
                        } else if (targ > 1.0 && targ < 1.0 + targAperture) {
                            float t = (targ - 1.0) / targAperture;
                            // transm *= exp(-step * col1 * uExtintionFactor * t -step * col2 * uExtintionFactor * (1.0 - t));
                            transm *= exp(-step * (col1 * t + col2 * (1.0 - t)) * uExtintionFactor);
                        } else {
                            transm *= exp(-step * col1 * uExtintionFactor);
                        }
                    }
                    col = col * transm;

                    return col;
                }







                void main() {
                    vec2 screenUV = gl_FragCoord.xy * uScreenSizeInv;

                    vec3 viewDir = normalize(vWorldSpaceFragPos - uCameraPos); 
                    vec3 normal  = vWorldSpaceNormal;
                    float refractionIndex = 1.5;

                    
                    vec3 outward_normal;
                    vec3 reflected = reflect(viewDir, normal);
                    float ni_over_nt;
                    vec3 refracted;
                    float reflect_prob;
                    float cosine;
                
                    if (dot(viewDir, normal) > 0.0) {
                        outward_normal = -normal;
                        ni_over_nt = refractionIndex;
                        cosine = refractionIndex * dot(viewDir, normal);
                    } else {
                        outward_normal = normal;
                        ni_over_nt = 1.0 / refractionIndex;
                        cosine = -dot(viewDir, normal);
                    }

                
                    if (refract2(viewDir, outward_normal, ni_over_nt, refracted)) {
                        float r0 = (1.0 - refractionIndex) / (1.0 + refractionIndex);
                        r0 *= r0;
                        reflect_prob = r0 + (1.0 - r0) * pow((1.0 - cosine), 5.0);
                    } else {
                        reflect_prob = 1.0;
                    }
                



                    vec3 reflectedCol;
                    if(reflected.y < 0.0) {
                        float t = vWorldSpaceFragPos.y / abs(reflected.y);
                        vec3 planeHitP = vWorldSpaceFragPos + reflected * t;
                        if(abs(planeHitP.x) < planeSize && abs(planeHitP.z) < planeSize) {
                            reflectedCol = planeColor;
                        } else {
                            reflectedCol = getSkyboxColor(reflected);
                        }
                    } else {
                        reflectedCol = getSkyboxColor(reflected);
                    }

                    vec3 col = reflectedCol * reflect_prob * uReflectionFactor + getRefractedColor(refracted, vWorldSpaceFragPos, refractionIndex) * (1.0 - reflect_prob);
                    // vec3 col = getRefractedColor(normalize(refracted + vec3(0.0, 0.0, 0.0)), vWorldSpaceFragPos) * (1.0 - reflect_prob) * 0.333 +
                    //     getRefractedColor(normalize(refracted + vec3(0.0, 0.15, 0.0)), vWorldSpaceFragPos) * (1.0 - reflect_prob) * 0.333 +
                    //     getRefractedColor(normalize(refracted + vec3(0.0, 0.35, 0.0)), vWorldSpaceFragPos) * (1.0 - reflect_prob) * 0.333;
                    

                    // col = getRefractedColor(refracted, vWorldSpaceFragPos) * (1.0 - reflect_prob);
                    // vec3 col = getRefractedColor(refracted, vWorldSpaceFragPos);
                    // col = getSkyboxColor(reflected) * reflect_prob * 1.0;

                    // vec3 col = viewDir;
                    // gl_FragColor = vec4(col, 1.0);
                    // return;

                    col *= pow(2.0, uExposure);
                    col = acesFilm(col);
                    col = pow(col, vec3(1.0 / 2.2)); 


                    gl_FragColor = vec4(col, 1.0); 
                    // gl_FragColor = vec4(getSkyboxColor(viewDir), 1.0) * 0.5 + vec4(viewDir * 0.5 + 0.5, 1.0); 
                }`
			})
			this.camera = camera
			this.renderer = renderer
			this.scene = scene
			this.planeMeshMaterial = new ShaderMaterial({
				uniforms: {
					uTexture: { value: null }
				},
				vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);    
                        vUv = uv;
                    }`,
				fragmentShader: `
                    varying vec2 vUv;
                    uniform sampler2D uTexture;

                    float smoothstep2(float t) {
                        return t * t * (3.0 - 2.0 * t);
                    }

                    void main() {
                        vec4 col = texture2D(uTexture, vUv * 1.0 + (1.0 - 1.0) * 0.5);
                        
                            // col.rgb *= vec3(1.3, 1.15, 1.0) * 1.2;
                            col.rgb *= vec3(0.97, 0.95, 0.9) * 1.2;
                            
                            float alpha = 1.0;
                            float d = length(vUv - vec2(0.5));
                            if(d > 0.35) {
                                alpha = 1.0 - smoothstep2( clamp( (d - 0.35) / 0.15, 0.0, 1.0) );
                            }
    
                            gl_FragColor = vec4(col.rgb, alpha);  
                       

                    }`,
				transparent: true
			})
			this.planeMesh = new Mesh(
				// new THREE.PlaneBufferGeometry(60, 60), // original size
				// new THREE.PlaneBufferGeometry(60 * 0.35, 60 * 0.35),
				new PlaneGeometry(20, 20), this.planeMeshMaterial)
			this.planeMesh.name = 'pure'
			this.planeMesh.rotation.x = -Math.PI * 0.5
			this.planeMesh.rotation.z = -Math.PI * 1.0
			this.scene.add(this.planeMesh)
		}
		render (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
			this.material.uniforms.uBackFaceBuffer.value = this.ddbPass.getBackFaceTexture()
			this.material.uniforms.uFrontFaceBuffer.value = this.ddbPass.getFrontFaceTexture()
			this.material.uniforms.uCameraPos.value = this.camera.position.clone()
			this.material.uniforms.uTime.value += deltaTime
			this.renderer.setRenderTarget(null)
			this.renderer.autoClear = false
			this.renderer.render(this.scene, this.camera)
			this.renderer.autoClear = true
			this.renderer.setRenderTarget(null)
		}
	}

	var filterVertexShader = `
varying vec2 vUv;

void main() {

	vUv = uv;

	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

}

`

	var filterFragmentShader = `
uniform sampler2D tDiffuse;
varying vec2 vUv;

uniform float hue;
uniform float saturation;
uniform float vibrance;
uniform float brightness;
uniform float contrast;

#define LUMA vec3(0.2125, 0.7154, 0.0721)

vec3 hueAdjustment(vec3 rgb, float adjustment) {
    const mat3 RGBtoYIQ = mat3(0.299, 0.587, 0.114, 0.595716, -0.274453, -0.321263, 0.211456, -0.522591, 0.311135);
    const mat3 YIQtoRGB = mat3(1.0, 0.9563, 0.6210, 1.0, -0.2721, -0.6474, 1.0, -1.107, 1.7046);

    vec3 yiq = RGBtoYIQ * rgb;

    float _hue = atan(yiq.z, yiq.y) + adjustment;
    float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);

    return YIQtoRGB * vec3(yiq.x, chroma * cos(_hue), chroma * sin(_hue));
}

float luminanceAdjustment( vec3 rgb ) {return dot( rgb, LUMA );}

vec3 saturationAdjustment(vec3 rgb, float adjustment) {
    vec3 intensity = vec3( luminanceAdjustment( rgb ) );
    return mix( intensity, rgb, adjustment );
}

vec3 vibranceAdjustment(vec3 rgb, float adjustment) {
    float average = (rgb.r + rgb.g + rgb.b) / 3.0;

    float mx = max(rgb.r, max(rgb.g, rgb.b));
    float amt = (mx - average) * (-3.0 * adjustment);

    return mix(rgb.rgb, vec3(mx), amt);
}

void main() {
    vec4 inputColor = texture2D( tDiffuse, vUv );

    vec3 outputRGB = hueAdjustment(inputColor.rgb, hue);
    outputRGB = saturationAdjustment(outputRGB, saturation);
    outputRGB = vibranceAdjustment(outputRGB, vibrance);

    outputRGB = vec3(outputRGB.r * contrast + brightness,outputRGB.g * contrast + brightness,outputRGB.b * contrast + brightness);

    gl_FragColor = vec4(outputRGB, inputColor.a);
}
`

	class FilterPass extends Pass {
		fsQuad
		filterMaterial
		opts
		hue
		saturation
		vibrance
		brightness
		contrast
		constructor(opts) {
			super()
			this.opts = Object.assign({
				hue: 0,
				saturation: 1,
				vibrance: 0,
				brightness: 0,
				contrast: 1
			}, opts)
			this.hue = this.opts.hue !== undefined ? this.opts.hue : 0
			this.saturation = this.opts.saturation !== undefined ? this.opts.saturation : 1
			this.vibrance = this.opts.vibrance !== undefined ? this.opts.vibrance : 0
			this.brightness = this.opts.brightness !== undefined ? this.opts.brightness : 0
			this.contrast = this.opts.contrast !== undefined ? this.opts.contrast : 1
			this.fsQuad = new FullScreenQuad()
			this.filterMaterial = new ShaderMaterial({
				uniforms: {
					tDiffuse: { value: null },
					hue: { value: this.hue },
					saturation: { value: this.saturation },
					vibrance: { value: this.vibrance },
					brightness: { value: this.brightness },
					contrast: { value: this.contrast }
				},
				vertexShader: filterVertexShader,
				fragmentShader: filterFragmentShader
			})
		}
		render (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
			this.filterMaterial.uniforms.tDiffuse.value = readBuffer.texture
			renderer.setRenderTarget(writeBuffer)
			// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
			if (this.clear)
				renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil)
			this.fsQuad.material = this.filterMaterial
			this.fsQuad.render(renderer)
		}
	}

	const SKY_RENDER_ORDER = 1
	const MODEL_RENDER_ORDER = 2
	const ICON_RENDER_ORDER = 101
	const TEXT_RENDER_ORDER = 102

	class Panel {
		min
		max
		PR
		WIDTH
		HEIGHT
		TEXT_X
		TEXT_Y
		GRAPH_X
		GRAPH_Y
		GRAPH_WIDTH
		GRAPH_HEIGHT
		canvas
		context
		name
		fg
		bg
		round
		constructor(name, fg, bg) {
			this.name = name
			this.fg = fg
			this.bg = bg
			this.min = Infinity
			this.max = 0
			this.round = Math.round
			// this.PR = this.round(window.devicePixelRatio || 1)
			this.PR = 1
			this.WIDTH = 80 * this.PR
			this.HEIGHT = 48 * this.PR
			this.TEXT_X = 3 * this.PR
			this.TEXT_Y = 2 * this.PR
			this.GRAPH_X = 3 * this.PR
			this.GRAPH_Y = 15 * this.PR
			this.GRAPH_WIDTH = 74 * this.PR
			this.GRAPH_HEIGHT = 30 * this.PR
			this.canvas = document.createElement('canvas')
			// this.canvas.width = this.WIDTH
			// this.canvas.height = this.HEIGHT
			// this.canvas.style.cssText = 'width:80px;height:48px'
			this.canvas.width = 80
			this.canvas.height = 48
			this.canvas.style.width = '80px'
			this.canvas.style.height = '48px'
			this.context = this.canvas.getContext('2d')
			this.context.font = 'bold ' + 9 * this.PR + 'px Helvetica,Arial,sans-serif'
			this.context.textBaseline = 'top'
			this.context.fillStyle = bg
			this.context.fillRect(0, 0, this.WIDTH, this.HEIGHT)
			this.context.fillStyle = fg
			this.context.fillText(name, this.TEXT_X, this.TEXT_Y)
			this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT)
			this.context.fillStyle = bg
			this.context.globalAlpha = 0.9
			this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT)
		}
		update (value, maxValue) {
			this.min = Math.min(this.min, value)
			this.max = Math.max(this.max, value)
			this.context.fillStyle = this.bg
			this.context.globalAlpha = 1
			this.context.fillRect(0, 0, this.WIDTH, this.GRAPH_Y)
			this.context.fillStyle = this.fg
			this.context.fillText(this.round(value) + ' ' + name + ' (' + this.round(this.min) + '-' + this.round(this.max) + ')', this.TEXT_X, this.TEXT_Y)
			this.context.drawImage(this.canvas, this.GRAPH_X + this.PR, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT, this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT)
			this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, this.GRAPH_HEIGHT)
			this.context.fillStyle = this.bg
			this.context.globalAlpha = 0.9
			this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, this.round((1 - value / maxValue) * this.GRAPH_HEIGHT))
		}
	}
	class Stats {
		REVISION
		mode
		container
		beginTime
		prevTime
		frames
		fpsPanel
		msPanel
		memPanel
		constructor() {
			this.mode = 0
			this.container = document.createElement('div')
			this.container.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000'
			this.container.addEventListener('click', (event) => {
				event.preventDefault()
				this.showPanel(++this.mode % this.container.children.length)
			}, false)
			this.beginTime = (performance || Date).now()
			this.prevTime = this.beginTime
			this.frames = 0
			this.fpsPanel = this.addPanel(new Panel('FPS', '#0ff', '#002'))
			this.msPanel = this.addPanel(new Panel('MS', '#0f0', '#020'))
			if (self.performance && self.performance.memory) {
				this.memPanel = this.addPanel(new Panel('MB', '#f08', '#201'))
			}
			this.showPanel(0)
		}
		addPanel (panel) {
			this.container.appendChild(panel.canvas)
			return panel
		}
		showPanel (id) {
			for (var i = 0; i < this.container.children.length; i++) {
				this.container.children[i].style.display = i === id ? 'block' : 'none'
			}
			this.mode = id
		}
		begin () {
			this.beginTime = (performance || Date).now()
		}
		end () {
			this.frames++
			var time = (performance || Date).now()
			this.msPanel.update(time - this.beginTime, 200)
			if (time >= this.prevTime + 1000) {
				this.fpsPanel.update((this.frames * 1000) / (time - this.prevTime), 100)
				this.prevTime = time
				this.frames = 0
				if (this.memPanel) {
					var memory = performance.memory
					this.memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576)
				}
			}
			return time
		}
		update () {
			this.beginTime = this.end()
		}
	}

	class OutlinePass extends Pass$1 {
		renderScene
		renderCamera
		selectedObjects
		visibleEdgeColor
		hiddenEdgeColor
		edgeGlow
		usePatternTexture
		edgeThickness
		edgeStrength
		downSampleRatio
		pulsePeriod
		_visibilityCache
		resolution
		maskBufferMaterial
		renderTargetMaskBuffer
		depthMaterial
		prepareMaskMaterial
		renderTargetDepthBuffer
		renderTargetMaskDownSampleBuffer
		renderTargetBlurBuffer1
		renderTargetBlurBuffer2
		edgeDetectionMaterial
		renderTargetEdgeBuffer1
		renderTargetEdgeBuffer2
		separableBlurMaterial1
		separableBlurMaterial2
		// Overlay material
		overlayMaterial
		copyUniforms
		materialCopy
		enabled
		needsSwap
		_oldClearColor
		oldClearAlpha
		fsQuad
		tempPulseColor1
		tempPulseColor2
		textureMatrix
		BlurDirectionX
		BlurDirectionY
		constructor(resolution, scene, camera, selectedObjects, msaa) {
			super()
			this.BlurDirectionX = new Vector2(1.0, 0.0)
			this.BlurDirectionY = new Vector2(0.0, 1.0)
			this.renderScene = scene
			this.renderCamera = camera
			this.selectedObjects = selectedObjects !== undefined ? selectedObjects : []
			this.visibleEdgeColor = new Color(1, 1, 1)
			this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02)
			this.edgeGlow = 0.0
			this.usePatternTexture = false
			this.edgeThickness = 1.0
			this.edgeStrength = 3.0
			this.downSampleRatio = 2
			this.pulsePeriod = 0
			this._visibilityCache = new Map()
			this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256)
			const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat }
			const resx = Math.round(this.resolution.x / this.downSampleRatio)
			const resy = Math.round(this.resolution.y / this.downSampleRatio)
			this.maskBufferMaterial = new MeshBasicMaterial({ color: 0xffffff })
			this.maskBufferMaterial.side = DoubleSide
			this.renderTargetMaskBuffer = msaa ? new WebGLMultisampleRenderTarget(this.resolution.x, this.resolution.y, pars) : new WebGLRenderTarget(this.resolution.x, this.resolution.y, pars)
			this.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask'
			this.renderTargetMaskBuffer.texture.generateMipmaps = false
			this.depthMaterial = new MeshDepthMaterial()
			this.depthMaterial.side = DoubleSide
			this.depthMaterial.depthPacking = RGBADepthPacking
			this.depthMaterial.blending = NoBlending
			this.prepareMaskMaterial = this.getPrepareMaskMaterial()
			this.prepareMaskMaterial.side = DoubleSide
			this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(this.prepareMaskMaterial.fragmentShader, this.renderCamera)
			this.renderTargetDepthBuffer = msaa ? new WebGLMultisampleRenderTarget(this.resolution.x, this.resolution.y, pars) : new WebGLRenderTarget(this.resolution.x, this.resolution.y, pars)
			this.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth'
			this.renderTargetDepthBuffer.texture.generateMipmaps = false
			this.renderTargetMaskDownSampleBuffer = msaa ? new WebGLMultisampleRenderTarget(resx, resy, pars) : new WebGLRenderTarget(resx, resy, pars)
			this.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample'
			this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false
			this.renderTargetBlurBuffer1 = msaa ? new WebGLMultisampleRenderTarget(resx, resy, pars) : new WebGLRenderTarget(resx, resy, pars)
			this.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1'
			this.renderTargetBlurBuffer1.texture.generateMipmaps = false
			this.renderTargetBlurBuffer2 = msaa ? new WebGLMultisampleRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars) : new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars)
			this.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2'
			this.renderTargetBlurBuffer2.texture.generateMipmaps = false
			this.edgeDetectionMaterial = this.getEdgeDetectionMaterial()
			this.renderTargetEdgeBuffer1 = msaa ? new WebGLMultisampleRenderTarget(resx, resy, pars) : new WebGLRenderTarget(resx, resy, pars)
			this.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1'
			this.renderTargetEdgeBuffer1.texture.generateMipmaps = false
			this.renderTargetEdgeBuffer2 = msaa ? new WebGLMultisampleRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars) : new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars)
			this.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2'
			this.renderTargetEdgeBuffer2.texture.generateMipmaps = false
			const MAX_EDGE_THICKNESS = 4
			const MAX_EDGE_GLOW = 4
			this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS)
			this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy)
			this.separableBlurMaterial1.uniforms['kernelRadius'].value = 1
			this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW)
			this.separableBlurMaterial2.uniforms['texSize'].value.set(Math.round(resx / 2), Math.round(resy / 2))
			this.separableBlurMaterial2.uniforms['kernelRadius'].value = MAX_EDGE_GLOW
			// Overlay material
			this.overlayMaterial = this.getOverlayMaterial()
			// copy material
			if (CopyShader$1 === undefined)
				console.error('THREE.OutlinePass relies on CopyShader')
			const copyShader = CopyShader$1
			this.copyUniforms = UniformsUtils$1.clone(copyShader.uniforms)
			this.copyUniforms['opacity'].value = 1.0
			this.materialCopy = new ShaderMaterial({
				uniforms: this.copyUniforms,
				vertexShader: copyShader.vertexShader,
				fragmentShader: copyShader.fragmentShader,
				blending: NoBlending,
				depthTest: false,
				depthWrite: false,
				transparent: true
			})
			this.enabled = true
			this.needsSwap = false
			this._oldClearColor = new Color()
			this.oldClearAlpha = 1
			this.fsQuad = new FullScreenQuad$1()
			this.tempPulseColor1 = new Color()
			this.tempPulseColor2 = new Color()
			this.textureMatrix = new Matrix4()
			function replaceDepthToViewZ (string, camera) {
				var type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic'
				return string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ')
			}
		}
		dispose () {
			this.renderTargetMaskBuffer.dispose()
			this.renderTargetDepthBuffer.dispose()
			this.renderTargetMaskDownSampleBuffer.dispose()
			this.renderTargetBlurBuffer1.dispose()
			this.renderTargetBlurBuffer2.dispose()
			this.renderTargetEdgeBuffer1.dispose()
			this.renderTargetEdgeBuffer2.dispose()
		}
		setSize (width, height) {
			this.renderTargetMaskBuffer.setSize(width, height)
			this.renderTargetDepthBuffer.setSize(width, height)
			let resx = Math.round(width / this.downSampleRatio)
			let resy = Math.round(height / this.downSampleRatio)
			this.renderTargetMaskDownSampleBuffer.setSize(resx, resy)
			this.renderTargetBlurBuffer1.setSize(resx, resy)
			this.renderTargetEdgeBuffer1.setSize(resx, resy)
			this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy)
			resx = Math.round(resx / 2)
			resy = Math.round(resy / 2)
			this.renderTargetBlurBuffer2.setSize(resx, resy)
			this.renderTargetEdgeBuffer2.setSize(resx, resy)
			this.separableBlurMaterial2.uniforms['texSize'].value.set(resx, resy)
		}
		changeVisibilityOfSelectedObjects (bVisible) {
			const cache = this._visibilityCache
			function gatherSelectedMeshesCallBack (object) {
				if (object.isMesh) {
					if (bVisible === true) {
						object.visible = cache.get(object)
					}
					else {
						cache.set(object, object.visible)
						object.visible = bVisible
					}
				}
			}
			for (let i = 0; i < this.selectedObjects.length; i++) {
				const selectedObject = this.selectedObjects[i]
				selectedObject.traverse(gatherSelectedMeshesCallBack)
			}
		}
		changeVisibilityOfNonSelectedObjects (bVisible) {
			const cache = this._visibilityCache
			const selectedMeshes = []
			function gatherSelectedMeshesCallBack (object) {
				if (object.isMesh)
					selectedMeshes.push(object)
			}
			for (let i = 0; i < this.selectedObjects.length; i++) {
				const selectedObject = this.selectedObjects[i]
				selectedObject.traverse(gatherSelectedMeshesCallBack)
			}
			function VisibilityChangeCallBack (object) {
				if (object.userData.root == 'TransformControls') {
					if (bVisible === true) {
						object.visible = cache.get(object) // restore
					}
					else {
						cache.set(object, object.visible)
						object.visible = bVisible
					}
				}
				else if (object.isMesh || object.isSprite) {
					// only meshes and sprites are supported by OutlinePass
					let bFound = false
					for (let i = 0; i < selectedMeshes.length; i++) {
						const selectedObjectId = selectedMeshes[i].id
						if (selectedObjectId === object.id) {
							bFound = true
							break
						}
					}
					if (bFound === false) {
						const visibility = object.visible
						if (bVisible === false || cache.get(object) === true) {
							object.visible = bVisible
						}
						cache.set(object, visibility)
					}
				}
				else if (object.isPoints || object.isLine) {
					// the visibilty of points and lines is always set to false in order to
					// not affect the outline computation
					if (bVisible === true) {
						object.visible = cache.get(object) // restore
					}
					else {
						cache.set(object, object.visible)
						object.visible = bVisible
					}
				}
			}
			this.renderScene.traverse(VisibilityChangeCallBack)
		}
		updateTextureMatrix () {
			this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0)
			this.textureMatrix.multiply(this.renderCamera.projectionMatrix)
			this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse)
		}
		render (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
			if (this.selectedObjects.length > 0) {
				renderer.getClearColor(this._oldClearColor)
				this.oldClearAlpha = renderer.getClearAlpha()
				const oldAutoClear = renderer.autoClear
				renderer.autoClear = false
				if (maskActive)
					renderer.state.buffers.stencil.setTest(false)
				renderer.setClearColor(0xffffff, 1)
				// Make selected objects invisible
				this.changeVisibilityOfSelectedObjects(false)
				const currentBackground = this.renderScene.background
				this.renderScene.background = null
				// 1. Draw Non Selected objects in the depth buffer
				this.renderScene.overrideMaterial = this.depthMaterial
				renderer.setRenderTarget(this.renderTargetDepthBuffer)
				renderer.clear()
				renderer.render(this.renderScene, this.renderCamera)
				// Make selected objects visible
				this.changeVisibilityOfSelectedObjects(true)
				this._visibilityCache.clear()
				// Update Texture Matrix for Depth compare
				this.updateTextureMatrix()
				// Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects
				this.changeVisibilityOfNonSelectedObjects(false)
				this.renderScene.overrideMaterial = this.prepareMaskMaterial
				this.prepareMaskMaterial.uniforms['cameraNearFar'].value.set(this.renderCamera.near, this.renderCamera.far)
				this.prepareMaskMaterial.uniforms['depthTexture'].value = this.renderTargetDepthBuffer.texture
				this.prepareMaskMaterial.uniforms['textureMatrix'].value = this.textureMatrix
				renderer.setRenderTarget(this.renderTargetMaskBuffer)
				renderer.clear()
				renderer.render(this.renderScene, this.renderCamera)
				this.renderScene.overrideMaterial = null
				this.changeVisibilityOfNonSelectedObjects(true)
				this._visibilityCache.clear()
				this.renderScene.background = currentBackground
				// 2. Downsample to Half resolution
				this.fsQuad.material = this.materialCopy
				this.copyUniforms['tDiffuse'].value = this.renderTargetMaskBuffer.texture
				renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer)
				renderer.clear()
				this.fsQuad.render(renderer)
				this.tempPulseColor1.copy(this.visibleEdgeColor)
				this.tempPulseColor2.copy(this.hiddenEdgeColor)
				if (this.pulsePeriod > 0) {
					const scalar = (1 + 0.25) / 2 + (Math.cos((performance.now() * 0.01) / this.pulsePeriod) * (1.0 - 0.25)) / 2
					this.tempPulseColor1.multiplyScalar(scalar)
					this.tempPulseColor2.multiplyScalar(scalar)
				}
				// 3. Apply Edge Detection Pass
				this.fsQuad.material = this.edgeDetectionMaterial
				this.edgeDetectionMaterial.uniforms['maskTexture'].value = this.renderTargetMaskDownSampleBuffer.texture
				this.edgeDetectionMaterial.uniforms['texSize'].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height)
				this.edgeDetectionMaterial.uniforms['visibleEdgeColor'].value = this.tempPulseColor1
				this.edgeDetectionMaterial.uniforms['hiddenEdgeColor'].value = this.tempPulseColor2
				renderer.setRenderTarget(this.renderTargetEdgeBuffer1)
				renderer.clear()
				this.fsQuad.render(renderer)
				// 4. Apply Blur on Half res
				this.fsQuad.material = this.separableBlurMaterial1
				this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture
				this.separableBlurMaterial1.uniforms['direction'].value = this.BlurDirectionX
				this.separableBlurMaterial1.uniforms['kernelRadius'].value = this.edgeThickness
				renderer.setRenderTarget(this.renderTargetBlurBuffer1)
				renderer.clear()
				this.fsQuad.render(renderer)
				this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetBlurBuffer1.texture
				this.separableBlurMaterial1.uniforms['direction'].value = this.BlurDirectionY
				renderer.setRenderTarget(this.renderTargetEdgeBuffer1)
				renderer.clear()
				this.fsQuad.render(renderer)
				// Apply Blur on quarter res
				this.fsQuad.material = this.separableBlurMaterial2
				this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture
				this.separableBlurMaterial2.uniforms['direction'].value = this.BlurDirectionX
				renderer.setRenderTarget(this.renderTargetBlurBuffer2)
				renderer.clear()
				this.fsQuad.render(renderer)
				this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetBlurBuffer2.texture
				this.separableBlurMaterial2.uniforms['direction'].value = this.BlurDirectionY
				renderer.setRenderTarget(this.renderTargetEdgeBuffer2)
				renderer.clear()
				this.fsQuad.render(renderer)
				// Blend it additively over the input texture
				this.fsQuad.material = this.overlayMaterial
				this.overlayMaterial.uniforms['maskTexture'].value = this.renderTargetMaskBuffer.texture
				this.overlayMaterial.uniforms['edgeTexture1'].value = this.renderTargetEdgeBuffer1.texture
				this.overlayMaterial.uniforms['edgeTexture2'].value = this.renderTargetEdgeBuffer2.texture
				//   this.overlayMaterial.uniforms['patternTexture'].value = this.patternTexture
				this.overlayMaterial.uniforms['edgeStrength'].value = this.edgeStrength
				this.overlayMaterial.uniforms['edgeGlow'].value = this.edgeGlow
				this.overlayMaterial.uniforms['usePatternTexture'].value = this.usePatternTexture
				if (maskActive)
					renderer.state.buffers.stencil.setTest(true)
				renderer.setRenderTarget(readBuffer)
				this.fsQuad.render(renderer)
				renderer.setClearColor(this._oldClearColor, this.oldClearAlpha)
				renderer.autoClear = oldAutoClear
			}
			if (this.renderToScreen) {
				this.fsQuad.material = this.materialCopy
				this.copyUniforms['tDiffuse'].value = readBuffer.texture
				renderer.setRenderTarget(null)
				this.fsQuad.render(renderer)
			}
		}
		getPrepareMaskMaterial () {
			return new ShaderMaterial({
				uniforms: {
					depthTexture: { value: null },
					cameraNearFar: { value: new Vector2(0.5, 0.5) },
					textureMatrix: { value: null }
				},
				vertexShader: `#include <morphtarget_pars_vertex>
				#include <skinning_pars_vertex>

				varying vec4 projTexCoord;
				varying vec4 vPosition;
				uniform mat4 textureMatrix;

				void main() {

					#include <skinbase_vertex>
					#include <begin_vertex>
					#include <morphtarget_vertex>
					#include <skinning_vertex>
					#include <project_vertex>

					vPosition = mvPosition;
					vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );
					projTexCoord = textureMatrix * worldPosition;

				}`,
				fragmentShader: `#include <packing>
				varying vec4 vPosition;
				varying vec4 projTexCoord;
				uniform sampler2D depthTexture;
				uniform vec2 cameraNearFar;

				void main() {

					float depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));
					float viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );
					float depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;
					gl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);

				}`
			})
		}
		getEdgeDetectionMaterial () {
			return new ShaderMaterial({
				uniforms: {
					maskTexture: { value: null },
					texSize: { value: new Vector2(0.5, 0.5) },
					visibleEdgeColor: { value: new Vector3(1.0, 1.0, 1.0) },
					hiddenEdgeColor: { value: new Vector3(1.0, 1.0, 1.0) }
				},
				vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
				fragmentShader: `varying vec2 vUv;

				uniform sampler2D maskTexture;
				uniform vec2 texSize;
				uniform vec3 visibleEdgeColor;
				uniform vec3 hiddenEdgeColor;

				void main() {
					vec2 invSize = 1.0 / texSize;
					vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);
					vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);
					vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);
					vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);
					vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);
					float diff1 = (c1.r - c2.r)*0.5;
					float diff2 = (c3.r - c4.r)*0.5;
					float d = length( vec2(diff1, diff2) );
					float a1 = min(c1.g, c2.g);
					float a2 = min(c3.g, c4.g);
					float visibilityFactor = min(a1, a2);
					vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;
					gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);
				}`
			})
		}
		getSeperableBlurMaterial (maxRadius) {
			return new ShaderMaterial({
				defines: {
					MAX_RADIUS: maxRadius
				},
				uniforms: {
					colorTexture: { value: null },
					texSize: { value: new Vector2(0.5, 0.5) },
					direction: { value: new Vector2(0.5, 0.5) },
					kernelRadius: { value: 1.0 }
				},
				vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
				fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;
				uniform float kernelRadius;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}

				void main() {
					vec2 invSize = 1.0 / texSize;
					float weightSum = gaussianPdf(0.0, kernelRadius);
					vec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;
					vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);
					vec2 uvOffset = delta;
					for( int i = 1; i <= MAX_RADIUS; i ++ ) {
						float w = gaussianPdf(uvOffset.x, kernelRadius);
						vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);
						vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);
						diffuseSum += ((sample1 + sample2) * w);
						weightSum += (2.0 * w);
						uvOffset += delta;
					}
					gl_FragColor = diffuseSum/weightSum;
				}`
			})
		}
		getOverlayMaterial () {
			return new ShaderMaterial({
				uniforms: {
					maskTexture: { value: null },
					edgeTexture1: { value: null },
					edgeTexture2: { value: null },
					patternTexture: { value: null },
					edgeStrength: { value: 1.0 },
					edgeGlow: { value: 1.0 },
					usePatternTexture: { value: 0.0 }
				},
				vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
				fragmentShader: `varying vec2 vUv;

				uniform sampler2D maskTexture;
				uniform sampler2D edgeTexture1;
				uniform sampler2D edgeTexture2;
				uniform sampler2D patternTexture;
				uniform float edgeStrength;
				uniform float edgeGlow;
				uniform bool usePatternTexture;

				void main() {
					vec4 edgeValue1 = texture2D(edgeTexture1, vUv);
					vec4 edgeValue2 = texture2D(edgeTexture2, vUv);
					vec4 maskColor = texture2D(maskTexture, vUv);
					vec4 patternColor = texture2D(patternTexture, 6.0 * vUv);
					float visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;
					vec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;
					vec4 finalColor = edgeStrength * maskColor.r * edgeValue;
					if(usePatternTexture)
						finalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);
					gl_FragColor = finalColor;
				}`,
				blending: AdditiveBlending,
				depthTest: false,
				depthWrite: false,
				transparent: true
			})
		}
	}

	var gammaFragmentShader = `
uniform sampler2D tDiffuse;
varying vec2 vUv;
uniform float factor;

vec4 gamma(vec4 color, float g)
{
    vec3 rgb = color.rgb;
    vec3 opColor = pow(rgb, vec3(g));
    return vec4(opColor, color.a);
}

void main() {
    vec4 tex = texture2D( tDiffuse, vUv );
    gl_FragColor = gamma(tex , 1.0 / factor);
}
`

	var gammaVertexShader = `
varying vec2 vUv;

void main() {

	vUv = uv;

	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

}

`

	class CSS2DObject$1 extends Object3D {
		element
		isCSS2DObject
		constructor(element) {
			super()
			this.isCSS2DObject = true
			this.element = element || document.createElement('div')
			this.element.style.position = 'absolute'
			this.element.style.userSelect = 'none'
			this.element.setAttribute('draggable', '0')
			const self = this
			this.addEventListener('removed', function () {
				self.traverse((object) => {
					if (object.element instanceof Element && object.element.parentNode !== null) {
						object.element.parentNode.removeChild(object.element)
					}
				})
			})
		}
		copy (source, recursive) {
			super.copy(source, recursive)
			this.element = source.element.cloneNode(true)
			return this
		}
	}
	//
	const _vector$1 = new Vector3()
	const _viewMatrix = new Matrix4()
	const _viewProjectionMatrix = new Matrix4()
	const _a = new Vector3()
	const _b = new Vector3()
	class CSS2DRenderer {
		domElement
		_width
		_height
		_widthHalf
		_heightHalf
		cache
		constructor() {
			this.cache = {
				objects: new WeakMap()
			}
			const domElement = document.createElement('div')
			domElement.style.overflow = 'hidden'
			this.domElement = domElement
		}
		getSize () {
			return {
				width: this._width,
				height: this._height
			}
		}
		render (scene, camera) {
			if (scene.autoUpdate === true)
				scene.updateMatrixWorld()
			if (camera.parent === null)
				camera.updateMatrixWorld()
			_viewMatrix.copy(camera.matrixWorldInverse)
			_viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix)
			this.renderObject(scene, scene, camera)
			this.zOrder(scene)
		}
		zOrder (scene) {
			const self = this
			const sorted = this.filterAndFlatten(scene).sort((a, b) => {
				const distanceA = self.cache.objects.get(a).distanceToCameraSquared
				const distanceB = self.cache.objects.get(b).distanceToCameraSquared
				return distanceA - distanceB
			})
			const zMax = sorted.length
			for (let i = 0, l = sorted.length; i < l; i++) {
				sorted[i].element.style.zIndex = zMax - i
			}
		}
		filterAndFlatten (scene) {
			const result = []
			scene.traverse((object) => {
				if (object.isCSS2DObject)
					result.push(object)
			})
			return result
		}
		getDistanceToSquared (object1, object2) {
			_a.setFromMatrixPosition(object1.matrixWorld)
			_b.setFromMatrixPosition(object2.matrixWorld)
			return _a.distanceToSquared(_b)
		}
		renderObject (object, scene, camera) {
			if (object.isCSS2DObject) {
				object.onBeforeRender(this, scene, camera)
				_vector$1.setFromMatrixPosition(object.matrixWorld)
				_vector$1.applyMatrix4(_viewProjectionMatrix)
				const element = object.element
				const center = new Vector2(-0.5, -0.5)
				if (object.center)
					center.copy(object.center)
				if (/apple/i.test(navigator.vendor)) {
					// https://github.com/mrdoob/three.js/issues/21415
					element.style.transform =
						'translate(' +
						center.x * 100 +
						'%,' +
						center.y * 100 +
						'%) translate(' +
						Math.round(_vector$1.x * this._widthHalf + this._widthHalf) +
						'px,' +
						Math.round(-_vector$1.y * this._heightHalf + this._heightHalf) +
						'px)'
				}
				else {
					element.style.transform =
						'translate(' + center.x * 100 + '%,' + center.y * 100 + '%) translate(' + (_vector$1.x * this._widthHalf + this._widthHalf) + 'px,' + (-_vector$1.y * this._heightHalf + this._heightHalf) + 'px)'
				}
				element.style.display = object.visible && _vector$1.z >= -1 && _vector$1.z <= 1 ? '' : 'none'
				const objectData = {
					distanceToCameraSquared: this.getDistanceToSquared(camera, object)
				}
				this.cache.objects.set(object, objectData)
				if (element.parentNode !== this.domElement) {
					this.domElement.appendChild(element)
				}
				object.onAfterRender(this, scene, camera)
			}
			for (let i = 0, l = object.children.length; i < l; i++) {
				this.renderObject(object.children[i], scene, camera)
			}
		}
		setSize (width, height) {
			this._width = width
			this._height = height
			this._widthHalf = this._width / 2
			this._heightHalf = this._height / 2
			this.domElement.style.width = width + 'px'
			this.domElement.style.height = height + 'px'
		}
	}

	/**
	 * Based on http://www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs
	 */
	class CSS3DObject$1 extends Object3D {
		element
		isCSS3DObject
		constructor(element) {
			super()
			this.element = element || document.createElement('div')
			this.element.style.position = 'absolute'
			this.element.style.pointerEvents = 'auto'
			this.element.style.userSelect = 'none'
			this.element.setAttribute('draggable', '0')
			this.isCSS3DObject = true
			const self = this
			this.addEventListener('removed', function () {
				self.traverse((object) => {
					if (object.element instanceof Element && object.element.parentNode !== null) {
						object.element.parentNode.removeChild(object.element)
					}
				})
			})
		}
		copy (source, recursive) {
			super.copy(source, recursive)
			this.element = source.element.cloneNode(true)
			return this
		}
	}
	class CSS3DRenderer {
		domElement
		cameraElement
		_matrix
		_matrix2
		_width
		_height
		_widthHalf
		_heightHalf
		cache
		constructor() {
			this.cache = {
				camera: { fov: 0, style: '' },
				objects: new WeakMap()
			}
			this._width = 0
			this._height = 0
			this._widthHalf = 0
			this._heightHalf = 0
			const domElement = document.createElement('div')
			domElement.style.overflow = 'hidden'
			this.domElement = domElement
			const cameraElement = document.createElement('div')
			cameraElement.style.transformStyle = 'preserve-3d'
			cameraElement.style.pointerEvents = 'none'
			this.cameraElement = cameraElement
			this.domElement.appendChild(cameraElement)
			this._matrix = new Matrix4()
			this._matrix2 = new Matrix4()
		}
		getSize () {
			return {
				width: this._width,
				height: this._height
			}
		}
		render (scene, camera) {
			const fov = camera.projectionMatrix.elements[5] * this._heightHalf
			if (this.cache.camera.fov !== fov) {
				this.domElement.style.perspective = camera.isPerspectiveCamera ? fov + 'px' : ''
				this.cache.camera.fov = fov
			}
			if (scene.autoUpdate === true)
				scene.updateMatrixWorld()
			if (camera.parent === null)
				camera.updateMatrixWorld()
			let tx, ty
			if (camera.isOrthographicCamera) {
				tx = -(camera.right + camera.left) / 2
				ty = (camera.top + camera.bottom) / 2
			}
			const cameraCSSMatrix = camera.isOrthographicCamera
				? 'scale(' + fov + ')' + 'translate(' + this.epsilon(tx) + 'px,' + this.epsilon(ty) + 'px)' + this.getCameraCSSMatrix(camera.matrixWorldInverse)
				: 'translateZ(' + fov + 'px)' + this.getCameraCSSMatrix(camera.matrixWorldInverse)
			const style = cameraCSSMatrix + 'translate(' + this._widthHalf + 'px,' + this._heightHalf + 'px)'
			if (this.cache.camera.style !== style) {
				this.cameraElement.style.transform = style
				this.cache.camera.style = style
			}
			this.renderObject(scene, scene, camera, cameraCSSMatrix)
		}
		setSize (width, height) {
			this._width = width
			this._height = height
			this._widthHalf = this._width / 2
			this._heightHalf = this._height / 2
			this.domElement.style.width = width + 'px'
			this.domElement.style.height = height + 'px'
			this.cameraElement.style.width = width + 'px'
			this.cameraElement.style.height = height + 'px'
		}
		epsilon (value) {
			return Math.abs(value) < 1e-10 ? 0 : value
		}
		getCameraCSSMatrix (matrix) {
			const elements = matrix.elements
			return ('matrix3d(' +
				this.epsilon(elements[0]) +
				',' +
				this.epsilon(-elements[1]) +
				',' +
				this.epsilon(elements[2]) +
				',' +
				this.epsilon(elements[3]) +
				',' +
				this.epsilon(elements[4]) +
				',' +
				this.epsilon(-elements[5]) +
				',' +
				this.epsilon(elements[6]) +
				',' +
				this.epsilon(elements[7]) +
				',' +
				this.epsilon(elements[8]) +
				',' +
				this.epsilon(-elements[9]) +
				',' +
				this.epsilon(elements[10]) +
				',' +
				this.epsilon(elements[11]) +
				',' +
				this.epsilon(elements[12]) +
				',' +
				this.epsilon(-elements[13]) +
				',' +
				this.epsilon(elements[14]) +
				',' +
				this.epsilon(elements[15]) +
				')')
		}
		getObjectCSSMatrix (matrix) {
			const elements = matrix.elements
			const matrix3d = 'matrix3d(' +
				this.epsilon(elements[0]) +
				',' +
				this.epsilon(elements[1]) +
				',' +
				this.epsilon(elements[2]) +
				',' +
				this.epsilon(elements[3]) +
				',' +
				this.epsilon(-elements[4]) +
				',' +
				this.epsilon(-elements[5]) +
				',' +
				this.epsilon(-elements[6]) +
				',' +
				this.epsilon(-elements[7]) +
				',' +
				this.epsilon(elements[8]) +
				',' +
				this.epsilon(elements[9]) +
				',' +
				this.epsilon(elements[10]) +
				',' +
				this.epsilon(elements[11]) +
				',' +
				this.epsilon(elements[12]) +
				',' +
				this.epsilon(elements[13]) +
				',' +
				this.epsilon(elements[14]) +
				',' +
				this.epsilon(elements[15]) +
				')'
			return 'translate(-50%,-50%)' + matrix3d
		}
		renderObject (object, scene, camera, cameraCSSMatrix) {
			if (object.isCSS3DObject) {
				object.onBeforeRender(this, scene, camera)
				let style
				if (object.isCSS3DSprite) {
					// http://swiftcoder.wordpress.com/2008/11/25/constructing-a-billboard-matrix/
					this._matrix.copy(camera.matrixWorldInverse)
					this._matrix.transpose()
					if (object.rotation2D !== 0)
						this._matrix.multiply(this._matrix2.makeRotationZ(object.rotation2D))
					this._matrix.copyPosition(object.matrixWorld)
					this._matrix.scale(object.scale)
					this._matrix.elements[3] = 0
					this._matrix.elements[7] = 0
					this._matrix.elements[11] = 0
					this._matrix.elements[15] = 1
					style = this.getObjectCSSMatrix(this._matrix)
				}
				else {
					style = this.getObjectCSSMatrix(object.matrixWorld)
				}
				const element = object.element
				const cachedObject = this.cache.objects.get(object)
				if (cachedObject === undefined || cachedObject.style !== style) {
					element.style.transform = style
					const objectData = { style: style }
					this.cache.objects.set(object, objectData)
				}
				element.style.display = object.visible ? '' : 'none'
				if (element.parentNode !== this.cameraElement) {
					this.cameraElement.appendChild(element)
				}
				object.onAfterRender(this, scene, camera)
			}
			for (let i = 0, l = object.children.length; i < l; i++) {
				this.renderObject(object.children[i], scene, camera, cameraCSSMatrix)
			}
		}
	}

	const css1 = `.spinner {
    width: 60px;
    height: 60px;
    background-color: #fff;
  
    margin: 100px auto;
    -webkit-animation: sk-rotateplane 1.2s infinite ease-in-out;
    animation: sk-rotateplane 1.2s infinite ease-in-out;
  }
  
  @-webkit-keyframes sk-rotateplane {
    0% { -webkit-transform: perspective(120px) }
    50% { -webkit-transform: perspective(120px) rotateY(180deg) }
    100% { -webkit-transform: perspective(120px) rotateY(180deg)  rotateX(180deg) }
  }
  
  @keyframes sk-rotateplane {
    0% { 
      transform: perspective(120px) rotateX(0deg) rotateY(0deg);
      -webkit-transform: perspective(120px) rotateX(0deg) rotateY(0deg) 
    } 50% { 
      transform: perspective(120px) rotateX(-180.1deg) rotateY(0deg);
      -webkit-transform: perspective(120px) rotateX(-180.1deg) rotateY(0deg) 
    } 100% { 
      transform: perspective(120px) rotateX(-180deg) rotateY(-179.9deg);
      -webkit-transform: perspective(120px) rotateX(-180deg) rotateY(-179.9deg);
    }
  }`
	const css2 = `.sk-chase {
    width: 60px;
    height: 60px;
    position: relative;
    animation: sk-chase 2.5s infinite linear both;
  }
  
  .sk-chase-dot {
    width: 100%;
    height: 100%;
    position: absolute;
    left: 0;
    top: 0; 
    animation: sk-chase-dot 2.0s infinite ease-in-out both; 
  }
  
  .sk-chase-dot:before {
    content: '';
    display: block;
    width: 25%;
    height: 25%;
    background-color: #fff;
    border-radius: 100%;
    animation: sk-chase-dot-before 2.0s infinite ease-in-out both; 
  }
  
  .sk-chase-dot:nth-child(1) { animation-delay: -1.1s; }
  .sk-chase-dot:nth-child(2) { animation-delay: -1.0s; }
  .sk-chase-dot:nth-child(3) { animation-delay: -0.9s; }
  .sk-chase-dot:nth-child(4) { animation-delay: -0.8s; }
  .sk-chase-dot:nth-child(5) { animation-delay: -0.7s; }
  .sk-chase-dot:nth-child(6) { animation-delay: -0.6s; }
  .sk-chase-dot:nth-child(1):before { animation-delay: -1.1s; }
  .sk-chase-dot:nth-child(2):before { animation-delay: -1.0s; }
  .sk-chase-dot:nth-child(3):before { animation-delay: -0.9s; }
  .sk-chase-dot:nth-child(4):before { animation-delay: -0.8s; }
  .sk-chase-dot:nth-child(5):before { animation-delay: -0.7s; }
  .sk-chase-dot:nth-child(6):before { animation-delay: -0.6s; }
  
  @keyframes sk-chase {
    100% { transform: rotate(360deg); } 
  }
  
  @keyframes sk-chase-dot {
    80%, 100% { transform: rotate(360deg); } 
  }
  
  @keyframes sk-chase-dot-before {
    50% {
      transform: scale(0.4); 
    } 100%, 0% {
      transform: scale(1.0); 
    } 
  }`
	const css3 = `.spinner {
    width: 60px;
    height: 60px;
  
    position: relative;
    margin: 100px auto;
  }
  
  .double-bounce1, .double-bounce2 {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: #fff;
    opacity: 0.6;
    position: absolute;
    top: 0;
    left: 0;
    
    -webkit-animation: sk-bounce 2.0s infinite ease-in-out;
    animation: sk-bounce 2.0s infinite ease-in-out;
  }
  
  .double-bounce2 {
    -webkit-animation-delay: -1.0s;
    animation-delay: -1.0s;
  }
  
  @-webkit-keyframes sk-bounce {
    0%, 100% { -webkit-transform: scale(0.0) }
    50% { -webkit-transform: scale(1.0) }
  }
  
  @keyframes sk-bounce {
    0%, 100% { 
      transform: scale(0.0);
      -webkit-transform: scale(0.0);
    } 50% { 
      transform: scale(1.0);
      -webkit-transform: scale(1.0);
    }
  }`
	const css4 = `.spinner {
    margin: 100px auto;
    width: 60px;
    height: 60px;
    text-align: center;
    font-size: 10px;
  }
  
  .spinner > div {
    background-color: #fff;
    height: 100%;
    display: inline-block;
    width: 7px;
    margin: 0 3px 0 0;
    
    -webkit-animation: sk-stretchdelay 1.2s infinite ease-in-out;
    animation: sk-stretchdelay 1.2s infinite ease-in-out;
  }
  
  .spinner .rect2 {
    -webkit-animation-delay: -1.1s;
    animation-delay: -1.1s;
  }
  
  .spinner .rect3 {
    -webkit-animation-delay: -1.0s;
    animation-delay: -1.0s;
  }
  
  .spinner .rect4 {
    -webkit-animation-delay: -0.9s;
    animation-delay: -0.9s;
  }
  
  .spinner .rect5 {
    -webkit-animation-delay: -0.8s;
    animation-delay: -0.8s;
  }
  
  @-webkit-keyframes sk-stretchdelay {
    0%, 40%, 100% { -webkit-transform: scaleY(0.4) }  
    20% { -webkit-transform: scaleY(1.0) }
  }
  
  @keyframes sk-stretchdelay {
    0%, 40%, 100% { 
      transform: scaleY(0.4);
      -webkit-transform: scaleY(0.4);
    }  20% { 
      transform: scaleY(1.0);
      -webkit-transform: scaleY(1.0);
    }
  }`
	const css5 = `.spinner {
    margin: 100px auto;
    width: 60px;
    height: 60px;
    position: relative;
  }
  
  .cube1, .cube2 {
    background-color: #fff;
    width: 15px;
    height: 15px;
    position: absolute;
    top: 0;
    left: 0;
    
    -webkit-animation: sk-cubemove 1.8s infinite ease-in-out;
    animation: sk-cubemove 1.8s infinite ease-in-out;
  }
  
  .cube2 {
    -webkit-animation-delay: -0.9s;
    animation-delay: -0.9s;
  }
  
  @-webkit-keyframes sk-cubemove {
    25% { -webkit-transform: translateX(42px) rotate(-90deg) scale(0.5) }
    50% { -webkit-transform: translateX(42px) translateY(42px) rotate(-180deg) }
    75% { -webkit-transform: translateX(0px) translateY(42px) rotate(-270deg) scale(0.5) }
    100% { -webkit-transform: rotate(-360deg) }
  }
  
  @keyframes sk-cubemove {
    25% { 
      transform: translateX(42px) rotate(-90deg) scale(0.5);
      -webkit-transform: translateX(42px) rotate(-90deg) scale(0.5);
    } 50% { 
      transform: translateX(42px) translateY(42px) rotate(-179deg);
      -webkit-transform: translateX(42px) translateY(42px) rotate(-179deg);
    } 50.1% { 
      transform: translateX(42px) translateY(42px) rotate(-180deg);
      -webkit-transform: translateX(42px) translateY(42px) rotate(-180deg);
    } 75% { 
      transform: translateX(0px) translateY(42px) rotate(-270deg) scale(0.5);
      -webkit-transform: translateX(0px) translateY(42px) rotate(-270deg) scale(0.5);
    } 100% { 
      transform: rotate(-360deg);
      -webkit-transform: rotate(-360deg);
    }
  }`
	const css6 = `.spinner {
    width: 60px;
    height: 60px;
    margin: 100px auto;
    background-color: #fff;
  
    border-radius: 100%;  
    -webkit-animation: sk-scaleout 1.0s infinite ease-in-out;
    animation: sk-scaleout 1.0s infinite ease-in-out;
  }
  
  @-webkit-keyframes sk-scaleout {
    0% { -webkit-transform: scale(0) }
    100% {
      -webkit-transform: scale(1.0);
      opacity: 0;
    }
  }
  
  @keyframes sk-scaleout {
    0% { 
      -webkit-transform: scale(0);
      transform: scale(0);
    } 100% {
      -webkit-transform: scale(1.0);
      transform: scale(1.0);
      opacity: 0;
    }
  }`
	const css7 = `.spinner {
    margin: 100px auto;
    width: 60px;
    height: 60px;
    position: relative;
    text-align: center;
    
    -webkit-animation: sk-rotate 2.0s infinite linear;
    animation: sk-rotate 2.0s infinite linear;
  }
  
  .dot1, .dot2 {
    width: 60%;
    height: 60%;
    display: inline-block;
    position: absolute;
    top: 0;
    background-color: #fff;
    border-radius: 100%;
    
    -webkit-animation: sk-bounce 2.0s infinite ease-in-out;
    animation: sk-bounce 2.0s infinite ease-in-out;
  }
  
  .dot2 {
    top: auto;
    bottom: 0;
    -webkit-animation-delay: -1.0s;
    animation-delay: -1.0s;
  }
  
  @-webkit-keyframes sk-rotate { 100% { -webkit-transform: rotate(360deg) }}
  @keyframes sk-rotate { 100% { transform: rotate(360deg); -webkit-transform: rotate(360deg) }}
  
  @-webkit-keyframes sk-bounce {
    0%, 100% { -webkit-transform: scale(0.0) }
    50% { -webkit-transform: scale(1.0) }
  }
  
  @keyframes sk-bounce {
    0%, 100% { 
      transform: scale(0.0);
      -webkit-transform: scale(0.0);
    } 50% { 
      transform: scale(1.0);
      -webkit-transform: scale(1.0);
    }
  }`
	const css8 = `.spinner {
    margin: 0;
    width: 70px;
    text-align: center;
  }
  
  .spinner > div {
    width: 18px;
    height: 18px;
    background-color: #fff;
    margin: 0 4px 0 0;
  
    border-radius: 100%;
    display: inline-block;
    -webkit-animation: sk-bouncedelay 1.4s infinite ease-in-out both;
    animation: sk-bouncedelay 1.4s infinite ease-in-out both;
  }
  
  .spinner .bounce1 {
    -webkit-animation-delay: -0.32s;
    animation-delay: -0.32s;
  }
  
  .spinner .bounce2 {
    -webkit-animation-delay: -0.16s;
    animation-delay: -0.16s;
  }
  
  @-webkit-keyframes sk-bouncedelay {
    0%, 80%, 100% { -webkit-transform: scale(0) }
    40% { -webkit-transform: scale(1.0) }
  }
  
  @keyframes sk-bouncedelay {
    0%, 80%, 100% { 
      -webkit-transform: scale(0);
      transform: scale(0);
    } 40% { 
      -webkit-transform: scale(1.0);
      transform: scale(1.0);
    }
  }`
	const css9 = `.sk-circle {
    margin: 100px auto;
    width: 60px;
    height: 60px;
    position: relative;
  }
  .sk-circle .sk-child {
    width: 100%;
    height: 100%;
    position: absolute;
    left: 0;
    top: 0;
  }
  .sk-circle .sk-child:before {
    content: '';
    display: block;
    margin: 0 auto;
    width: 15%;
    height: 15%;
    background-color: #fff;
    border-radius: 100%;
    -webkit-animation: sk-circleBounceDelay 1.2s infinite ease-in-out both;
            animation: sk-circleBounceDelay 1.2s infinite ease-in-out both;
  }
  .sk-circle .sk-circle2 {
    -webkit-transform: rotate(30deg);
        -ms-transform: rotate(30deg);
            transform: rotate(30deg); }
  .sk-circle .sk-circle3 {
    -webkit-transform: rotate(60deg);
        -ms-transform: rotate(60deg);
            transform: rotate(60deg); }
  .sk-circle .sk-circle4 {
    -webkit-transform: rotate(90deg);
        -ms-transform: rotate(90deg);
            transform: rotate(90deg); }
  .sk-circle .sk-circle5 {
    -webkit-transform: rotate(120deg);
        -ms-transform: rotate(120deg);
            transform: rotate(120deg); }
  .sk-circle .sk-circle6 {
    -webkit-transform: rotate(150deg);
        -ms-transform: rotate(150deg);
            transform: rotate(150deg); }
  .sk-circle .sk-circle7 {
    -webkit-transform: rotate(180deg);
        -ms-transform: rotate(180deg);
            transform: rotate(180deg); }
  .sk-circle .sk-circle8 {
    -webkit-transform: rotate(210deg);
        -ms-transform: rotate(210deg);
            transform: rotate(210deg); }
  .sk-circle .sk-circle9 {
    -webkit-transform: rotate(240deg);
        -ms-transform: rotate(240deg);
            transform: rotate(240deg); }
  .sk-circle .sk-circle10 {
    -webkit-transform: rotate(270deg);
        -ms-transform: rotate(270deg);
            transform: rotate(270deg); }
  .sk-circle .sk-circle11 {
    -webkit-transform: rotate(300deg);
        -ms-transform: rotate(300deg);
            transform: rotate(300deg); }
  .sk-circle .sk-circle12 {
    -webkit-transform: rotate(330deg);
        -ms-transform: rotate(330deg);
            transform: rotate(330deg); }
  .sk-circle .sk-circle2:before {
    -webkit-animation-delay: -1.1s;
            animation-delay: -1.1s; }
  .sk-circle .sk-circle3:before {
    -webkit-animation-delay: -1s;
            animation-delay: -1s; }
  .sk-circle .sk-circle4:before {
    -webkit-animation-delay: -0.9s;
            animation-delay: -0.9s; }
  .sk-circle .sk-circle5:before {
    -webkit-animation-delay: -0.8s;
            animation-delay: -0.8s; }
  .sk-circle .sk-circle6:before {
    -webkit-animation-delay: -0.7s;
            animation-delay: -0.7s; }
  .sk-circle .sk-circle7:before {
    -webkit-animation-delay: -0.6s;
            animation-delay: -0.6s; }
  .sk-circle .sk-circle8:before {
    -webkit-animation-delay: -0.5s;
            animation-delay: -0.5s; }
  .sk-circle .sk-circle9:before {
    -webkit-animation-delay: -0.4s;
            animation-delay: -0.4s; }
  .sk-circle .sk-circle10:before {
    -webkit-animation-delay: -0.3s;
            animation-delay: -0.3s; }
  .sk-circle .sk-circle11:before {
    -webkit-animation-delay: -0.2s;
            animation-delay: -0.2s; }
  .sk-circle .sk-circle12:before {
    -webkit-animation-delay: -0.1s;
            animation-delay: -0.1s; }
  
  @-webkit-keyframes sk-circleBounceDelay {
    0%, 80%, 100% {
      -webkit-transform: scale(0);
              transform: scale(0);
    } 40% {
      -webkit-transform: scale(1);
              transform: scale(1);
    }
  }
  
  @keyframes sk-circleBounceDelay {
    0%, 80%, 100% {
      -webkit-transform: scale(0);
              transform: scale(0);
    } 40% {
      -webkit-transform: scale(1);
              transform: scale(1);
    }
  }`
	const css10 = `.sk-cube-grid {
    width: 60px;
    height: 60px;
    margin: 100px auto;
  }
  
  .sk-cube-grid .sk-cube {
    width: 33%;
    height: 33%;
    background-color: #fff;
    float: left;
    -webkit-animation: sk-cubeGridScaleDelay 1.3s infinite ease-in-out;
            animation: sk-cubeGridScaleDelay 1.3s infinite ease-in-out; 
  }
  .sk-cube-grid .sk-cube1 {
    -webkit-animation-delay: 0.2s;
            animation-delay: 0.2s; }
  .sk-cube-grid .sk-cube2 {
    -webkit-animation-delay: 0.3s;
            animation-delay: 0.3s; }
  .sk-cube-grid .sk-cube3 {
    -webkit-animation-delay: 0.4s;
            animation-delay: 0.4s; }
  .sk-cube-grid .sk-cube4 {
    -webkit-animation-delay: 0.1s;
            animation-delay: 0.1s; }
  .sk-cube-grid .sk-cube5 {
    -webkit-animation-delay: 0.2s;
            animation-delay: 0.2s; }
  .sk-cube-grid .sk-cube6 {
    -webkit-animation-delay: 0.3s;
            animation-delay: 0.3s; }
  .sk-cube-grid .sk-cube7 {
    -webkit-animation-delay: 0s;
            animation-delay: 0s; }
  .sk-cube-grid .sk-cube8 {
    -webkit-animation-delay: 0.1s;
            animation-delay: 0.1s; }
  .sk-cube-grid .sk-cube9 {
    -webkit-animation-delay: 0.2s;
            animation-delay: 0.2s; }
  
  @-webkit-keyframes sk-cubeGridScaleDelay {
    0%, 70%, 100% {
      -webkit-transform: scale3D(1, 1, 1);
              transform: scale3D(1, 1, 1);
    } 35% {
      -webkit-transform: scale3D(0, 0, 1);
              transform: scale3D(0, 0, 1); 
    }
  }
  
  @keyframes sk-cubeGridScaleDelay {
    0%, 70%, 100% {
      -webkit-transform: scale3D(1, 1, 1);
              transform: scale3D(1, 1, 1);
    } 35% {
      -webkit-transform: scale3D(0, 0, 1);
              transform: scale3D(0, 0, 1);
    } 
  }`
	function loadingAnimation ({ type }) {
		const loadingBar = document.createElement('div')
		loadingBar.style.width = window.innerWidth + 'px'
		loadingBar.style.height = window.innerHeight + 'px'
		loadingBar.style.zIndex = '1'
		loadingBar.style.position = 'absolute'
		loadingBar.style.left = '0'
		loadingBar.style.top = '0'
		loadingBar.style.display = 'flex'
		loadingBar.style.alignItems = 'center'
		loadingBar.style.justifyContent = 'center'
		let runkeyframes
		if (type == '1') {
			// bg color #d35400
			loadingBar.style.background = '#d35400'
			// loading icon
			const loadingIconBox = document.createElement('div')
			loadingIconBox.className = 'spinner'
			// loading icon
			loadingBar.appendChild(loadingIconBox)
			// key frames
			runkeyframes = css1
		}
		else if (type == '2') {
			// bg color #2c3e50
			loadingBar.style.background = '#2c3e50'
			// loading icons
			const loadingIconBox = document.createElement('div')
			loadingIconBox.className = 'sk-chase'
			for (let i = 0; i < 6; i++) {
				const loadingIcon = document.createElement('div')
				loadingIcon.className = 'sk-chase-dot'
				loadingIconBox.appendChild(loadingIcon)
			}
			loadingBar.appendChild(loadingIconBox)
			// key frames
			runkeyframes = css2
		}
		else if (type == '3') {
			// bg color #1abc9c
			loadingBar.style.background = '#1abc9c'
			// loading icons
			const loadingIconBox = document.createElement('div')
			loadingIconBox.className = 'spinner'
			for (let i = 0; i < 2; i++) {
				const loadingIcon = document.createElement('div')
				loadingIcon.className = 'double-bounce' + (i + 1)
				loadingIconBox.appendChild(loadingIcon)
			}
			loadingBar.appendChild(loadingIconBox)
			// key frames
			runkeyframes = css3
		}
		else if (type == '4') {
			// bg color #2980b9
			loadingBar.style.background = '#2980b9'
			// loading icons
			const loadingIconBox = document.createElement('div')
			loadingIconBox.className = 'spinner'
			for (let i = 0; i < 5; i++) {
				const loadingIcon = document.createElement('div')
				loadingIcon.className = 'rect' + (i + 1)
				loadingIconBox.appendChild(loadingIcon)
			}
			loadingBar.appendChild(loadingIconBox)
			// key frames
			runkeyframes = css4
		}
		else if (type == '5') {
			// bg color #7f8c8d
			loadingBar.style.background = '#7f8c8d'
			// loading icons
			const loadingIconBox = document.createElement('div')
			loadingIconBox.className = 'spinner'
			for (let i = 0; i < 2; i++) {
				const loadingIcon = document.createElement('div')
				loadingIcon.className = 'cube' + (i + 1)
				loadingIconBox.appendChild(loadingIcon)
			}
			loadingBar.appendChild(loadingIconBox)
			// key frames
			runkeyframes = css5
		}
		else if (type == '6') {
			// bg color #ffcb65
			loadingBar.style.background = '#ffcb65'
			// loading icons
			const loadingIconBox = document.createElement('div')
			loadingIconBox.className = 'spinner'
			loadingBar.appendChild(loadingIconBox)
			// key frames
			runkeyframes = css6
		}
		else if (type == '7') {
			// bg color #d35400
			loadingBar.style.background = '#d35400'
			// loading icons
			const loadingIconBox = document.createElement('div')
			loadingIconBox.className = 'spinner'
			for (let i = 0; i < 2; i++) {
				const loadingIcon = document.createElement('div')
				loadingIcon.className = 'dot' + (i + 1)
				loadingIconBox.appendChild(loadingIcon)
			}
			loadingBar.appendChild(loadingIconBox)
			// key frames
			runkeyframes = css7
		}
		else if (type == '8') {
			// bg color #27ae60
			loadingBar.style.background = '#27ae60'
			// loading icons
			const loadingIconBox = document.createElement('div')
			loadingIconBox.className = 'spinner'
			for (let i = 0; i < 3; i++) {
				const loadingIcon = document.createElement('div')
				loadingIcon.className = 'bounce' + (i + 1)
				loadingIconBox.appendChild(loadingIcon)
			}
			loadingBar.appendChild(loadingIconBox)
			// key frames
			runkeyframes = css8
		}
		else if (type == '9') {
			// bg color #d35400
			loadingBar.style.background = '#d35400'
			// loading icons
			const loadingIconBox = document.createElement('div')
			loadingIconBox.className = 'sk-circle'
			for (let i = 0; i < 12; i++) {
				const loadingIcon = document.createElement('div')
				loadingIcon.className = 'sk-circle' + (i + 1) + ' sk-child'
				loadingIconBox.appendChild(loadingIcon)
			}
			loadingBar.appendChild(loadingIconBox)
			// key frames
			runkeyframes = css9
		}
		else if (type == '10') {
			// bg color #2c3e50
			loadingBar.style.background = '#2c3e50'
			// loading icons
			const loadingIconBox = document.createElement('div')
			loadingIconBox.className = 'sk-cube-grid'
			for (let i = 0; i < 9; i++) {
				const loadingIcon = document.createElement('div')
				loadingIcon.className = 'sk-cube sk-cube' + (i + 1)
				loadingIconBox.appendChild(loadingIcon)
			}
			loadingBar.appendChild(loadingIconBox)
			// key frames
			runkeyframes = css10
		}
		// create style
		const style = document.createElement('style')
		// append keyframes
		style.innerHTML = runkeyframes
		// append style
		document.getElementsByTagName('head')[0].appendChild(style)
		document.body.appendChild(loadingBar)
		return loadingBar
	}

	// (c) Dean McNamee <dean@gmail.com>, 2012.
	//
	// https://github.com/deanm/css-color-parser-js
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	// IN THE SOFTWARE.
	// http://www.w3.org/TR/css3-color/
	const kCSSColorTable = {
		transparent: [0, 0, 0, 0],
		aliceblue: [240, 248, 255, 1],
		antiquewhite: [250, 235, 215, 1],
		aqua: [0, 255, 255, 1],
		aquamarine: [127, 255, 212, 1],
		azure: [240, 255, 255, 1],
		beige: [245, 245, 220, 1],
		bisque: [255, 228, 196, 1],
		black: [0, 0, 0, 1],
		blanchedalmond: [255, 235, 205, 1],
		blue: [0, 0, 255, 1],
		blueviolet: [138, 43, 226, 1],
		brown: [165, 42, 42, 1],
		burlywood: [222, 184, 135, 1],
		cadetblue: [95, 158, 160, 1],
		chartreuse: [127, 255, 0, 1],
		chocolate: [210, 105, 30, 1],
		coral: [255, 127, 80, 1],
		cornflowerblue: [100, 149, 237, 1],
		cornsilk: [255, 248, 220, 1],
		crimson: [220, 20, 60, 1],
		cyan: [0, 255, 255, 1],
		darkblue: [0, 0, 139, 1],
		darkcyan: [0, 139, 139, 1],
		darkgoldenrod: [184, 134, 11, 1],
		darkgray: [169, 169, 169, 1],
		darkgreen: [0, 100, 0, 1],
		darkgrey: [169, 169, 169, 1],
		darkkhaki: [189, 183, 107, 1],
		darkmagenta: [139, 0, 139, 1],
		darkolivegreen: [85, 107, 47, 1],
		darkorange: [255, 140, 0, 1],
		darkorchid: [153, 50, 204, 1],
		darkred: [139, 0, 0, 1],
		darksalmon: [233, 150, 122, 1],
		darkseagreen: [143, 188, 143, 1],
		darkslateblue: [72, 61, 139, 1],
		darkslategray: [47, 79, 79, 1],
		darkslategrey: [47, 79, 79, 1],
		darkturquoise: [0, 206, 209, 1],
		darkviolet: [148, 0, 211, 1],
		deeppink: [255, 20, 147, 1],
		deepskyblue: [0, 191, 255, 1],
		dimgray: [105, 105, 105, 1],
		dimgrey: [105, 105, 105, 1],
		dodgerblue: [30, 144, 255, 1],
		firebrick: [178, 34, 34, 1],
		floralwhite: [255, 250, 240, 1],
		forestgreen: [34, 139, 34, 1],
		fuchsia: [255, 0, 255, 1],
		gainsboro: [220, 220, 220, 1],
		ghostwhite: [248, 248, 255, 1],
		gold: [255, 215, 0, 1],
		goldenrod: [218, 165, 32, 1],
		gray: [128, 128, 128, 1],
		green: [0, 128, 0, 1],
		greenyellow: [173, 255, 47, 1],
		grey: [128, 128, 128, 1],
		honeydew: [240, 255, 240, 1],
		hotpink: [255, 105, 180, 1],
		indianred: [205, 92, 92, 1],
		indigo: [75, 0, 130, 1],
		ivory: [255, 255, 240, 1],
		khaki: [240, 230, 140, 1],
		lavender: [230, 230, 250, 1],
		lavenderblush: [255, 240, 245, 1],
		lawngreen: [124, 252, 0, 1],
		lemonchiffon: [255, 250, 205, 1],
		lightblue: [173, 216, 230, 1],
		lightcoral: [240, 128, 128, 1],
		lightcyan: [224, 255, 255, 1],
		lightgoldenrodyellow: [250, 250, 210, 1],
		lightgray: [211, 211, 211, 1],
		lightgreen: [144, 238, 144, 1],
		lightgrey: [211, 211, 211, 1],
		lightpink: [255, 182, 193, 1],
		lightsalmon: [255, 160, 122, 1],
		lightseagreen: [32, 178, 170, 1],
		lightskyblue: [135, 206, 250, 1],
		lightslategray: [119, 136, 153, 1],
		lightslategrey: [119, 136, 153, 1],
		lightsteelblue: [176, 196, 222, 1],
		lightyellow: [255, 255, 224, 1],
		lime: [0, 255, 0, 1],
		limegreen: [50, 205, 50, 1],
		linen: [250, 240, 230, 1],
		magenta: [255, 0, 255, 1],
		maroon: [128, 0, 0, 1],
		mediumaquamarine: [102, 205, 170, 1],
		mediumblue: [0, 0, 205, 1],
		mediumorchid: [186, 85, 211, 1],
		mediumpurple: [147, 112, 219, 1],
		mediumseagreen: [60, 179, 113, 1],
		mediumslateblue: [123, 104, 238, 1],
		mediumspringgreen: [0, 250, 154, 1],
		mediumturquoise: [72, 209, 204, 1],
		mediumvioletred: [199, 21, 133, 1],
		midnightblue: [25, 25, 112, 1],
		mintcream: [245, 255, 250, 1],
		mistyrose: [255, 228, 225, 1],
		moccasin: [255, 228, 181, 1],
		navajowhite: [255, 222, 173, 1],
		navy: [0, 0, 128, 1],
		oldlace: [253, 245, 230, 1],
		olive: [128, 128, 0, 1],
		olivedrab: [107, 142, 35, 1],
		orange: [255, 165, 0, 1],
		orangered: [255, 69, 0, 1],
		orchid: [218, 112, 214, 1],
		palegoldenrod: [238, 232, 170, 1],
		palegreen: [152, 251, 152, 1],
		paleturquoise: [175, 238, 238, 1],
		palevioletred: [219, 112, 147, 1],
		papayawhip: [255, 239, 213, 1],
		peachpuff: [255, 218, 185, 1],
		peru: [205, 133, 63, 1],
		pink: [255, 192, 203, 1],
		plum: [221, 160, 221, 1],
		powderblue: [176, 224, 230, 1],
		purple: [128, 0, 128, 1],
		rebeccapurple: [102, 51, 153, 1],
		red: [255, 0, 0, 1],
		rosybrown: [188, 143, 143, 1],
		royalblue: [65, 105, 225, 1],
		saddlebrown: [139, 69, 19, 1],
		salmon: [250, 128, 114, 1],
		sandybrown: [244, 164, 96, 1],
		seagreen: [46, 139, 87, 1],
		seashell: [255, 245, 238, 1],
		sienna: [160, 82, 45, 1],
		silver: [192, 192, 192, 1],
		skyblue: [135, 206, 235, 1],
		slateblue: [106, 90, 205, 1],
		slategray: [112, 128, 144, 1],
		slategrey: [112, 128, 144, 1],
		snow: [255, 250, 250, 1],
		springgreen: [0, 255, 127, 1],
		steelblue: [70, 130, 180, 1],
		tan: [210, 180, 140, 1],
		teal: [0, 128, 128, 1],
		thistle: [216, 191, 216, 1],
		tomato: [255, 99, 71, 1],
		turquoise: [64, 224, 208, 1],
		violet: [238, 130, 238, 1],
		wheat: [245, 222, 179, 1],
		white: [255, 255, 255, 1],
		whitesmoke: [245, 245, 245, 1],
		yellow: [255, 255, 0, 1],
		yellowgreen: [154, 205, 50, 1]
	}
	function clamp_css_byte (i) {
		// Clamp to integer 0 .. 255.
		i = Math.round(i) // Seems to be what Chrome does (vs truncation).
		return i < 0 ? 0 : i > 255 ? 255 : i
	}
	function clamp_css_float (f) {
		// Clamp to float 0.0 .. 1.0.
		return f < 0 ? 0 : f > 1 ? 1 : f
	}
	function parse_css_int (str) {
		// int or percentage.
		if (str[str.length - 1] === '%')
			return clamp_css_byte((parseFloat(str) / 100) * 255)
		return clamp_css_byte(parseInt(str))
	}
	function parse_css_float (str) {
		// float or percentage.
		if (str[str.length - 1] === '%')
			return clamp_css_float(parseFloat(str) / 100)
		return clamp_css_float(parseFloat(str))
	}
	function css_hue_to_rgb (m1, m2, h) {
		if (h < 0)
			h += 1
		else if (h > 1)
			h -= 1
		if (h * 6 < 1)
			return m1 + (m2 - m1) * h * 6
		if (h * 2 < 1)
			return m2
		if (h * 3 < 2)
			return m1 + (m2 - m1) * (2 / 3 - h) * 6
		return m1
	}
	function parseCSSColor (css_str) {
		// Remove all whitespace, not compliant, but should just be more accepting.
		var str = css_str.replace(/ /g, '').toLowerCase()
		// Color keywords (and transparent) lookup.
		if (str in kCSSColorTable)
			return kCSSColorTable[str].slice() // dup.
		// #abc and #abc123 syntax.
		if (str[0] === '#') {
			if (str.length === 4) {
				var iv = parseInt(str.substr(1), 16) // TODO(deanm): Stricter parsing.
				if (!(iv >= 0 && iv <= 0xfff))
					return null // Covers NaN.
				return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8), (iv & 0xf0) | ((iv & 0xf0) >> 4), (iv & 0xf) | ((iv & 0xf) << 4), 1]
			}
			else if (str.length === 7) {
				var iv = parseInt(str.substr(1), 16) // TODO(deanm): Stricter parsing.
				if (!(iv >= 0 && iv <= 0xffffff))
					return null // Covers NaN.
				return [(iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1]
			}
			return null
		}
		var op = str.indexOf('('), ep = str.indexOf(')')
		if (op !== -1 && ep + 1 === str.length) {
			var fname = str.substr(0, op)
			var params = str.substr(op + 1, ep - (op + 1)).split(',')
			var alpha = 1 // To allow case fallthrough.
			switch (fname) {
				case 'rgba':
					if (params.length !== 4)
						return null
					alpha = parse_css_float(params.pop())
				// Fall through.
				case 'rgb':
					if (params.length !== 3)
						return null
					return [parse_css_int(params[0]), parse_css_int(params[1]), parse_css_int(params[2]), alpha]
				case 'hsla':
					if (params.length !== 4)
						return null
					alpha = parse_css_float(params.pop())
				// Fall through.
				case 'hsl':
					if (params.length !== 3)
						return null
					var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360 // 0 .. 1
					// NOTE(deanm): According to the CSS spec s/l should only be
					// percentages, but we don't bother and let float or percentage.
					var s = parse_css_float(params[1])
					var l = parse_css_float(params[2])
					var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s
					var m1 = l * 2 - m2
					return [clamp_css_byte(css_hue_to_rgb(m1, m2, h + 1 / 3) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h - 1 / 3) * 255), alpha]
				default:
					return null
			}
		}
		return null
	}

	// @flow
	/**
	 * An RGBA color value. Create instances from color strings using the static
	 * method `ColorRGBA.parse`. The constructor accepts RGB channel values in the range
	 * `[0, 1]`, premultiplied by A.
	 *
	 * @param {number} r The red channel.
	 * @param {number} g The green channel.
	 * @param {number} b The blue channel.
	 * @param {number} a The alpha channel.
	 * @private
	 */
	class ColorRGBA {
		r
		g
		b
		a
		constructor(r, g, b, a = 1) {
			this.r = r
			this.g = g
			this.b = b
			this.a = a
		}
		static black
		static white
		static transparent
		static red
		static blue
		/**
		 * Parses valid CSS color strings and returns a `ColorRGBA` instance.
		 * @returns A `ColorRGBA` instance, or `undefined` if the input is not a valid color string.
		 */
		static parse (input) {
			if (!input) {
				return undefined
			}
			if (input instanceof ColorRGBA) {
				return input
			}
			if (typeof input !== 'string') {
				return undefined
			}
			const rgba = parseCSSColor(input)
			if (!rgba) {
				return undefined
			}
			return new ColorRGBA((rgba[0] / 255) * rgba[3], (rgba[1] / 255) * rgba[3], (rgba[2] / 255) * rgba[3], rgba[3])
		}
		/**
		 * Returns an RGBA string representing the color value.
		 *
		 * @returns An RGBA string.
		 * @example
		 * var purple = new ColorRGBA.parse('purple');
		 * purple.toString; // = "rgba(128,0,128,1)"
		 * var translucentGreen = new ColorRGBA.parse('rgba(26, 207, 26, .73)');
		 * translucentGreen.toString(); // = "rgba(26,207,26,0.73)"
		 */
		toString () {
			const [r, g, b, a] = this.toArray()
			return `rgba(${Math.round(r)},${Math.round(g)},${Math.round(b)},${a})`
		}
		toArray () {
			const { r, g, b, a } = this
			return a === 0 ? [0, 0, 0, 0] : [(r * 255) / a, (g * 255) / a, (b * 255) / a, a]
		}
	}
	ColorRGBA.black = new ColorRGBA(0, 0, 0, 1)
	ColorRGBA.white = new ColorRGBA(1, 1, 1, 1)
	ColorRGBA.transparent = new ColorRGBA(0, 0, 0, 0)
	ColorRGBA.red = new ColorRGBA(1, 0, 0, 1)
	ColorRGBA.blue = new ColorRGBA(0, 0, 1, 1)

	function loadTex (loader, url) {
		return new Promise((resolve, reject) => {
			loader.load(url, (tex) => {
				resolve(tex)
			})
		})
	}
	function parseImageFile (reader, file) {
		return new Promise((resolve, reject) => {
			reader.readAsDataURL(file)
			reader.onload = (e) => {
				let base64 = e.target?.result // base64file
				const image = new Image()
				image.src = base64
				image.crossOrigin = 'anonymous'
				resolve(image)
			}
		})
	}
	const DEG_TO_RAD = Math.PI / 180
	/**
	 * Converts an angle in degrees to radians
	 * copy all properties from the source objects into the destination.
	 * The last source object given overrides properties from previous
	 * source objects.
	 *
	 * @param a angle to convert
	 * @returns the angle in radians
	 * @private
	 */
	function degToRad (a) {
		return a * DEG_TO_RAD
	}
	/**
	 * UUID
	 */
	function traverseGenerateUUID (model, pId) {
		model.uuid = `${pId}`
		model.children.forEach((m) => {
			m.uuid = `${pId}_${m.name}`
			if (m.children.length > 0)
				traverseGenerateUUID(m, m.uuid)
		})
	}
	/**
	 * uuidnode
	 */
	function traverseSelectNodeByUUID (scene, uuid, result) {
		if (scene.uuid == uuid) {
			result.push(scene)
			return
		}
		for (let i = 0; i < scene.children.length; i++) {
			const s = scene.children[i]
			if (s.uuid == uuid) {
				result.push(s)
				return
			}
			if (s.children.length > 0) {
				traverseSelectNodeByUUID(s, uuid, result)
			}
		}
	}
	//  
	function recursiveCalParentsMat (obj, v, mat) {
		mat.compose(obj.position, new Quaternion().setFromEuler(new Euler().setFromVector3(obj.rotation)), obj.scale)
		v.applyMatrix4(mat)
		if (!obj.parent || obj.parent.type == 'Scene')
			return
		recursiveCalParentsMat(obj.parent, v, mat)
	}
	// canvas 1
	const drawTextCanvas = ({ text, fontColor, bgColor, strokeColor, fontSize = 100 }) => {
		const canvas = document.createElement('canvas')
		const ctx = canvas.getContext('2d') //
		ctx.font = 'Bold ' + fontSize + 'px Microsoft YaHei'
		const rgbaStroke = ColorRGBA.parse(strokeColor)
		const w = ctx.measureText(text).width + 20
		let width = 512
		let height = 128
		for (let i = 9; i < 13; i++) {
			// 4096
			if (Math.pow(2, i) > w) {
				width = Math.pow(2, i)
				break
			}
		}
		canvas.width = width
		canvas.height = height
		canvas.style.width = width / 2 + 'px'
		canvas.style.height = height / 2 + 'px'
		// clear bg
		ctx.clearRect(0, 0, width, height)
		// bg
		ctx.fillStyle = bgColor
		ctx.fillRect(10, 10, width - 20, height - 20)
		// stroke
		ctx.beginPath()
		ctx.moveTo(10 + 5, 0)
		ctx.lineTo(0, 0)
		ctx.lineTo(0, height)
		ctx.lineTo(10 + 5, height)
		ctx.moveTo(width - 10 - 5, height)
		ctx.lineTo(width, height)
		ctx.lineTo(width, 0)
		ctx.lineTo(width - 10 - 5, 0)
		ctx.strokeStyle = `rgb(${rgbaStroke.r * 255},${rgbaStroke.g * 255},${rgbaStroke.b * 255})`
		ctx.lineWidth = 8
		ctx.stroke()
		// stroke 2
		ctx.beginPath()
		ctx.moveTo(10 + 5, 0)
		ctx.lineTo(width - 10 - 5, 0)
		ctx.moveTo(width - 10 - 5, height)
		ctx.lineTo(10 + 5, height)
		ctx.strokeStyle = `rgba(${rgbaStroke.r * 255},${rgbaStroke.g * 255},${rgbaStroke.b * 255},.1)`
		ctx.lineWidth = 8
		ctx.stroke()
		// text
		ctx.font = 'Bold ' + fontSize + 'px Microsoft YaHei'
		ctx.textBaseline = 'top'
		ctx.fillStyle = fontColor
		ctx.fillText(text, (width - ctx.measureText(text).width) / 2, (1.2 * (height - fontSize)) / 2)
		return { canvas, height, width }
	}
	// canvas 1
	const updateTextCanvas = ({ canvas, text, fontColor, bgColor, strokeColor, fontSize = 100 }) => {
		const ctx = canvas.getContext('2d')
		ctx.font = 'Bold ' + fontSize + 'px Microsoft YaHei'
		const rgbaStroke = ColorRGBA.parse(strokeColor)
		const w = ctx.measureText(text).width + 20
		let width = 512
		let height = 128
		for (let i = 9; i < 13; i++) {
			// 4096
			if (Math.pow(2, i) > w) {
				width = Math.pow(2, i)
				break
			}
		}
		canvas.width = width
		canvas.height = height
		canvas.style.width = width / 2 + 'px'
		canvas.style.height = height / 2 + 'px'
		// clear bg
		ctx.clearRect(0, 0, width, height)
		// bg
		ctx.fillStyle = bgColor
		ctx.fillRect(10, 10, width - 20, height - 20)
		// stroke
		ctx.beginPath()
		ctx.moveTo(10 + 5, 0)
		ctx.lineTo(0, 0)
		ctx.lineTo(0, height)
		ctx.lineTo(10 + 5, height)
		ctx.moveTo(width - 10 - 5, height)
		ctx.lineTo(width, height)
		ctx.lineTo(width, 0)
		ctx.lineTo(width - 10 - 5, 0)
		ctx.strokeStyle = `rgb(${rgbaStroke.r * 255},${rgbaStroke.g * 255},${rgbaStroke.b * 255})`
		ctx.lineWidth = 8
		ctx.stroke()
		// stroke 2
		ctx.beginPath()
		ctx.moveTo(10 + 5, 0)
		ctx.lineTo(width - 10 - 5, 0)
		ctx.moveTo(width - 10 - 5, height)
		ctx.lineTo(10 + 5, height)
		ctx.strokeStyle = `rgba(${rgbaStroke.r * 255},${rgbaStroke.g * 255},${rgbaStroke.b * 255},.1)`
		ctx.lineWidth = 8
		ctx.stroke()
		// text
		ctx.font = 'Bold ' + fontSize + 'px Microsoft YaHei'
		ctx.textBaseline = 'top'
		ctx.fillStyle = fontColor
		ctx.fillText(text, (width - ctx.measureText(text).width) / 2, (1.2 * (height - fontSize)) / 2)
		return { canvas, height, width }
	}
	// canvas 2
	const drawTextCanvas2 = ({ text, fontColor, bgColor, strokeColor, horizontal = 50, vertical = 4, fontSize = 100 }) => {
		const canvas = document.createElement('canvas')
		const ctx = canvas.getContext('2d') //
		ctx.font = 'Bold ' + fontSize + 'px Microsoft YaHei'
		const rgbaStroke = ColorRGBA.parse(strokeColor)
		const w = ctx.measureText(text).width + 200
		let width = 512
		let height = 128
		for (let i = 9; i < 13; i++) {
			// 4096
			if (Math.pow(2, i) > w) {
				width = Math.pow(2, i)
				break
			}
		}
		canvas.width = width
		canvas.height = height
		canvas.style.width = width / 2 + 'px'
		canvas.style.height = height / 2 + 'px'
		// clear bg
		ctx.clearRect(0, 0, width, height)
		// bg
		ctx.fillStyle = bgColor
		const radius = 64 - vertical
		ctx.beginPath()
		//01/2PI
		ctx.arc(width - horizontal - radius, height - radius - vertical, radius, 0, Math.PI / 2)
		//
		ctx.lineTo(radius + horizontal, height - vertical)
		//1/2PIPI
		ctx.arc(radius + horizontal, height - radius - vertical, radius, Math.PI / 2, Math.PI)
		//
		ctx.lineTo(horizontal, radius)
		//PI3/2PI
		ctx.arc(radius + horizontal, radius + vertical, radius, Math.PI, (Math.PI * 3) / 2)
		//
		ctx.lineTo(width - radius - horizontal, vertical)
		//
		ctx.arc(width - radius - horizontal, radius + vertical, radius, (Math.PI * 3) / 2, Math.PI * 2)
		//
		ctx.lineTo(width - horizontal, height - radius)
		ctx.closePath()
		ctx.fill()
		// stroke
		ctx.lineWidth = 2 //2
		ctx.strokeStyle = `rgba(255,255,255,.1)`
		ctx.stroke()
		// stroke2
		ctx.beginPath()
		ctx.moveTo(25, height / 2)
		ctx.lineTo(100, height / 2)
		const grd1 = ctx.createLinearGradient(25, height / 2, 100, height / 2)
		grd1.addColorStop(0, `rgba(${rgbaStroke.r * 255},${rgbaStroke.g * 255},${rgbaStroke.b * 255},1)`)
		grd1.addColorStop(1, `rgba(66,66,66,.1)`)
		ctx.strokeStyle = grd1
		ctx.lineWidth = 8
		ctx.stroke()
		// stroke3
		ctx.beginPath()
		ctx.moveTo(width - 25, height / 2)
		ctx.lineTo(width - 100, height / 2)
		const grd2 = ctx.createLinearGradient(width - 25, height / 2, width - 100, height / 2)
		grd2.addColorStop(0, `rgba(${rgbaStroke.r * 255},${rgbaStroke.g * 255},${rgbaStroke.b * 255},1)`)
		grd2.addColorStop(1, `rgba(66,66,66,.1)`)
		ctx.strokeStyle = grd2
		ctx.lineWidth = 8
		ctx.stroke()
		// text
		ctx.font = 'Bold ' + fontSize + 'px Microsoft YaHei'
		ctx.textBaseline = 'top'
		ctx.fillStyle = fontColor
		ctx.fillText(text, (width - ctx.measureText(text).width) / 2, (1.2 * (height - fontSize)) / 2)
		return { canvas, height, width }
	}
	// canvas 2
	const updateTextCanvas2 = ({ canvas, text, fontColor, bgColor, strokeColor, horizontal = 50, vertical = 4, fontSize = 100 }) => {
		const ctx = canvas.getContext('2d') //
		ctx.font = 'Bold ' + fontSize + 'px Microsoft YaHei'
		const rgbaStroke = ColorRGBA.parse(strokeColor)
		const w = ctx.measureText(text).width + 200
		let width = 512
		let height = 128
		for (let i = 9; i < 13; i++) {
			// 4096
			if (Math.pow(2, i) > w) {
				width = Math.pow(2, i)
				break
			}
		}
		canvas.width = width
		canvas.height = height
		canvas.style.width = width / 2 + 'px'
		canvas.style.height = height / 2 + 'px'
		// clear bg
		ctx.clearRect(0, 0, width, height)
		// bg
		ctx.fillStyle = bgColor
		const radius = 64 - vertical
		ctx.beginPath()
		//01/2PI
		ctx.arc(width - horizontal - radius, height - radius - vertical, radius, 0, Math.PI / 2)
		//
		ctx.lineTo(radius + horizontal, height - vertical)
		//1/2PIPI
		ctx.arc(radius + horizontal, height - radius - vertical, radius, Math.PI / 2, Math.PI)
		//
		ctx.lineTo(horizontal, radius)
		//PI3/2PI
		ctx.arc(radius + horizontal, radius + vertical, radius, Math.PI, (Math.PI * 3) / 2)
		//
		ctx.lineTo(width - radius - horizontal, vertical)
		//
		ctx.arc(width - radius - horizontal, radius + vertical, radius, (Math.PI * 3) / 2, Math.PI * 2)
		//
		ctx.lineTo(width - horizontal, height - radius)
		ctx.closePath()
		ctx.fill()
		// stroke
		ctx.lineWidth = 2 //2
		ctx.strokeStyle = `rgba(255,255,255,.1)`
		ctx.stroke()
		// stroke2
		ctx.beginPath()
		ctx.moveTo(25, height / 2)
		ctx.lineTo(100, height / 2)
		const grd1 = ctx.createLinearGradient(25, height / 2, 100, height / 2)
		grd1.addColorStop(0, `rgba(${rgbaStroke.r * 255},${rgbaStroke.g * 255},${rgbaStroke.b * 255},1)`)
		grd1.addColorStop(1, `rgba(66,66,66,.1)`)
		ctx.strokeStyle = grd1
		ctx.lineWidth = 8
		ctx.stroke()
		// stroke3
		ctx.beginPath()
		ctx.moveTo(width - 25, height / 2)
		ctx.lineTo(width - 100, height / 2)
		const grd2 = ctx.createLinearGradient(width - 25, height / 2, width - 100, height / 2)
		grd2.addColorStop(0, `rgba(${rgbaStroke.r * 255},${rgbaStroke.g * 255},${rgbaStroke.b * 255},1)`)
		grd2.addColorStop(1, `rgba(66,66,66,.1)`)
		ctx.strokeStyle = grd2
		ctx.lineWidth = 8
		ctx.stroke()
		// text
		ctx.font = 'Bold ' + fontSize + 'px Microsoft YaHei'
		ctx.textBaseline = 'top'
		ctx.fillStyle = fontColor
		ctx.fillText(text, (width - ctx.measureText(text).width) / 2, (1.2 * (height - fontSize)) / 2)
		return { canvas, height, width }
	}
	// canvas 3
	const drawTextCanvas3 = ({ text, fontColor, bgColor, strokeColor, horizontal = 50, vertical = 4, fontSize = 100 }) => {
		const canvas = document.createElement('canvas')
		const ctx = canvas.getContext('2d') //
		ctx.font = 'Bold ' + fontSize + 'px Microsoft YaHei'
		ColorRGBA.parse(strokeColor)
		const w = ctx.measureText(text).width + 200
		let width = 512
		let height = 128
		for (let i = 9; i < 13; i++) {
			// 4096
			if (Math.pow(2, i) > w) {
				width = Math.pow(2, i)
				break
			}
		}
		canvas.width = width
		canvas.height = height
		canvas.style.width = width / 2 + 'px'
		canvas.style.height = height / 2 + 'px'
		// clear bg
		ctx.clearRect(0, 0, width, height)
		// bg
		ctx.fillStyle = bgColor
		const radius = 64 - vertical
		ctx.beginPath()
		//01/2PI
		ctx.arc(width - horizontal - radius, height - radius - vertical, radius, 0, Math.PI / 2)
		//
		ctx.lineTo(radius + horizontal, height - vertical)
		//1/2PIPI
		ctx.arc(radius + horizontal, height - radius - vertical, radius, Math.PI / 2, Math.PI)
		//
		ctx.lineTo(horizontal, radius)
		//PI3/2PI
		ctx.arc(radius + horizontal, radius + vertical, radius, Math.PI, (Math.PI * 3) / 2)
		//
		ctx.lineTo(width - radius - horizontal, vertical)
		//
		ctx.arc(width - radius - horizontal, radius + vertical, radius, (Math.PI * 3) / 2, Math.PI * 2)
		//
		ctx.lineTo(width - horizontal, height - radius)
		ctx.closePath()
		ctx.fill()
		// stroke
		ctx.lineWidth = 2 //2
		ctx.strokeStyle = `rgba(255,255,255,.1)`
		ctx.stroke()
		// text
		ctx.font = 'Bold ' + fontSize + 'px Microsoft YaHei'
		ctx.textBaseline = 'top'
		ctx.fillStyle = fontColor
		ctx.fillText(text, (width - ctx.measureText(text).width) / 2, (1.2 * (height - fontSize)) / 2)
		return { canvas, height, width }
	}
	// canvas 4
	const drawTextCanvas4 = ({ text, fontColor, bgColor, strokeColor, fontSize = 100 }) => {
		const canvas = document.createElement('canvas')
		const ctx = canvas.getContext('2d') //
		ctx.font = 'Bold ' + fontSize + 'px Microsoft YaHei'
		ColorRGBA.parse(strokeColor)
		const w = ctx.measureText(text).width
		let width = 512
		let height = 128
		for (let i = 9; i < 13; i++) {
			// 4096
			if (Math.pow(2, i) > w) {
				width = Math.pow(2, i)
				break
			}
		}
		canvas.width = width
		canvas.height = height
		canvas.style.width = width / 2 + 'px'
		canvas.style.height = height / 2 + 'px'
		// clear bg
		ctx.clearRect(0, 0, width, height)
		// bg
		ctx.fillStyle = bgColor
		ctx.beginPath()
		ctx.lineTo(0, 0)
		ctx.lineTo(0, height)
		ctx.lineTo(width, height)
		ctx.lineTo(width, 0)
		ctx.closePath()
		ctx.fill()
		// stroke
		ctx.lineWidth = 2 //2
		ctx.strokeStyle = `rgba(255,255,255,.1)`
		ctx.stroke()
		// text
		ctx.font = 'Bold ' + fontSize + 'px Microsoft YaHei'
		ctx.textBaseline = 'top'
		ctx.fillStyle = fontColor
		ctx.fillText(text, (width - ctx.measureText(text).width) / 2, (1.2 * (height - fontSize)) / 2)
		return { canvas, height, width }
	}
	// canvas 5
	const drawTextCanvas5 = ({ text, fontColor, bgColor, strokeColor, textPadding = 0, fontSize = 100 }) => {
		const canvas = document.createElement('canvas')
		const ctx = canvas.getContext('2d') //
		ctx.font = 'Bold ' + fontSize + 'px Microsoft YaHei'
		const rgbaStroke = ColorRGBA.parse(strokeColor)
		let w = ctx.measureText(text).width
		w = Math.max(120, w * 1.2)
		let width = 2048
		let height = 256
		width = Math.max(128, Math.min(width, 4096))
		canvas.width = width
		canvas.height = height
		canvas.style.width = width / 2 + 'px'
		canvas.style.height = height / 2 + 'px'
		// clear bg
		ctx.clearRect(0, 0, width, height)
		// bg
		ctx.fillStyle = bgColor
		ctx.fillRect(width / 2 - w * 0.6, 10, w * 1.2, height / 1.5 - 20)
		// stroke
		ctx.beginPath()
		ctx.moveTo(width / 2 - w * 0.6 + 8, 0)
		ctx.lineTo(width / 2 - w * 0.6 - 8, 0)
		ctx.lineTo(width / 2 - w * 0.6 - 8, height / 1.5)
		ctx.lineTo(width / 2 - w * 0.6 + 8, height / 1.5)
		ctx.moveTo(width / 2 + w * 0.6 - 8, height / 1.5)
		ctx.lineTo(width / 2 + w * 0.6 + 8, height / 1.5)
		ctx.lineTo(width / 2 + w * 0.6 + 8, 0)
		ctx.lineTo(width / 2 + w * 0.6 - 8, 0)
		ctx.strokeStyle = `rgb(${rgbaStroke.r * 255},${rgbaStroke.g * 255},${rgbaStroke.b * 255})`
		ctx.lineWidth = 6
		ctx.stroke()
		// 
		ctx.beginPath()
		ctx.clearRect(width / 2 - w * 0.6 - 12, height / 6, 10, (height / 6) * 2)
		ctx.clearRect(width / 2 + w * 0.6 + 4, height / 6, 8, (height / 6) * 2)
		ctx.moveTo(width / 2 - w * 0.6 - 8, height / 6)
		ctx.lineTo(width / 2 - w * 0.6 - 8, (height / 6) * 3)
		ctx.moveTo(width / 2 + w * 0.6 + 8, height / 6)
		ctx.lineTo(width / 2 + w * 0.6 + 8, (height / 6) * 3)
		ctx.strokeStyle = `rgb(${rgbaStroke.r * 255},${rgbaStroke.g * 255},${rgbaStroke.b * 255},.2)`
		ctx.lineWidth = 6
		ctx.stroke()
		// stroke 2
		ctx.beginPath()
		ctx.moveTo(width / 2 - w * 0.6 + 8, 0)
		ctx.lineTo(width / 2 + w * 0.6 - 8, 0)
		ctx.moveTo(width / 2 + w * 0.6 - 8, height / 1.5)
		ctx.lineTo(width / 2 - w * 0.6 + 8, height / 1.5)
		ctx.strokeStyle = `rgba(${rgbaStroke.r * 255},${rgbaStroke.g * 255},${rgbaStroke.b * 255},.1)`
		ctx.lineWidth = 8
		ctx.stroke()
		// stroke 3
		ctx.beginPath()
		ctx.strokeStyle = `rgb(${rgbaStroke.r * 255},${rgbaStroke.g * 255},${rgbaStroke.b * 255})`
		ctx.moveTo(width / 2, height - 15)
		ctx.lineTo(width / 2 + 25, height / 1.3)
		ctx.lineTo(width / 2 - 25, height / 1.3)
		ctx.closePath()
		ctx.fill()
		ctx.stroke()
		// text
		ctx.font = 'Bold ' + fontSize + 'px Microsoft YaHei'
		ctx.textBaseline = 'top'
		ctx.fillStyle = fontColor
		ctx.fillText(text, (width - ctx.measureText(text).width) / 2, height / 3 - fontSize / 2)
		return { canvas, height, width }
	}
	// canvas 6
	const drawTextCanvas6 = ({ text, fontColor, bgColor, strokeColor, textPadding = 0, fontSize = 100 }) => {
		const canvas = document.createElement('canvas')
		const ctx = canvas.getContext('2d') //
		ctx.font = 'Bold ' + fontSize + 'px Microsoft YaHei'
		const rgbaStroke = ColorRGBA.parse(strokeColor)
		let w = ctx.measureText(text).width
		w = Math.max(350, w + 150)
		let width = 2048
		let height = 256
		width = Math.max(128, Math.min(width, 4096))
		canvas.width = width
		canvas.height = height
		canvas.style.width = width / 2 + 'px'
		canvas.style.height = height / 2 + 'px'
		// clear bg
		ctx.clearRect(0, 0, width, height)
		// bg
		ctx.fillStyle = bgColor
		// stroke
		ctx.beginPath()
		ctx.moveTo(0, height / 2)
		ctx.lineTo(90, height - 50)
		ctx.lineTo(w + 250 - 90, height - 50)
		ctx.lineTo(w + 250, 50)
		ctx.lineTo(90, 50)
		ctx.strokeStyle = `rgb(${rgbaStroke.r * 255},${rgbaStroke.g * 255},${rgbaStroke.b * 255})`
		//ctx.lineWidth = 8
		ctx.closePath()
		ctx.fill()
		ctx.stroke()
		// stroke 2
		ctx.beginPath()
		ctx.moveTo(95, 58)
		ctx.lineTo(4, height / 2)
		ctx.lineTo(95, height - 58)
		ctx.moveTo(w + 250 - 5, 58)
		ctx.lineTo(w + 250 - 95, height - 58)
		ctx.moveTo(w + 250 - 125, height - 58)
		ctx.lineTo(w + 250 - 54, height / 3)
		ctx.lineTo(w + 250 - 79, height / 3)
		ctx.lineTo(w + 250 - 150, height - 58)
		ctx.moveTo(w + 250 - 175, height - 58)
		ctx.lineTo(w + 250 - 99, height / 3)
		ctx.lineTo(w + 250 - 124, height / 3)
		ctx.lineTo(w + 250 - 200, height - 58)
		ctx.moveTo(w + 250 - 225, height - 58)
		ctx.lineTo(w + 250 - 144, height / 3)
		ctx.lineTo(w + 250 - 169, height / 3)
		ctx.lineTo(w + 250 - 250, height - 58)
		const addColor = [rgbaStroke.r + 0.2, rgbaStroke.g + 0.2, rgbaStroke.b + 0.2]
		ctx.strokeStyle = `rgb(${addColor[0] * 255},${addColor[1] * 255},${addColor[2] * 255})`
		ctx.lineWidth = 2
		ctx.stroke()
		// text
		ctx.font = 'Bold ' + fontSize + 'px Microsoft YaHei'
		ctx.textBaseline = 'top'
		ctx.fillStyle = fontColor
		ctx.fillText(text, 90 + fontSize / 2, height / 2 - fontSize / 2)
		return { canvas, height, width }
	}
	// canvas 1
	const drawTagCanvas = ({ text, fontColor, bgColor, strokeColor, fontSize = 100 }) => {
		const canvas = document.createElement('canvas')
		const ctx = canvas.getContext('2d') //
		ctx.font = 'Bold ' + fontSize + 'px Microsoft YaHei'
		ColorRGBA.parse(strokeColor)
		const w = ctx.measureText(text).width
		let width = 512
		let height = 128
		for (let i = 9; i < 13; i++) {
			// 4096
			if (Math.pow(2, i) > w) {
				width = Math.pow(2, i)
				break
			}
		}
		canvas.width = width
		canvas.height = height
		canvas.style.width = width / 2 + 'px'
		canvas.style.height = height / 2 + 'px'
		// clear bg
		ctx.clearRect(0, 0, width, height)
		// text
		ctx.font = 'Bold ' + fontSize + 'px Microsoft YaHei'
		ctx.textBaseline = 'top'
		ctx.fillStyle = fontColor
		ctx.fillText(text, (width - ctx.measureText(text).width) / 2, (1.2 * (height - fontSize)) / 2)
		return { canvas, height, width }
	}
	// canvas+ Popup 1
	const drawTextCanvasWithImg = ({ title1, title2, title3, fontColor1, fontColor2, fontColor3, bgColor, strokeColor, fontSize1 = 100, fontSize2 = 80, fontSize3 = 60, img }) => {
		const canvas = document.createElement('canvas')
		const ctx = canvas.getContext('2d') //
		ctx.font = 'Bold ' + fontSize1 + 'px Microsoft YaHei'
		const rgbaStroke = ColorRGBA.parse(strokeColor)
		const w = ctx.measureText(title1).width + 20
		let width = 512
		let height = 256
		for (let i = 9; i < 13; i++) {
			// 4096
			if (Math.pow(2, i) > w) {
				width = Math.pow(2, i)
				height = width / 2
				break
			}
		}
		ctx.font = 'Bold ' + fontSize2 + 'px Microsoft YaHei'
		const w2 = ctx.measureText(title2).width + width / 2
		for (let i = 9; i < 13; i++) {
			// 4096
			if (Math.pow(2, i) > w2) {
				width = Math.pow(2, i)
				height = width / 2
				break
			}
		}
		ctx.font = 'Bold ' + fontSize3 + 'px Microsoft YaHei'
		const w3 = ctx.measureText(title3).width + width / 2
		for (let i = 9; i < 13; i++) {
			// 4096
			if (Math.pow(2, i) > w3) {
				width = Math.pow(2, i)
				height = width / 2
				break
			}
		}
		canvas.width = width
		canvas.height = height
		canvas.style.width = width / 2 + 'px'
		canvas.style.height = height / 2 + 'px'
		let paddingTop = 10 * (width / 512)
		let paddingLeft = 10 * (width / 512)
		// clear bg
		ctx.clearRect(0, 0, width, height)
		// bg
		ctx.fillStyle = bgColor
		ctx.fillRect(paddingLeft, paddingTop, width - paddingLeft * 2, height - paddingTop * 2)
		// stroke
		ctx.beginPath()
		ctx.moveTo(paddingLeft + paddingLeft / 2, 0)
		ctx.lineTo(0, 0)
		ctx.lineTo(0, height)
		ctx.lineTo(paddingLeft + paddingLeft / 2, height)
		ctx.moveTo(width - paddingLeft - paddingLeft / 2, height)
		ctx.lineTo(width, height)
		ctx.lineTo(width, 0)
		ctx.lineTo(width - paddingLeft - paddingLeft / 2, 0)
		ctx.strokeStyle = `rgb(${rgbaStroke.r * 255},${rgbaStroke.g * 255},${rgbaStroke.b * 255})`
		ctx.lineWidth = (8 * width) / 512
		ctx.stroke()
		// stroke 2
		ctx.beginPath()
		ctx.moveTo(paddingTop + paddingTop / 2, 0)
		ctx.lineTo(width - paddingTop - paddingTop / 2, 0)
		ctx.moveTo(width - paddingTop - paddingTop / 2, height)
		ctx.lineTo(paddingTop + paddingTop / 2, height)
		ctx.strokeStyle = `rgba(${rgbaStroke.r * 255},${rgbaStroke.g * 255},${rgbaStroke.b * 255},.1)`
		ctx.lineWidth = (8 * width) / 512
		ctx.stroke()
		// title1
		ctx.font = 'Bold ' + fontSize1 + 'px Microsoft YaHei'
		ctx.textBaseline = 'top'
		ctx.fillStyle = fontColor1
		ctx.fillText(title1, (width - ctx.measureText(title1).width) / 2, paddingTop * 4)
		// title2 & title3 & img
		if (img) {
			// img
			ctx.drawImage(img, width / 8, (height - (paddingTop * 2 + fontSize1)) / 2, width / 4, width / 4)
			// title2
			ctx.font = 'Bold ' + fontSize2 + 'px Microsoft YaHei'
			ctx.textBaseline = 'top'
			ctx.fillStyle = fontColor2
			ctx.fillText(title2, width / 2, (height - (paddingTop * 2 + fontSize1)) / 2)
			// title3
			ctx.font = 'Bold ' + fontSize3 + 'px Microsoft YaHei'
			ctx.textBaseline = 'top'
			ctx.fillStyle = fontColor3
			ctx.fillText(title3, width / 2, (height - (paddingTop * 2 + fontSize1)) / 2 + (fontSize2 + paddingTop))
		}
		else {
			// title2
			ctx.font = 'Bold ' + fontSize2 + 'px Microsoft YaHei'
			ctx.textBaseline = 'top'
			ctx.fillStyle = fontColor2
			ctx.fillText(title2, width / 2, (height - (paddingTop * 2 + fontSize1)) / 2)
			// title3
			ctx.font = 'Bold ' + fontSize3 + 'px Microsoft YaHei'
			ctx.textBaseline = 'top'
			ctx.fillStyle = fontColor3
			ctx.fillText(title3, width / 2, (height - (paddingTop * 2 + fontSize1)) / 2 + (fontSize2 + paddingTop))
		}
		return { canvas, height, width }
	}
	// canvas+ Popup 1
	const updateTextCanvasWithImg = ({ canvas, title1, title2, title3, fontColor1, fontColor2, fontColor3, bgColor, strokeColor, fontSize1 = 100, fontSize2 = 80, fontSize3 = 60, img }) => {
		const ctx = canvas.getContext('2d') //
		ctx.font = 'Bold ' + fontSize1 + 'px Microsoft YaHei'
		const rgbaStroke = ColorRGBA.parse(strokeColor)
		const w = ctx.measureText(title1).width + 20
		let width = 512
		let height = 256
		for (let i = 9; i < 13; i++) {
			// 4096
			if (Math.pow(2, i) > w) {
				width = Math.pow(2, i)
				height = width / 2
				break
			}
		}
		ctx.font = 'Bold ' + fontSize2 + 'px Microsoft YaHei'
		const w2 = ctx.measureText(title2).width + width / 2
		for (let i = 9; i < 13; i++) {
			// 4096
			if (Math.pow(2, i) > w2) {
				width = Math.pow(2, i)
				height = width / 2
				break
			}
		}
		ctx.font = 'Bold ' + fontSize3 + 'px Microsoft YaHei'
		const w3 = ctx.measureText(title3).width + width / 2
		for (let i = 9; i < 13; i++) {
			// 4096
			if (Math.pow(2, i) > w3) {
				width = Math.pow(2, i)
				height = width / 2
				break
			}
		}
		canvas.width = width
		canvas.height = height
		canvas.style.width = width / 2 + 'px'
		canvas.style.height = height / 2 + 'px'
		let paddingTop = 10 * (width / 512)
		let paddingLeft = 10 * (width / 512)
		// clear bg
		ctx.clearRect(0, 0, width, height)
		// bg
		ctx.fillStyle = bgColor
		ctx.fillRect(paddingLeft, paddingTop, width - paddingLeft * 2, height - paddingTop * 2)
		// stroke
		ctx.beginPath()
		ctx.moveTo(paddingLeft + paddingLeft / 2, 0)
		ctx.lineTo(0, 0)
		ctx.lineTo(0, height)
		ctx.lineTo(paddingLeft + paddingLeft / 2, height)
		ctx.moveTo(width - paddingLeft - paddingLeft / 2, height)
		ctx.lineTo(width, height)
		ctx.lineTo(width, 0)
		ctx.lineTo(width - paddingLeft - paddingLeft / 2, 0)
		ctx.strokeStyle = `rgb(${rgbaStroke.r * 255},${rgbaStroke.g * 255},${rgbaStroke.b * 255})`
		ctx.lineWidth = (8 * width) / 512
		ctx.stroke()
		// stroke 2
		ctx.beginPath()
		ctx.moveTo(paddingTop + paddingTop / 2, 0)
		ctx.lineTo(width - paddingTop - paddingTop / 2, 0)
		ctx.moveTo(width - paddingTop - paddingTop / 2, height)
		ctx.lineTo(paddingTop + paddingTop / 2, height)
		ctx.strokeStyle = `rgba(${rgbaStroke.r * 255},${rgbaStroke.g * 255},${rgbaStroke.b * 255},.1)`
		ctx.lineWidth = (8 * width) / 512
		ctx.stroke()
		// title1
		ctx.font = 'Bold ' + fontSize1 + 'px Microsoft YaHei'
		ctx.textBaseline = 'top'
		ctx.fillStyle = fontColor1
		ctx.fillText(title1, (width - ctx.measureText(title1).width) / 2, paddingTop * 4)
		// title2 & title3 & img
		if (img) {
			// img
			ctx.drawImage(img, width / 8, (height - (paddingTop * 2 + fontSize1)) / 2, width / 4, width / 4)
			// title2
			ctx.font = 'Bold ' + fontSize2 + 'px Microsoft YaHei'
			ctx.textBaseline = 'top'
			ctx.fillStyle = fontColor2
			ctx.fillText(title2, width / 2, (height - (paddingTop * 2 + fontSize1)) / 2)
			// title3
			ctx.font = 'Bold ' + fontSize3 + 'px Microsoft YaHei'
			ctx.textBaseline = 'top'
			ctx.fillStyle = fontColor3
			ctx.fillText(title3, width / 2, (height - (paddingTop * 2 + fontSize1)) / 2 + (fontSize2 + paddingTop))
		}
		else {
			// title2
			ctx.font = 'Bold ' + fontSize2 + 'px Microsoft YaHei'
			ctx.textBaseline = 'top'
			ctx.fillStyle = fontColor2
			ctx.fillText(title2, width / 2, (height - (paddingTop * 2 + fontSize1)) / 2)
			// title3
			ctx.font = 'Bold ' + fontSize3 + 'px Microsoft YaHei'
			ctx.textBaseline = 'top'
			ctx.fillStyle = fontColor3
			ctx.fillText(title3, width / 2, (height - (paddingTop * 2 + fontSize1)) / 2 + (fontSize2 + paddingTop))
		}
		return { canvas, height, width }
	}
	//
	function lnglat2mercator (coord) {
		//[114.32894, 30.585748]
		const mercator = []
		const earthRad = 6378137.0
		// console.log("mercator-poi",poi);
		mercator[0] = ((coord[0] * Math.PI) / 180) * earthRad
		let a = (coord[1] * Math.PI) / 180
		mercator[1] = (earthRad / 2) * Math.log((1.0 + Math.sin(a)) / (1.0 - Math.sin(a)))
		return mercator
	}
	//
	function mercator2lnglat (coord) {
		const lnglat = []
		lnglat[0] = (coord[0] / 20037508.34) * 180
		const mmy = (coord[1] / 20037508.34) * 180
		lnglat[1] = (180 / Math.PI) * (2 * Math.atan(Math.exp((mmy * Math.PI) / 180)) - Math.PI / 2)
		return lnglat
	}

	class GIFTexture extends CanvasTexture {
		reader
		context
		frameNumber
		previousFrameInfo
		datas
		currentTime
		constructor(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
			super(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy)
			this.needsUpdate = false
			this.datas = []
			this.currentTime = -1
		}
		setReader (reader) {
			this.reader = reader
			this.image = document.createElement('canvas')
			this.image.width = reader.width
			this.image.height = reader.height
			this.context = this.image.getContext('2d')
			this.frameNumber = 0
			this.previousFrameInfo = null
			const nums = reader.numFrames()
			for (let i = 0; i < nums; i++) {
				const imageData = this.context.getImageData(0, 0, reader.width, reader.height)
				reader.decodeAndBlitFrameRGBA(i, imageData.data)
				this.datas.push(imageData)
			}
		}
		draw () {
			if (!this.reader) {
				return
			}
			const { reader, context } = this
			const frameNum = (this.frameNumber + 2) % reader.numFrames()
			if (this.currentTime == -1) {
				this.currentTime = new Date().getTime()
			}
			else {
				const nextTime = new Date().getTime()
				if (nextTime - this.currentTime < this.reader.frameInfo(frameNum).delay * 10) {
					return
				}
				else {
					this.currentTime = nextTime
				}
			}
			// always clear canvas to start
			context.clearRect(0, 0, reader.width, reader.height)
			context.putImageData(this.datas[frameNum], 0, 0)
			this.needsUpdate = true
			this.frameNumber++
		}
	}

	function createCommonjsModule (fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports
	}

	var omggif = createCommonjsModule(function (module, exports) {

		function GifWriter (buf, width, height, gopts) {
			var p = 0

			var gopts = gopts === undefined ? {} : gopts
			var loop_count = gopts.loop === undefined ? null : gopts.loop
			var global_palette = gopts.palette === undefined ? null : gopts.palette

			if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
				throw new Error("Width/Height invalid.")

			function check_palette_and_num_colors (palette) {
				var num_colors = palette.length
				if (num_colors < 2 || num_colors > 256 || num_colors & (num_colors - 1)) {
					throw new Error(
						"Invalid code/color length, must be power of 2 and 2 .. 256.")
				}
				return num_colors
			}

			// - Header.
			buf[p++] = 0x47; buf[p++] = 0x49; buf[p++] = 0x46  // GIF
			buf[p++] = 0x38; buf[p++] = 0x39; buf[p++] = 0x61  // 89a

			// Handling of Global Color Table (palette) and background index.
			var gp_num_colors_pow2 = 0
			var background = 0
			if (global_palette !== null) {
				var gp_num_colors = check_palette_and_num_colors(global_palette)
				while (gp_num_colors >>= 1) ++gp_num_colors_pow2
				gp_num_colors = 1 << gp_num_colors_pow2
				--gp_num_colors_pow2
				if (gopts.background !== undefined) {
					background = gopts.background
					if (background >= gp_num_colors)
						throw new Error("Background index out of range.")
					// The GIF spec states that a background index of 0 should be ignored, so
					// this is probably a mistake and you really want to set it to another
					// slot in the palette.  But actually in the end most browsers, etc end
					// up ignoring this almost completely (including for dispose background).
					if (background === 0)
						throw new Error("Background index explicitly passed as 0.")
				}
			}

			// - Logical Screen Descriptor.
			// NOTE(deanm): w/h apparently ignored by implementations, but set anyway.
			buf[p++] = width & 0xff; buf[p++] = width >> 8 & 0xff
			buf[p++] = height & 0xff; buf[p++] = height >> 8 & 0xff
			// NOTE: Indicates 0-bpp original color resolution (unused?).
			buf[p++] = (global_palette !== null ? 0x80 : 0) |  // Global Color Table Flag.
				gp_num_colors_pow2  // NOTE: No sort flag (unused?).
			buf[p++] = background  // Background Color Index.
			buf[p++] = 0  // Pixel aspect ratio (unused?).

			// - Global Color Table
			if (global_palette !== null) {
				for (var i = 0, il = global_palette.length; i < il; ++i) {
					var rgb = global_palette[i]
					buf[p++] = rgb >> 16 & 0xff
					buf[p++] = rgb >> 8 & 0xff
					buf[p++] = rgb & 0xff
				}
			}

			if (loop_count !== null) {  // Netscape block for looping.
				if (loop_count < 0 || loop_count > 65535)
					throw new Error("Loop count invalid.")
				// Extension code, label, and length.
				buf[p++] = 0x21; buf[p++] = 0xff; buf[p++] = 0x0b
				// NETSCAPE2.0
				buf[p++] = 0x4e; buf[p++] = 0x45; buf[p++] = 0x54; buf[p++] = 0x53
				buf[p++] = 0x43; buf[p++] = 0x41; buf[p++] = 0x50; buf[p++] = 0x45
				buf[p++] = 0x32; buf[p++] = 0x2e; buf[p++] = 0x30
				// Sub-block
				buf[p++] = 0x03; buf[p++] = 0x01
				buf[p++] = loop_count & 0xff; buf[p++] = loop_count >> 8 & 0xff
				buf[p++] = 0x00  // Terminator.
			}


			var ended = false

			this.addFrame = function (x, y, w, h, indexed_pixels, opts) {
				if (ended === true) { --p; ended = false }  // Un-end.

				opts = opts === undefined ? {} : opts

				// TODO(deanm): Bounds check x, y.  Do they need to be within the virtual
				// canvas width/height, I imagine?
				if (x < 0 || y < 0 || x > 65535 || y > 65535)
					throw new Error("x/y invalid.")

				if (w <= 0 || h <= 0 || w > 65535 || h > 65535)
					throw new Error("Width/Height invalid.")

				if (indexed_pixels.length < w * h)
					throw new Error("Not enough pixels for the frame size.")

				var using_local_palette = true
				var palette = opts.palette
				if (palette === undefined || palette === null) {
					using_local_palette = false
					palette = global_palette
				}

				if (palette === undefined || palette === null)
					throw new Error("Must supply either a local or global palette.")

				var num_colors = check_palette_and_num_colors(palette)

				// Compute the min_code_size (power of 2), destroying num_colors.
				var min_code_size = 0
				while (num_colors >>= 1) ++min_code_size
				num_colors = 1 << min_code_size  // Now we can easily get it back.

				var delay = opts.delay === undefined ? 0 : opts.delay

				// From the spec:
				//     0 -   No disposal specified. The decoder is
				//           not required to take any action.
				//     1 -   Do not dispose. The graphic is to be left
				//           in place.
				//     2 -   Restore to background color. The area used by the
				//           graphic must be restored to the background color.
				//     3 -   Restore to previous. The decoder is required to
				//           restore the area overwritten by the graphic with
				//           what was there prior to rendering the graphic.
				//  4-7 -    To be defined.
				// NOTE(deanm): Dispose background doesn't really work, apparently most
				// browsers ignore the background palette index and clear to transparency.
				var disposal = opts.disposal === undefined ? 0 : opts.disposal
				if (disposal < 0 || disposal > 3)  // 4-7 is reserved.
					throw new Error("Disposal out of range.")

				var use_transparency = false
				var transparent_index = 0
				if (opts.transparent !== undefined && opts.transparent !== null) {
					use_transparency = true
					transparent_index = opts.transparent
					if (transparent_index < 0 || transparent_index >= num_colors)
						throw new Error("Transparent color index.")
				}

				if (disposal !== 0 || use_transparency || delay !== 0) {
					// - Graphics Control Extension
					buf[p++] = 0x21; buf[p++] = 0xf9  // Extension / Label.
					buf[p++] = 4  // Byte size.

					buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0)
					buf[p++] = delay & 0xff; buf[p++] = delay >> 8 & 0xff
					buf[p++] = transparent_index  // Transparent color index.
					buf[p++] = 0  // Block Terminator.
				}

				// - Image Descriptor
				buf[p++] = 0x2c  // Image Seperator.
				buf[p++] = x & 0xff; buf[p++] = x >> 8 & 0xff  // Left.
				buf[p++] = y & 0xff; buf[p++] = y >> 8 & 0xff  // Top.
				buf[p++] = w & 0xff; buf[p++] = w >> 8 & 0xff
				buf[p++] = h & 0xff; buf[p++] = h >> 8 & 0xff
				// NOTE: No sort flag (unused?).
				// TODO(deanm): Support interlace.
				buf[p++] = using_local_palette === true ? (0x80 | (min_code_size - 1)) : 0

				// - Local Color Table
				if (using_local_palette === true) {
					for (var i = 0, il = palette.length; i < il; ++i) {
						var rgb = palette[i]
						buf[p++] = rgb >> 16 & 0xff
						buf[p++] = rgb >> 8 & 0xff
						buf[p++] = rgb & 0xff
					}
				}

				p = GifWriterOutputLZWCodeStream(
					buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels)

				return p
			}

			this.end = function () {
				if (ended === false) {
					buf[p++] = 0x3b  // Trailer.
					ended = true
				}
				return p
			}

			this.getOutputBuffer = function () { return buf }
			this.setOutputBuffer = function (v) { buf = v }
			this.getOutputBufferPosition = function () { return p }
			this.setOutputBufferPosition = function (v) { p = v }
		}

		// Main compression routine, palette indexes -> LZW code stream.
		// |index_stream| must have at least one entry.
		function GifWriterOutputLZWCodeStream (buf, p, min_code_size, index_stream) {
			buf[p++] = min_code_size
			var cur_subblock = p++  // Pointing at the length field.

			var clear_code = 1 << min_code_size
			var code_mask = clear_code - 1
			var eoi_code = clear_code + 1
			var next_code = eoi_code + 1

			var cur_code_size = min_code_size + 1  // Number of bits per code.
			var cur_shift = 0
			// We have at most 12-bit codes, so we should have to hold a max of 19
			// bits here (and then we would write out).
			var cur = 0

			function emit_bytes_to_buffer (bit_block_size) {
				while (cur_shift >= bit_block_size) {
					buf[p++] = cur & 0xff
					cur >>= 8; cur_shift -= 8
					if (p === cur_subblock + 256) {  // Finished a subblock.
						buf[cur_subblock] = 255
						cur_subblock = p++
					}
				}
			}

			function emit_code (c) {
				cur |= c << cur_shift
				cur_shift += cur_code_size
				emit_bytes_to_buffer(8)
			}

			// I am not an expert on the topic, and I don't want to write a thesis.
			// However, it is good to outline here the basic algorithm and the few data
			// structures and optimizations here that make this implementation fast.
			// The basic idea behind LZW is to build a table of previously seen runs
			// addressed by a short id (herein called output code).  All data is
			// referenced by a code, which represents one or more values from the
			// original input stream.  All input bytes can be referenced as the same
			// value as an output code.  So if you didn't want any compression, you
			// could more or less just output the original bytes as codes (there are
			// some details to this, but it is the idea).  In order to achieve
			// compression, values greater then the input range (codes can be up to
			// 12-bit while input only 8-bit) represent a sequence of previously seen
			// inputs.  The decompressor is able to build the same mapping while
			// decoding, so there is always a shared common knowledge between the
			// encoding and decoder, which is also important for "timing" aspects like
			// how to handle variable bit width code encoding.
			//
			// One obvious but very important consequence of the table system is there
			// is always a unique id (at most 12-bits) to map the runs.  'A' might be
			// 4, then 'AA' might be 10, 'AAA' 11, 'AAAA' 12, etc.  This relationship
			// can be used for an effecient lookup strategy for the code mapping.  We
			// need to know if a run has been seen before, and be able to map that run
			// to the output code.  Since we start with known unique ids (input bytes),
			// and then from those build more unique ids (table entries), we can
			// continue this chain (almost like a linked list) to always have small
			// integer values that represent the current byte chains in the encoder.
			// This means instead of tracking the input bytes (AAAABCD) to know our
			// current state, we can track the table entry for AAAABC (it is guaranteed
			// to exist by the nature of the algorithm) and the next character D.
			// Therefor the tuple of (table_entry, byte) is guaranteed to also be
			// unique.  This allows us to create a simple lookup key for mapping input
			// sequences to codes (table indices) without having to store or search
			// any of the code sequences.  So if 'AAAA' has a table entry of 12, the
			// tuple of ('AAAA', K) for any input byte K will be unique, and can be our
			// key.  This leads to a integer value at most 20-bits, which can always
			// fit in an SMI value and be used as a fast sparse array / object key.

			// Output code for the current contents of the index buffer.
			var ib_code = index_stream[0] & code_mask  // Load first input index.
			var code_table = {}  // Key'd on our 20-bit "tuple".

			emit_code(clear_code)  // Spec says first code should be a clear code.

			// First index already loaded, process the rest of the stream.
			for (var i = 1, il = index_stream.length; i < il; ++i) {
				var k = index_stream[i] & code_mask
				var cur_key = ib_code << 8 | k  // (prev, k) unique tuple.
				var cur_code = code_table[cur_key]  // buffer + k.

				// Check if we have to create a new code table entry.
				if (cur_code === undefined) {  // We don't have buffer + k.
					// Emit index buffer (without k).
					// This is an inline version of emit_code, because this is the core
					// writing routine of the compressor (and V8 cannot inline emit_code
					// because it is a closure here in a different context).  Additionally
					// we can call emit_byte_to_buffer less often, because we can have
					// 30-bits (from our 31-bit signed SMI), and we know our codes will only
					// be 12-bits, so can safely have 18-bits there without overflow.
					// emit_code(ib_code);
					cur |= ib_code << cur_shift
					cur_shift += cur_code_size
					while (cur_shift >= 8) {
						buf[p++] = cur & 0xff
						cur >>= 8; cur_shift -= 8
						if (p === cur_subblock + 256) {  // Finished a subblock.
							buf[cur_subblock] = 255
							cur_subblock = p++
						}
					}

					if (next_code === 4096) {  // Table full, need a clear.
						emit_code(clear_code)
						next_code = eoi_code + 1
						cur_code_size = min_code_size + 1
						code_table = {}
					} else {  // Table not full, insert a new entry.
						// Increase our variable bit code sizes if necessary.  This is a bit
						// tricky as it is based on "timing" between the encoding and
						// decoder.  From the encoders perspective this should happen after
						// we've already emitted the index buffer and are about to create the
						// first table entry that would overflow our current code bit size.
						if (next_code >= (1 << cur_code_size)) ++cur_code_size
						code_table[cur_key] = next_code++  // Insert into code table.
					}

					ib_code = k  // Index buffer to single input k.
				} else {
					ib_code = cur_code  // Index buffer to sequence in code table.
				}
			}

			emit_code(ib_code)  // There will still be something in the index buffer.
			emit_code(eoi_code)  // End Of Information.

			// Flush / finalize the sub-blocks stream to the buffer.
			emit_bytes_to_buffer(1)

			// Finish the sub-blocks, writing out any unfinished lengths and
			// terminating with a sub-block of length 0.  If we have already started
			// but not yet used a sub-block it can just become the terminator.
			if (cur_subblock + 1 === p) {  // Started but unused.
				buf[cur_subblock] = 0
			} else {  // Started and used, write length and additional terminator block.
				buf[cur_subblock] = p - cur_subblock - 1
				buf[p++] = 0
			}
			return p
		}

		function GifReader (buf) {
			var p = 0

			// - Header (GIF87a or GIF89a).
			if (buf[p++] !== 0x47 || buf[p++] !== 0x49 || buf[p++] !== 0x46 ||
				buf[p++] !== 0x38 || (buf[p++] + 1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {
				throw new Error("Invalid GIF 87a/89a header.")
			}

			// - Logical Screen Descriptor.
			var width = buf[p++] | buf[p++] << 8
			var height = buf[p++] | buf[p++] << 8
			var pf0 = buf[p++]  // <Packed Fields>.
			var global_palette_flag = pf0 >> 7
			var num_global_colors_pow2 = pf0 & 0x7
			var num_global_colors = 1 << (num_global_colors_pow2 + 1)
			buf[p++]
			buf[p++]  // Pixel aspect ratio (unused?).

			var global_palette_offset = null
			var global_palette_size = null

			if (global_palette_flag) {
				global_palette_offset = p
				global_palette_size = num_global_colors
				p += num_global_colors * 3  // Seek past palette.
			}

			var no_eof = true

			var frames = []

			var delay = 0
			var transparent_index = null
			var disposal = 0  // 0 - No disposal specified.
			var loop_count = null

			this.width = width
			this.height = height

			while (no_eof && p < buf.length) {
				switch (buf[p++]) {
					case 0x21:  // Graphics Control Extension Block
						switch (buf[p++]) {
							case 0xff:  // Application specific block
								// Try if it's a Netscape block (with animation loop counter).
								if (buf[p] !== 0x0b ||  // 21 FF already read, check block size.
									// NETSCAPE2.0
									buf[p + 1] == 0x4e && buf[p + 2] == 0x45 && buf[p + 3] == 0x54 &&
									buf[p + 4] == 0x53 && buf[p + 5] == 0x43 && buf[p + 6] == 0x41 &&
									buf[p + 7] == 0x50 && buf[p + 8] == 0x45 && buf[p + 9] == 0x32 &&
									buf[p + 10] == 0x2e && buf[p + 11] == 0x30 &&
									// Sub-block
									buf[p + 12] == 0x03 && buf[p + 13] == 0x01 && buf[p + 16] == 0) {
									p += 14
									loop_count = buf[p++] | buf[p++] << 8
									p++  // Skip terminator.
								} else {  // We don't know what it is, just try to get past it.
									p += 12
									while (true) {  // Seek through subblocks.
										var block_size = buf[p++]
										// Bad block size (ex: undefined from an out of bounds read).
										if (!(block_size >= 0)) throw Error("Invalid block size")
										if (block_size === 0) break  // 0 size is terminator
										p += block_size
									}
								}
								break

							case 0xf9:  // Graphics Control Extension
								if (buf[p++] !== 0x4 || buf[p + 4] !== 0)
									throw new Error("Invalid graphics extension block.")
								var pf1 = buf[p++]
								delay = buf[p++] | buf[p++] << 8
								transparent_index = buf[p++]
								if ((pf1 & 1) === 0) transparent_index = null
								disposal = pf1 >> 2 & 0x7
								p++  // Skip terminator.
								break

							case 0xfe:  // Comment Extension.
								while (true) {  // Seek through subblocks.
									var block_size = buf[p++]
									// Bad block size (ex: undefined from an out of bounds read).
									if (!(block_size >= 0)) throw Error("Invalid block size")
									if (block_size === 0) break  // 0 size is terminator
									// console.log(buf.slice(p, p+block_size).toString('ascii'));
									p += block_size
								}
								break

							default:
								throw new Error(
									"Unknown graphic control label: 0x" + buf[p - 1].toString(16))
						}
						break

					case 0x2c:  // Image Descriptor.
						var x = buf[p++] | buf[p++] << 8
						var y = buf[p++] | buf[p++] << 8
						var w = buf[p++] | buf[p++] << 8
						var h = buf[p++] | buf[p++] << 8
						var pf2 = buf[p++]
						var local_palette_flag = pf2 >> 7
						var interlace_flag = pf2 >> 6 & 1
						var num_local_colors_pow2 = pf2 & 0x7
						var num_local_colors = 1 << (num_local_colors_pow2 + 1)
						var palette_offset = global_palette_offset
						var palette_size = global_palette_size
						var has_local_palette = false
						if (local_palette_flag) {
							var has_local_palette = true
							palette_offset = p  // Override with local palette.
							palette_size = num_local_colors
							p += num_local_colors * 3  // Seek past palette.
						}

						var data_offset = p

						p++  // codesize
						while (true) {
							var block_size = buf[p++]
							// Bad block size (ex: undefined from an out of bounds read).
							if (!(block_size >= 0)) throw Error("Invalid block size")
							if (block_size === 0) break  // 0 size is terminator
							p += block_size
						}

						frames.push({
							x: x, y: y, width: w, height: h,
							has_local_palette: has_local_palette,
							palette_offset: palette_offset,
							palette_size: palette_size,
							data_offset: data_offset,
							data_length: p - data_offset,
							transparent_index: transparent_index,
							interlaced: !!interlace_flag,
							delay: delay,
							disposal: disposal
						})
						break

					case 0x3b:  // Trailer Marker (end of file).
						no_eof = false
						break

					default:
						throw new Error("Unknown gif block: 0x" + buf[p - 1].toString(16))
				}
			}

			this.numFrames = function () {
				return frames.length
			}

			this.loopCount = function () {
				return loop_count
			}

			this.frameInfo = function (frame_num) {
				if (frame_num < 0 || frame_num >= frames.length)
					throw new Error("Frame index out of range.")
				return frames[frame_num]
			}

			this.decodeAndBlitFrameBGRA = function (frame_num, pixels) {
				var frame = this.frameInfo(frame_num)
				var num_pixels = frame.width * frame.height
				var index_stream = new Uint8Array(num_pixels)  // At most 8-bit indices.
				GifReaderLZWOutputIndexStream(
					buf, frame.data_offset, index_stream, num_pixels)
				var palette_offset = frame.palette_offset

				// NOTE(deanm): It seems to be much faster to compare index to 256 than
				// to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
				// the profile, not sure if it's related to using a Uint8Array.
				var trans = frame.transparent_index
				if (trans === null) trans = 256

				// We are possibly just blitting to a portion of the entire frame.
				// That is a subrect within the framerect, so the additional pixels
				// must be skipped over after we finished a scanline.
				var framewidth = frame.width
				var framestride = width - framewidth
				var xleft = framewidth  // Number of subrect pixels left in scanline.

				// Output indicies of the top left and bottom right corners of the subrect.
				var opbeg = ((frame.y * width) + frame.x) * 4
				var opend = ((frame.y + frame.height) * width + frame.x) * 4
				var op = opbeg

				var scanstride = framestride * 4

				// Use scanstride to skip past the rows when interlacing.  This is skipping
				// 7 rows for the first two passes, then 3 then 1.
				if (frame.interlaced === true) {
					scanstride += width * 4 * 7  // Pass 1.
				}

				var interlaceskip = 8  // Tracking the row interval in the current pass.

				for (var i = 0, il = index_stream.length; i < il; ++i) {
					var index = index_stream[i]

					if (xleft === 0) {  // Beginning of new scan line
						op += scanstride
						xleft = framewidth
						if (op >= opend) { // Catch the wrap to switch passes when interlacing.
							scanstride = framestride * 4 + width * 4 * (interlaceskip - 1)
							// interlaceskip / 2 * 4 is interlaceskip << 1.
							op = opbeg + (framewidth + framestride) * (interlaceskip << 1)
							interlaceskip >>= 1
						}
					}

					if (index === trans) {
						op += 4
					} else {
						var r = buf[palette_offset + index * 3]
						var g = buf[palette_offset + index * 3 + 1]
						var b = buf[palette_offset + index * 3 + 2]
						pixels[op++] = b
						pixels[op++] = g
						pixels[op++] = r
						pixels[op++] = 255
					}
					--xleft
				}
			}

			// I will go to copy and paste hell one day...
			this.decodeAndBlitFrameRGBA = function (frame_num, pixels) {
				var frame = this.frameInfo(frame_num)
				var num_pixels = frame.width * frame.height
				var index_stream = new Uint8Array(num_pixels)  // At most 8-bit indices.
				GifReaderLZWOutputIndexStream(
					buf, frame.data_offset, index_stream, num_pixels)
				var palette_offset = frame.palette_offset

				// NOTE(deanm): It seems to be much faster to compare index to 256 than
				// to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
				// the profile, not sure if it's related to using a Uint8Array.
				var trans = frame.transparent_index
				if (trans === null) trans = 256

				// We are possibly just blitting to a portion of the entire frame.
				// That is a subrect within the framerect, so the additional pixels
				// must be skipped over after we finished a scanline.
				var framewidth = frame.width
				var framestride = width - framewidth
				var xleft = framewidth  // Number of subrect pixels left in scanline.

				// Output indicies of the top left and bottom right corners of the subrect.
				var opbeg = ((frame.y * width) + frame.x) * 4
				var opend = ((frame.y + frame.height) * width + frame.x) * 4
				var op = opbeg

				var scanstride = framestride * 4

				// Use scanstride to skip past the rows when interlacing.  This is skipping
				// 7 rows for the first two passes, then 3 then 1.
				if (frame.interlaced === true) {
					scanstride += width * 4 * 7  // Pass 1.
				}

				var interlaceskip = 8  // Tracking the row interval in the current pass.

				for (var i = 0, il = index_stream.length; i < il; ++i) {
					var index = index_stream[i]

					if (xleft === 0) {  // Beginning of new scan line
						op += scanstride
						xleft = framewidth
						if (op >= opend) { // Catch the wrap to switch passes when interlacing.
							scanstride = framestride * 4 + width * 4 * (interlaceskip - 1)
							// interlaceskip / 2 * 4 is interlaceskip << 1.
							op = opbeg + (framewidth + framestride) * (interlaceskip << 1)
							interlaceskip >>= 1
						}
					}

					if (index === trans) {
						op += 4
					} else {
						var r = buf[palette_offset + index * 3]
						var g = buf[palette_offset + index * 3 + 1]
						var b = buf[palette_offset + index * 3 + 2]
						pixels[op++] = r
						pixels[op++] = g
						pixels[op++] = b
						pixels[op++] = 255
					}
					--xleft
				}
			}
		}

		function GifReaderLZWOutputIndexStream (code_stream, p, output, output_length) {
			var min_code_size = code_stream[p++]

			var clear_code = 1 << min_code_size
			var eoi_code = clear_code + 1
			var next_code = eoi_code + 1

			var cur_code_size = min_code_size + 1  // Number of bits per code.
			// NOTE: This shares the same name as the encoder, but has a different
			// meaning here.  Here this masks each code coming from the code stream.
			var code_mask = (1 << cur_code_size) - 1
			var cur_shift = 0
			var cur = 0

			var op = 0  // Output pointer.

			var subblock_size = code_stream[p++]

			// TODO(deanm): Would using a TypedArray be any faster?  At least it would
			// solve the fast mode / backing store uncertainty.
			// var code_table = Array(4096);
			var code_table = new Int32Array(4096)  // Can be signed, we only use 20 bits.

			var prev_code = null  // Track code-1.

			while (true) {
				// Read up to two bytes, making sure we always 12-bits for max sized code.
				while (cur_shift < 16) {
					if (subblock_size === 0) break  // No more data to be read.

					cur |= code_stream[p++] << cur_shift
					cur_shift += 8

					if (subblock_size === 1) {  // Never let it get to 0 to hold logic above.
						subblock_size = code_stream[p++]  // Next subblock.
					} else {
						--subblock_size
					}
				}

				// TODO(deanm): We should never really get here, we should have received
				// and EOI.
				if (cur_shift < cur_code_size)
					break

				var code = cur & code_mask
				cur >>= cur_code_size
				cur_shift -= cur_code_size

				// TODO(deanm): Maybe should check that the first code was a clear code,
				// at least this is what you're supposed to do.  But actually our encoder
				// now doesn't emit a clear code first anyway.
				if (code === clear_code) {
					// We don't actually have to clear the table.  This could be a good idea
					// for greater error checking, but we don't really do any anyway.  We
					// will just track it with next_code and overwrite old entries.

					next_code = eoi_code + 1
					cur_code_size = min_code_size + 1
					code_mask = (1 << cur_code_size) - 1

					// Don't update prev_code ?
					prev_code = null
					continue
				} else if (code === eoi_code) {
					break
				}

				// We have a similar situation as the decoder, where we want to store
				// variable length entries (code table entries), but we want to do in a
				// faster manner than an array of arrays.  The code below stores sort of a
				// linked list within the code table, and then "chases" through it to
				// construct the dictionary entries.  When a new entry is created, just the
				// last byte is stored, and the rest (prefix) of the entry is only
				// referenced by its table entry.  Then the code chases through the
				// prefixes until it reaches a single byte code.  We have to chase twice,
				// first to compute the length, and then to actually copy the data to the
				// output (backwards, since we know the length).  The alternative would be
				// storing something in an intermediate stack, but that doesn't make any
				// more sense.  I implemented an approach where it also stored the length
				// in the code table, although it's a bit tricky because you run out of
				// bits (12 + 12 + 8), but I didn't measure much improvements (the table
				// entries are generally not the long).  Even when I created benchmarks for
				// very long table entries the complexity did not seem worth it.
				// The code table stores the prefix entry in 12 bits and then the suffix
				// byte in 8 bits, so each entry is 20 bits.

				var chase_code = code < next_code ? code : prev_code

				// Chase what we will output, either {CODE} or {CODE-1}.
				var chase_length = 0
				var chase = chase_code
				while (chase > clear_code) {
					chase = code_table[chase] >> 8
					++chase_length
				}

				var k = chase

				var op_end = op + chase_length + (chase_code !== code ? 1 : 0)
				if (op_end > output_length) {
					console.log("Warning, gif stream longer than expected.")
					return
				}

				// Already have the first byte from the chase, might as well write it fast.
				output[op++] = k

				op += chase_length
				var b = op  // Track pointer, writing backwards.

				if (chase_code !== code)  // The case of emitting {CODE-1} + k.
					output[op++] = k

				chase = chase_code
				while (chase_length--) {
					chase = code_table[chase]
					output[--b] = chase & 0xff  // Write backwards.
					chase >>= 8  // Pull down to the prefix code.
				}

				if (prev_code !== null && next_code < 4096) {
					code_table[next_code++] = prev_code << 8 | k
					// TODO(deanm): Figure out this clearing vs code growth logic better.  I
					// have an feeling that it should just happen somewhere else, for now it
					// is awkward between when we grow past the max and then hit a clear code.
					// For now just check if we hit the max 12-bits (then a clear code should
					// follow, also of course encoded in 12-bits).
					if (next_code >= code_mask + 1 && cur_code_size < 12) {
						++cur_code_size
						code_mask = code_mask << 1 | 1
					}
				}

				prev_code = code
			}

			if (op !== output_length) {
				console.log("Warning, gif stream shorter than expected.")
			}

			return output
		}

		// CommonJS.
		try { exports.GifWriter = GifWriter; exports.GifReader = GifReader } catch (e) { }
	})
	omggif.GifWriter
	var omggif_2 = omggif.GifReader

	class GifLoader {
		manager
		crossOrigin
		path
		texture
		constructor(manager) {
			this.manager = manager || DefaultLoadingManager
			this.crossOrigin = 'anonymous'
			this.texture = new GIFTexture()
		}
		load (url, onLoad, onProgress, onError) {
			const loader = new FileLoader(this.manager)
			loader.setPath(this.path)
			loader.setResponseType('arraybuffer')
			loader.load(url, (response) => {
				const gifData = new Uint8Array(response)
				const reader = new omggif_2(gifData)
				this.texture.setReader(reader)
				if (onLoad)
					onLoad(this.texture)
			}, onProgress, onError)
			return this.texture
		}
		setPath (value) {
			this.path = value
			return this
		}
	}

	const _raycaster = new Raycaster()

	const _tempVector = new Vector3()
	const _tempVector2 = new Vector3()
	const _tempQuaternion = new Quaternion()
	const _unit = {
		X: new Vector3(1, 0, 0),
		Y: new Vector3(0, 1, 0),
		Z: new Vector3(0, 0, 1)
	}

	const _changeEvent = { type: 'change' }
	const _mouseDownEvent = { type: 'mouseDown' }
	const _mouseUpEvent = { type: 'mouseUp', mode: null }
	const _objectChangeEvent = { type: 'objectChange' }

	class TransformControls extends Object3D {

		constructor(camera, domElement) {

			super()

			if (domElement === undefined) {

				console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.')
				domElement = document

			}

			this.visible = false
			this.domElement = domElement
			this.domElement.style.touchAction = 'none' // disable touch scroll

			const _gizmo = new TransformControlsGizmo()
			this._gizmo = _gizmo
			this.add(_gizmo)

			const _plane = new TransformControlsPlane()
			this._plane = _plane
			this.add(_plane)

			const scope = this

			// Defined getter, setter and store for a property
			function defineProperty (propName, defaultValue) {

				let propValue = defaultValue

				Object.defineProperty(scope, propName, {

					get: function () {

						return propValue !== undefined ? propValue : defaultValue

					},

					set: function (value) {

						if (propValue !== value) {

							propValue = value
							_plane[propName] = value
							_gizmo[propName] = value

							scope.dispatchEvent({ type: propName + '-changed', value: value })
							scope.dispatchEvent(_changeEvent)

						}

					}

				})

				scope[propName] = defaultValue
				_plane[propName] = defaultValue
				_gizmo[propName] = defaultValue

			}

			// Define properties with getters/setter
			// Setting the defined property will automatically trigger change event
			// Defined properties are passed down to gizmo and plane

			defineProperty('camera', camera)
			defineProperty('object', undefined)
			defineProperty('enabled', true)
			defineProperty('axis', null)
			defineProperty('mode', 'translate')
			defineProperty('translationSnap', null)
			defineProperty('rotationSnap', null)
			defineProperty('scaleSnap', null)
			defineProperty('space', 'world')
			defineProperty('size', 1)
			defineProperty('dragging', false)
			defineProperty('showX', true)
			defineProperty('showY', true)
			defineProperty('showZ', true)

			// Reusable utility variables

			const worldPosition = new Vector3()
			const worldPositionStart = new Vector3()
			const worldQuaternion = new Quaternion()
			const worldQuaternionStart = new Quaternion()
			const cameraPosition = new Vector3()
			const cameraQuaternion = new Quaternion()
			const pointStart = new Vector3()
			const pointEnd = new Vector3()
			const rotationAxis = new Vector3()
			const rotationAngle = 0
			const eye = new Vector3()

			// TODO: remove properties unused in plane and gizmo

			defineProperty('worldPosition', worldPosition)
			defineProperty('worldPositionStart', worldPositionStart)
			defineProperty('worldQuaternion', worldQuaternion)
			defineProperty('worldQuaternionStart', worldQuaternionStart)
			defineProperty('cameraPosition', cameraPosition)
			defineProperty('cameraQuaternion', cameraQuaternion)
			defineProperty('pointStart', pointStart)
			defineProperty('pointEnd', pointEnd)
			defineProperty('rotationAxis', rotationAxis)
			defineProperty('rotationAngle', rotationAngle)
			defineProperty('eye', eye)

			this._offset = new Vector3()
			this._startNorm = new Vector3()
			this._endNorm = new Vector3()
			this._cameraScale = new Vector3()

			this._parentPosition = new Vector3()
			this._parentQuaternion = new Quaternion()
			this._parentQuaternionInv = new Quaternion()
			this._parentScale = new Vector3()

			this._worldScaleStart = new Vector3()
			this._worldQuaternionInv = new Quaternion()
			this._worldScale = new Vector3()

			this._positionStart = new Vector3()
			this._quaternionStart = new Quaternion()
			this._scaleStart = new Vector3()

			this._getPointer = getPointer.bind(this)
			this._onPointerDown = onPointerDown.bind(this)
			this._onPointerHover = onPointerHover.bind(this)
			this._onPointerMove = onPointerMove.bind(this)
			this._onPointerUp = onPointerUp.bind(this)

			this.domElement.addEventListener('pointerdown', this._onPointerDown)
			this.domElement.addEventListener('pointermove', this._onPointerHover)
			this.domElement.addEventListener('pointerup', this._onPointerUp)

		}

		// updateMatrixWorld  updates key transformation variables
		updateMatrixWorld () {

			if (this.object !== undefined) {

				this.object.updateMatrixWorld()

				if (this.object.parent === null) {

					console.error('TransformControls: The attached 3D object must be a part of the scene graph.')

				} else {

					this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale)

				}

				this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale)

				this._parentQuaternionInv.copy(this._parentQuaternion).invert()
				this._worldQuaternionInv.copy(this.worldQuaternion).invert()

			}

			this.camera.updateMatrixWorld()
			this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale)

			this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize()

			super.updateMatrixWorld(this)

		}

		pointerHover (pointer) {

			if (this.object === undefined || this.dragging === true) return

			_raycaster.setFromCamera(pointer, this.camera)

			const intersect = intersectObjectWithRay(this._gizmo.picker[this.mode], _raycaster)

			if (intersect) {

				this.axis = intersect.object.name

			} else {

				this.axis = null

			}

		}

		pointerDown (pointer) {

			if (this.object === undefined || this.dragging === true || pointer.button !== 0) return

			if (this.axis !== null) {

				_raycaster.setFromCamera(pointer, this.camera)

				const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true)

				if (planeIntersect) {

					let space = this.space

					if (this.mode === 'scale') {

						space = 'local'

					} else if (this.axis === 'E' || this.axis === 'XYZE' || this.axis === 'XYZ') {

						space = 'world'

					}

					if (space === 'local' && this.mode === 'rotate') {

						const snap = this.rotationSnap

						if (this.axis === 'X' && snap) this.object.rotation.x = Math.round(this.object.rotation.x / snap) * snap
						if (this.axis === 'Y' && snap) this.object.rotation.y = Math.round(this.object.rotation.y / snap) * snap
						if (this.axis === 'Z' && snap) this.object.rotation.z = Math.round(this.object.rotation.z / snap) * snap

					}

					this.object.updateMatrixWorld()
					this.object.parent.updateMatrixWorld()

					this._positionStart.copy(this.object.position)
					this._quaternionStart.copy(this.object.quaternion)
					this._scaleStart.copy(this.object.scale)

					this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart)

					this.pointStart.copy(planeIntersect.point).sub(this.worldPositionStart)

				}

				this.dragging = true
				_mouseDownEvent.mode = this.mode
				this.dispatchEvent(_mouseDownEvent)

			}

		}

		pointerMove (pointer) {

			const axis = this.axis
			const mode = this.mode
			const object = this.object
			let space = this.space

			if (mode === 'scale') {

				space = 'local'

			} else if (axis === 'E' || axis === 'XYZE' || axis === 'XYZ') {

				space = 'world'

			}

			if (object === undefined || axis === null || this.dragging === false || pointer.button !== - 1) return

			_raycaster.setFromCamera(pointer, this.camera)

			const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true)

			if (!planeIntersect) return

			this.pointEnd.copy(planeIntersect.point).sub(this.worldPositionStart)

			if (mode === 'translate') {

				// Apply translate

				this._offset.copy(this.pointEnd).sub(this.pointStart)

				if (space === 'local' && axis !== 'XYZ') {

					this._offset.applyQuaternion(this._worldQuaternionInv)

				}

				if (axis.indexOf('X') === - 1) this._offset.x = 0
				if (axis.indexOf('Y') === - 1) this._offset.y = 0
				if (axis.indexOf('Z') === - 1) this._offset.z = 0

				if (space === 'local' && axis !== 'XYZ') {

					this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale)

				} else {

					this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale)

				}

				object.position.copy(this._offset).add(this._positionStart)

				// Apply translation snap

				if (this.translationSnap) {

					if (space === 'local') {

						object.position.applyQuaternion(_tempQuaternion.copy(this._quaternionStart).invert())

						if (axis.search('X') !== - 1) {

							object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap

						}

						if (axis.search('Y') !== - 1) {

							object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap

						}

						if (axis.search('Z') !== - 1) {

							object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap

						}

						object.position.applyQuaternion(this._quaternionStart)

					}

					if (space === 'world') {

						if (object.parent) {

							object.position.add(_tempVector.setFromMatrixPosition(object.parent.matrixWorld))

						}

						if (axis.search('X') !== - 1) {

							object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap

						}

						if (axis.search('Y') !== - 1) {

							object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap

						}

						if (axis.search('Z') !== - 1) {

							object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap

						}

						if (object.parent) {

							object.position.sub(_tempVector.setFromMatrixPosition(object.parent.matrixWorld))

						}

					}

				}

			} else if (mode === 'scale') {

				if (axis.search('XYZ') !== - 1) {

					let d = this.pointEnd.length() / this.pointStart.length()

					if (this.pointEnd.dot(this.pointStart) < 0) d *= - 1

					_tempVector2.set(d, d, d)

				} else {

					_tempVector.copy(this.pointStart)
					_tempVector2.copy(this.pointEnd)

					_tempVector.applyQuaternion(this._worldQuaternionInv)
					_tempVector2.applyQuaternion(this._worldQuaternionInv)

					_tempVector2.divide(_tempVector)

					if (axis.search('X') === - 1) {

						_tempVector2.x = 1

					}

					if (axis.search('Y') === - 1) {

						_tempVector2.y = 1

					}

					if (axis.search('Z') === - 1) {

						_tempVector2.z = 1

					}

				}

				// Apply scale

				object.scale.copy(this._scaleStart).multiply(_tempVector2)

				if (this.scaleSnap) {

					if (axis.search('X') !== - 1) {

						object.scale.x = Math.round(object.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap

					}

					if (axis.search('Y') !== - 1) {

						object.scale.y = Math.round(object.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap

					}

					if (axis.search('Z') !== - 1) {

						object.scale.z = Math.round(object.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap

					}

				}

			} else if (mode === 'rotate') {

				this._offset.copy(this.pointEnd).sub(this.pointStart)

				const ROTATION_SPEED = 20 / this.worldPosition.distanceTo(_tempVector.setFromMatrixPosition(this.camera.matrixWorld))

				if (axis === 'E') {

					this.rotationAxis.copy(this.eye)
					this.rotationAngle = this.pointEnd.angleTo(this.pointStart)

					this._startNorm.copy(this.pointStart).normalize()
					this._endNorm.copy(this.pointEnd).normalize()

					this.rotationAngle *= (this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : - 1)

				} else if (axis === 'XYZE') {

					this.rotationAxis.copy(this._offset).cross(this.eye).normalize()
					this.rotationAngle = this._offset.dot(_tempVector.copy(this.rotationAxis).cross(this.eye)) * ROTATION_SPEED

				} else if (axis === 'X' || axis === 'Y' || axis === 'Z') {

					this.rotationAxis.copy(_unit[axis])

					_tempVector.copy(_unit[axis])

					if (space === 'local') {

						_tempVector.applyQuaternion(this.worldQuaternion)

					}

					this.rotationAngle = this._offset.dot(_tempVector.cross(this.eye).normalize()) * ROTATION_SPEED

				}

				// Apply rotation snap

				if (this.rotationSnap) this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap

				// Apply rotate
				if (space === 'local' && axis !== 'E' && axis !== 'XYZE') {

					object.quaternion.copy(this._quaternionStart)
					object.quaternion.multiply(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()

				} else {

					this.rotationAxis.applyQuaternion(this._parentQuaternionInv)
					object.quaternion.copy(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle))
					object.quaternion.multiply(this._quaternionStart).normalize()

				}

			}

			this.dispatchEvent(_changeEvent)
			this.dispatchEvent(_objectChangeEvent)

		}

		pointerUp (pointer) {

			if (pointer.button !== 0) return

			if (this.dragging && (this.axis !== null)) {

				_mouseUpEvent.mode = this.mode
				this.dispatchEvent(_mouseUpEvent)

			}

			this.dragging = false
			this.axis = null

		}

		dispose () {

			this.domElement.removeEventListener('pointerdown', this._onPointerDown)
			this.domElement.removeEventListener('pointermove', this._onPointerHover)
			this.domElement.removeEventListener('pointermove', this._onPointerMove)
			this.domElement.removeEventListener('pointerup', this._onPointerUp)

			this.traverse(function (child) {

				if (child.geometry) child.geometry.dispose()
				if (child.material) child.material.dispose()

			})

		}

		// Set current object
		attach (object) {

			this.object = object
			this.visible = true

			return this

		}

		// Detatch from object
		detach () {

			this.object = undefined
			this.visible = false
			this.axis = null

			return this

		}

		getRaycaster () {

			return _raycaster

		}

		// TODO: deprecate

		getMode () {

			return this.mode

		}

		setMode (mode) {

			this.mode = mode

		}

		setTranslationSnap (translationSnap) {

			this.translationSnap = translationSnap

		}

		setRotationSnap (rotationSnap) {

			this.rotationSnap = rotationSnap

		}

		setScaleSnap (scaleSnap) {

			this.scaleSnap = scaleSnap

		}

		setSize (size) {

			this.size = size

		}

		setSpace (space) {

			this.space = space

		}

		update () {

			console.warn('THREE.TransformControls: update function has no more functionality and therefore has been deprecated.')

		}

	}

	TransformControls.prototype.isTransformControls = true

	// mouse / touch event handlers

	function getPointer (event) {

		if (this.domElement.ownerDocument.pointerLockElement) {

			return {
				x: 0,
				y: 0,
				button: event.button
			}

		} else {

			const rect = this.domElement.getBoundingClientRect()

			return {
				x: (event.clientX - rect.left) / rect.width * 2 - 1,
				y: - (event.clientY - rect.top) / rect.height * 2 + 1,
				button: event.button
			}

		}

	}

	function onPointerHover (event) {

		if (!this.enabled) return

		switch (event.pointerType) {

			case 'mouse':
			case 'pen':
				this.pointerHover(this._getPointer(event))
				break

		}

	}

	function onPointerDown (event) {

		if (!this.enabled) return

		this.domElement.setPointerCapture(event.pointerId)

		this.domElement.addEventListener('pointermove', this._onPointerMove)

		this.pointerHover(this._getPointer(event))
		this.pointerDown(this._getPointer(event))

	}

	function onPointerMove (event) {

		if (!this.enabled) return

		this.pointerMove(this._getPointer(event))

	}

	function onPointerUp (event) {

		if (!this.enabled) return

		this.domElement.releasePointerCapture(event.pointerId)

		this.domElement.removeEventListener('pointermove', this._onPointerMove)

		this.pointerUp(this._getPointer(event))

	}

	function intersectObjectWithRay (object, raycaster, includeInvisible) {

		const allIntersections = raycaster.intersectObject(object, true)

		for (let i = 0; i < allIntersections.length; i++) {

			if (allIntersections[i].object.visible || includeInvisible) {

				return allIntersections[i]

			}

		}

		return false

	}

	//

	// Reusable utility variables

	const _tempEuler = new Euler()
	const _alignVector = new Vector3(0, 1, 0)
	const _zeroVector = new Vector3(0, 0, 0)
	const _lookAtMatrix = new Matrix4()
	const _tempQuaternion2 = new Quaternion()
	const _identityQuaternion = new Quaternion()
	const _dirVector = new Vector3()
	const _tempMatrix = new Matrix4()

	const _unitX = new Vector3(1, 0, 0)
	const _unitY = new Vector3(0, 1, 0)
	const _unitZ = new Vector3(0, 0, 1)

	const _v1 = new Vector3()
	const _v2 = new Vector3()
	const _v3 = new Vector3()

	class TransformControlsGizmo extends Object3D {

		constructor() {

			super()

			this.type = 'TransformControlsGizmo'

			// shared materials

			const gizmoMaterial = new MeshBasicMaterial({
				depthTest: false,
				depthWrite: false,
				fog: false,
				toneMapped: false,
				transparent: true
			})

			const gizmoLineMaterial = new LineBasicMaterial({
				depthTest: false,
				depthWrite: false,
				fog: false,
				toneMapped: false,
				transparent: true
			})

			// Make unique material for each axis/color

			const matInvisible = gizmoMaterial.clone()
			matInvisible.opacity = 0.15

			const matHelper = gizmoLineMaterial.clone()
			matHelper.opacity = 0.5

			const matRed = gizmoMaterial.clone()
			matRed.color.setHex(0xff0000)

			const matGreen = gizmoMaterial.clone()
			matGreen.color.setHex(0x00ff00)

			const matBlue = gizmoMaterial.clone()
			matBlue.color.setHex(0x0000ff)

			const matRedTransparent = gizmoMaterial.clone()
			matRedTransparent.color.setHex(0xff0000)
			matRedTransparent.opacity = 0.5

			const matGreenTransparent = gizmoMaterial.clone()
			matGreenTransparent.color.setHex(0x00ff00)
			matGreenTransparent.opacity = 0.5

			const matBlueTransparent = gizmoMaterial.clone()
			matBlueTransparent.color.setHex(0x0000ff)
			matBlueTransparent.opacity = 0.5

			const matWhiteTransparent = gizmoMaterial.clone()
			matWhiteTransparent.opacity = 0.25

			const matYellowTransparent = gizmoMaterial.clone()
			matYellowTransparent.color.setHex(0xffff00)
			matYellowTransparent.opacity = 0.25

			const matYellow = gizmoMaterial.clone()
			matYellow.color.setHex(0xffff00)

			const matGray = gizmoMaterial.clone()
			matGray.color.setHex(0x787878)

			// reusable geometry

			const arrowGeometry = new CylinderGeometry(0, 0.04, 0.1, 12)
			arrowGeometry.translate(0, 0.05, 0)

			const scaleHandleGeometry = new BoxGeometry(0.08, 0.08, 0.08)
			scaleHandleGeometry.translate(0, 0.04, 0)

			const lineGeometry = new BufferGeometry()
			lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3))

			const lineGeometry2 = new CylinderGeometry(0.0075, 0.0075, 0.5, 3)
			lineGeometry2.translate(0, 0.25, 0)

			function CircleGeometry (radius, arc) {

				const geometry = new TorusGeometry(radius, 0.0075, 3, 64, arc * Math.PI * 2)
				geometry.rotateY(Math.PI / 2)
				geometry.rotateX(Math.PI / 2)
				return geometry

			}

			// Special geometry for transform helper. If scaled with position vector it spans from [0,0,0] to position

			function TranslateHelperGeometry () {

				const geometry = new BufferGeometry()

				geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3))

				return geometry

			}

			// Gizmo definitions - custom hierarchy definitions for setupGizmo() function

			const gizmoTranslate = {
				X: [
					[new Mesh(arrowGeometry, matRed), [0.5, 0, 0], [0, 0, - Math.PI / 2]],
					[new Mesh(arrowGeometry, matRed), [- 0.5, 0, 0], [0, 0, Math.PI / 2]],
					[new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, - Math.PI / 2]]
				],
				Y: [
					[new Mesh(arrowGeometry, matGreen), [0, 0.5, 0]],
					[new Mesh(arrowGeometry, matGreen), [0, - 0.5, 0], [Math.PI, 0, 0]],
					[new Mesh(lineGeometry2, matGreen)]
				],
				Z: [
					[new Mesh(arrowGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
					[new Mesh(arrowGeometry, matBlue), [0, 0, - 0.5], [- Math.PI / 2, 0, 0]],
					[new Mesh(lineGeometry2, matBlue), null, [Math.PI / 2, 0, 0]]
				],
				XYZ: [
					[new Mesh(new OctahedronGeometry(0.1, 0), matWhiteTransparent.clone()), [0, 0, 0]]
				],
				XY: [
					[new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent.clone()), [0.15, 0.15, 0]]
				],
				YZ: [
					[new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
				],
				XZ: [
					[new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent.clone()), [0.15, 0, 0.15], [- Math.PI / 2, 0, 0]]
				]
			}

			const pickerTranslate = {
				X: [
					[new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, - Math.PI / 2]],
					[new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [- 0.3, 0, 0], [0, 0, Math.PI / 2]]
				],
				Y: [
					[new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
					[new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, - 0.3, 0], [0, 0, Math.PI]]
				],
				Z: [
					[new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
					[new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, - 0.3], [- Math.PI / 2, 0, 0]]
				],
				XYZ: [
					[new Mesh(new OctahedronGeometry(0.2, 0), matInvisible)]
				],
				XY: [
					[new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
				],
				YZ: [
					[new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
				],
				XZ: [
					[new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [- Math.PI / 2, 0, 0]]
				]
			}

			const helperTranslate = {
				START: [
					[new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, 'helper']
				],
				END: [
					[new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, 'helper']
				],
				DELTA: [
					[new Line(TranslateHelperGeometry(), matHelper), null, null, null, 'helper']
				],
				X: [
					[new Line(lineGeometry, matHelper.clone()), [- 1e3, 0, 0], null, [1e6, 1, 1], 'helper']
				],
				Y: [
					[new Line(lineGeometry, matHelper.clone()), [0, - 1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], 'helper']
				],
				Z: [
					[new Line(lineGeometry, matHelper.clone()), [0, 0, - 1e3], [0, - Math.PI / 2, 0], [1e6, 1, 1], 'helper']
				]
			}

			const gizmoRotate = {
				XYZE: [
					[new Mesh(CircleGeometry(0.5, 1), matGray), null, [0, Math.PI / 2, 0]]
				],
				X: [
					[new Mesh(CircleGeometry(0.5, 0.5), matRed)]
				],
				Y: [
					[new Mesh(CircleGeometry(0.5, 0.5), matGreen), null, [0, 0, - Math.PI / 2]]
				],
				Z: [
					[new Mesh(CircleGeometry(0.5, 0.5), matBlue), null, [0, Math.PI / 2, 0]]
				],
				E: [
					[new Mesh(CircleGeometry(0.75, 1), matYellowTransparent), null, [0, Math.PI / 2, 0]]
				]
			}

			const helperRotate = {
				AXIS: [
					[new Line(lineGeometry, matHelper.clone()), [- 1e3, 0, 0], null, [1e6, 1, 1], 'helper']
				]
			}

			const pickerRotate = {
				XYZE: [
					[new Mesh(new SphereGeometry(0.25, 10, 8), matInvisible)]
				],
				X: [
					[new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, - Math.PI / 2, - Math.PI / 2]],
				],
				Y: [
					[new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [Math.PI / 2, 0, 0]],
				],
				Z: [
					[new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, 0, - Math.PI / 2]],
				],
				E: [
					[new Mesh(new TorusGeometry(0.75, 0.1, 2, 24), matInvisible)]
				]
			}

			const gizmoScale = {
				X: [
					[new Mesh(scaleHandleGeometry, matRed), [0.5, 0, 0], [0, 0, - Math.PI / 2]],
					[new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, - Math.PI / 2]],
					[new Mesh(scaleHandleGeometry, matRed), [- 0.5, 0, 0], [0, 0, Math.PI / 2]],
				],
				Y: [
					[new Mesh(scaleHandleGeometry, matGreen), [0, 0.5, 0]],
					[new Mesh(lineGeometry2, matGreen)],
					[new Mesh(scaleHandleGeometry, matGreen), [0, - 0.5, 0], [0, 0, Math.PI]],
				],
				Z: [
					[new Mesh(scaleHandleGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
					[new Mesh(lineGeometry2, matBlue), [0, 0, 0], [Math.PI / 2, 0, 0]],
					[new Mesh(scaleHandleGeometry, matBlue), [0, 0, - 0.5], [- Math.PI / 2, 0, 0]]
				],
				XY: [
					[new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent), [0.15, 0.15, 0]]
				],
				YZ: [
					[new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
				],
				XZ: [
					[new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent), [0.15, 0, 0.15], [- Math.PI / 2, 0, 0]]
				],
				XYZ: [
					[new Mesh(new BoxGeometry(0.1, 0.1, 0.1), matWhiteTransparent.clone())],
				]
			}

			const pickerScale = {
				X: [
					[new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, - Math.PI / 2]],
					[new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [- 0.3, 0, 0], [0, 0, Math.PI / 2]]
				],
				Y: [
					[new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
					[new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, - 0.3, 0], [0, 0, Math.PI]]
				],
				Z: [
					[new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
					[new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, - 0.3], [- Math.PI / 2, 0, 0]]
				],
				XY: [
					[new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]],
				],
				YZ: [
					[new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]],
				],
				XZ: [
					[new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [- Math.PI / 2, 0, 0]],
				],
				XYZ: [
					[new Mesh(new BoxGeometry(0.2, 0.2, 0.2), matInvisible), [0, 0, 0]],
				]
			}

			const helperScale = {
				X: [
					[new Line(lineGeometry, matHelper.clone()), [- 1e3, 0, 0], null, [1e6, 1, 1], 'helper']
				],
				Y: [
					[new Line(lineGeometry, matHelper.clone()), [0, - 1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], 'helper']
				],
				Z: [
					[new Line(lineGeometry, matHelper.clone()), [0, 0, - 1e3], [0, - Math.PI / 2, 0], [1e6, 1, 1], 'helper']
				]
			}

			// Creates an Object3D with gizmos described in custom hierarchy definition.

			function setupGizmo (gizmoMap) {

				const gizmo = new Object3D()

				for (const name in gizmoMap) {

					for (let i = gizmoMap[name].length; i--;) {

						const object = gizmoMap[name][i][0].clone()
						const position = gizmoMap[name][i][1]
						const rotation = gizmoMap[name][i][2]
						const scale = gizmoMap[name][i][3]
						const tag = gizmoMap[name][i][4]

						// name and tag properties are essential for picking and updating logic.
						object.name = name
						object.tag = tag

						if (position) {

							object.position.set(position[0], position[1], position[2])

						}

						if (rotation) {

							object.rotation.set(rotation[0], rotation[1], rotation[2])

						}

						if (scale) {

							object.scale.set(scale[0], scale[1], scale[2])

						}

						object.updateMatrix()

						const tempGeometry = object.geometry.clone()
						tempGeometry.applyMatrix4(object.matrix)
						object.geometry = tempGeometry
						object.renderOrder = Infinity

						object.position.set(0, 0, 0)
						object.rotation.set(0, 0, 0)
						object.scale.set(1, 1, 1)

						gizmo.add(object)

					}

				}

				return gizmo

			}

			// Gizmo creation

			this.gizmo = {}
			this.picker = {}
			this.helper = {}

			this.add(this.gizmo['translate'] = setupGizmo(gizmoTranslate))
			this.add(this.gizmo['rotate'] = setupGizmo(gizmoRotate))
			this.add(this.gizmo['scale'] = setupGizmo(gizmoScale))
			this.add(this.picker['translate'] = setupGizmo(pickerTranslate))
			this.add(this.picker['rotate'] = setupGizmo(pickerRotate))
			this.add(this.picker['scale'] = setupGizmo(pickerScale))
			this.add(this.helper['translate'] = setupGizmo(helperTranslate))
			this.add(this.helper['rotate'] = setupGizmo(helperRotate))
			this.add(this.helper['scale'] = setupGizmo(helperScale))

			// Pickers should be hidden always

			this.picker['translate'].visible = false
			this.picker['rotate'].visible = false
			this.picker['scale'].visible = false

		}

		// updateMatrixWorld will update transformations and appearance of individual handles

		updateMatrixWorld (force) {

			const space = (this.mode === 'scale') ? 'local' : this.space // scale always oriented to local rotation

			const quaternion = (space === 'local') ? this.worldQuaternion : _identityQuaternion

			// Show only gizmos for current transform mode

			this.gizmo['translate'].visible = this.mode === 'translate'
			this.gizmo['rotate'].visible = this.mode === 'rotate'
			this.gizmo['scale'].visible = this.mode === 'scale'

			this.helper['translate'].visible = this.mode === 'translate'
			this.helper['rotate'].visible = this.mode === 'rotate'
			this.helper['scale'].visible = this.mode === 'scale'


			let handles = []
			handles = handles.concat(this.picker[this.mode].children)
			handles = handles.concat(this.gizmo[this.mode].children)
			handles = handles.concat(this.helper[this.mode].children)

			for (let i = 0; i < handles.length; i++) {

				const handle = handles[i]

				// hide aligned to camera

				handle.visible = true
				handle.rotation.set(0, 0, 0)
				handle.position.copy(this.worldPosition)

				let factor

				if (this.camera.isOrthographicCamera) {

					factor = (this.camera.top - this.camera.bottom) / this.camera.zoom

				} else {

					factor = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7)

				}

				handle.scale.set(1, 1, 1).multiplyScalar(factor * this.size / 4)

				// TODO: simplify helpers and consider decoupling from gizmo

				if (handle.tag === 'helper') {

					handle.visible = false

					if (handle.name === 'AXIS') {

						handle.position.copy(this.worldPositionStart)
						handle.visible = !!this.axis

						if (this.axis === 'X') {

							_tempQuaternion.setFromEuler(_tempEuler.set(0, 0, 0))
							handle.quaternion.copy(quaternion).multiply(_tempQuaternion)

							if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {

								handle.visible = false

							}

						}

						if (this.axis === 'Y') {

							_tempQuaternion.setFromEuler(_tempEuler.set(0, 0, Math.PI / 2))
							handle.quaternion.copy(quaternion).multiply(_tempQuaternion)

							if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {

								handle.visible = false

							}

						}

						if (this.axis === 'Z') {

							_tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0))
							handle.quaternion.copy(quaternion).multiply(_tempQuaternion)

							if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {

								handle.visible = false

							}

						}

						if (this.axis === 'XYZE') {

							_tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0))
							_alignVector.copy(this.rotationAxis)
							handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(_zeroVector, _alignVector, _unitY))
							handle.quaternion.multiply(_tempQuaternion)
							handle.visible = this.dragging

						}

						if (this.axis === 'E') {

							handle.visible = false

						}


					} else if (handle.name === 'START') {

						handle.position.copy(this.worldPositionStart)
						handle.visible = this.dragging

					} else if (handle.name === 'END') {

						handle.position.copy(this.worldPosition)
						handle.visible = this.dragging

					} else if (handle.name === 'DELTA') {

						handle.position.copy(this.worldPositionStart)
						handle.quaternion.copy(this.worldQuaternionStart)
						_tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(- 1)
						_tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert())
						handle.scale.copy(_tempVector)
						handle.visible = this.dragging

					} else {

						handle.quaternion.copy(quaternion)

						if (this.dragging) {

							handle.position.copy(this.worldPositionStart)

						} else {

							handle.position.copy(this.worldPosition)

						}

						if (this.axis) {

							handle.visible = this.axis.search(handle.name) !== - 1

						}

					}

					// If updating helper, skip rest of the loop
					continue

				}

				// Align handles to current local or world rotation

				handle.quaternion.copy(quaternion)

				if (this.mode === 'translate' || this.mode === 'scale') {

					// Hide translate and scale axis facing the camera

					const AXIS_HIDE_TRESHOLD = 0.99
					const PLANE_HIDE_TRESHOLD = 0.2

					if (handle.name === 'X') {

						if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_TRESHOLD) {

							handle.scale.set(1e-10, 1e-10, 1e-10)
							handle.visible = false

						}

					}

					if (handle.name === 'Y') {

						if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_TRESHOLD) {

							handle.scale.set(1e-10, 1e-10, 1e-10)
							handle.visible = false

						}

					}

					if (handle.name === 'Z') {

						if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_TRESHOLD) {

							handle.scale.set(1e-10, 1e-10, 1e-10)
							handle.visible = false

						}

					}

					if (handle.name === 'XY') {

						if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_TRESHOLD) {

							handle.scale.set(1e-10, 1e-10, 1e-10)
							handle.visible = false

						}

					}

					if (handle.name === 'YZ') {

						if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_TRESHOLD) {

							handle.scale.set(1e-10, 1e-10, 1e-10)
							handle.visible = false

						}

					}

					if (handle.name === 'XZ') {

						if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_TRESHOLD) {

							handle.scale.set(1e-10, 1e-10, 1e-10)
							handle.visible = false

						}

					}

				} else if (this.mode === 'rotate') {

					// Align handles to current local or world rotation

					_tempQuaternion2.copy(quaternion)
					_alignVector.copy(this.eye).applyQuaternion(_tempQuaternion.copy(quaternion).invert())

					if (handle.name.search('E') !== - 1) {

						handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(this.eye, _zeroVector, _unitY))

					}

					if (handle.name === 'X') {

						_tempQuaternion.setFromAxisAngle(_unitX, Math.atan2(- _alignVector.y, _alignVector.z))
						_tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion)
						handle.quaternion.copy(_tempQuaternion)

					}

					if (handle.name === 'Y') {

						_tempQuaternion.setFromAxisAngle(_unitY, Math.atan2(_alignVector.x, _alignVector.z))
						_tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion)
						handle.quaternion.copy(_tempQuaternion)

					}

					if (handle.name === 'Z') {

						_tempQuaternion.setFromAxisAngle(_unitZ, Math.atan2(_alignVector.y, _alignVector.x))
						_tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion)
						handle.quaternion.copy(_tempQuaternion)

					}

				}

				// Hide disabled axes
				handle.visible = handle.visible && (handle.name.indexOf('X') === - 1 || this.showX)
				handle.visible = handle.visible && (handle.name.indexOf('Y') === - 1 || this.showY)
				handle.visible = handle.visible && (handle.name.indexOf('Z') === - 1 || this.showZ)
				handle.visible = handle.visible && (handle.name.indexOf('E') === - 1 || (this.showX && this.showY && this.showZ))

				// highlight selected axis

				handle.material._color = handle.material._color || handle.material.color.clone()
				handle.material._opacity = handle.material._opacity || handle.material.opacity

				handle.material.color.copy(handle.material._color)
				handle.material.opacity = handle.material._opacity

				if (this.enabled && this.axis) {

					if (handle.name === this.axis) {

						handle.material.color.setHex(0xffff00)
						handle.material.opacity = 1.0

					} else if (this.axis.split('').some(function (a) {

						return handle.name === a

					})) {

						handle.material.color.setHex(0xffff00)
						handle.material.opacity = 1.0

					}

				}

			}

			super.updateMatrixWorld(force)

		}

	}

	TransformControlsGizmo.prototype.isTransformControlsGizmo = true

	//

	class TransformControlsPlane extends Mesh {

		constructor() {

			super(
				new PlaneGeometry(100000, 100000, 2, 2),
				new MeshBasicMaterial({ visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false })
			)

			this.type = 'TransformControlsPlane'

		}

		updateMatrixWorld (force) {

			let space = this.space

			this.position.copy(this.worldPosition)

			if (this.mode === 'scale') space = 'local' // scale always oriented to local rotation

			_v1.copy(_unitX).applyQuaternion(space === 'local' ? this.worldQuaternion : _identityQuaternion)
			_v2.copy(_unitY).applyQuaternion(space === 'local' ? this.worldQuaternion : _identityQuaternion)
			_v3.copy(_unitZ).applyQuaternion(space === 'local' ? this.worldQuaternion : _identityQuaternion)

			// Align the plane for current transform mode, axis and space.

			_alignVector.copy(_v2)

			switch (this.mode) {

				case 'translate':
				case 'scale':
					switch (this.axis) {

						case 'X':
							_alignVector.copy(this.eye).cross(_v1)
							_dirVector.copy(_v1).cross(_alignVector)
							break
						case 'Y':
							_alignVector.copy(this.eye).cross(_v2)
							_dirVector.copy(_v2).cross(_alignVector)
							break
						case 'Z':
							_alignVector.copy(this.eye).cross(_v3)
							_dirVector.copy(_v3).cross(_alignVector)
							break
						case 'XY':
							_dirVector.copy(_v3)
							break
						case 'YZ':
							_dirVector.copy(_v1)
							break
						case 'XZ':
							_alignVector.copy(_v3)
							_dirVector.copy(_v2)
							break
						case 'XYZ':
						case 'E':
							_dirVector.set(0, 0, 0)
							break

					}

					break
				case 'rotate':
				default:
					// special case for rotate
					_dirVector.set(0, 0, 0)

			}

			if (_dirVector.length() === 0) {

				// If in rotate mode, make the plane parallel to camera
				this.quaternion.copy(this.cameraQuaternion)

			} else {

				_tempMatrix.lookAt(_tempVector.set(0, 0, 0), _dirVector, _alignVector)

				this.quaternion.setFromRotationMatrix(_tempMatrix)

			}

			super.updateMatrixWorld(force)

		}

	}

	TransformControlsPlane.prototype.isTransformControlsPlane = true

	/**
	 * Uniforms library for RectAreaLight shared webgl shaders
	 *
	 * NOTE: This is a temporary location for the BRDF approximation texture data
	 *       based off of Eric Heitz's work (see citation below).  BRDF data for
	 *       RectAreaLight is currently approximated using a precomputed texture
	 *       of roughly 80kb in size.  The hope is to find a better way to include
	 *       the large texture data before including the full RectAreaLight implementation
	 *       in the main build files.
	 *
	 * TODO: figure out a way to compress the LTC BRDF data
	 */

	// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
	// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
	// code: https://github.com/selfshadow/ltc_code/

	class RectAreaLightUniformsLib {

		static init () {

			// source: https://github.com/selfshadow/ltc_code/tree/master/fit/results/ltc.js

			const LTC_MAT_1 = [1, 0, 0, 2e-05, 1, 0, 0, 0.000503905, 1, 0, 0, 0.00201562, 1, 0, 0, 0.00453516, 1, 0, 0, 0.00806253, 1, 0, 0, 0.0125978, 1, 0, 0, 0.018141, 1, 0, 0, 0.0246924, 1, 0, 0, 0.0322525, 1, 0, 0, 0.0408213, 1, 0, 0, 0.0503999, 1, 0, 0, 0.0609894, 1, 0, 0, 0.0725906, 1, 0, 0, 0.0852058, 1, 0, 0, 0.0988363, 1, 0, 0, 0.113484, 1, 0, 0, 0.129153, 1, 0, 0, 0.145839, 1, 0, 0, 0.163548, 1, 0, 0, 0.182266, 1, 0, 0, 0.201942, 1, 0, 0, 0.222314, 1, 0, 0, 0.241906, 1, 0, 0, 0.262314, 1, 0, 0, 0.285754, 1, 0, 0, 0.310159, 1, 0, 0, 0.335426, 1, 0, 0, 0.361341, 1, 0, 0, 0.387445, 1, 0, 0, 0.412784, 1, 0, 0, 0.438197, 1, 0, 0, 0.466966, 1, 0, 0, 0.49559, 1, 0, 0, 0.523448, 1, 0, 0, 0.549938, 1, 0, 0, 0.57979, 1, 0, 0, 0.608746, 1, 0, 0, 0.636185, 1, 0, 0, 0.664748, 1, 0, 0, 0.69313, 1, 0, 0, 0.71966, 1, 0, 0, 0.747662, 1, 0, 0, 0.774023, 1, 0, 0, 0.799775, 1, 0, 0, 0.825274, 1, 0, 0, 0.849156, 1, 0, 0, 0.873248, 1, 0, 0, 0.89532, 1, 0, 0, 0.917565, 1, 0, 0, 0.937863, 1, 0, 0, 0.958139, 1, 0, 0, 0.976563, 1, 0, 0, 0.994658, 1, 0, 0, 1.0112, 1, 0, 0, 1.02712, 1, 0, 0, 1.04189, 1, 0, 0, 1.05568, 1, 0, 0, 1.06877, 1, 0, 0, 1.08058, 1, 0, 0, 1.09194, 1, 0, 0, 1.10191, 1, 0, 0, 1.11161, 1, 0, 0, 1.1199, 1, 0, 0, 1.12813, 0.999547, - 4.48815e-07, 0.0224417, 1.99902e-05, 0.999495, - 1.13079e-05, 0.0224406, 0.000503651, 0.999496, - 4.52317e-05, 0.0224406, 0.00201461, 0.999496, - 0.000101772, 0.0224406, 0.00453287, 0.999495, - 0.000180928, 0.0224406, 0.00805845, 0.999497, - 0.000282702, 0.0224406, 0.0125914, 0.999496, - 0.000407096, 0.0224406, 0.0181319, 0.999498, - 0.000554114, 0.0224406, 0.02468, 0.999499, - 0.000723768, 0.0224406, 0.0322363, 0.999495, - 0.000916058, 0.0224405, 0.0408009, 0.999499, - 0.00113101, 0.0224408, 0.050375, 0.999494, - 0.00136863, 0.0224405, 0.0609586, 0.999489, - 0.00162896, 0.0224401, 0.0725537, 0.999489, - 0.00191201, 0.0224414, 0.0851619, 0.999498, - 0.00221787, 0.0224413, 0.0987867, 0.999492, - 0.00254642, 0.0224409, 0.113426, 0.999507, - 0.00289779, 0.0224417, 0.129088, 0.999494, - 0.0032716, 0.0224386, 0.145767, 0.999546, - 0.0036673, 0.0224424, 0.163472, 0.999543, - 0.00408166, 0.0224387, 0.182182, 0.999499, - 0.00450056, 0.0224338, 0.201843, 0.999503, - 0.00483661, 0.0224203, 0.222198, 0.999546, - 0.00452928, 0.022315, 0.241714, 0.999508, - 0.00587403, 0.0224329, 0.262184, 0.999509, - 0.00638806, 0.0224271, 0.285609, 0.999501, - 0.00691028, 0.0224166, 0.309998, 0.999539, - 0.00741979, 0.0223989, 0.335262, 0.999454, - 0.00786282, 0.0223675, 0.361154, 0.999529, - 0.00811928, 0.0222828, 0.387224, 0.999503, - 0.00799941, 0.0221063, 0.41252, 0.999561, - 0.00952753, 0.0223057, 0.438006, 0.999557, - 0.0099134, 0.0222065, 0.466735, 0.999541, - 0.0100935, 0.0220402, 0.495332, 0.999562, - 0.00996821, 0.0218067, 0.523197, 0.999556, - 0.0105031, 0.0217096, 0.550223, 0.999561, - 0.0114191, 0.0217215, 0.579498, 0.999588, - 0.0111818, 0.0213357, 0.608416, 0.999633, - 0.0107725, 0.0208689, 0.635965, 0.999527, - 0.0121671, 0.0210149, 0.664476, 0.999508, - 0.0116005, 0.020431, 0.692786, 0.999568, - 0.0115604, 0.0199791, 0.719709, 0.999671, - 0.0121117, 0.0197415, 0.74737, 0.999688, - 0.0110769, 0.0188846, 0.773692, 0.99962, - 0.0122368, 0.0188452, 0.799534, 0.999823, - 0.0110325, 0.0178001, 0.825046, 0.999599, - 0.0114923, 0.0174221, 0.849075, 0.999619, - 0.0105923, 0.0164345, 0.872999, 0.999613, - 0.0105988, 0.0158227, 0.895371, 0.99964, - 0.00979861, 0.0148131, 0.917364, 0.99977, - 0.00967238, 0.0140721, 0.938002, 0.999726, - 0.00869175, 0.0129543, 0.957917, 0.99973, - 0.00866872, 0.0122329, 0.976557, 0.999773, - 0.00731956, 0.0108958, 0.994459, 0.999811, - 0.00756027, 0.0102715, 1.01118, 0.999862, - 0.00583732, 0.00878781, 1.02701, 0.999835, - 0.00631438, 0.00827529, 1.04186, 0.999871, - 0.00450785, 0.00674583, 1.05569, 0.999867, - 0.00486079, 0.00621041, 1.06861, 0.999939, - 0.00322072, 0.00478301, 1.08064, 0.999918, - 0.00318199, 0.00406395, 1.09181, 1.00003, - 0.00193348, 0.00280682, 1.10207, 0.999928, - 0.00153729, 0.00198741, 1.11152, 0.999933, - 0.000623666, 0.000917714, 1.12009, 1, - 1.02387e-06, 9.07581e-07, 1.12813, 0.997866, - 8.96716e-07, 0.0448334, 1.99584e-05, 0.997987, - 2.25945e-05, 0.0448389, 0.000502891, 0.997987, - 9.03781e-05, 0.0448388, 0.00201156, 0.997985, - 0.000203351, 0.0448388, 0.00452602, 0.997986, - 0.000361514, 0.0448388, 0.00804629, 0.997987, - 0.00056487, 0.0448389, 0.0125724, 0.997988, - 0.000813423, 0.0448389, 0.0181045, 0.997984, - 0.00110718, 0.0448387, 0.0246427, 0.997985, - 0.00144616, 0.0448388, 0.0321875, 0.997987, - 0.00183038, 0.044839, 0.0407392, 0.997983, - 0.00225987, 0.0448387, 0.0502986, 0.997991, - 0.00273467, 0.0448389, 0.0608667, 0.997984, - 0.00325481, 0.0448384, 0.0724444, 0.998002, - 0.00382043, 0.044839, 0.0850348, 0.997997, - 0.00443145, 0.0448396, 0.0986372, 0.998007, - 0.00508796, 0.0448397, 0.113255, 0.998008, - 0.00578985, 0.04484, 0.128891, 0.998003, - 0.00653683, 0.0448384, 0.145548, 0.997983, - 0.00732713, 0.0448358, 0.163221, 0.997985, - 0.00815454, 0.0448358, 0.181899, 0.998005, - 0.00898985, 0.0448286, 0.201533, 0.998026, - 0.00964404, 0.0447934, 0.221821, 0.998055, - 0.00922677, 0.044611, 0.241282, 0.99804, - 0.0117361, 0.0448245, 0.261791, 0.998048, - 0.0127628, 0.0448159, 0.285181, 0.998088, - 0.0138055, 0.0447996, 0.30954, 0.998058, - 0.0148206, 0.0447669, 0.334751, 0.998099, - 0.0156998, 0.044697, 0.36061, 0.998116, - 0.0161976, 0.0445122, 0.386603, 0.998195, - 0.015945, 0.0441711, 0.411844, 0.998168, - 0.0183947, 0.0444255, 0.43773, 0.998184, - 0.0197913, 0.0443809, 0.466009, 0.998251, - 0.0201426, 0.0440689, 0.494574, 0.998305, - 0.0198847, 0.0435632, 0.522405, 0.998273, - 0.0210577, 0.043414, 0.549967, 0.998254, - 0.0227901, 0.0433943, 0.578655, 0.998349, - 0.0223108, 0.0426529, 0.60758, 0.99843, - 0.0223088, 0.042, 0.635524, 0.998373, - 0.0241141, 0.0418987, 0.663621, 0.998425, - 0.0231446, 0.0408118, 0.691906, 0.998504, - 0.0233684, 0.0400565, 0.719339, 0.998443, - 0.0241652, 0.0394634, 0.74643, 0.99848, - 0.0228715, 0.0380002, 0.773086, 0.998569, - 0.023519, 0.0372322, 0.798988, 0.998619, - 0.0223108, 0.0356468, 0.824249, 0.998594, - 0.0223105, 0.034523, 0.848808, 0.998622, - 0.0213426, 0.0328887, 0.87227, 0.998669, - 0.0207912, 0.0314374, 0.895157, 0.998705, - 0.0198416, 0.0296925, 0.916769, 0.998786, - 0.0189168, 0.0279634, 0.937773, 0.998888, - 0.0178811, 0.0261597, 0.957431, 0.99906, - 0.0166845, 0.0242159, 0.976495, 0.999038, - 0.0155464, 0.0222638, 0.994169, 0.999237, - 0.0141349, 0.0201967, 1.01112, 0.999378, - 0.0129324, 0.0181744, 1.02692, 0.999433, - 0.0113192, 0.0159898, 1.04174, 0.999439, - 0.0101244, 0.0140385, 1.05559, 0.999614, - 0.00837456, 0.0117826, 1.06852, 0.999722, - 0.00721769, 0.00983745, 1.08069, 0.999817, - 0.00554067, 0.00769002, 1.09176, 0.99983, - 0.00426961, 0.005782, 1.10211, 0.999964, - 0.00273904, 0.00374503, 1.11152, 1.00001, - 0.00136739, 0.00187176, 1.12031, 0.999946, 3.93227e-05, - 2.8919e-05, 1.12804, 0.995847, - 1.3435e-06, 0.0671785, 1.9916e-05, 0.995464, - 3.38387e-05, 0.0671527, 0.000501622, 0.99547, - 0.000135355, 0.0671531, 0.00200649, 0.995471, - 0.00030455, 0.0671532, 0.00451461, 0.99547, - 0.000541423, 0.0671531, 0.008026, 0.995471, - 0.00084598, 0.0671531, 0.0125407, 0.99547, - 0.00121823, 0.0671531, 0.0180589, 0.99547, - 0.00165817, 0.0671531, 0.0245806, 0.995463, - 0.00216583, 0.0671526, 0.0321062, 0.995468, - 0.00274127, 0.0671527, 0.0406366, 0.995474, - 0.00338447, 0.0671534, 0.0501717, 0.995473, - 0.00409554, 0.0671533, 0.0607131, 0.995478, - 0.00487451, 0.0671531, 0.0722618, 0.995476, - 0.00572148, 0.0671532, 0.0848191, 0.995477, - 0.00663658, 0.0671539, 0.0983882, 0.995498, - 0.00761986, 0.0671541, 0.112972, 0.995509, - 0.00867094, 0.0671542, 0.128568, 0.995509, - 0.00978951, 0.0671531, 0.145183, 0.995503, - 0.0109725, 0.0671491, 0.162808, 0.995501, - 0.012211, 0.0671465, 0.181441, 0.99553, - 0.0134565, 0.0671371, 0.201015, 0.99555, - 0.014391, 0.0670831, 0.221206, 0.99558, - 0.014351, 0.0668883, 0.240813, 0.995577, - 0.0173997, 0.0671055, 0.261257, 0.995602, - 0.0191111, 0.0671178, 0.284467, 0.995623, - 0.0206705, 0.0670946, 0.308765, 0.995658, - 0.022184, 0.0670472, 0.333905, 0.995705, - 0.0234832, 0.0669417, 0.359677, 0.995719, - 0.0241933, 0.0666714, 0.385554, 0.995786, - 0.0243539, 0.066266, 0.410951, 0.995887, - 0.0271866, 0.0664367, 0.437163, 0.995944, - 0.0296012, 0.0664931, 0.464842, 0.996004, - 0.0301045, 0.0660105, 0.49332, 0.996128, - 0.0298311, 0.0652694, 0.521131, 0.996253, - 0.0316426, 0.0650739, 0.549167, 0.996244, - 0.0339043, 0.0649433, 0.57737, 0.996309, - 0.033329, 0.0638926, 0.606073, 0.996417, - 0.0338935, 0.0630849, 0.634527, 0.996372, - 0.0353104, 0.0625083, 0.66256, 0.996542, - 0.0348942, 0.0611986, 0.690516, 0.996568, - 0.0351614, 0.060069, 0.718317, 0.996711, - 0.0354317, 0.0588522, 0.74528, 0.996671, - 0.0349513, 0.0571902, 0.772061, 0.996865, - 0.0345622, 0.0555321, 0.798089, 0.996802, - 0.0342566, 0.0537816, 0.823178, 0.996992, - 0.0330862, 0.0516095, 0.847949, 0.996944, - 0.0324666, 0.0495537, 0.871431, 0.997146, - 0.0309544, 0.0470302, 0.894357, 0.997189, - 0.0299372, 0.0446043, 0.916142, 0.997471, - 0.0281389, 0.0418812, 0.937193, 0.997515, - 0.0268702, 0.0391823, 0.957, 0.997812, - 0.0247166, 0.0361338, 0.975936, 0.998027, - 0.0233525, 0.0333945, 0.99391, 0.998233, - 0.0209839, 0.0301917, 1.01075, 0.998481, - 0.0194309, 0.027271, 1.02669, 0.998859, - 0.0169728, 0.0240162, 1.04173, 0.99894, - 0.0152322, 0.0210517, 1.05551, 0.999132, - 0.0127497, 0.0178632, 1.06856, 0.999369, - 0.0108282, 0.014787, 1.08054, 0.999549, - 0.00845886, 0.0116185, 1.09185, 0.999805, - 0.0063937, 0.00867209, 1.10207, 0.99985, - 0.00414582, 0.00566823, 1.1117, 0.999912, - 0.00207443, 0.00277562, 1.12022, 1.00001, 8.70226e-05, - 5.3766e-05, 1.12832, 0.991943, - 1.78672e-06, 0.0893382, 1.98384e-05, 0.991952, - 4.50183e-05, 0.089339, 0.000499849, 0.991956, - 0.000180074, 0.0893394, 0.0019994, 0.991955, - 0.000405167, 0.0893393, 0.00449867, 0.991953, - 0.000720298, 0.0893391, 0.00799764, 0.991955, - 0.00112548, 0.0893393, 0.0124964, 0.991957, - 0.0016207, 0.0893395, 0.0179951, 0.991958, - 0.00220601, 0.0893396, 0.0244939, 0.991947, - 0.00288137, 0.0893385, 0.0319929, 0.991962, - 0.00364693, 0.0893399, 0.0404933, 0.991965, - 0.00450264, 0.0893399, 0.049995, 0.99198, - 0.00544862, 0.0893411, 0.0604995, 0.99197, - 0.00648491, 0.0893397, 0.0720074, 0.991976, - 0.00761164, 0.089341, 0.0845207, 0.99198, - 0.00882891, 0.0893405, 0.0980413, 0.991982, - 0.0101367, 0.0893396, 0.112571, 0.992008, - 0.011535, 0.0893415, 0.128115, 0.992026, - 0.0130228, 0.0893414, 0.144672, 0.992064, - 0.0145966, 0.0893418, 0.162241, 0.992041, - 0.0162421, 0.0893359, 0.180801, 0.992086, - 0.0178888, 0.0893214, 0.200302, 0.992157, - 0.0190368, 0.0892401, 0.220332, 0.992181, - 0.0195584, 0.0890525, 0.240144, 0.992175, - 0.0227257, 0.0892153, 0.260728, 0.99221, - 0.0254195, 0.089304, 0.283473, 0.99222, - 0.0274883, 0.0892703, 0.307673, 0.992317, - 0.0294905, 0.0892027, 0.332729, 0.992374, - 0.0311861, 0.0890577, 0.358387, 0.992505, - 0.0320656, 0.0886994, 0.384102, 0.992568, - 0.0329715, 0.0883198, 0.409767, 0.992675, - 0.036006, 0.0883602, 0.436145, 0.992746, - 0.0392897, 0.0884591, 0.463217, 0.992873, - 0.0399337, 0.0878287, 0.491557, 0.992934, - 0.040231, 0.0870108, 0.519516, 0.993091, - 0.0422013, 0.0865857, 0.547741, 0.993259, - 0.0443503, 0.0861937, 0.575792, 0.993455, - 0.0446368, 0.0851187, 0.604233, 0.993497, - 0.0454299, 0.0840576, 0.632925, 0.993694, - 0.0463296, 0.0829671, 0.660985, 0.993718, - 0.0470619, 0.0817185, 0.688714, 0.993973, - 0.0468838, 0.0800294, 0.716743, 0.994207, - 0.046705, 0.0781286, 0.74377, 0.994168, - 0.0469698, 0.0763337, 0.77042, 0.9945, - 0.0456816, 0.0738184, 0.796659, 0.994356, - 0.0455518, 0.0715545, 0.821868, 0.994747, - 0.0439488, 0.0686085, 0.846572, 0.994937, - 0.0430056, 0.065869, 0.870435, 0.995142, - 0.0413414, 0.0626446, 0.893272, 0.995451, - 0.0396521, 0.05929, 0.915376, 0.995445, - 0.0378453, 0.0558503, 0.936196, 0.995967, - 0.0355219, 0.0520949, 0.956376, 0.996094, - 0.0335146, 0.048377, 0.975327, 0.996622, - 0.030682, 0.0442575, 0.993471, 0.996938, - 0.0285504, 0.0404693, 1.01052, 0.997383, - 0.0253399, 0.0360903, 1.02637, 0.997714, - 0.0231651, 0.0322176, 1.04139, 0.998249, - 0.0198138, 0.0278433, 1.05542, 0.998596, - 0.0174337, 0.0238759, 1.06846, 0.998946, - 0.0141349, 0.0195944, 1.08056, 0.99928, - 0.0115603, 0.0156279, 1.09181, 0.999507, - 0.00839065, 0.0114607, 1.10213, 0.999697, - 0.005666, 0.00763325, 1.11169, 0.999869, - 0.00269902, 0.00364946, 1.12042, 1.00001, 6.23836e-05, - 3.19288e-05, 1.12832, 0.987221, - 2.22675e-06, 0.111332, 1.97456e-05, 0.98739, - 5.61116e-05, 0.111351, 0.000497563, 0.987448, - 0.000224453, 0.111357, 0.00199031, 0.987441, - 0.000505019, 0.111357, 0.0044782, 0.987442, - 0.000897816, 0.111357, 0.00796129, 0.987442, - 0.00140284, 0.111357, 0.0124396, 0.987444, - 0.00202012, 0.111357, 0.0179132, 0.987442, - 0.00274964, 0.111357, 0.0243824, 0.987446, - 0.00359147, 0.111357, 0.0318474, 0.987435, - 0.00454562, 0.111356, 0.0403086, 0.987461, - 0.00561225, 0.111358, 0.0497678, 0.987458, - 0.00679125, 0.111358, 0.0602239, 0.987443, - 0.0080828, 0.111356, 0.0716792, 0.987476, - 0.0094872, 0.111358, 0.0841364, 0.98749, - 0.0110044, 0.111361, 0.097597, 0.987508, - 0.0126344, 0.111362, 0.112062, 0.987494, - 0.0143767, 0.111357, 0.127533, 0.987526, - 0.0162307, 0.111359, 0.144015, 0.987558, - 0.0181912, 0.111361, 0.161502, 0.987602, - 0.0202393, 0.111355, 0.179979, 0.987692, - 0.022273, 0.111346, 0.199386, 0.987702, - 0.0235306, 0.111215, 0.219183, 0.987789, - 0.0247628, 0.111061, 0.239202, 0.987776, - 0.0280668, 0.111171, 0.259957, 0.987856, - 0.0316751, 0.111327, 0.282198, 0.987912, - 0.0342468, 0.111282, 0.306294, 0.988, - 0.0367205, 0.111198, 0.331219, 0.988055, - 0.0387766, 0.110994, 0.356708, 0.988241, - 0.0397722, 0.110547, 0.382234, 0.988399, - 0.0416076, 0.110198, 0.408227, 0.988539, - 0.0448192, 0.110137, 0.434662, 0.988661, - 0.0483793, 0.110143, 0.461442, 0.988967, - 0.0495895, 0.109453, 0.489318, 0.989073, - 0.0506797, 0.108628, 0.517516, 0.989274, - 0.0526953, 0.108003, 0.545844, 0.989528, - 0.054578, 0.107255, 0.573823, 0.989709, - 0.0561503, 0.106294, 0.601944, 0.989991, - 0.056866, 0.104896, 0.630855, 0.990392, - 0.0572914, 0.103336, 0.658925, 0.990374, - 0.0586224, 0.10189, 0.686661, 0.990747, - 0.0584764, 0.099783, 0.714548, 0.991041, - 0.0582662, 0.0974309, 0.74186, 0.991236, - 0.0584118, 0.0951678, 0.768422, 0.991585, - 0.0573055, 0.0921581, 0.794817, 0.991984, - 0.0564241, 0.0891167, 0.820336, 0.9921, - 0.0553608, 0.085805, 0.84493, 0.992749, - 0.0533816, 0.0820354, 0.868961, 0.99288, - 0.0518661, 0.0782181, 0.891931, 0.993511, - 0.0492492, 0.0738935, 0.914186, 0.993617, - 0.0471956, 0.0696402, 0.93532, 0.99411, - 0.044216, 0.0649659, 0.95543, 0.994595, - 0.0416654, 0.0603177, 0.974685, 0.994976, - 0.0384314, 0.0553493, 0.992807, 0.995579, - 0.0353491, 0.0503942, 1.00996, 0.996069, - 0.0319787, 0.0452123, 1.02606, 0.996718, - 0.028472, 0.0400112, 1.04114, 0.997173, - 0.0250789, 0.0349456, 1.05517, 0.997818, - 0.0213326, 0.029653, 1.0683, 0.998318, - 0.0178509, 0.024549, 1.0805, 0.998853, - 0.0141118, 0.0194197, 1.09177, 0.999218, - 0.0105914, 0.0143869, 1.1022, 0.999594, - 0.00693474, 0.00943517, 1.11175, 0.99975, - 0.00340478, 0.00464051, 1.12056, 1.00001, 0.000109172, - 0.000112821, 1.12853, 0.983383, - 2.66524e-06, 0.133358, 1.96534e-05, 0.981942, - 6.71009e-05, 0.133162, 0.000494804, 0.981946, - 0.000268405, 0.133163, 0.00197923, 0.981944, - 0.000603912, 0.133163, 0.00445326, 0.981941, - 0.00107362, 0.133162, 0.00791693, 0.981946, - 0.00167755, 0.133163, 0.0123703, 0.981944, - 0.00241569, 0.133162, 0.0178135, 0.981945, - 0.00328807, 0.133163, 0.0242466, 0.981945, - 0.00429472, 0.133162, 0.03167, 0.981955, - 0.00543573, 0.133164, 0.0400846, 0.981951, - 0.00671105, 0.133163, 0.0494901, 0.981968, - 0.00812092, 0.133165, 0.0598886, 0.981979, - 0.00966541, 0.133166, 0.0712811, 0.981996, - 0.0113446, 0.133168, 0.083669, 0.982014, - 0.0131585, 0.133169, 0.0970533, 0.982011, - 0.0151073, 0.133167, 0.111438, 0.982062, - 0.0171906, 0.133172, 0.126826, 0.9821, - 0.0194067, 0.133175, 0.143215, 0.982149, - 0.0217502, 0.133176, 0.160609, 0.982163, - 0.0241945, 0.133173, 0.178981, 0.982247, - 0.0265907, 0.133148, 0.198249, 0.982291, - 0.027916, 0.132974, 0.217795, 0.982396, - 0.0299663, 0.132868, 0.238042, 0.982456, - 0.0334544, 0.132934, 0.258901, 0.982499, - 0.0378636, 0.133137, 0.280639, 0.982617, - 0.0409274, 0.133085, 0.304604, 0.98274, - 0.0438523, 0.132985, 0.329376, 0.982944, - 0.0462288, 0.132728, 0.354697, 0.98308, - 0.0475995, 0.132228, 0.380102, 0.983391, - 0.0501901, 0.131924, 0.406256, 0.983514, - 0.0535899, 0.131737, 0.432735, 0.98373, - 0.0571858, 0.131567, 0.459359, 0.984056, - 0.0592353, 0.130932, 0.486637, 0.984234, - 0.0610488, 0.130092, 0.51509, 0.984748, - 0.0630758, 0.12923, 0.543461, 0.985073, - 0.0647398, 0.128174, 0.571376, 0.985195, - 0.0671941, 0.127133, 0.599414, 0.985734, - 0.0681345, 0.125576, 0.628134, 0.986241, - 0.0686089, 0.123639, 0.656399, 0.986356, - 0.0698511, 0.121834, 0.684258, 0.986894, - 0.0700931, 0.119454, 0.711818, 0.987382, - 0.0698321, 0.116718, 0.739511, 0.988109, - 0.0693975, 0.113699, 0.766267, 0.988363, - 0.0689584, 0.110454, 0.792456, 0.989112, - 0.0672353, 0.106602, 0.81813, 0.989241, - 0.0662034, 0.10267, 0.842889, 0.990333, - 0.0638938, 0.0981381, 0.867204, 0.990591, - 0.0618534, 0.0935388, 0.89038, 0.991106, - 0.0593117, 0.088553, 0.912576, 0.991919, - 0.0562676, 0.0832187, 0.934118, 0.992111, - 0.0534085, 0.0778302, 0.954254, 0.992997, - 0.0495459, 0.0720453, 0.973722, 0.993317, - 0.0463707, 0.0663458, 0.991949, 0.994133, - 0.0421245, 0.0601883, 1.00936, 0.994705, - 0.0384977, 0.0542501, 1.02559, 0.995495, - 0.0340956, 0.0479862, 1.04083, 0.996206, - 0.030105, 0.041887, 1.05497, 0.996971, - 0.0256095, 0.0355355, 1.06824, 0.997796, - 0.0213932, 0.0293655, 1.08056, 0.998272, - 0.0169612, 0.0232926, 1.09182, 0.998857, - 0.0126756, 0.0172786, 1.10219, 0.99939, - 0.00832486, 0.0113156, 1.11192, 0.999752, - 0.00410826, 0.00557892, 1.12075, 1, 0.000150957, - 0.000119101, 1.12885, 0.975169, - 3.09397e-06, 0.154669, 1.95073e-05, 0.975439, - 7.79608e-05, 0.154712, 0.000491534, 0.975464, - 0.000311847, 0.154716, 0.00196617, 0.975464, - 0.000701656, 0.154716, 0.00442387, 0.975462, - 0.0012474, 0.154715, 0.0078647, 0.975461, - 0.00194906, 0.154715, 0.0122886, 0.975464, - 0.00280667, 0.154715, 0.0176959, 0.975468, - 0.00382025, 0.154716, 0.0240867, 0.975471, - 0.00498985, 0.154716, 0.0314612, 0.975472, - 0.00631541, 0.154717, 0.0398199, 0.975486, - 0.00779719, 0.154718, 0.0491639, 0.975489, - 0.00943505, 0.154718, 0.0594932, 0.975509, - 0.0112295, 0.154721, 0.0708113, 0.97554, - 0.0131802, 0.154724, 0.0831176, 0.975557, - 0.0152876, 0.154726, 0.096415, 0.975585, - 0.0175512, 0.154728, 0.110705, 0.975605, - 0.0199713, 0.154729, 0.125992, 0.975645, - 0.0225447, 0.154729, 0.142272, 0.975711, - 0.0252649, 0.154735, 0.159549, 0.975788, - 0.0280986, 0.154736, 0.177805, 0.975872, - 0.0308232, 0.154704, 0.196911, 0.975968, - 0.0324841, 0.154525, 0.216324, 0.976063, - 0.0351281, 0.154432, 0.236628, 0.976157, - 0.0388618, 0.15446, 0.257539, 0.976204, - 0.0437704, 0.154665, 0.278975, 0.976358, - 0.047514, 0.154652, 0.302606, 0.976571, - 0.0508638, 0.154535, 0.327204, 0.976725, - 0.0534995, 0.154221, 0.352276, 0.977013, - 0.0555547, 0.153737, 0.377696, 0.977294, - 0.0586728, 0.153403, 0.403855, 0.977602, - 0.0622715, 0.15312, 0.430333, 0.977932, - 0.0658166, 0.152755, 0.456855, 0.978241, - 0.0689877, 0.152233, 0.483668, 0.978602, - 0.0712805, 0.15132, 0.512097, 0.979234, - 0.0732775, 0.150235, 0.540455, 0.97977, - 0.075163, 0.148978, 0.568486, 0.979995, - 0.0778026, 0.147755, 0.596524, 0.98078, - 0.0791854, 0.146019, 0.624825, 0.981628, - 0.0799666, 0.143906, 0.653403, 0.982067, - 0.0808532, 0.141561, 0.681445, 0.98271, - 0.0816024, 0.139025, 0.708918, 0.983734, - 0.0812511, 0.135764, 0.736594, 0.98431, - 0.0806201, 0.132152, 0.763576, 0.985071, - 0.0801605, 0.12846, 0.789797, 0.98618, - 0.0784208, 0.124084, 0.815804, 0.986886, - 0.0766643, 0.1193, 0.840869, 0.987485, - 0.0747744, 0.114236, 0.864952, 0.988431, - 0.0716701, 0.108654, 0.888431, 0.988886, - 0.0691609, 0.102994, 0.910963, 0.990024, - 0.0654048, 0.0967278, 0.932629, 0.990401, - 0.0619765, 0.090384, 0.95313, 0.991093, - 0.0579296, 0.0837885, 0.972587, 0.992018, - 0.0536576, 0.0770171, 0.991184, 0.992536, - 0.0493719, 0.0701486, 1.00863, 0.993421, - 0.0444813, 0.062953, 1.02494, 0.993928, - 0.040008, 0.0560455, 1.04017, 0.994994, - 0.0347982, 0.04856, 1.05463, 0.995866, - 0.0301017, 0.0416152, 1.06807, 0.996916, - 0.0248225, 0.0342597, 1.08039, 0.997766, - 0.0199229, 0.0271668, 1.09177, 0.998479, - 0.0147422, 0.0201387, 1.10235, 0.99921, - 0.00980173, 0.0131944, 1.11206, 0.999652, - 0.0047426, 0.00640712, 1.12104, 0.999998, 8.91673e-05, - 0.00010379, 1.12906, 0.967868, - 3.51885e-06, 0.175947, 1.93569e-05, 0.968001, - 8.86733e-05, 0.175972, 0.000487782, 0.96801, - 0.000354697, 0.175973, 0.00195115, 0.968012, - 0.000798063, 0.175974, 0.00439006, 0.968011, - 0.00141879, 0.175973, 0.00780461, 0.968011, - 0.00221686, 0.175973, 0.0121948, 0.968016, - 0.00319231, 0.175974, 0.0175607, 0.968019, - 0.00434515, 0.175974, 0.0239027, 0.968018, - 0.00567538, 0.175974, 0.0312208, 0.968033, - 0.00718308, 0.175977, 0.0395158, 0.968049, - 0.00886836, 0.175979, 0.0487885, 0.968047, - 0.0107312, 0.175978, 0.0590394, 0.968072, - 0.0127719, 0.175981, 0.0702705, 0.968108, - 0.0149905, 0.175986, 0.0824836, 0.968112, - 0.0173866, 0.175985, 0.0956783, 0.968173, - 0.0199611, 0.175993, 0.109862, 0.96827, - 0.0227128, 0.176008, 0.125033, 0.968292, - 0.025639, 0.17601, 0.141193, 0.968339, - 0.0287299, 0.176007, 0.158336, 0.968389, - 0.0319399, 0.176001, 0.176441, 0.968501, - 0.034941, 0.175962, 0.195359, 0.968646, - 0.0370812, 0.175793, 0.214686, 0.968789, - 0.0402329, 0.175708, 0.234973, 0.96886, - 0.0442601, 0.1757, 0.255871, 0.969013, - 0.049398, 0.175876, 0.277238, 0.969242, - 0.0539932, 0.17594, 0.300326, 0.969419, - 0.0577299, 0.175781, 0.324702, 0.969763, - 0.0605643, 0.175432, 0.349527, 0.970093, - 0.0634488, 0.174992, 0.374976, 0.970361, - 0.0670589, 0.174611, 0.401097, 0.970825, - 0.0708246, 0.174226, 0.427496, 0.971214, - 0.0742871, 0.173684, 0.453858, 0.971622, - 0.0782608, 0.173186, 0.480637, 0.972175, - 0.0813151, 0.172288, 0.508655, 0.972944, - 0.0832678, 0.170979, 0.536973, 0.973595, - 0.0855964, 0.169573, 0.565138, 0.974345, - 0.0882163, 0.168152, 0.593222, 0.975233, - 0.0901671, 0.166314, 0.621201, 0.976239, - 0.0912111, 0.163931, 0.649919, 0.977289, - 0.0916959, 0.161106, 0.678011, 0.978076, - 0.0927061, 0.158272, 0.705717, 0.979533, - 0.0925562, 0.15475, 0.733228, 0.980335, - 0.0918159, 0.150638, 0.760454, 0.981808, - 0.0908508, 0.146201, 0.786918, 0.983061, - 0.0896172, 0.141386, 0.812953, 0.984148, - 0.0871588, 0.135837, 0.838281, 0.985047, - 0.0850624, 0.130135, 0.862594, 0.986219, - 0.0818541, 0.123882, 0.88633, 0.987043, - 0.0784523, 0.117126, 0.908952, 0.988107, - 0.0749601, 0.110341, 0.930744, 0.988955, - 0.0703548, 0.102885, 0.951728, 0.989426, - 0.0662798, 0.0954167, 0.971166, 0.990421, - 0.0610834, 0.0876331, 0.989984, 0.991032, - 0.0562936, 0.0797785, 1.00765, 0.992041, - 0.0508154, 0.0718166, 1.02434, 0.992794, - 0.0454045, 0.0637125, 1.03976, 0.993691, - 0.0398194, 0.0555338, 1.05418, 0.994778, - 0.0341482, 0.0473388, 1.06772, 0.995915, - 0.028428, 0.0391016, 1.08028, 0.997109, - 0.022642, 0.0309953, 1.09185, 0.998095, - 0.0168738, 0.0230288, 1.10247, 0.998985, - 0.0111274, 0.0150722, 1.11229, 0.999581, - 0.00543881, 0.00740605, 1.12131, 1.00003, 0.000162239, - 0.000105549, 1.12946, 0.959505, - 3.93734e-06, 0.196876, 1.91893e-05, 0.959599, - 9.92157e-05, 0.196895, 0.000483544, 0.959641, - 0.000396868, 0.196903, 0.0019342, 0.959599, - 0.000892948, 0.196895, 0.00435193, 0.959603, - 0.00158747, 0.196896, 0.0077368, 0.959604, - 0.00248042, 0.196896, 0.0120888, 0.959605, - 0.00357184, 0.196896, 0.0174082, 0.959605, - 0.00486169, 0.196896, 0.0236949, 0.959613, - 0.00635008, 0.196897, 0.0309497, 0.959619, - 0.00803696, 0.196898, 0.0391725, 0.959636, - 0.00992255, 0.196901, 0.0483649, 0.959634, - 0.0120067, 0.1969, 0.0585266, 0.959675, - 0.0142898, 0.196906, 0.0696609, 0.959712, - 0.0167717, 0.196911, 0.0817678, 0.959752, - 0.0194524, 0.196918, 0.0948494, 0.959807, - 0.0223321, 0.196925, 0.10891, 0.959828, - 0.0254091, 0.196924, 0.123947, 0.959906, - 0.0286815, 0.196934, 0.139968, 0.960005, - 0.0321371, 0.196944, 0.156968, 0.960071, - 0.0357114, 0.196936, 0.17491, 0.960237, - 0.0389064, 0.196882, 0.193597, 0.960367, - 0.041623, 0.196731, 0.21285, 0.960562, - 0.0452655, 0.196654, 0.233075, 0.960735, - 0.0496207, 0.196643, 0.253941, 0.960913, - 0.0549379, 0.196774, 0.275278, 0.961121, - 0.0603414, 0.196893, 0.297733, 0.96139, - 0.0644244, 0.196717, 0.321877, 0.961818, - 0.067556, 0.196314, 0.346476, 0.962175, - 0.0712709, 0.195917, 0.371907, 0.96255, - 0.0752848, 0.1955, 0.397916, 0.963164, - 0.0792073, 0.195026, 0.424229, 0.963782, - 0.0828225, 0.194424, 0.450637, 0.964306, - 0.0873119, 0.193831, 0.477288, 0.964923, - 0.0911051, 0.192973, 0.504716, 0.966048, - 0.093251, 0.19151, 0.533053, 0.967024, - 0.0958983, 0.190013, 0.561366, 0.968038, - 0.09835, 0.188253, 0.589464, 0.969152, - 0.100754, 0.186257, 0.617433, 0.970557, - 0.102239, 0.183775, 0.645801, 0.972104, - 0.102767, 0.180645, 0.674278, 0.973203, - 0.103492, 0.177242, 0.702004, 0.975123, - 0.103793, 0.17345, 0.729529, 0.97641, - 0.102839, 0.168886, 0.756712, 0.978313, - 0.101687, 0.163892, 0.783801, 0.980036, - 0.100314, 0.158439, 0.809671, 0.981339, - 0.097836, 0.152211, 0.835402, 0.982794, - 0.0950006, 0.145679, 0.860081, 0.984123, - 0.0920994, 0.138949, 0.883757, 0.984918, - 0.0878641, 0.131283, 0.90685, 0.985999, - 0.083939, 0.123464, 0.928786, 0.987151, - 0.0791234, 0.115324, 0.94983, 0.987827, - 0.0739332, 0.106854, 0.96962, 0.988806, - 0.0688088, 0.0982691, 0.98861, 0.989588, - 0.0628962, 0.0893456, 1.00667, 0.990438, - 0.0573146, 0.0805392, 1.02344, 0.991506, - 0.0509433, 0.0713725, 1.03933, 0.992492, - 0.0448724, 0.0623732, 1.05378, 0.993663, - 0.0383497, 0.0530838, 1.06747, 0.994956, - 0.0319593, 0.0439512, 1.08007, 0.99634, - 0.025401, 0.0347803, 1.09182, 0.99761, - 0.0189687, 0.0257954, 1.1025, 0.99863, - 0.0124441, 0.0169893, 1.11247, 0.99947, - 0.00614003, 0.00829498, 1.12151, 1.00008, 0.000216624, - 0.000146107, 1.12993, 0.950129, - 4.34955e-06, 0.217413, 1.90081e-05, 0.950264, - 0.00010957, 0.217444, 0.00047884, 0.9503, - 0.000438299, 0.217451, 0.00191543, 0.950246, - 0.000986124, 0.21744, 0.00430951, 0.950246, - 0.00175311, 0.21744, 0.00766137, 0.950245, - 0.00273923, 0.21744, 0.011971, 0.950253, - 0.00394453, 0.217441, 0.0172385, 0.950258, - 0.00536897, 0.217442, 0.0234641, 0.950267, - 0.00701262, 0.217444, 0.030648, 0.950277, - 0.00887551, 0.217446, 0.038791, 0.950284, - 0.0109576, 0.217446, 0.0478931, 0.950312, - 0.0132591, 0.217451, 0.0579568, 0.950334, - 0.01578, 0.217454, 0.0689821, 0.950378, - 0.0185204, 0.217462, 0.0809714, 0.950417, - 0.0214803, 0.217467, 0.0939265, 0.950488, - 0.0246594, 0.217479, 0.10785, 0.950534, - 0.0280565, 0.217483, 0.122743, 0.950633, - 0.0316685, 0.217498, 0.138611, 0.950698, - 0.0354787, 0.217499, 0.155442, 0.950844, - 0.0394003, 0.217507, 0.173208, 0.950999, - 0.0426812, 0.217419, 0.191605, 0.951221, - 0.0461302, 0.217317, 0.21084, 0.951412, - 0.0502131, 0.217238, 0.230945, 0.951623, - 0.0549183, 0.21722, 0.251745, 0.951867, - 0.0604493, 0.217306, 0.273001, 0.952069, - 0.0665189, 0.217466, 0.294874, 0.952459, - 0.0709179, 0.217266, 0.318732, 0.952996, - 0.0746112, 0.216891, 0.34318, 0.953425, - 0.0789252, 0.216503, 0.36849, 0.953885, - 0.0833293, 0.216042, 0.394373, 0.954617, - 0.087371, 0.215469, 0.420505, 0.955429, - 0.0914054, 0.214802, 0.446907, 0.956068, - 0.0961671, 0.214146, 0.473522, 0.957094, - 0.10048, 0.213286, 0.50052, 0.958372, - 0.103248, 0.211796, 0.528715, 0.959654, - 0.106033, 0.21016, 0.557065, 0.961305, - 0.108384, 0.208149, 0.585286, 0.962785, - 0.111122, 0.206024, 0.613334, 0.964848, - 0.112981, 0.203442, 0.641334, 0.966498, - 0.113717, 0.19996, 0.669955, 0.968678, - 0.114121, 0.196105, 0.698094, 0.970489, - 0.114524, 0.191906, 0.725643, 0.972903, - 0.113792, 0.186963, 0.752856, 0.974701, - 0.112406, 0.181343, 0.780013, 0.976718, - 0.110685, 0.175185, 0.806268, 0.978905, - 0.108468, 0.168535, 0.832073, 0.980267, - 0.105061, 0.161106, 0.857149, 0.981967, - 0.101675, 0.153387, 0.881145, 0.983063, - 0.0974492, 0.145199, 0.904255, 0.984432, - 0.0925815, 0.136527, 0.926686, 0.985734, - 0.0877983, 0.127584, 0.947901, 0.986228, - 0.081884, 0.118125, 0.968111, 0.98719, - 0.0761208, 0.108594, 0.98719, 0.988228, - 0.0698196, 0.0989996, 1.00559, 0.989046, - 0.0632739, 0.0890074, 1.02246, 0.990242, - 0.056522, 0.0790832, 1.03841, 0.991252, - 0.0495272, 0.0689182, 1.05347, 0.992542, - 0.0425373, 0.0588592, 1.06724, 0.994096, - 0.0353198, 0.0486833, 1.08009, 0.995593, - 0.028235, 0.0385977, 1.09177, 0.99711, - 0.0209511, 0.0286457, 1.10274, 0.998263, - 0.0139289, 0.0188497, 1.11262, 0.999254, - 0.0067359, 0.009208, 1.12191, 0.999967, 0.000141846, - 6.57764e-05, 1.13024, 0.935608, - 4.74692e-06, 0.236466, 1.87817e-05, 0.93996, - 0.00011971, 0.237568, 0.000473646, 0.939959, - 0.000478845, 0.237567, 0.0018946, 0.939954, - 0.0010774, 0.237566, 0.00426284, 0.939956, - 0.00191538, 0.237566, 0.00757842, 0.939954, - 0.00299277, 0.237566, 0.0118413, 0.93996, - 0.00430961, 0.237567, 0.0170518, 0.939969, - 0.00586589, 0.237569, 0.02321, 0.939982, - 0.00766166, 0.237572, 0.0303164, 0.939987, - 0.00969686, 0.237572, 0.0383711, 0.939997, - 0.0119715, 0.237574, 0.0473751, 0.940031, - 0.0144858, 0.237581, 0.0573298, 0.940073, - 0.0172399, 0.237589, 0.0682366, 0.94012, - 0.0202335, 0.237598, 0.080097, 0.940162, - 0.0234663, 0.237604, 0.0929116, 0.940237, - 0.0269387, 0.237615, 0.106686, 0.940328, - 0.0306489, 0.237632, 0.121421, 0.940419, - 0.0345917, 0.237645, 0.137115, 0.940522, - 0.0387481, 0.237654, 0.153766, 0.940702, - 0.0429906, 0.237661, 0.17133, 0.940871, - 0.0465089, 0.237561, 0.189502, 0.941103, - 0.050531, 0.23748, 0.208616, 0.941369, - 0.0550657, 0.237423, 0.228595, 0.941641, - 0.0601337, 0.237399, 0.249287, 0.941903, - 0.0658804, 0.237443, 0.270467, 0.942224, - 0.0722674, 0.237597, 0.292024, 0.942633, - 0.0771788, 0.237419, 0.315272, 0.943172, - 0.0815623, 0.237068, 0.339579, 0.943691, - 0.0863973, 0.236682, 0.364717, 0.944382, - 0.0911536, 0.236213, 0.390435, 0.945392, - 0.0952967, 0.235562, 0.416425, 0.946185, - 0.0998948, 0.234832, 0.442772, 0.947212, - 0.104796, 0.234114, 0.469347, 0.948778, - 0.10928, 0.233222, 0.496162, 0.950149, - 0.113081, 0.231845, 0.523978, 0.951989, - 0.115893, 0.230005, 0.552295, 0.953921, - 0.11846, 0.227862, 0.580569, 0.955624, - 0.12115, 0.225439, 0.608698, 0.958234, - 0.123373, 0.222635, 0.636696, 0.960593, - 0.124519, 0.219093, 0.665208, 0.963201, - 0.124736, 0.214749, 0.693557, 0.965642, - 0.125012, 0.210059, 0.721334, 0.968765, - 0.124661, 0.204935, 0.748613, 0.971753, - 0.122996, 0.198661, 0.776224, 0.973751, - 0.120998, 0.191823, 0.802461, 0.976709, - 0.118583, 0.184359, 0.828399, 0.977956, - 0.115102, 0.176437, 0.853693, 0.979672, - 0.111077, 0.167681, 0.877962, 0.981816, - 0.10688, 0.158872, 0.901564, 0.98238, - 0.101469, 0.149398, 0.924057, 0.983964, - 0.0960013, 0.139436, 0.945751, 0.984933, - 0.0899626, 0.12943, 0.966272, 0.985694, - 0.0832973, 0.11894, 0.985741, 0.986822, - 0.0767082, 0.108349, 1.00407, 0.987725, - 0.0693614, 0.0976026, 1.02154, 0.98877, - 0.06211, 0.086652, 1.03757, 0.990129, - 0.0544143, 0.0756182, 1.05296, 0.991337, - 0.046744, 0.0645753, 1.06683, 0.992978, - 0.0387931, 0.0534683, 1.0798, 0.994676, - 0.030973, 0.0424137, 1.09181, 0.99645, - 0.0230311, 0.0314035, 1.10286, 0.997967, - 0.0152065, 0.0206869, 1.11291, 0.99922, - 0.00744837, 0.010155, 1.12237, 1.00002, 0.000240209, - 7.52767e-05, 1.13089, 0.922948, - 5.15351e-06, 0.255626, 1.86069e-05, 0.928785, - 0.000129623, 0.257244, 0.000468009, 0.928761, - 0.00051849, 0.257237, 0.00187202, 0.928751, - 0.0011666, 0.257235, 0.00421204, 0.928751, - 0.00207395, 0.257234, 0.0074881, 0.928754, - 0.00324055, 0.257235, 0.0117002, 0.92876, - 0.00466639, 0.257236, 0.0168486, 0.928763, - 0.00635149, 0.257237, 0.0229334, 0.928774, - 0.00829584, 0.257239, 0.029955, 0.928791, - 0.0104995, 0.257243, 0.0379139, 0.928804, - 0.0129623, 0.257245, 0.0468108, 0.928847, - 0.0156846, 0.257255, 0.0566473, 0.92889, - 0.0186661, 0.257263, 0.0674246, 0.928924, - 0.0219067, 0.257268, 0.0791433, 0.928989, - 0.0254066, 0.257282, 0.0918076, 0.92909, - 0.0291651, 0.257301, 0.105419, 0.92918, - 0.0331801, 0.257316, 0.119978, 0.92929, - 0.0374469, 0.257332, 0.135491, 0.929453, - 0.041939, 0.257357, 0.151948, 0.929586, - 0.0464612, 0.257347, 0.169275, 0.929858, - 0.0503426, 0.257269, 0.187257, 0.930125, - 0.0548409, 0.257199, 0.206204, 0.930403, - 0.0598063, 0.257149, 0.22601, 0.930726, - 0.0652437, 0.257122, 0.246561, 0.931098, - 0.0712376, 0.257153, 0.267618, 0.931396, - 0.0777506, 0.257237, 0.288993, 0.931947, - 0.0832374, 0.257124, 0.311527, 0.932579, - 0.0883955, 0.25683, 0.335697, 0.933194, - 0.0937037, 0.256444, 0.360634, 0.934013, - 0.0987292, 0.255939, 0.386126, 0.935307, - 0.103215, 0.255282, 0.412018, 0.936374, - 0.108234, 0.254538, 0.438292, 0.93776, - 0.113234, 0.253728, 0.464805, 0.939599, - 0.118013, 0.25275, 0.491464, 0.941036, - 0.122661, 0.251404, 0.518751, 0.94337, - 0.125477, 0.249435, 0.547133, 0.945318, - 0.128374, 0.247113, 0.575456, 0.947995, - 0.130996, 0.244441, 0.60372, 0.950818, - 0.133438, 0.241352, 0.63174, 0.954378, - 0.135004, 0.237849, 0.659971, 0.957151, - 0.135313, 0.233188, 0.688478, 0.960743, - 0.13521, 0.228001, 0.716767, 0.964352, - 0.135007, 0.222249, 0.744349, 0.967273, - 0.133523, 0.21542, 0.771786, 0.969767, - 0.131155, 0.208039, 0.798639, 0.973195, - 0.128492, 0.200076, 0.824774, 0.975557, - 0.125094, 0.191451, 0.850222, 0.977692, - 0.120578, 0.18184, 0.874761, 0.98026, - 0.115882, 0.172102, 0.898497, 0.981394, - 0.110372, 0.161859, 0.921636, 0.982386, - 0.10415, 0.15108, 0.943467, 0.983783, - 0.0978128, 0.140407, 0.964045, 0.98422, - 0.0906171, 0.129058, 0.98398, 0.985447, - 0.0832921, 0.117614, 1.00276, 0.986682, - 0.0754412, 0.10585, 1.02047, 0.987326, - 0.0673885, 0.0940943, 1.03678, 0.988707, - 0.0592565, 0.0822093, 1.05218, 0.990185, - 0.050717, 0.070192, 1.06652, 0.991866, - 0.0423486, 0.0582081, 1.07965, 0.993897, - 0.0336118, 0.0460985, 1.09188, 0.995841, - 0.0252178, 0.0342737, 1.10307, 0.997605, - 0.0164893, 0.0224829, 1.11324, 0.999037, - 0.00817112, 0.0110647, 1.12262, 1.00003, 0.000291686, - 0.000168673, 1.13139, 0.915304, - 5.52675e-06, 0.275999, 1.83285e-05, 0.91668, - 0.000139285, 0.276414, 0.000461914, 0.916664, - 0.00055713, 0.276409, 0.00184763, 0.916653, - 0.00125354, 0.276406, 0.00415715, 0.916651, - 0.00222851, 0.276405, 0.00739053, 0.916655, - 0.00348205, 0.276406, 0.0115478, 0.916653, - 0.00501414, 0.276405, 0.0166291, 0.916667, - 0.00682478, 0.276409, 0.0226346, 0.91668, - 0.00891398, 0.276412, 0.0295648, 0.91669, - 0.0112817, 0.276413, 0.0374199, 0.916727, - 0.013928, 0.276422, 0.0462016, 0.916759, - 0.0168528, 0.276429, 0.0559101, 0.916793, - 0.0200558, 0.276436, 0.0665466, 0.916849, - 0.0235373, 0.276448, 0.0781139, 0.916964, - 0.0272973, 0.276474, 0.0906156, 0.917047, - 0.0313344, 0.276491, 0.104051, 0.917152, - 0.0356465, 0.276511, 0.118424, 0.917286, - 0.0402271, 0.276533, 0.133736, 0.917469, - 0.0450408, 0.276564, 0.149978, 0.917686, - 0.0497872, 0.276563, 0.167057, 0.917953, - 0.0540937, 0.276493, 0.184846, 0.918228, - 0.0590709, 0.276437, 0.203614, 0.918572, - 0.0644277, 0.276398, 0.223212, 0.918918, - 0.0702326, 0.276362, 0.243584, 0.919356, - 0.076484, 0.276383, 0.264465, 0.919842, - 0.0830808, 0.276434, 0.285701, 0.920451, - 0.0892972, 0.276407, 0.307559, 0.921113, - 0.095016, 0.276128, 0.331501, 0.921881, - 0.100771, 0.275754, 0.356207, 0.923027, - 0.106029, 0.275254, 0.381477, 0.924364, - 0.111029, 0.274595, 0.40722, 0.925818, - 0.116345, 0.273841, 0.433385, 0.92746, - 0.121424, 0.272913, 0.459848, 0.929167, - 0.12657, 0.271837, 0.486493, 0.931426, - 0.131581, 0.270575, 0.513432, 0.934001, - 0.135038, 0.268512, 0.541502, 0.936296, - 0.138039, 0.266135, 0.569658, 0.939985, - 0.140687, 0.263271, 0.598375, 0.943516, - 0.143247, 0.260058, 0.626563, 0.94782, - 0.145135, 0.256138, 0.654711, 0.951023, - 0.145733, 0.251154, 0.683285, 0.955338, - 0.145554, 0.245562, 0.711831, 0.959629, - 0.145008, 0.239265, 0.739573, 0.963123, - 0.144003, 0.232064, 0.767027, 0.966742, - 0.141289, 0.224036, 0.794359, 0.969991, - 0.138247, 0.215305, 0.820361, 0.973403, - 0.134786, 0.206051, 0.846548, 0.975317, - 0.129966, 0.195914, 0.871541, 0.977647, - 0.12471, 0.185184, 0.895313, 0.980137, - 0.119086, 0.174161, 0.918398, 0.981031, - 0.112297, 0.162792, 0.940679, 0.982037, - 0.105372, 0.150952, 0.961991, 0.983164, - 0.097821, 0.138921, 0.981913, 0.983757, - 0.0897245, 0.126611, 1.00109, 0.985036, - 0.0815974, 0.114228, 1.01902, 0.986289, - 0.0727725, 0.101389, 1.03604, 0.987329, - 0.0639323, 0.0886476, 1.05149, 0.989193, - 0.0548109, 0.0756837, 1.06619, 0.990716, - 0.045687, 0.0627581, 1.07948, 0.992769, - 0.0364315, 0.0498337, 1.09172, 0.99524, - 0.0271761, 0.0370305, 1.1033, 0.997154, - 0.0179609, 0.0243959, 1.11353, 0.998845, - 0.00878063, 0.0119567, 1.12319, 1.00002, 0.000259038, - 0.000108146, 1.13177, 0.903945, - 5.91681e-06, 0.295126, 1.81226e-05, 0.903668, - 0.000148672, 0.295037, 0.000455367, 0.903677, - 0.000594683, 0.29504, 0.00182145, 0.903673, - 0.00133805, 0.295039, 0.00409831, 0.903666, - 0.00237872, 0.295036, 0.00728584, 0.903668, - 0.00371676, 0.295037, 0.0113842, 0.903679, - 0.00535212, 0.29504, 0.0163936, 0.903684, - 0.00728479, 0.295041, 0.0223141, 0.903698, - 0.00951473, 0.295044, 0.0291462, 0.903718, - 0.0120419, 0.295049, 0.0368904, 0.903754, - 0.0148664, 0.295058, 0.0455477, 0.903801, - 0.017988, 0.29507, 0.0551194, 0.903851, - 0.0214064, 0.295082, 0.0656058, 0.903921, - 0.0251219, 0.295097, 0.0770109, 0.904002, - 0.0291337, 0.295116, 0.0893354, 0.904111, - 0.033441, 0.29514, 0.102583, 0.904246, - 0.0380415, 0.295169, 0.116755, 0.904408, - 0.0429258, 0.295202, 0.131853, 0.904637, - 0.0480468, 0.295245, 0.147869, 0.904821, - 0.0529208, 0.295214, 0.164658, 0.905163, - 0.0577748, 0.295185, 0.182274, 0.905469, - 0.0631763, 0.295143, 0.200828, 0.905851, - 0.068917, 0.295112, 0.2202, 0.906322, - 0.0750861, 0.295104, 0.240372, 0.906761, - 0.0815855, 0.295086, 0.261082, 0.90735, - 0.0882138, 0.295095, 0.282123, 0.908087, - 0.095082, 0.295139, 0.303563, 0.908826, - 0.101488, 0.29492, 0.327028, 0.909832, - 0.107577, 0.294577, 0.351464, 0.911393, - 0.113033, 0.294115, 0.376497, 0.912804, - 0.118629, 0.293446, 0.402115, 0.914081, - 0.124232, 0.292581, 0.428111, 0.91637, - 0.129399, 0.29166, 0.454442, 0.91814, - 0.134892, 0.290422, 0.481024, 0.921179, - 0.140069, 0.289194, 0.507924, 0.924544, - 0.144431, 0.287421, 0.535557, 0.927995, - 0.147498, 0.284867, 0.563984, 0.931556, - 0.150197, 0.281722, 0.5923, 0.935777, - 0.152711, 0.278207, 0.620832, 0.940869, - 0.154836, 0.274148, 0.649069, 0.945994, - 0.155912, 0.269057, 0.677746, 0.949634, - 0.155641, 0.262799, 0.706293, 0.955032, - 0.154809, 0.256097, 0.734278, 0.95917, - 0.153678, 0.248618, 0.761751, 0.962931, - 0.151253, 0.239794, 0.789032, 0.966045, - 0.147625, 0.230281, 0.815422, 0.96971, - 0.143964, 0.220382, 0.841787, 0.972747, - 0.139464, 0.209846, 0.867446, 0.975545, - 0.133459, 0.198189, 0.892004, 0.978381, - 0.127424, 0.186362, 0.915458, 0.979935, - 0.120506, 0.173964, 0.937948, 0.980948, - 0.11282, 0.161429, 0.959732, 0.982234, - 0.104941, 0.148557, 0.980118, 0.982767, - 0.0962905, 0.135508, 0.999463, 0.983544, - 0.0873625, 0.122338, 1.01756, 0.984965, - 0.0783447, 0.108669, 1.03492, 0.986233, - 0.0684798, 0.0949911, 1.05087, 0.987796, - 0.0590867, 0.0811386, 1.0656, 0.989885, - 0.0489145, 0.0673099, 1.0794, 0.991821, - 0.0391, 0.0535665, 1.09174, 0.99448, - 0.029087, 0.0397529, 1.10341, 0.996769, - 0.019114, 0.0261463, 1.11383, 0.998641, - 0.00947007, 0.0128731, 1.1237, 0.999978, 0.000446316, - 0.000169093, 1.13253, 0.888362, - 6.27064e-06, 0.312578, 1.78215e-05, 0.889988, - 0.000157791, 0.313148, 0.000448451, 0.889825, - 0.000631076, 0.313092, 0.00179356, 0.88984, - 0.00141994, 0.313097, 0.00403554, 0.889828, - 0.0025243, 0.313092, 0.00717429, 0.889831, - 0.00394421, 0.313093, 0.0112099, 0.889831, - 0.00567962, 0.313093, 0.0161425, 0.889844, - 0.00773051, 0.313096, 0.0219724, 0.889858, - 0.0100968, 0.3131, 0.0286999, 0.889882, - 0.0127786, 0.313106, 0.0363256, 0.889918, - 0.0157757, 0.313116, 0.0448509, 0.889967, - 0.0190878, 0.313129, 0.0542758, 0.89003, - 0.022715, 0.313145, 0.0646032, 0.890108, - 0.0266566, 0.313165, 0.0758339, 0.890218, - 0.0309131, 0.313193, 0.0879729, 0.890351, - 0.0354819, 0.313226, 0.101019, 0.89051, - 0.0403613, 0.313263, 0.114979, 0.890672, - 0.0455385, 0.313294, 0.129848, 0.890882, - 0.0509444, 0.313333, 0.145616, 0.891189, - 0.0559657, 0.313324, 0.162122, 0.891457, - 0.0613123, 0.313281, 0.179524, 0.891856, - 0.0671488, 0.313281, 0.197855, 0.892312, - 0.0732732, 0.313268, 0.216991, 0.892819, - 0.0797865, 0.313263, 0.236924, 0.893369, - 0.0865269, 0.313247, 0.257433, 0.894045, - 0.0931592, 0.313205, 0.278215, 0.894884, - 0.100532, 0.313276, 0.299467, 0.895832, - 0.107716, 0.313205, 0.322276, 0.897043, - 0.114099, 0.312873, 0.34642, 0.898515, - 0.119941, 0.312331, 0.371187, 0.900191, - 0.126044, 0.311731, 0.396656, 0.90188, - 0.131808, 0.310859, 0.422488, 0.904359, - 0.137289, 0.309857, 0.448744, 0.906923, - 0.142991, 0.308714, 0.475239, 0.910634, - 0.148253, 0.307465, 0.501983, 0.914502, - 0.153332, 0.305774, 0.529254, 0.919046, - 0.156646, 0.303156, 0.557709, 0.923194, - 0.159612, 0.299928, 0.586267, 0.928858, - 0.162027, 0.296245, 0.614925, 0.934464, - 0.164203, 0.291832, 0.643187, 0.939824, - 0.165602, 0.286565, 0.671601, 0.944582, - 0.165383, 0.280073, 0.700213, 0.949257, - 0.164439, 0.272891, 0.728432, 0.954389, - 0.162953, 0.264771, 0.756082, 0.958595, - 0.161007, 0.255927, 0.78369, 0.962138, - 0.157243, 0.245769, 0.810769, 0.966979, - 0.152872, 0.235127, 0.836999, 0.969566, - 0.148209, 0.22347, 0.862684, 0.972372, - 0.142211, 0.211147, 0.887847, 0.975916, - 0.135458, 0.198606, 0.911843, 0.978026, - 0.128398, 0.185498, 0.934795, 0.979686, - 0.120313, 0.17171, 0.956787, 0.980748, - 0.11166, 0.158159, 0.978046, 0.981622, - 0.103035, 0.144399, 0.997693, 0.982356, - 0.0930328, 0.13001, 1.01642, 0.983308, - 0.0834627, 0.115778, 1.03366, 0.985037, - 0.0732249, 0.101327, 1.05014, 0.986493, - 0.0628145, 0.086554, 1.06507, 0.988484, - 0.0526556, 0.0720413, 1.07907, 0.991051, - 0.0415744, 0.0571151, 1.09189, 0.993523, - 0.0314275, 0.0426643, 1.10369, 0.99628, - 0.0203603, 0.0279325, 1.11423, 0.998344, - 0.0102446, 0.0138182, 1.12421, 0.999997, 0.00042612, - 0.000193628, 1.1333, 0.871555, - 6.60007e-06, 0.329176, 1.74749e-05, 0.875255, - 0.000166579, 0.330571, 0.000441051, 0.875644, - 0.000666394, 0.330718, 0.00176441, 0.875159, - 0.00149903, 0.330536, 0.00396899, 0.87516, - 0.00266493, 0.330536, 0.007056, 0.875158, - 0.00416393, 0.330535, 0.0110251, 0.87516, - 0.00599598, 0.330535, 0.0158764, 0.875163, - 0.00816108, 0.330536, 0.0216101, 0.875174, - 0.0106591, 0.330538, 0.0282266, 0.875199, - 0.0134899, 0.330545, 0.0357266, 0.875257, - 0.0166538, 0.330563, 0.0441117, 0.875304, - 0.0201501, 0.330575, 0.0533821, 0.875373, - 0.0239785, 0.330595, 0.0635395, 0.875464, - 0.0281389, 0.330619, 0.0745872, 0.875565, - 0.0326301, 0.330645, 0.0865255, 0.875691, - 0.0374516, 0.330676, 0.0993599, 0.875897, - 0.0425993, 0.330733, 0.113093, 0.876091, - 0.0480576, 0.330776, 0.127722, 0.876353, - 0.0537216, 0.330826, 0.143227, 0.876649, - 0.0589807, 0.330809, 0.159462, 0.877034, - 0.0647865, 0.330819, 0.176642, 0.877443, - 0.0709789, 0.330817, 0.194702, 0.877956, - 0.0774782, 0.330832, 0.213577, 0.878499, - 0.0843175, 0.330822, 0.233246, 0.879144, - 0.0912714, 0.330804, 0.253512, 0.879982, - 0.0980824, 0.330766, 0.274137, 0.88097, - 0.105823, 0.330864, 0.295209, 0.882051, - 0.113671, 0.330896, 0.317226, 0.883397, - 0.120303, 0.330545, 0.341068, 0.884987, - 0.12667, 0.330068, 0.365613, 0.886789, - 0.133118, 0.329418, 0.390807, 0.889311, - 0.139024, 0.328683, 0.416494, 0.891995, - 0.144971, 0.327729, 0.442618, 0.895106, - 0.150747, 0.326521, 0.469131, 0.899527, - 0.156283, 0.325229, 0.495921, 0.90504, - 0.161707, 0.32378, 0.523162, 0.909875, - 0.165661, 0.32122, 0.55092, 0.91561, - 0.168755, 0.317942, 0.579928, 0.921225, - 0.171193, 0.313983, 0.608539, 0.927308, - 0.17319, 0.309636, 0.636854, 0.933077, - 0.174819, 0.304262, 0.66523, 0.938766, - 0.175002, 0.297563, 0.693609, 0.943667, - 0.173946, 0.289613, 0.722157, 0.949033, - 0.172221, 0.281227, 0.750021, 0.953765, - 0.169869, 0.271545, 0.777466, 0.95804, - 0.166578, 0.261034, 0.804853, 0.962302, - 0.161761, 0.249434, 0.831569, 0.966544, - 0.156636, 0.237484, 0.857779, 0.969372, - 0.150784, 0.224395, 0.883051, 0.972486, - 0.143672, 0.210786, 0.907864, 0.975853, - 0.135772, 0.196556, 0.931223, 0.977975, - 0.127942, 0.182307, 0.954061, 0.979122, - 0.118347, 0.167607, 0.97531, 0.980719, - 0.109112, 0.152739, 0.995666, 0.981223, - 0.0991789, 0.137932, 1.01475, 0.98216, - 0.0883553, 0.122692, 1.03253, 0.983379, - 0.0780825, 0.107493, 1.04917, 0.985434, - 0.0665646, 0.0917791, 1.06464, 0.987332, - 0.0557714, 0.0764949, 1.07896, 0.990004, - 0.0442805, 0.060721, 1.09199, 0.992975, - 0.0331676, 0.0452284, 1.10393, 0.995811, - 0.0219547, 0.0297934, 1.11476, 0.9982, - 0.0107613, 0.0146415, 1.12484, 1.00002, 0.000248678, - 0.00014555, 1.13413, 0.859519, - 6.93595e-06, 0.347264, 1.71673e-05, 0.859843, - 0.00017503, 0.347394, 0.000433219, 0.859656, - 0.000700076, 0.347319, 0.00173277, 0.859671, - 0.00157517, 0.347325, 0.00389875, 0.859669, - 0.00280028, 0.347324, 0.00693112, 0.85967, - 0.0043754, 0.347324, 0.01083, 0.859665, - 0.00630049, 0.347321, 0.0155954, 0.859685, - 0.0085755, 0.347328, 0.0212278, 0.859694, - 0.0112003, 0.347329, 0.0277273, 0.859718, - 0.0141747, 0.347336, 0.0350946, 0.85976, - 0.0174988, 0.347348, 0.0433314, 0.85982, - 0.0211722, 0.347366, 0.0524384, 0.859892, - 0.0251941, 0.347387, 0.0624168, 0.860006, - 0.0295649, 0.347422, 0.0732708, 0.860122, - 0.0342825, 0.347453, 0.0849999, 0.860282, - 0.0393462, 0.347499, 0.0976102, 0.860482, - 0.0447513, 0.347554, 0.111104, 0.860719, - 0.0504775, 0.347614, 0.125479, 0.860998, - 0.0563577, 0.347666, 0.140703, 0.861322, - 0.0619473, 0.347662, 0.156681, 0.861724, - 0.0681277, 0.347684, 0.173597, 0.862198, - 0.0746567, 0.347709, 0.191371, 0.862733, - 0.0815234, 0.347727, 0.209976, 0.863371, - 0.0886643, 0.347744, 0.229351, 0.86414, - 0.0957908, 0.347734, 0.24934, 0.865138, - 0.102912, 0.34772, 0.269797, 0.866182, - 0.110924, 0.3478, 0.290654, 0.867436, - 0.119223, 0.347911, 0.312074, 0.869087, - 0.126197, 0.347649, 0.335438, 0.870859, - 0.133145, 0.347222, 0.359732, 0.872997, - 0.139869, 0.346645, 0.38467, 0.875939, - 0.146089, 0.345935, 0.41019, 0.879012, - 0.152334, 0.345012, 0.436218, 0.883353, - 0.15821, 0.343924, 0.462641, 0.888362, - 0.164097, 0.342636, 0.489449, 0.895026, - 0.169528, 0.341351, 0.516629, 0.900753, - 0.174408, 0.339115, 0.544109, 0.906814, - 0.17751, 0.335809, 0.572857, 0.912855, - 0.180101, 0.331597, 0.601554, 0.919438, - 0.182116, 0.32698, 0.630198, 0.925962, - 0.183494, 0.321449, 0.658404, 0.931734, - 0.184159, 0.314595, 0.686625, 0.93762, - 0.18304, 0.306462, 0.71531, 0.943858, - 0.181323, 0.297514, 0.744272, 0.948662, - 0.178683, 0.287447, 0.771462, 0.953299, - 0.175379, 0.276166, 0.798593, 0.957346, - 0.170395, 0.263758, 0.8256, 0.962565, - 0.165042, 0.251019, 0.852575, 0.966075, - 0.158655, 0.237011, 0.878316, 0.969048, - 0.151707, 0.222518, 0.90329, 0.972423, - 0.143271, 0.207848, 0.927745, 0.975833, - 0.134824, 0.192463, 0.950859, 0.977629, - 0.125444, 0.1768, 0.972947, 0.978995, - 0.114949, 0.161033, 0.993263, 0.980533, - 0.104936, 0.145523, 1.01337, 0.980745, - 0.0935577, 0.129799, 1.03128, 0.981814, - 0.0822956, 0.113486, 1.04825, 0.983943, - 0.0710082, 0.0972925, 1.06405, 0.986141, - 0.0587931, 0.0808138, 1.0785, 0.988878, - 0.0472755, 0.0644915, 1.09204, 0.992132, - 0.0349128, 0.0478128, 1.10413, 0.9953, - 0.0232407, 0.031621, 1.11527, 0.998117, - 0.0112713, 0.0154935, 1.12551, 1.00003, 0.000339743, - 0.000195763, 1.13504, 0.845441, - 7.29126e-06, 0.364305, 1.69208e-05, 0.843588, - 0.000183164, 0.363506, 0.000425067, 0.843412, - 0.00073253, 0.36343, 0.00169999, 0.843401, - 0.00164818, 0.363426, 0.00382495, 0.843399, - 0.00293008, 0.363425, 0.00679993, 0.843401, - 0.00457822, 0.363425, 0.010625, 0.843394, - 0.00659249, 0.363421, 0.0153002, 0.843398, - 0.00897282, 0.363421, 0.0208258, 0.843415, - 0.0117191, 0.363426, 0.0272024, 0.843438, - 0.0148312, 0.363432, 0.0344305, 0.843483, - 0.018309, 0.363447, 0.0425116, 0.84356, - 0.0221521, 0.363472, 0.0514471, 0.843646, - 0.0263597, 0.363499, 0.061238, 0.843743, - 0.0309315, 0.363527, 0.0718873, 0.84388, - 0.0358658, 0.363569, 0.0833969, 0.844079, - 0.0411624, 0.363631, 0.0957742, 0.844279, - 0.0468128, 0.363688, 0.109015, 0.844549, - 0.0527923, 0.363761, 0.123124, 0.844858, - 0.0588204, 0.363817, 0.138044, 0.84522, - 0.0647573, 0.36383, 0.153755, 0.845669, - 0.0713181, 0.363879, 0.170394, 0.846155, - 0.0781697, 0.363908, 0.187861, 0.846789, - 0.0853913, 0.363969, 0.206176, 0.847502, - 0.0928086, 0.363999, 0.225244, 0.8484, - 0.10005, 0.363997, 0.244926, 0.849461, - 0.107615, 0.364008, 0.265188, 0.850562, - 0.115814, 0.364055, 0.28587, 0.851962, - 0.124334, 0.364179, 0.306926, 0.854326, - 0.131995, 0.364233, 0.329605, 0.856295, - 0.139338, 0.363856, 0.35359, 0.858857, - 0.146346, 0.363347, 0.37831, 0.862428, - 0.152994, 0.362807, 0.403722, 0.866203, - 0.159463, 0.361963, 0.429537, 0.871629, - 0.165623, 0.36112, 0.456, 0.877365, - 0.171649, 0.359917, 0.482773, 0.883744, - 0.177151, 0.35848, 0.509705, 0.890693, - 0.182381, 0.356523, 0.537215, 0.897278, - 0.186076, 0.3533, 0.565493, 0.903958, - 0.188602, 0.349095, 0.594293, 0.910908, - 0.190755, 0.344215, 0.623165, 0.918117, - 0.192063, 0.338606, 0.651573, 0.924644, - 0.192758, 0.331544, 0.679869, 0.931054, - 0.192238, 0.323163, 0.708668, 0.937303, - 0.190035, 0.313529, 0.737201, 0.943387, - 0.187162, 0.303152, 0.764977, 0.948494, - 0.183876, 0.29146, 0.792683, 0.952546, - 0.178901, 0.277917, 0.819228, 0.958077, - 0.173173, 0.264753, 0.846559, 0.962462, - 0.16645, 0.25002, 0.872962, 0.966569, - 0.159452, 0.234873, 0.898729, 0.969108, - 0.15074, 0.218752, 0.923126, 0.973072, - 0.141523, 0.202673, 0.947278, 0.975452, - 0.132075, 0.186326, 0.969938, 0.977784, - 0.121257, 0.169396, 0.991325, 0.97899, - 0.110182, 0.153044, 1.01123, 0.979777, - 0.0989634, 0.136485, 1.0299, 0.980865, - 0.0865894, 0.119343, 1.04727, 0.982432, - 0.0746115, 0.102452, 1.06341, 0.984935, - 0.0621822, 0.0852423, 1.07834, 0.987776, - 0.0495694, 0.0678546, 1.092, 0.99103, - 0.0372386, 0.0506917, 1.1043, 0.99474, - 0.0244353, 0.0333316, 1.11576, 0.997768, - 0.0121448, 0.0164348, 1.12617, 1.00003, 0.00031774, - 0.000169504, 1.13598, 0.825551, - 7.56799e-06, 0.378425, 1.65099e-05, 0.82664, - 0.000190922, 0.378923, 0.000416504, 0.826323, - 0.000763495, 0.378779, 0.0016656, 0.826359, - 0.00171789, 0.378795, 0.00374768, 0.82636, - 0.00305402, 0.378795, 0.00666259, 0.826368, - 0.00477185, 0.378798, 0.0104104, 0.826364, - 0.00687131, 0.378795, 0.0149912, 0.826368, - 0.00935232, 0.378795, 0.0204054, 0.826376, - 0.0122146, 0.378797, 0.0266532, 0.826399, - 0.0154581, 0.378803, 0.0337355, 0.82646, - 0.0190825, 0.378824, 0.0416537, 0.826525, - 0.0230873, 0.378846, 0.0504091, 0.826614, - 0.0274719, 0.378876, 0.0600032, 0.82674, - 0.0322355, 0.378917, 0.0704393, 0.826888, - 0.0373766, 0.378964, 0.0817195, 0.827078, - 0.0428936, 0.379024, 0.0938492, 0.827318, - 0.0487778, 0.379099, 0.106828, 0.82764, - 0.0549935, 0.379199, 0.120659, 0.827926, - 0.0611058, 0.379227, 0.13526, 0.828325, - 0.0675054, 0.379275, 0.150713, 0.828801, - 0.0743455, 0.379332, 0.167034, 0.8294, - 0.0815523, 0.379415, 0.184209, 0.830094, - 0.0890779, 0.379495, 0.202203, 0.8309, - 0.096736, 0.379555, 0.220945, 0.831943, - 0.104135, 0.379577, 0.240306, 0.833037, - 0.112106, 0.379604, 0.260317, 0.834278, - 0.120554, 0.379668, 0.2808, 0.836192, - 0.129128, 0.3799, 0.301654, 0.838671, - 0.137541, 0.380109, 0.323502, 0.840939, - 0.14523, 0.379809, 0.347176, 0.844575, - 0.15248, 0.379593, 0.371706, 0.848379, - 0.159607, 0.37909, 0.39688, 0.853616, - 0.166267, 0.378617, 0.422702, 0.858921, - 0.172698, 0.377746, 0.448919, 0.865324, - 0.178823, 0.376749, 0.475661, 0.872207, - 0.184542, 0.375363, 0.502599, 0.880018, - 0.189836, 0.373657, 0.529914, 0.88694, - 0.194294, 0.370673, 0.557683, 0.894779, - 0.197022, 0.36662, 0.586848, 0.902242, - 0.199108, 0.36138, 0.615831, 0.909914, - 0.200398, 0.355434, 0.644478, 0.917088, - 0.20094, 0.348173, 0.672905, 0.923888, - 0.200671, 0.339482, 0.701327, 0.930495, - 0.198773, 0.32956, 0.730101, 0.937247, - 0.195394, 0.318363, 0.758383, 0.943108, - 0.191956, 0.306323, 0.786539, 0.948296, - 0.187227, 0.292576, 0.813637, 0.953472, - 0.181165, 0.278234, 0.840793, 0.958485, - 0.174119, 0.263054, 0.867712, 0.962714, - 0.166564, 0.246756, 0.893635, 0.966185, - 0.158181, 0.229945, 0.919028, 0.970146, - 0.148275, 0.212633, 0.943413, 0.973491, - 0.138157, 0.195229, 0.966627, 0.975741, - 0.127574, 0.178048, 0.988817, 0.977238, - 0.11554, 0.160312, 1.00924, 0.978411, - 0.10364, 0.142857, 1.02845, 0.979811, - 0.0913122, 0.125317, 1.04648, 0.98116, - 0.0782558, 0.107627, 1.06284, 0.983543, - 0.0655957, 0.0895862, 1.07798, 0.986789, - 0.0520411, 0.0713756, 1.092, 0.990292, - 0.0389727, 0.053228, 1.10484, 0.994187, - 0.025808, 0.0351945, 1.11642, 0.997499, - 0.0126071, 0.0173198, 1.12703, 0.999999, 0.000275604, - 0.000148602, 1.13674, 0.81075, - 7.8735e-06, 0.394456, 1.61829e-05, 0.808692, - 0.000198293, 0.393453, 0.000407564, 0.80846, - 0.000792877, 0.39334, 0.00162965, 0.808595, - 0.00178416, 0.393407, 0.00366711, 0.808597, - 0.00317182, 0.393408, 0.00651934, 0.808598, - 0.00495589, 0.393408, 0.0101866, 0.808591, - 0.00713627, 0.393403, 0.0146689, 0.808592, - 0.00971285, 0.393402, 0.0199667, 0.80861, - 0.0126855, 0.393407, 0.0260803, 0.808633, - 0.0160538, 0.393413, 0.0330107, 0.80868, - 0.0198175, 0.393429, 0.0407589, 0.808748, - 0.0239758, 0.393453, 0.0493264, 0.808854, - 0.0285286, 0.39349, 0.0587161, 0.808992, - 0.0334748, 0.39354, 0.0689304, 0.809141, - 0.0388116, 0.393588, 0.0799707, 0.809352, - 0.0445375, 0.39366, 0.0918432, 0.809608, - 0.0506427, 0.393742, 0.104549, 0.809915, - 0.0570708, 0.393834, 0.118085, 0.810253, - 0.0633526, 0.393885, 0.132377, 0.810687, - 0.0700966, 0.393953, 0.147537, 0.811233, - 0.0772274, 0.394047, 0.163543, 0.811865, - 0.0847629, 0.394148, 0.180394, 0.812648, - 0.0925663, 0.394265, 0.198051, 0.813583, - 0.100416, 0.394363, 0.216443, 0.814683, - 0.108119, 0.394402, 0.235502, 0.815948, - 0.11644, 0.394489, 0.255242, 0.817278, - 0.125036, 0.394542, 0.275441, 0.819605, - 0.133655, 0.39486, 0.296094, 0.822256, - 0.142682, 0.395248, 0.317309, 0.825349, - 0.150756, 0.395241, 0.340516, 0.829605, - 0.158392, 0.395285, 0.364819, 0.83391, - 0.165801, 0.394922, 0.389736, 0.839808, - 0.172677, 0.394691, 0.415409, 0.845708, - 0.179448, 0.394006, 0.441546, 0.853025, - 0.185746, 0.393279, 0.46832, 0.859666, - 0.191684, 0.391655, 0.495302, 0.86789, - 0.197146, 0.390068, 0.52262, 0.875845, - 0.201904, 0.38727, 0.550336, 0.882634, - 0.205023, 0.382688, 0.578825, 0.891076, - 0.207098, 0.377543, 0.608103, 0.900589, - 0.208474, 0.371752, 0.63723, 0.90791, - 0.209068, 0.364016, 0.665769, 0.915971, - 0.208655, 0.355593, 0.694428, 0.923455, - 0.20729, 0.345439, 0.723224, 0.931514, - 0.203821, 0.334099, 0.751925, 0.937885, - 0.19986, 0.321069, 0.780249, 0.943136, - 0.194993, 0.306571, 0.8077, 0.948818, - 0.189132, 0.291556, 0.83497, 0.954433, - 0.181617, 0.275745, 0.86188, 0.959078, - 0.173595, 0.258695, 0.888562, 0.962705, - 0.164855, 0.240825, 0.914008, 0.966753, - 0.155129, 0.22268, 0.939145, 0.970704, - 0.144241, 0.204542, 0.963393, 0.973367, - 0.133188, 0.185927, 0.985983, 0.975984, - 0.121146, 0.167743, 1.00704, 0.976994, - 0.108366, 0.149218, 1.02715, 0.978485, - 0.0956746, 0.13131, 1.0455, 0.980074, - 0.0820733, 0.112513, 1.06221, 0.98225, - 0.0684061, 0.0938323, 1.07782, 0.98553, - 0.0549503, 0.0749508, 1.09199, 0.989529, - 0.0407857, 0.055848, 1.10508, 0.993536, - 0.0271978, 0.0368581, 1.11684, 0.997247, - 0.0132716, 0.0181845, 1.12789, 1, 0.000431817, - 0.000198809, 1.13792, 0.785886, - 8.12608e-06, 0.405036, 1.57669e-05, 0.790388, - 0.000205278, 0.407355, 0.000398297, 0.790145, - 0.000820824, 0.407231, 0.00159263, 0.790135, - 0.00184681, 0.407226, 0.00358336, 0.790119, - 0.00328316, 0.407218, 0.00637039, 0.790126, - 0.00512988, 0.40722, 0.0099539, 0.79013, - 0.00738684, 0.407221, 0.0143339, 0.790135, - 0.0100538, 0.407221, 0.0195107, 0.790134, - 0.0131306, 0.407217, 0.0254848, 0.79016, - 0.0166169, 0.407224, 0.0322572, 0.790197, - 0.020512, 0.407236, 0.0398284, 0.790273, - 0.0248157, 0.407263, 0.0482014, 0.790381, - 0.029527, 0.407304, 0.0573777, 0.790521, - 0.0346446, 0.407355, 0.0673602, 0.790704, - 0.0401665, 0.40742, 0.0781522, 0.790925, - 0.0460896, 0.407499, 0.0897582, 0.791195, - 0.0524017, 0.407589, 0.10218, 0.791522, - 0.0590121, 0.407691, 0.11541, 0.791878, - 0.0654876, 0.407748, 0.12939, 0.792361, - 0.0725207, 0.407849, 0.144237, 0.792942, - 0.0799844, 0.407963, 0.159924, 0.79362, - 0.0877896, 0.408087, 0.176425, 0.794529, - 0.0958451, 0.408259, 0.193733, 0.795521, - 0.103827, 0.408362, 0.211756, 0.796778, - 0.111937, 0.408482, 0.230524, 0.798027, - 0.120521, 0.408547, 0.249967, 0.799813, - 0.129242, 0.408721, 0.269926, 0.802387, - 0.138048, 0.409148, 0.290338, 0.805279, - 0.147301, 0.409641, 0.311193, 0.809251, - 0.155895, 0.410154, 0.333611, 0.813733, - 0.163942, 0.410297, 0.357615, 0.819081, - 0.171666, 0.410373, 0.382339, 0.825427, - 0.178905, 0.410348, 0.407828, 0.83172, - 0.185812, 0.409486, 0.434034, 0.83877, - 0.192318, 0.408776, 0.460493, 0.845817, - 0.198249, 0.407176, 0.487346, 0.854664, - 0.204034, 0.405719, 0.514832, 0.863495, - 0.208908, 0.403282, 0.542401, 0.871883, - 0.212765, 0.399293, 0.570683, 0.88065, - 0.214911, 0.393803, 0.599947, 0.89004, - 0.216214, 0.387536, 0.62932, 0.898476, - 0.216745, 0.379846, 0.658319, 0.906738, - 0.216387, 0.370625, 0.687138, 0.914844, - 0.215053, 0.360139, 0.71601, 0.923877, - 0.212007, 0.348849, 0.745124, 0.931925, - 0.207481, 0.335639, 0.773366, 0.938054, - 0.202418, 0.320798, 0.801636, 0.943895, - 0.196507, 0.304772, 0.829055, 0.949468, - 0.189009, 0.288033, 0.856097, 0.955152, - 0.180539, 0.270532, 0.88301, 0.959403, - 0.171437, 0.251639, 0.909296, 0.963309, - 0.161661, 0.232563, 0.934868, 0.967399, - 0.150425, 0.213231, 0.959662, 0.972009, - 0.138659, 0.194247, 0.98302, 0.97433, - 0.126595, 0.174718, 1.00517, 0.975823, - 0.113205, 0.155518, 1.02566, 0.976371, - 0.0996096, 0.136709, 1.04418, 0.978705, - 0.0860754, 0.117571, 1.06146, 0.981477, - 0.0714438, 0.0980046, 1.07777, 0.984263, - 0.0572304, 0.0782181, 1.09214, 0.988423, - 0.0428875, 0.0584052, 1.10553, 0.993, - 0.0282442, 0.038522, 1.11758, 0.99704, - 0.0140183, 0.0190148, 1.12864, 0.999913, 0.000369494, - 0.000145203, 1.13901, 0.777662, - 8.4153e-06, 0.423844, 1.54403e-05, 0.770458, - 0.000211714, 0.419915, 0.00038845, 0.770716, - 0.000846888, 0.420055, 0.00155386, 0.770982, - 0.00190567, 0.420202, 0.00349653, 0.770981, - 0.00338782, 0.420201, 0.00621606, 0.77098, - 0.00529338, 0.4202, 0.00971274, 0.770983, - 0.00762223, 0.4202, 0.0139867, 0.770985, - 0.0103741, 0.420198, 0.0190381, 0.770996, - 0.0135489, 0.4202, 0.0248677, 0.771029, - 0.0171461, 0.420212, 0.0314764, 0.771052, - 0.0211647, 0.420215, 0.0388648, 0.771131, - 0.0256048, 0.420245, 0.047036, 0.771235, - 0.0304647, 0.420284, 0.0559911, 0.771383, - 0.0357436, 0.420341, 0.0657346, 0.771591, - 0.0414392, 0.420423, 0.0762694, 0.771819, - 0.0475462, 0.420506, 0.0875984, 0.772123, - 0.0540506, 0.420617, 0.099727, 0.772464, - 0.060797, 0.42072, 0.112637, 0.772855, - 0.0675393, 0.420799, 0.126313, 0.773317, - 0.0748323, 0.420893, 0.140824, 0.773981, - 0.0825681, 0.421058, 0.15617, 0.774746, - 0.0906307, 0.421226, 0.172322, 0.77566, - 0.0988982, 0.421397, 0.189253, 0.776837, - 0.106994, 0.421569, 0.206912, 0.778097, - 0.115528, 0.421704, 0.225359, 0.779588, - 0.124317, 0.421849, 0.24447, 0.781574, - 0.133139, 0.422097, 0.264156, 0.784451, - 0.142179, 0.422615, 0.284318, 0.787682, - 0.15165, 0.423269, 0.304902, 0.792433, - 0.160771, 0.424396, 0.3265, 0.797359, - 0.169166, 0.424772, 0.35014, 0.803986, - 0.177149, 0.425475, 0.374768, 0.809504, - 0.184745, 0.424996, 0.399928, 0.815885, - 0.19173, 0.424247, 0.425796, 0.823513, - 0.198525, 0.423515, 0.452287, 0.832549, - 0.204709, 0.422787, 0.479321, 0.841653, - 0.210447, 0.421187, 0.506718, 0.850401, - 0.215501, 0.418519, 0.53432, 0.859854, - 0.219752, 0.414715, 0.56242, 0.869364, - 0.222305, 0.409462, 0.591558, 0.878837, - 0.223744, 0.402926, 0.621074, 0.888636, - 0.224065, 0.395043, 0.650538, 0.898132, - 0.223742, 0.38564, 0.679538, 0.907181, - 0.222308, 0.375378, 0.708674, 0.915621, - 0.219837, 0.363212, 0.737714, 0.9239, - 0.215233, 0.349313, 0.767014, 0.931644, - 0.209592, 0.334162, 0.795133, 0.938887, - 0.203644, 0.317943, 0.823228, 0.945282, - 0.196349, 0.300581, 0.850822, 0.950758, - 0.18742, 0.282195, 0.877594, 0.956146, - 0.177879, 0.262481, 0.904564, 0.960355, - 0.167643, 0.242487, 0.930741, 0.965256, - 0.156671, 0.222668, 0.955868, 0.968029, - 0.144123, 0.201907, 0.979869, 0.97251, - 0.131305, 0.18202, 1.00291, 0.974925, - 0.118335, 0.161909, 1.02392, 0.975402, - 0.103714, 0.142129, 1.0433, 0.976987, - 0.089415, 0.122447, 1.06089, 0.979677, - 0.0748858, 0.102248, 1.07713, 0.983184, - 0.0596086, 0.0814851, 1.09218, 0.987466, - 0.0447671, 0.0609484, 1.10585, 0.992348, - 0.0295217, 0.0401835, 1.11829, 0.996674, - 0.0143917, 0.0198163, 1.12966, 1.00003, 0.000321364, - 0.000149983, 1.1402, 0.757901, - 8.69074e-06, 0.436176, 1.51011e-05, 0.751195, - 0.000217848, 0.432317, 0.000378533, 0.751178, - 0.000871373, 0.432307, 0.0015141, 0.751195, - 0.00196061, 0.432317, 0.0034068, 0.751198, - 0.00348552, 0.432318, 0.00605659, 0.751195, - 0.00544599, 0.432315, 0.00946353, 0.751207, - 0.00784203, 0.43232, 0.013628, 0.751213, - 0.0106732, 0.43232, 0.0185499, 0.751221, - 0.0139393, 0.432319, 0.0242302, 0.751244, - 0.0176398, 0.432325, 0.0306694, 0.7513, - 0.0217743, 0.432348, 0.0378698, 0.751358, - 0.0263412, 0.432367, 0.0458321, 0.751458, - 0.0313396, 0.432404, 0.0545587, 0.751608, - 0.0367682, 0.432464, 0.0640543, 0.7518, - 0.0426246, 0.43254, 0.0743222, 0.752065, - 0.0489031, 0.432645, 0.0853668, 0.752376, - 0.0555828, 0.432762, 0.0971911, 0.752715, - 0.0623861, 0.432859, 0.109768, 0.753137, - 0.069415, 0.432958, 0.123126, 0.753676, - 0.0770039, 0.433099, 0.137308, 0.754345, - 0.084971, 0.433272, 0.15229, 0.755235, - 0.0932681, 0.433504, 0.168075, 0.756186, - 0.10171, 0.433693, 0.184625, 0.757363, - 0.110019, 0.433857, 0.201897, 0.75884, - 0.11887, 0.434102, 0.220014, 0.760467, - 0.127881, 0.434306, 0.238778, 0.762969, - 0.136766, 0.434751, 0.258172, 0.765823, - 0.14612, 0.43529, 0.278062, 0.769676, - 0.15566, 0.436236, 0.298437, 0.774909, - 0.165177, 0.437754, 0.319532, 0.77994, - 0.17402, 0.438343, 0.342505, 0.785757, - 0.182201, 0.438609, 0.366693, 0.792487, - 0.190104, 0.438762, 0.391668, 0.80038, - 0.197438, 0.438795, 0.417494, 0.808494, - 0.204365, 0.438226, 0.443933, 0.817695, - 0.210714, 0.437283, 0.470929, 0.828111, - 0.216651, 0.436087, 0.498569, 0.837901, - 0.221804, 0.433717, 0.526165, 0.847813, - 0.226318, 0.430133, 0.554155, 0.858314, - 0.229297, 0.425213, 0.582822, 0.868891, - 0.230999, 0.418576, 0.612847, 0.878941, - 0.231155, 0.410405, 0.642445, 0.888809, - 0.230935, 0.400544, 0.672024, 0.898089, - 0.229343, 0.389613, 0.701366, 0.908081, - 0.226886, 0.377197, 0.730763, 0.916819, - 0.222676, 0.363397, 0.759642, 0.924968, - 0.216835, 0.347437, 0.788775, 0.932906, - 0.210245, 0.32995, 0.817135, 0.940025, - 0.202992, 0.312262, 0.844912, 0.946101, - 0.19436, 0.293313, 0.872164, 0.952835, - 0.184125, 0.273638, 0.899443, 0.957347, - 0.173657, 0.252385, 0.926389, 0.961434, - 0.162204, 0.231038, 0.951947, 0.965522, - 0.14979, 0.209834, 0.976751, 0.969412, - 0.136307, 0.188821, 1.00022, 0.973902, - 0.122527, 0.168013, 1.02229, 0.974045, - 0.108213, 0.147634, 1.04199, 0.975775, - 0.0927397, 0.12705, 1.06019, 0.978383, - 0.0778212, 0.106309, 1.07711, 0.98211, - 0.0621216, 0.0849279, 1.09245, 0.986517, - 0.0463847, 0.0633519, 1.10651, 0.991696, - 0.0309353, 0.0419698, 1.11903, 0.996349, - 0.0150914, 0.0206272, 1.13073, 1.00003, 0.000442449, - 0.000231396, 1.14146, 0.727498, - 8.85074e-06, 0.441528, 1.45832e-05, 0.730897, - 0.000223525, 0.443589, 0.000368298, 0.730796, - 0.000893996, 0.443528, 0.00147303, 0.730805, - 0.00201149, 0.443533, 0.00331433, 0.730814, - 0.00357596, 0.443538, 0.00589222, 0.730815, - 0.00558734, 0.443538, 0.00920678, 0.730822, - 0.00804544, 0.44354, 0.0132582, 0.730836, - 0.0109501, 0.443545, 0.0180468, 0.730848, - 0.0143008, 0.443546, 0.0235732, 0.730871, - 0.0180969, 0.443552, 0.0298382, 0.730915, - 0.022338, 0.443567, 0.0368438, 0.730982, - 0.0270225, 0.443591, 0.044591, 0.731076, - 0.0321491, 0.443627, 0.0530831, 0.731245, - 0.0377166, 0.443699, 0.0623243, 0.73144, - 0.0437216, 0.443777, 0.0723181, 0.7317, - 0.0501576, 0.443881, 0.0830691, 0.732034, - 0.0569942, 0.444014, 0.0945809, 0.732388, - 0.0638756, 0.444113, 0.106825, 0.732853, - 0.071203, 0.444247, 0.119859, 0.733473, - 0.0790076, 0.444442, 0.13369, 0.734195, - 0.0871937, 0.444645, 0.148304, 0.735069, - 0.095696, 0.444877, 0.163702, 0.736169, - 0.10426, 0.445133, 0.179861, 0.73747, - 0.112853, 0.44537, 0.196778, 0.738991, - 0.12199, 0.445651, 0.214496, 0.740865, - 0.131153, 0.445958, 0.232913, 0.743637, - 0.140245, 0.446548, 0.251977, 0.746797, - 0.149722, 0.447246, 0.271551, 0.751517, - 0.159341, 0.448656, 0.291774, 0.756156, - 0.169106, 0.449866, 0.312455, 0.761519, - 0.178436, 0.450919, 0.334552, 0.768295, - 0.186904, 0.451776, 0.358491, 0.776613, - 0.195117, 0.452832, 0.383446, 0.783966, - 0.202695, 0.45249, 0.408945, 0.793542, - 0.20985, 0.452587, 0.435364, 0.803192, - 0.216403, 0.451852, 0.462336, 0.813892, - 0.22251, 0.450708, 0.48987, 0.824968, - 0.227676, 0.4486, 0.517697, 0.835859, - 0.232443, 0.445156, 0.545975, 0.846825, - 0.235775, 0.440351, 0.574483, 0.858085, - 0.237897, 0.433641, 0.604246, 0.868825, - 0.238074, 0.425354, 0.634101, 0.879638, - 0.237661, 0.415383, 0.664201, 0.889966, - 0.236186, 0.404136, 0.693918, 0.899479, - 0.233599, 0.390917, 0.723481, 0.908769, - 0.229737, 0.376352, 0.75258, 0.917966, - 0.223836, 0.360372, 0.781764, 0.926304, - 0.217067, 0.342551, 0.811139, 0.934626, - 0.209309, 0.324238, 0.839585, 0.941841, - 0.20071, 0.304484, 0.867044, 0.94789, - 0.190602, 0.283607, 0.894579, 0.954196, - 0.179253, 0.262205, 0.921743, 0.958383, - 0.167646, 0.239847, 0.948026, 0.963119, - 0.155073, 0.218078, 0.973296, 0.966941, - 0.141426, 0.195899, 0.998135, 0.970836, - 0.126849, 0.174121, 1.02021, 0.973301, - 0.112296, 0.153052, 1.04085, 0.97448, - 0.0964965, 0.131733, 1.05946, 0.977045, - 0.080489, 0.10997, 1.07693, 0.980751, - 0.064844, 0.0881657, 1.09254, 0.985475, - 0.0481938, 0.0657987, 1.10697, 0.991089, - 0.0319185, 0.0435215, 1.12004, 0.996122, - 0.0158088, 0.0214779, 1.13173, 1.00001, 0.000372455, - 0.000200295, 1.14291, 0.708622, - 9.07597e-06, 0.45304, 1.41962e-05, 0.711162, - 0.000228911, 0.454662, 0.000358052, 0.709812, - 0.000914446, 0.453797, 0.00143034, 0.709865, - 0.00205819, 0.453834, 0.00321935, 0.709864, - 0.00365894, 0.453833, 0.00572331, 0.709855, - 0.00571692, 0.453826, 0.00894278, 0.709862, - 0.00823201, 0.453828, 0.012878, 0.709875, - 0.011204, 0.453832, 0.0175295, 0.709896, - 0.0146323, 0.453839, 0.0228978, 0.709925, - 0.0185163, 0.453847, 0.0289839, 0.709974, - 0.0228551, 0.453866, 0.0357894, 0.710045, - 0.0276473, 0.453892, 0.0433161, 0.710133, - 0.032891, 0.453924, 0.0515665, 0.710292, - 0.0385851, 0.453992, 0.0605458, 0.710485, - 0.0447254, 0.45407, 0.0702574, 0.710769, - 0.0513051, 0.454192, 0.0807077, 0.711106, - 0.0582733, 0.454329, 0.091896, 0.711516, - 0.0652866, 0.45446, 0.103814, 0.712071, - 0.0728426, 0.454653, 0.116508, 0.712676, - 0.0808307, 0.45484, 0.129968, 0.713476, - 0.0892216, 0.455096, 0.144206, 0.714377, - 0.0979047, 0.455346, 0.159212, 0.715579, - 0.106531, 0.455647, 0.174973, 0.716977, - 0.115492, 0.455961, 0.191504, 0.71862, - 0.124821, 0.456315, 0.208835, 0.72084, - 0.134079, 0.4568, 0.226869, 0.723786, - 0.143427, 0.457521, 0.245582, 0.727464, - 0.153061, 0.458475, 0.264957, 0.732771, - 0.162768, 0.460239, 0.284948, 0.736515, - 0.172627, 0.460899, 0.30522, 0.743519, - 0.182487, 0.463225, 0.326717, 0.750041, - 0.191295, 0.464027, 0.350113, 0.758589, - 0.199746, 0.465227, 0.374782, 0.767703, - 0.207584, 0.465877, 0.400226, 0.777484, - 0.214973, 0.465996, 0.426442, 0.788792, - 0.221796, 0.466019, 0.453688, 0.800194, - 0.228038, 0.465083, 0.481246, 0.811234, - 0.233346, 0.462506, 0.509086, 0.822859, - 0.238073, 0.459257, 0.537338, 0.835082, - 0.241764, 0.454863, 0.566108, 0.846332, - 0.244241, 0.448163, 0.595126, 0.858355, - 0.244736, 0.439709, 0.625574, 0.87034, - 0.244278, 0.429837, 0.65617, 0.881027, - 0.24255, 0.418002, 0.686029, 0.891007, - 0.239912, 0.404325, 0.716039, 0.900874, - 0.236133, 0.389222, 0.745518, 0.911072, - 0.230672, 0.373269, 0.775026, 0.920359, - 0.22356, 0.355083, 0.804521, 0.928604, - 0.215591, 0.335533, 0.834045, 0.937175, - 0.206503, 0.315278, 0.861612, 0.942825, - 0.196684, 0.293653, 0.889131, 0.949805, - 0.185116, 0.271503, 0.916853, 0.955535, - 0.172703, 0.248821, 0.943541, 0.959843, - 0.159978, 0.225591, 0.970132, 0.964393, - 0.146375, 0.202719, 0.994709, 0.968008, - 0.131269, 0.179928, 1.0186, 0.971013, - 0.11569, 0.158007, 1.03928, 0.973334, - 0.1003, 0.13624, 1.05887, 0.975775, - 0.0833352, 0.1138, 1.07652, 0.979579, - 0.0668981, 0.0913141, 1.09297, 0.984323, - 0.0500902, 0.0683051, 1.10734, 0.990351, - 0.0332377, 0.0451771, 1.12084, 0.995823, - 0.0161491, 0.0221705, 1.13296, 1.0001, 0.000234083, - 0.000108712, 1.14441, 0.683895, - 9.24677e-06, 0.46015, 1.37429e-05, 0.68833, - 0.000233383, 0.463134, 0.000346865, 0.688368, - 0.000933547, 0.463159, 0.00138748, 0.688367, - 0.00210049, 0.463159, 0.00312187, 0.688369, - 0.00373415, 0.463159, 0.00555004, 0.688377, - 0.00583449, 0.463163, 0.00867216, 0.688386, - 0.00840128, 0.463166, 0.0124884, 0.688398, - 0.0114343, 0.463169, 0.0169993, 0.688418, - 0.0149329, 0.463175, 0.0222054, 0.688453, - 0.0188964, 0.463188, 0.028108, 0.688515, - 0.0233239, 0.463214, 0.0347085, 0.68857, - 0.0282136, 0.463231, 0.0420091, 0.688679, - 0.033564, 0.463276, 0.0500132, 0.688854, - 0.0393733, 0.463356, 0.0587255, 0.689038, - 0.0456354, 0.46343, 0.0681476, 0.689321, - 0.0523433, 0.463553, 0.0782897, 0.689662, - 0.059412, 0.463693, 0.0891501, 0.690188, - 0.0665736, 0.4639, 0.100735, 0.690755, - 0.0743106, 0.464107, 0.113074, 0.691405, - 0.0824722, 0.464329, 0.126161, 0.692198, - 0.0910484, 0.464585, 0.140007, 0.693196, - 0.0998778, 0.464893, 0.154612, 0.69454, - 0.108651, 0.465285, 0.169984, 0.695921, - 0.117855, 0.465596, 0.186106, 0.697749, - 0.12734, 0.466056, 0.203034, 0.700375, - 0.136714, 0.466771, 0.220703, 0.703395, - 0.146386, 0.467579, 0.239062, 0.707904, - 0.156096, 0.469067, 0.258188, 0.711673, - 0.165904, 0.469851, 0.277759, 0.717489, - 0.175812, 0.471815, 0.297935, 0.724051, - 0.185931, 0.47389, 0.318916, 0.731965, - 0.195238, 0.47587, 0.341591, 0.741151, - 0.204021, 0.477523, 0.366062, 0.751416, - 0.212113, 0.478881, 0.391396, 0.761848, - 0.21979, 0.479226, 0.417599, 0.771886, - 0.2267, 0.478495, 0.444401, 0.783998, - 0.232991, 0.477622, 0.472084, 0.796523, - 0.238645, 0.475833, 0.500193, 0.808851, - 0.243396, 0.472568, 0.52865, 0.821191, - 0.247226, 0.467857, 0.557362, 0.834261, - 0.250102, 0.461871, 0.586768, 0.846762, - 0.251056, 0.453543, 0.617085, 0.859867, - 0.250604, 0.443494, 0.647659, 0.871948, - 0.248783, 0.431711, 0.678119, 0.882967, - 0.245855, 0.417911, 0.708399, 0.892826, - 0.242168, 0.401993, 0.738256, 0.90332, - 0.237062, 0.385371, 0.767999, 0.913633, - 0.22997, 0.366837, 0.798191, 0.922774, - 0.221687, 0.346372, 0.827756, 0.931371, - 0.212345, 0.325682, 0.856425, 0.938929, - 0.20206, 0.303665, 0.884299, 0.944821, - 0.190981, 0.280786, 0.912023, 0.951792, - 0.178065, 0.2573, 0.939669, 0.957712, - 0.164634, 0.233448, 0.96655, 0.961912, - 0.150863, 0.209504, 0.992366, 0.966382, - 0.13577, 0.18597, 1.01633, 0.969588, - 0.119593, 0.162905, 1.03843, 0.971777, - 0.103203, 0.14053, 1.05841, 0.97433, - 0.0865888, 0.117909, 1.07632, 0.978686, - 0.0690829, 0.0944101, 1.09326, 0.983281, - 0.0516568, 0.0705671, 1.10796, 0.989562, - 0.034558, 0.0468592, 1.12182, 0.995465, - 0.0167808, 0.0229846, 1.1342, 0.999991, 0.000373016, - 0.000235606, 1.1459, 0.662251, - 9.39016e-06, 0.468575, 1.32714e-05, 0.666634, - 0.000237624, 0.471675, 0.000335842, 0.666411, - 0.000950385, 0.471516, 0.00134321, 0.666399, - 0.00213833, 0.471509, 0.00302221, 0.666386, - 0.0038014, 0.471499, 0.00537283, 0.666405, - 0.00593958, 0.471511, 0.00839533, 0.666406, - 0.00855253, 0.471508, 0.0120898, 0.666428, - 0.0116401, 0.471519, 0.0164569, 0.666444, - 0.0152015, 0.471522, 0.0214971, 0.66649, - 0.0192362, 0.471543, 0.027212, 0.666537, - 0.0237428, 0.471558, 0.033603, 0.666617, - 0.0287198, 0.471591, 0.0406728, 0.666718, - 0.0341647, 0.471631, 0.0484238, 0.666889, - 0.0400759, 0.47171, 0.0568621, 0.667104, - 0.0464479, 0.471805, 0.0659915, 0.667374, - 0.0532677, 0.471923, 0.0758178, 0.667772, - 0.0603805, 0.472098, 0.0863425, 0.668371, - 0.0677392, 0.472363, 0.0975917, 0.668971, - 0.0756028, 0.472596, 0.109567, 0.669696, - 0.0839293, 0.472869, 0.122272, 0.670481, - 0.0926683, 0.473126, 0.135718, 0.6715, - 0.1016, 0.473442, 0.149914, 0.672911, - 0.110566, 0.47389, 0.164882, 0.674512, - 0.119984, 0.474354, 0.180602, 0.67651, - 0.129574, 0.474922, 0.19711, 0.679292, - 0.139106, 0.475764, 0.214371, 0.682798, - 0.148993, 0.476886, 0.232405, 0.686955, - 0.158737, 0.478179, 0.251153, 0.691406, - 0.168754, 0.479432, 0.270436, 0.697438, - 0.178703, 0.481481, 0.290374, 0.704761, - 0.188955, 0.484143, 0.311044, 0.713599, - 0.198814, 0.487007, 0.333003, 0.723194, - 0.207869, 0.488962, 0.357144, 0.732601, - 0.216189, 0.489815, 0.382169, 0.744193, - 0.22398, 0.490888, 0.408227, 0.754907, - 0.231156, 0.490355, 0.434928, 0.767403, - 0.23747, 0.489548, 0.462599, 0.78107, - 0.243503, 0.488274, 0.490908, 0.793893, - 0.248114, 0.484843, 0.519421, 0.807296, - 0.25222, 0.4803, 0.548561, 0.820529, - 0.255265, 0.474097, 0.577772, 0.833716, - 0.256741, 0.466041, 0.607782, 0.848403, - 0.25637, 0.456547, 0.638807, 0.860755, - 0.254804, 0.443946, 0.670058, 0.874012, - 0.251834, 0.430852, 0.700749, 0.885619, - 0.247867, 0.414903, 0.731446, 0.896069, - 0.242634, 0.397276, 0.761191, 0.906266, - 0.236093, 0.378535, 0.791053, 0.916759, - 0.227543, 0.358038, 0.821298, 0.92523, - 0.21783, 0.335705, 0.850747, 0.93436, - 0.207534, 0.313797, 0.879258, 0.941631, - 0.195983, 0.289671, 0.907734, 0.947564, - 0.183567, 0.265319, 0.935206, 0.953681, - 0.169345, 0.240815, 0.962739, 0.960008, - 0.154909, 0.216119, 0.989227, 0.964145, - 0.140161, 0.192096, 1.01465, 0.968171, - 0.123411, 0.167855, 1.03737, 0.969859, - 0.106525, 0.144817, 1.05767, 0.972666, - 0.0891023, 0.12149, 1.0761, 0.977055, - 0.0718094, 0.0975306, 1.09336, 0.982527, - 0.0534213, 0.0730217, 1.10878, 0.989001, - 0.0355579, 0.0483366, 1.12285, 0.99512, - 0.0176383, 0.023938, 1.13548, 1.00007, 0.000368831, - 0.000211581, 1.14744, 0.651047, - 9.60845e-06, 0.484101, 1.2922e-05, 0.644145, - 0.000241347, 0.478968, 0.000324578, 0.64396, - 0.000965142, 0.478831, 0.00129798, 0.64396, - 0.00217154, 0.47883, 0.00292046, 0.643968, - 0.00386049, 0.478835, 0.00519202, 0.643974, - 0.00603186, 0.478838, 0.0081128, 0.643977, - 0.0086854, 0.478836, 0.011683, 0.643982, - 0.0118207, 0.478834, 0.0159031, 0.644024, - 0.0154374, 0.478856, 0.0207743, 0.644059, - 0.0195343, 0.478868, 0.0262975, 0.644122, - 0.0241103, 0.478896, 0.0324747, 0.644207, - 0.0291638, 0.478933, 0.039309, 0.64432, - 0.0346919, 0.478981, 0.0468029, 0.644481, - 0.0406919, 0.479053, 0.0549614, 0.644722, - 0.047159, 0.479169, 0.0637909, 0.645013, - 0.0540748, 0.479302, 0.0732974, 0.645503, - 0.0612001, 0.479541, 0.0834898, 0.646117, - 0.0687303, 0.479829, 0.0943873, 0.646707, - 0.0767846, 0.480061, 0.105991, 0.647431, - 0.0852465, 0.480343, 0.11831, 0.64831, - 0.0940719, 0.48066, 0.131348, 0.649486, - 0.103056, 0.481083, 0.14514, 0.650864, - 0.112261, 0.481528, 0.159676, 0.652604, - 0.121852, 0.482102, 0.174979, 0.654825, - 0.131505, 0.482813, 0.191079, 0.657876, - 0.141189, 0.483876, 0.207927, 0.661339, - 0.151239, 0.48499, 0.225586, 0.665463, - 0.161091, 0.486279, 0.243947, 0.670542, - 0.171235, 0.487968, 0.262957, 0.677361, - 0.181347, 0.49053, 0.282781, 0.685672, - 0.191679, 0.493862, 0.303311, 0.694551, - 0.201781, 0.49699, 0.324607, 0.703753, - 0.211164, 0.498884, 0.347916, 0.713703, - 0.219675, 0.500086, 0.372628, 0.725911, - 0.227836, 0.501554, 0.398694, 0.73862, - 0.23533, 0.502193, 0.425529, 0.752118, - 0.241786, 0.501811, 0.453209, 0.76579, - 0.247865, 0.500185, 0.481381, 0.779568, - 0.252696, 0.497159, 0.51011, 0.793991, - 0.256802, 0.492765, 0.539322, 0.808182, - 0.259942, 0.486827, 0.569078, 0.821698, - 0.261703, 0.478386, 0.598818, 0.836009, - 0.262006, 0.468772, 0.629762, 0.849824, - 0.260333, 0.456352, 0.661366, 0.863888, - 0.257398, 0.442533, 0.69295, 0.876585, - 0.253264, 0.426573, 0.723608, 0.888665, - 0.248026, 0.408964, 0.754378, 0.899537, - 0.241487, 0.389677, 0.784761, 0.9094, - 0.233463, 0.368516, 0.814688, 0.920166, - 0.223397, 0.346624, 0.845009, 0.928899, - 0.21255, 0.322717, 0.874431, 0.937156, - 0.200869, 0.298698, 0.902922, 0.943861, - 0.188387, 0.273491, 0.931356, 0.949557, - 0.174341, 0.247866, 0.958854, 0.955862, - 0.158994, 0.222496, 0.986098, 0.961721, - 0.143664, 0.197522, 1.01229, 0.965976, - 0.127412, 0.17302, 1.03571, 0.968652, - 0.109798, 0.148954, 1.05699, 0.971084, - 0.0916787, 0.125044, 1.07587, 0.975584, - 0.0739634, 0.100577, 1.09372, 0.98122, - 0.055322, 0.0753666, 1.10948, 0.988253, - 0.0366825, 0.0498899, 1.12394, 0.99482, - 0.0180389, 0.024611, 1.13694, 1.00001, 0.000229839, - 0.000188283, 1.14919, 0.613867, - 9.64198e-06, 0.479449, 1.23452e-05, 0.621485, - 0.000244534, 0.485399, 0.000313091, 0.621429, - 0.000978202, 0.485353, 0.00125245, 0.62112, - 0.00220004, 0.485114, 0.00281687, 0.621119, - 0.0039111, 0.485112, 0.00500783, 0.621122, - 0.00611091, 0.485112, 0.00782498, 0.621133, - 0.00879922, 0.485117, 0.0112687, 0.621152, - 0.0119756, 0.485125, 0.0153394, 0.621183, - 0.0156396, 0.485139, 0.0200382, 0.621227, - 0.0197898, 0.485158, 0.0253663, 0.621298, - 0.0244253, 0.485192, 0.0313261, 0.621388, - 0.0295441, 0.485233, 0.0379204, 0.621507, - 0.0351432, 0.485286, 0.0451523, 0.621693, - 0.0412198, 0.485378, 0.0530277, 0.621933, - 0.0477673, 0.485495, 0.0615522, 0.622232, - 0.0547574, 0.485635, 0.0707316, 0.622809, - 0.0619417, 0.485943, 0.0805883, 0.623407, - 0.069625, 0.486232, 0.0911267, 0.62406, - 0.077796, 0.486516, 0.102354, 0.624835, - 0.0863731, 0.486838, 0.114279, 0.625758, - 0.095251, 0.487188, 0.126902, 0.627043, - 0.104299, 0.487695, 0.140285, 0.628438, - 0.113724, 0.488163, 0.154397, 0.630325, - 0.123417, 0.488858, 0.169267, 0.632801, - 0.133137, 0.489754, 0.184941, 0.635784, - 0.143052, 0.490815, 0.20136, 0.639406, - 0.153132, 0.492048, 0.218643, 0.643872, - 0.163143, 0.49363, 0.236615, 0.6499, - 0.17333, 0.496009, 0.255449, 0.657201, - 0.183622, 0.498994, 0.275006, 0.666221, - 0.194019, 0.502888, 0.295354, 0.674419, - 0.204192, 0.505459, 0.316244, 0.683729, - 0.21406, 0.507771, 0.33849, 0.695584, - 0.222854, 0.510245, 0.363166, 0.708583, - 0.231315, 0.512293, 0.389071, 0.721233, - 0.238911, 0.512747, 0.415737, 0.735134, - 0.245657, 0.512482, 0.443331, 0.750179, - 0.251879, 0.511526, 0.471891, 0.765073, - 0.256911, 0.508935, 0.500892, 0.779794, - 0.261144, 0.504341, 0.530294, 0.794801, - 0.264316, 0.498515, 0.560144, 0.810339, - 0.266276, 0.491015, 0.590213, 0.824818, - 0.266981, 0.481126, 0.620865, 0.839375, - 0.265778, 0.468685, 0.652687, 0.853043, - 0.262748, 0.453925, 0.684759, 0.867335, - 0.258474, 0.437912, 0.716209, 0.88037, - 0.253187, 0.419648, 0.747508, 0.891711, - 0.246476, 0.39982, 0.77797, 0.902896, - 0.238735, 0.37879, 0.808586, 0.913601, - 0.22885, 0.355891, 0.838843, 0.923019, - 0.217656, 0.331773, 0.869014, 0.933432, - 0.205539, 0.307356, 0.898512, 0.939691, - 0.192595, 0.281321, 0.9269, 0.946938, - 0.178945, 0.255441, 0.955297, 0.952372, - 0.163587, 0.229013, 0.983231, 0.95909, - 0.147214, 0.203179, 1.00971, 0.963675, - 0.13064, 0.17792, 1.03438, 0.968247, - 0.113121, 0.152898, 1.05625, 0.97001, - 0.0945824, 0.128712, 1.07598, 0.974458, - 0.0755648, 0.103349, 1.094, 0.980168, - 0.0571998, 0.0776731, 1.1104, 0.987295, - 0.0377994, 0.0514445, 1.12491, 0.994432, - 0.0186417, 0.025429, 1.13851, 0.999975, 0.000542714, - 0.000282356, 1.15108, 0.592656, - 9.80249e-06, 0.486018, 1.19532e-05, 0.598467, - 0.000247275, 0.490781, 0.000301531, 0.597934, - 0.000988317, 0.490343, 0.00120517, 0.597903, - 0.00222366, 0.490319, 0.0027116, 0.597913, - 0.00395315, 0.490327, 0.00482077, 0.597919, - 0.00617653, 0.490329, 0.00753264, 0.597936, - 0.00889375, 0.490339, 0.0108478, 0.597956, - 0.0121043, 0.490347, 0.0147668, 0.597992, - 0.0158073, 0.490365, 0.0192905, 0.598032, - 0.0200017, 0.490382, 0.0244204, 0.598109, - 0.0246865, 0.49042, 0.0301593, 0.598215, - 0.0298594, 0.490474, 0.03651, 0.59833, - 0.0355167, 0.490524, 0.0434757, 0.598525, - 0.0416559, 0.490624, 0.0510629, 0.598778, - 0.0482692, 0.490753, 0.0592781, 0.599135, - 0.0553114, 0.49094, 0.0681304, 0.599802, - 0.062542, 0.491328, 0.0776467, 0.600361, - 0.0703638, 0.491598, 0.0878184, 0.60101, - 0.0786256, 0.491882, 0.0986573, 0.601811, - 0.0872962, 0.492232, 0.11018, 0.602861, - 0.0962284, 0.492684, 0.1224, 0.604167, - 0.10538, 0.493213, 0.135354, 0.605693, - 0.114896, 0.493799, 0.149034, 0.607682, - 0.124654, 0.494576, 0.163469, 0.610672, - 0.13456, 0.4959, 0.178747, 0.613313, - 0.144581, 0.496713, 0.194723, 0.617603, - 0.154703, 0.498499, 0.211617, 0.622174, - 0.16489, 0.500188, 0.229183, 0.628855, - 0.175164, 0.503072, 0.247786, 0.636963, - 0.185565, 0.506798, 0.267116, 0.644866, - 0.195911, 0.509719, 0.28702, 0.653741, - 0.206104, 0.512776, 0.307763, 0.664942, - 0.216447, 0.516812, 0.329631, 0.67633, - 0.22552, 0.519181, 0.353515, 0.690012, - 0.234316, 0.521681, 0.379226, 0.704243, - 0.242032, 0.523129, 0.405901, 0.719396, - 0.249172, 0.523768, 0.433585, 0.734471, - 0.255543, 0.522541, 0.462085, 0.750539, - 0.260697, 0.520217, 0.491233, 0.766365, - 0.26501, 0.516293, 0.521094, 0.781677, - 0.268409, 0.509708, 0.551014, 0.797132, - 0.270399, 0.501944, 0.581463, 0.812655, - 0.271247, 0.492025, 0.612402, 0.828592, - 0.270708, 0.480424, 0.643798, 0.844044, - 0.268085, 0.465955, 0.67682, 0.857305, - 0.263459, 0.448425, 0.708496, 0.87114, - 0.258151, 0.430243, 0.74046, 0.884936, - 0.251171, 0.410578, 0.771583, 0.895772, - 0.243305, 0.38862, 0.802234, 0.906961, - 0.234037, 0.365214, 0.833179, 0.917775, - 0.222714, 0.34116, 0.86353, 0.927883, - 0.210175, 0.31572, 0.893557, 0.936617, - 0.196925, 0.289159, 0.922976, 0.943384, - 0.182788, 0.261996, 0.951606, 0.949713, - 0.167965, 0.235324, 0.979958, 0.955818, - 0.151109, 0.208408, 1.00765, 0.961344, - 0.133834, 0.182591, 1.03329, 0.965469, - 0.115987, 0.156958, 1.0557, 0.968693, - 0.09746, 0.132239, 1.07583, 0.973165, - 0.0778514, 0.106195, 1.09451, 0.979387, - 0.0585067, 0.0797669, 1.11137, 0.98671, - 0.0390409, 0.0530263, 1.12643, 0.994093, - 0.019408, 0.0263163, 1.14016, 1.00002, 0.000540029, - 0.000194487, 1.15299, 0.574483, - 9.89066e-06, 0.494533, 1.14896e-05, 0.574478, - 0.000249127, 0.494528, 0.000289403, 0.574607, - 0.000996811, 0.494637, 0.00115797, 0.574396, - 0.00224241, 0.494458, 0.00260498, 0.574377, - 0.00398632, 0.49444, 0.00463102, 0.574386, - 0.00622836, 0.494445, 0.00723623, 0.574401, - 0.0089683, 0.494453, 0.010421, 0.574419, - 0.0122056, 0.49446, 0.0141859, 0.574459, - 0.0159396, 0.494481, 0.0185322, 0.574525, - 0.0201692, 0.49452, 0.0234617, 0.574587, - 0.0248924, 0.494547, 0.0289762, 0.574697, - 0.0301074, 0.494604, 0.0350797, 0.574853, - 0.0358114, 0.494688, 0.0417767, 0.575027, - 0.041999, 0.494772, 0.0490718, 0.575294, - 0.0486618, 0.494915, 0.0569728, 0.575733, - 0.0557148, 0.495173, 0.0654955, 0.576356, - 0.0630489, 0.495537, 0.0746612, 0.576944, - 0.0709285, 0.495836, 0.0844615, 0.57765, - 0.0792723, 0.496177, 0.0949142, 0.578491, - 0.0880167, 0.496563, 0.10603, 0.579639, - 0.0969462, 0.497096, 0.117841, 0.580989, - 0.10622, 0.497684, 0.130367, 0.582587, - 0.115861, 0.498337, 0.143609, 0.584951, - 0.125605, 0.499414, 0.157625, 0.587602, - 0.135608, 0.500518, 0.172413, 0.59076, - 0.145742, 0.501767, 0.187999, 0.594992, - 0.155934, 0.503542, 0.20445, 0.600656, - 0.166303, 0.506135, 0.221764, 0.607816, - 0.176681, 0.509542, 0.24002, 0.61522, - 0.187071, 0.51263, 0.258992, 0.623702, - 0.197465, 0.516021, 0.278773, 0.634192, - 0.207816, 0.520422, 0.299377, 0.644936, - 0.218183, 0.524073, 0.320802, 0.657888, - 0.2278, 0.528049, 0.34384, 0.670666, - 0.236747, 0.52986, 0.36916, 0.685626, - 0.24484, 0.531892, 0.395867, 0.701304, - 0.252071, 0.532727, 0.423488, 0.717727, - 0.258714, 0.532146, 0.452201, 0.733914, - 0.264211, 0.529883, 0.481579, 0.750529, - 0.26859, 0.5259, 0.511558, 0.76747, - 0.272046, 0.51999, 0.542042, 0.785189, - 0.274225, 0.513083, 0.572799, 0.800954, - 0.275189, 0.502936, 0.603816, 0.816962, - 0.274946, 0.490921, 0.635461, 0.83336, - 0.272695, 0.47684, 0.6676, 0.848143, - 0.268223, 0.459405, 0.70051, 0.861818, - 0.262768, 0.440319, 0.732902, 0.876828, - 0.255872, 0.420123, 0.765084, 0.889312, - 0.247703, 0.398379, 0.796391, 0.900412, - 0.238381, 0.374496, 0.827333, 0.912251, - 0.227783, 0.349874, 0.858385, 0.921792, - 0.214832, 0.323181, 0.888652, 0.931273, - 0.200949, 0.296624, 0.917763, 0.940295, - 0.186537, 0.269211, 0.947878, 0.946812, - 0.171538, 0.241447, 0.977016, 0.953588, - 0.155254, 0.213829, 1.00501, 0.958841, - 0.137156, 0.186807, 1.03179, 0.963746, - 0.118699, 0.160706, 1.05502, 0.966468, - 0.0998358, 0.135504, 1.07568, 0.971178, - 0.0805186, 0.109131, 1.09479, 0.97831, - 0.0599348, 0.0818293, 1.1123, 0.985886, - 0.0399661, 0.0545872, 1.12771, 0.994021, - 0.0198682, 0.0269405, 1.14186, 1.00009, 0.000271022, - 0.00012989, 1.15514, 0.538716, - 9.90918e-06, 0.486732, 1.09675e-05, 0.550656, - 0.000250642, 0.497518, 0.000277412, 0.55057, - 0.00100265, 0.497441, 0.00110974, 0.550903, - 0.00225672, 0.497733, 0.00249779, 0.550568, - 0.00401046, 0.497438, 0.00443906, 0.550574, - 0.00626613, 0.49744, 0.00693637, 0.550591, - 0.0090226, 0.497449, 0.00998921, 0.550623, - 0.0122795, 0.497469, 0.0135984, 0.550667, - 0.0160361, 0.497495, 0.0177654, 0.550724, - 0.0202908, 0.497526, 0.0224915, 0.550792, - 0.0250421, 0.497557, 0.0277795, 0.550918, - 0.0302878, 0.49763, 0.0336334, 0.551058, - 0.0360241, 0.497701, 0.0400573, 0.551276, - 0.0422473, 0.497824, 0.0470585, 0.551551, - 0.0489441, 0.497977, 0.0546433, 0.552074, - 0.0559596, 0.498312, 0.0628367, 0.552681, - 0.0633978, 0.498679, 0.071646, 0.553324, - 0.0713176, 0.499031, 0.0810746, 0.554011, - 0.0797268, 0.499365, 0.091129, 0.55488, - 0.0885238, 0.499779, 0.101837, 0.556171, - 0.0974417, 0.500444, 0.113239, 0.557498, - 0.106841, 0.501025, 0.125316, 0.559299, - 0.116533, 0.501864, 0.138128, 0.561647, - 0.126298, 0.502967, 0.151695, 0.564347, - 0.136388, 0.504129, 0.16604, 0.567863, - 0.146576, 0.505713, 0.181207, 0.572569, - 0.156832, 0.507953, 0.197259, 0.578919, - 0.167323, 0.511186, 0.214258, 0.585387, - 0.177712, 0.514042, 0.232038, 0.593134, - 0.188184, 0.517484, 0.250733, 0.603295, - 0.198717, 0.522345, 0.270454, 0.613854, - 0.209177, 0.526751, 0.290807, 0.626092, - 0.219644, 0.531595, 0.312202, 0.637868, - 0.229494, 0.534721, 0.334435, 0.652458, - 0.238718, 0.538304, 0.359184, 0.666985, - 0.247061, 0.539875, 0.385637, 0.683301, - 0.254652, 0.541042, 0.41328, 0.69998, - 0.261376, 0.540735, 0.441903, 0.717824, - 0.267085, 0.539139, 0.471609, 0.734617, - 0.271465, 0.534958, 0.501446, 0.753663, - 0.27528, 0.53032, 0.532571, 0.770512, - 0.277617, 0.522134, 0.563641, 0.787356, - 0.278525, 0.51206, 0.595067, 0.806252, - 0.278512, 0.50119, 0.627226, 0.822061, - 0.277023, 0.486791, 0.659402, 0.838959, - 0.273175, 0.470467, 0.692874, 0.85379, - 0.267238, 0.450688, 0.725702, 0.868268, - 0.260327, 0.429741, 0.75832, 0.881994, - 0.251946, 0.407223, 0.790189, 0.893885, - 0.242432, 0.383214, 0.821625, 0.905118, - 0.231904, 0.357297, 0.853011, 0.916045, - 0.219545, 0.330733, 0.883773, 0.927614, - 0.205378, 0.303916, 0.914435, 0.936005, - 0.190388, 0.275941, 0.944502, 0.944533, - 0.1749, 0.247493, 0.974439, 0.950758, - 0.158588, 0.218996, 1.00286, 0.957078, - 0.141027, 0.191559, 1.0304, 0.962448, - 0.121507, 0.164457, 1.05466, 0.964993, - 0.102068, 0.138636, 1.0761, 0.970017, - 0.0822598, 0.111861, 1.09541, 0.97661, - 0.062033, 0.0843438, 1.11317, 0.985073, - 0.0409832, 0.0558496, 1.12911, 0.993515, - 0.020146, 0.0275331, 1.1438, 1.00006, 0.00027329, - 0.000107883, 1.15736, 0.525324, - 9.99341e-06, 0.498153, 1.05385e-05, 0.526513, - 0.000251605, 0.499277, 0.000265329, 0.526517, - 0.00100641, 0.499282, 0.0010613, 0.526588, - 0.00226466, 0.499337, 0.00238823, 0.526539, - 0.0040255, 0.499302, 0.00424535, 0.526547, - 0.00628954, 0.499306, 0.00663364, 0.526561, - 0.00905628, 0.499313, 0.00955337, 0.526593, - 0.0123253, 0.499334, 0.0130054, 0.526642, - 0.0160957, 0.499365, 0.0169911, 0.5267, - 0.0203661, 0.499396, 0.0215122, 0.526792, - 0.0251347, 0.499451, 0.0265718, 0.526904, - 0.0303985, 0.499511, 0.0321732, 0.527079, - 0.0361554, 0.499617, 0.0383231, 0.527285, - 0.0423982, 0.499731, 0.045026, 0.527602, - 0.0491121, 0.499924, 0.0522936, 0.528166, - 0.0561127, 0.500306, 0.0601528, 0.52879, - 0.0635988, 0.5007, 0.0686059, 0.529421, - 0.071581, 0.501048, 0.0776518, 0.530144, - 0.0799854, 0.501421, 0.0873148, 0.531062, - 0.0888032, 0.501884, 0.0976084, 0.532374, - 0.0977643, 0.50259, 0.108588, 0.533828, - 0.107197, 0.50329, 0.120234, 0.53581, - 0.116887, 0.504312, 0.132602, 0.538063, - 0.126755, 0.505365, 0.145721, 0.5409, - 0.136819, 0.506668, 0.159617, 0.544882, - 0.147117, 0.508731, 0.174369, 0.550238, - 0.157446, 0.511601, 0.190028, 0.556038, - 0.167988, 0.514431, 0.206587, 0.563031, - 0.178364, 0.517808, 0.224046, 0.571543, - 0.189007, 0.521937, 0.242503, 0.582255, - 0.199546, 0.527415, 0.261977, 0.59272, - 0.210084, 0.531682, 0.282162, 0.605648, - 0.220448, 0.537123, 0.303426, 0.61785, - 0.230593, 0.540664, 0.325323, 0.632223, - 0.240238, 0.544467, 0.348993, 0.648819, - 0.24887, 0.547594, 0.375462, 0.665825, - 0.256657, 0.54912, 0.403024, 0.683389, - 0.263711, 0.549294, 0.431773, 0.701495, - 0.269666, 0.547649, 0.461494, 0.719197, - 0.274169, 0.543786, 0.491623, 0.737906, - 0.278124, 0.538644, 0.522994, 0.756652, - 0.280632, 0.531057, 0.554775, 0.775279, - 0.281741, 0.521972, 0.586441, 0.792688, - 0.281652, 0.509613, 0.618596, 0.811894, - 0.280345, 0.496497, 0.651462, 0.827938, - 0.277128, 0.47968, 0.684023, 0.844837, - 0.271646, 0.460688, 0.718024, 0.859239, - 0.264397, 0.438872, 0.751207, 0.874088, - 0.256144, 0.41577, 0.784232, 0.887693, - 0.246311, 0.391369, 0.816191, 0.899402, - 0.235497, 0.365872, 0.847828, 0.910973, - 0.223631, 0.338618, 0.87934, 0.92204, - 0.209874, 0.310803, 0.910325, 0.930987, - 0.194265, 0.281802, 0.940695, 0.94, - 0.178125, 0.252836, 0.970958, 0.948018, - 0.161479, 0.224239, 1.00078, 0.955141, - 0.144038, 0.195857, 1.0288, 0.960513, - 0.124915, 0.168487, 1.05371, 0.963964, - 0.104284, 0.141495, 1.07596, 0.968713, - 0.0838732, 0.114437, 1.09628, 0.975524, - 0.0635579, 0.0863105, 1.11448, 0.98431, - 0.042291, 0.0574774, 1.13069, 0.992916, - 0.0209131, 0.0284343, 1.14568, 0.999926, 0.000743097, - 0.000379265, 1.15955, 0.501042, - 9.98428e-06, 0.498726, 1.00306e-05, 0.502992, - 0.000252112, 0.500665, 0.000253283, 0.502417, - 0.00100791, 0.500092, 0.00101259, 0.502965, - 0.00226919, 0.500621, 0.00227978, 0.502318, - 0.00403109, 0.499994, 0.00405011, 0.502333, - 0.00629832, 0.500005, 0.00632868, 0.502362, - 0.00906907, 0.500027, 0.00911446, 0.502369, - 0.0123423, 0.500023, 0.0124078, 0.50243, - 0.0161178, 0.500066, 0.016211, 0.502493, - 0.0203937, 0.500103, 0.0205256, 0.502592, - 0.0251684, 0.500166, 0.0253548, 0.502707, - 0.0304389, 0.50023, 0.0307029, 0.502881, - 0.0362015, 0.500335, 0.0365753, 0.503124, - 0.0424507, 0.500488, 0.0429798, 0.503443, - 0.0491582, 0.500686, 0.0499268, 0.504083, - 0.0561476, 0.501155, 0.0574541, 0.504668, - 0.0636846, 0.501524, 0.0655408, 0.505319, - 0.0716834, 0.501904, 0.0742072, 0.50609, - 0.0800925, 0.502321, 0.0834699, 0.507122, - 0.0888425, 0.502896, 0.0933603, 0.508414, - 0.097855, 0.503603, 0.10391, 0.509955, - 0.107304, 0.504416, 0.115113, 0.512061, - 0.116921, 0.505565, 0.127054, 0.514419, - 0.12689, 0.506732, 0.139709, 0.517529, - 0.136934, 0.508338, 0.153173, 0.522085, - 0.147327, 0.510987, 0.167528, 0.526986, - 0.157612, 0.513527, 0.182708, 0.533122, - 0.168213, 0.516717, 0.198881, 0.540807, - 0.178688, 0.520832, 0.215986, 0.550687, - 0.189511, 0.52632, 0.234335, 0.560567, - 0.199998, 0.531009, 0.253375, 0.571698, - 0.210652, 0.535839, 0.273499, 0.584364, - 0.220917, 0.541091, 0.294355, 0.599066, - 0.23137, 0.546875, 0.316525, 0.614148, - 0.241206, 0.551306, 0.339671, 0.631157, - 0.250379, 0.555187, 0.36531, 0.647919, - 0.258397, 0.556595, 0.392767, 0.666112, - 0.265528, 0.556949, 0.421397, 0.686158, - 0.271827, 0.556617, 0.451433, 0.704838, - 0.27674, 0.552975, 0.482131, 0.723957, - 0.280733, 0.547814, 0.513458, 0.74262, - 0.283359, 0.53997, 0.545446, 0.762009, - 0.284541, 0.530422, 0.57775, 0.781314, - 0.284507, 0.518546, 0.610434, 0.799116, - 0.283309, 0.504178, 0.643178, 0.817604, - 0.280378, 0.48843, 0.676248, 0.83459, - 0.275619, 0.469457, 0.709698, 0.850974, - 0.26856, 0.447698, 0.744245, 0.866747, - 0.260094, 0.424791, 0.777695, 0.881412, - 0.249929, 0.399913, 0.810392, 0.8936, - 0.239137, 0.37308, 0.842872, 0.905943, - 0.226818, 0.345705, 0.874677, 0.916408, - 0.213699, 0.31706, 0.906257, 0.927215, - 0.198428, 0.288444, 0.936881, 0.935625, - 0.181643, 0.258329, 0.96795, 0.944076, - 0.164386, 0.228488, 0.998216, 0.951229, - 0.146339, 0.199763, 1.02689, 0.958793, - 0.127709, 0.172153, 1.0535, 0.963219, - 0.107244, 0.144989, 1.07646, 0.967562, - 0.0857764, 0.11685, 1.09675, 0.974866, - 0.0645377, 0.0880571, 1.11576, 0.983353, - 0.0431732, 0.0587352, 1.13227, 0.992503, - 0.0218356, 0.0294181, 1.1478, 1.00003, 0.000605203, - 0.000231013, 1.16207, 0.482935, - 1.01177e-05, 0.504695, 9.68142e-06, 0.477554, - 0.000251521, 0.499071, 0.000240676, 0.477904, - 0.00100683, 0.499436, 0.00096342, 0.478368, - 0.00226636, 0.499899, 0.0021687, 0.477977, - 0.00402719, 0.499513, 0.00385384, 0.477993, - 0.00629226, 0.499525, 0.0060221, 0.478011, - 0.00906011, 0.499536, 0.00867289, 0.478051, - 0.0123305, 0.499566, 0.0118074, 0.478089, - 0.016102, 0.499587, 0.0154269, 0.478171, - 0.0203736, 0.499645, 0.0195341, 0.478254, - 0.025143, 0.499692, 0.0241318, 0.47839, - 0.0304071, 0.499779, 0.0292247, 0.478588, - 0.0361631, 0.499911, 0.0348196, 0.478812, - 0.0424023, 0.500046, 0.0409231, 0.479208, - 0.0490724, 0.500326, 0.047552, 0.479841, - 0.0560722, 0.500805, 0.0547377, 0.480392, - 0.0636125, 0.501152, 0.0624607, 0.481068, - 0.0716134, 0.501561, 0.0707473, 0.481898, - 0.0800062, 0.502054, 0.0796118, 0.483022, - 0.0886568, 0.502728, 0.0890974, 0.484332, - 0.0977553, 0.503479, 0.0992099, 0.486126, - 0.107173, 0.504546, 0.10999, 0.488066, - 0.11677, 0.50557, 0.121476, 0.490521, - 0.126725, 0.506849, 0.133672, 0.494232, - 0.136793, 0.50911, 0.146731, 0.498302, - 0.147116, 0.511345, 0.160577, 0.503565, - 0.157446, 0.514344, 0.175335, 0.510902, - 0.168121, 0.518824, 0.191207, 0.519263, - 0.178799, 0.523666, 0.208058, 0.528204, - 0.189407, 0.528296, 0.225875, 0.538854, - 0.200145, 0.533724, 0.244782, 0.551278, - 0.210701, 0.539833, 0.264753, 0.565222, - 0.221303, 0.546131, 0.285745, 0.579403, - 0.231688, 0.551496, 0.307592, 0.595469, - 0.241718, 0.556809, 0.330582, 0.610929, - 0.250992, 0.559641, 0.354995, 0.629433, - 0.259602, 0.562379, 0.382471, 0.648504, - 0.267038, 0.563676, 0.411126, 0.66756, - 0.273388, 0.562092, 0.440924, 0.689143, - 0.278788, 0.560807, 0.472118, 0.709056, - 0.282783, 0.555701, 0.503774, 0.729855, - 0.285836, 0.548698, 0.536364, 0.748954, - 0.287078, 0.538544, 0.56895, 0.768373, - 0.287133, 0.526711, 0.601991, 0.78827, - 0.285839, 0.512511, 0.635403, 0.807465, - 0.283238, 0.496323, 0.668797, 0.825194, - 0.27906, 0.477638, 0.702584, 0.842203, - 0.272286, 0.456253, 0.736393, 0.857749, - 0.263854, 0.432412, 0.77096, 0.874799, - 0.253943, 0.407806, 0.80489, 0.887497, - 0.24237, 0.38033, 0.83771, 0.89966, - 0.230278, 0.352446, 0.870376, 0.911753, - 0.21646, 0.323268, 0.902256, 0.923011, - 0.202071, 0.294314, 0.933306, 0.932375, - 0.185519, 0.264104, 0.965177, 0.940537, - 0.167604, 0.234035, 0.996303, 0.948904, - 0.149068, 0.20412, 1.0261, 0.955263, - 0.129539, 0.175431, 1.05304, 0.960303, - 0.109932, 0.148116, 1.07617, 0.965512, - 0.0880572, 0.119693, 1.09742, 0.973466, - 0.0660548, 0.0901619, 1.11721, 0.98284, - 0.0439228, 0.0599875, 1.13436, 0.992216, - 0.0219588, 0.0298975, 1.15006, 0.999946, 0.000119402, - 2.08547e-05, 1.16471, 0.447827, - 1.00414e-05, 0.491543, 9.14833e-06, 0.454778, - 0.000251257, 0.499172, 0.00022891, 0.453519, - 0.00100342, 0.497787, 0.000914184, 0.45357, - 0.00225776, 0.497847, 0.00205701, 0.453578, - 0.00401371, 0.497855, 0.00365705, 0.45357, - 0.00627107, 0.497841, 0.00571453, 0.453598, - 0.00902968, 0.497864, 0.00823019, 0.453627, - 0.0122888, 0.497882, 0.0112049, 0.453684, - 0.0160475, 0.497923, 0.0146405, 0.453764, - 0.0203044, 0.49798, 0.0185394, 0.453866, - 0.0250576, 0.498049, 0.0229054, 0.453996, - 0.0303028, 0.49813, 0.0277424, 0.454196, - 0.0360379, 0.498267, 0.0330587, 0.454457, - 0.0422521, 0.498445, 0.0388613, 0.454926, - 0.0488393, 0.498812, 0.0451767, 0.455525, - 0.0558653, 0.499272, 0.0520153, 0.456074, - 0.0633772, 0.499625, 0.0593754, 0.456752, - 0.0713606, 0.500049, 0.0672751, 0.457648, - 0.07971, 0.500615, 0.0757447, 0.458849, - 0.0883032, 0.501399, 0.0848231, 0.46029, - 0.0974095, 0.502293, 0.0945135, 0.462, - 0.106729, 0.503301, 0.104848, 0.464121, - 0.116354, 0.504533, 0.115884, 0.466889, - 0.126214, 0.506172, 0.127652, 0.470744, - 0.136324, 0.508667, 0.14024, 0.47488, - 0.146595, 0.510995, 0.153673, 0.480845, - 0.157027, 0.514832, 0.168053, 0.488262, - 0.167658, 0.519506, 0.183508, 0.496547, - 0.178343, 0.524347, 0.199948, 0.506254, - 0.188916, 0.52983, 0.217503, 0.517961, - 0.199975, 0.536357, 0.236272, 0.531484, - 0.210624, 0.543641, 0.256096, 0.545496, - 0.221227, 0.550048, 0.277085, 0.559497, - 0.231568, 0.555076, 0.298615, 0.575752, - 0.241698, 0.560541, 0.321547, 0.591999, - 0.251172, 0.564156, 0.345602, 0.610654, - 0.260178, 0.567607, 0.371851, 0.630484, - 0.268094, 0.56923, 0.40076, 0.651807, - 0.274661, 0.569779, 0.430801, 0.67239, - 0.280331, 0.566791, 0.461939, 0.693024, - 0.284501, 0.562007, 0.493854, 0.715473, - 0.287852, 0.555791, 0.526992, 0.736323, - 0.28929, 0.546345, 0.560102, 0.755771, - 0.289405, 0.534, 0.593543, 0.775424, - 0.2881, 0.519114, 0.627256, 0.795447, - 0.285562, 0.502543, 0.661464, 0.815319, - 0.281416, 0.484773, 0.695206, 0.831769, - 0.275523, 0.463445, 0.729044, 0.849464, - 0.267516, 0.440269, 0.764069, 0.866775, - 0.257584, 0.415049, 0.799089, 0.881252, - 0.245817, 0.388049, 0.831948, 0.894209, - 0.233127, 0.35889, 0.865526, 0.906922, - 0.219579, 0.329915, 0.89818, 0.919686, - 0.204491, 0.300441, 0.930013, 0.929044, - 0.188962, 0.269445, 0.962061, 0.938393, - 0.171079, 0.238402, 0.994214, 0.94661, - 0.15199, 0.208204, 1.02533, 0.953095, - 0.131953, 0.178653, 1.0529, 0.958644, - 0.111233, 0.150684, 1.0771, 0.963925, - 0.0903098, 0.122359, 1.09855, 0.971995, - 0.0680505, 0.0923342, 1.11874, 0.981658, - 0.0448512, 0.0614195, 1.13635, 0.991649, - 0.0221931, 0.0303582, 1.15238, 0.999985, 0.000393403, - 0.000111086, 1.16772, 0.396806, - 9.71563e-06, 0.457671, 8.42355e-06, 0.429186, - 0.000249421, 0.495017, 0.00021625, 0.429324, - 0.000998052, 0.495173, 0.000865322, 0.429175, - 0.00224487, 0.494999, 0.00194637, 0.429129, - 0.00399041, 0.494952, 0.00346004, 0.429153, - 0.00623476, 0.494974, 0.00540684, 0.429168, - 0.0089773, 0.494983, 0.00778714, 0.429207, - 0.0122175, 0.495012, 0.0106022, 0.429257, - 0.0159542, 0.495047, 0.0138535, 0.429338, - 0.0201864, 0.495106, 0.0175443, 0.429431, - 0.0249104, 0.495165, 0.0216774, 0.429587, - 0.0301252, 0.495279, 0.0262594, 0.429796, - 0.0358249, 0.495432, 0.0312968, 0.430065, - 0.0419972, 0.495621, 0.0367985, 0.430588, - 0.0485144, 0.496061, 0.042798, 0.43113, - 0.0555028, 0.496472, 0.0492914, 0.431743, - 0.0629852, 0.496904, 0.0562907, 0.432448, - 0.0709256, 0.497369, 0.0638056, 0.433414, - 0.0791942, 0.498032, 0.071885, 0.434638, - 0.0877346, 0.498854, 0.0805517, 0.43611, - 0.0968056, 0.499812, 0.0898047, 0.437859, - 0.106002, 0.500891, 0.0997142, 0.440017, - 0.115648, 0.502198, 0.110289, 0.443236, - 0.125427, 0.504389, 0.121644, 0.44697, - 0.135492, 0.506809, 0.133769, 0.451689, - 0.145746, 0.509858, 0.146787, 0.45811, - 0.156219, 0.514247, 0.160793, 0.465305, - 0.166834, 0.518816, 0.175791, 0.474085, - 0.177546, 0.524331, 0.191906, 0.484808, - 0.188262, 0.53104, 0.209199, 0.49732, - 0.199346, 0.538511, 0.227825, 0.509693, - 0.209951, 0.544554, 0.247269, 0.524367, - 0.220533, 0.551616, 0.267978, 0.539228, - 0.231082, 0.557368, 0.289672, 0.55644, - 0.241342, 0.563782, 0.31268, 0.574204, - 0.250964, 0.568851, 0.33651, 0.593388, - 0.260306, 0.57312, 0.362219, 0.613358, - 0.268667, 0.574916, 0.390322, 0.634512, - 0.275591, 0.575053, 0.420478, 0.65563, - 0.281328, 0.572404, 0.451614, 0.678265, - 0.285948, 0.568893, 0.484112, 0.70011, - 0.289408, 0.561878, 0.517348, 0.723005, - 0.291328, 0.55359, 0.551355, 0.743744, - 0.291418, 0.541099, 0.585109, 0.763949, - 0.290252, 0.526489, 0.619487, 0.784186, - 0.287648, 0.509496, 0.65404, 0.804304, - 0.283782, 0.491484, 0.688649, 0.823629, - 0.278067, 0.470517, 0.723133, 0.84094, - 0.270588, 0.44705, 0.757163, 0.857852, - 0.261188, 0.421252, 0.792816, 0.874934, - 0.249313, 0.394191, 0.827248, 0.888709, - 0.236492, 0.365359, 0.861074, 0.902589, - 0.222185, 0.336016, 0.894417, 0.914201, - 0.207314, 0.30527, 0.926825, 0.925978, - 0.191146, 0.274532, 0.9595, 0.93512, - 0.174135, 0.243393, 0.991583, 0.943656, - 0.155231, 0.212414, 1.02356, 0.951719, - 0.134403, 0.182005, 1.05239, 0.957164, - 0.113023, 0.153043, 1.07754, 0.962656, - 0.0914493, 0.124186, 1.09984, 0.970695, - 0.0694179, 0.0941654, 1.12, 0.980749, - 0.0466199, 0.0629671, 1.13849, 0.991205, - 0.0227032, 0.0311146, 1.15494, 0.999884, 0.000632388, - 0.000254483, 1.1706, 0.379821, - 9.57289e-06, 0.460637, 7.89337e-06, 0.405188, - 0.000247483, 0.491396, 0.000204064, 0.404796, - 0.000989434, 0.490914, 0.000815853, 0.40483, - 0.00222607, 0.490949, 0.00183559, 0.40473, - 0.00395723, 0.49084, 0.00326332, 0.404731, - 0.00618287, 0.490836, 0.00509945, 0.404768, - 0.00890258, 0.490871, 0.00734463, 0.404791, - 0.0121156, 0.490883, 0.00999992, 0.404857, - 0.0158214, 0.490938, 0.0130676, 0.404943, - 0.0200178, 0.491004, 0.0165503, 0.405059, - 0.0247027, 0.491093, 0.0204521, 0.405213, - 0.0298729, 0.491205, 0.0247788, 0.405399, - 0.0355226, 0.491333, 0.0295373, 0.405731, - 0.0416352, 0.491604, 0.034741, 0.406303, - 0.0480807, 0.492116, 0.0404255, 0.406814, - 0.0550458, 0.492506, 0.0465732, 0.407404, - 0.0624652, 0.492926, 0.0532058, 0.408149, - 0.0702958, 0.493442, 0.0603442, 0.409128, - 0.0784623, 0.494136, 0.0680297, 0.410408, - 0.087007, 0.495054, 0.0762786, 0.411813, - 0.0959639, 0.495962, 0.0851046, 0.413735, - 0.105075, 0.497257, 0.0945878, 0.416137, - 0.114646, 0.498882, 0.104725, 0.41934, - 0.124394, 0.501132, 0.11563, 0.423326, - 0.134328, 0.503883, 0.127325, 0.428419, - 0.14458, 0.50747, 0.139911, 0.43484, - 0.154979, 0.511964, 0.153481, 0.442641, - 0.165628, 0.517328, 0.168114, 0.452511, - 0.176365, 0.524258, 0.183995, 0.463473, - 0.187298, 0.531248, 0.200953, 0.475564, - 0.198244, 0.538367, 0.219176, 0.488664, - 0.208938, 0.545175, 0.238514, 0.504073, - 0.219599, 0.553227, 0.259129, 0.520832, - 0.230378, 0.560653, 0.280997, 0.538455, - 0.240703, 0.567523, 0.303821, 0.55709, - 0.250548, 0.573287, 0.327948, 0.576646, - 0.259964, 0.577795, 0.353362, 0.596705, - 0.268721, 0.580077, 0.380336, 0.618053, - 0.276054, 0.58018, 0.4101, 0.640303, - 0.282176, 0.578747, 0.44161, 0.662365, - 0.286931, 0.574294, 0.474106, 0.684542, - 0.290521, 0.567035, 0.507549, 0.707984, - 0.292672, 0.558687, 0.541853, 0.730913, - 0.293189, 0.547606, 0.576581, 0.752948, - 0.292199, 0.533471, 0.61172, 0.773452, - 0.289508, 0.516395, 0.646339, 0.794715, - 0.285716, 0.497873, 0.682131, 0.814251, - 0.280051, 0.476845, 0.716396, 0.833057, - 0.272873, 0.453449, 0.751503, 0.84959, - 0.263982, 0.427857, 0.786085, 0.867022, - 0.252745, 0.400335, 0.821355, 0.882277, - 0.239655, 0.371304, 0.85646, 0.895375, - 0.225386, 0.340397, 0.890828, 0.909347, - 0.209587, 0.310005, 0.923532, 0.921885, - 0.193433, 0.2796, 0.956419, 0.932127, - 0.176135, 0.247276, 0.989445, 0.941869, - 0.157872, 0.216186, 1.02221, 0.949735, - 0.137577, 0.185602, 1.05195, 0.956617, - 0.115285, 0.155767, 1.07822, 0.961974, - 0.0928418, 0.126103, 1.10149, 0.96972, - 0.0700592, 0.0956758, 1.12207, 0.98012, - 0.0474671, 0.0643269, 1.1408, 0.990825, - 0.0238113, 0.0320863, 1.1577, 0.999876, 0.000381574, - 8.12203e-05, 1.17403, 0.367636, - 9.61342e-06, 0.469176, 7.53287e-06, 0.380377, - 0.000244772, 0.485434, 0.000191797, 0.380416, - 0.000978857, 0.485475, 0.000767015, 0.380376, - 0.00220165, 0.485435, 0.00172522, 0.380419, - 0.00391408, 0.485487, 0.00306734, 0.380438, - 0.00611549, 0.485505, 0.00479332, 0.380462, - 0.00880558, 0.485525, 0.00690391, 0.380496, - 0.0119837, 0.485551, 0.00940039, 0.38056, - 0.0156487, 0.485605, 0.0122848, 0.38064, - 0.0197988, 0.485666, 0.0155601, 0.380767, - 0.0244324, 0.48577, 0.0192313, 0.380909, - 0.0295444, 0.485871, 0.0233032, 0.381142, - 0.0351321, 0.48606, 0.0277861, 0.381472, - 0.0411535, 0.486336, 0.0326939, 0.382015, - 0.0475408, 0.486833, 0.0380565, 0.382523, - 0.0544395, 0.487231, 0.0438615, 0.383129, - 0.061784, 0.487683, 0.0501332, 0.383952, - 0.0695085, 0.488313, 0.0568996, 0.38498, - 0.0775819, 0.489077, 0.0641952, 0.386331, - 0.0860443, 0.490113, 0.0720324, 0.387788, - 0.0948406, 0.491099, 0.0804379, 0.389808, - 0.103899, 0.492566, 0.0894899, 0.39252, - 0.113313, 0.494601, 0.0992098, 0.395493, - 0.123007, 0.496619, 0.109641, 0.399826, - 0.132859, 0.499912, 0.120919, 0.405341, - 0.143077, 0.504061, 0.133107, 0.411932, - 0.153465, 0.508905, 0.146263, 0.420591, - 0.164108, 0.515482, 0.160544, 0.43101, - 0.174893, 0.523191, 0.176123, 0.441881, - 0.185839, 0.53026, 0.192757, 0.453919, - 0.196633, 0.537295, 0.210535, 0.468715, - 0.207611, 0.546156, 0.229886, 0.485182, - 0.218517, 0.555173, 0.250543, 0.501926, - 0.229249, 0.562728, 0.27221, 0.51785, - 0.239481, 0.567494, 0.294892, 0.536947, - 0.249395, 0.573889, 0.318987, 0.557115, - 0.259, 0.578831, 0.344348, 0.577966, - 0.268075, 0.582055, 0.371223, 0.599489, - 0.276115, 0.583307, 0.399834, 0.62479, - 0.282523, 0.583902, 0.431415, 0.647504, - 0.287663, 0.57953, 0.464301, 0.670601, - 0.291538, 0.573103, 0.498123, 0.693539, - 0.293842, 0.563731, 0.532662, 0.717385, - 0.294681, 0.553169, 0.567925, 0.741533, - 0.293717, 0.539908, 0.603502, 0.762142, - 0.291156, 0.521902, 0.639074, 0.783014, - 0.28719, 0.502815, 0.674439, 0.805158, - 0.281773, 0.482598, 0.710497, 0.823646, - 0.274682, 0.458949, 0.7456, 0.841879, - 0.266184, 0.433129, 0.781085, 0.859515, - 0.255682, 0.406064, 0.816, 0.875335, - 0.242849, 0.376509, 0.851074, 0.890147, - 0.228329, 0.345502, 0.886473, 0.903144, - 0.212491, 0.31428, 0.920751, 0.916618, - 0.195695, 0.282994, 0.954606, 0.927953, - 0.178267, 0.251091, 0.988402, 0.937414, - 0.159549, 0.219107, 1.02141, 0.946823, - 0.140022, 0.18896, 1.05167, 0.954651, - 0.118154, 0.158667, 1.07819, 0.959955, - 0.0946636, 0.128808, 1.1025, 0.96858, - 0.0711792, 0.0973787, 1.12391, 0.97938, - 0.0475046, 0.0650965, 1.14322, 0.990498, - 0.024059, 0.0326267, 1.16077, 0.999844, - 5.12408e-05, 0.000112444, 1.17727, 0.316912, - 9.34977e-06, 0.425996, 6.95559e-06, 0.356423, - 0.000241372, 0.479108, 0.000179562, 0.356272, - 0.000965292, 0.478897, 0.00071811, 0.356262, - 0.00217182, 0.478894, 0.00161574, 0.356265, - 0.00386092, 0.478895, 0.00287261, 0.356278, - 0.0060324, 0.478905, 0.00448907, 0.356293, - 0.00868565, 0.478914, 0.00646572, 0.356346, - 0.0118207, 0.478965, 0.00880438, 0.356395, - 0.0154355, 0.479001, 0.0115066, 0.356484, - 0.019529, 0.479075, 0.0145762, 0.356609, - 0.0240991, 0.47918, 0.018018, 0.356766, - 0.0291413, 0.479305, 0.0218379, 0.357009, - 0.0346498, 0.479512, 0.0260454, 0.357424, - 0.0405462, 0.479909, 0.0306657, 0.357899, - 0.0468825, 0.480337, 0.0357054, 0.358424, - 0.0536887, 0.480771, 0.0411728, 0.359041, - 0.0609416, 0.481242, 0.0470841, 0.359903, - 0.0685239, 0.481943, 0.0534831, 0.360932, - 0.0764883, 0.482741, 0.0603795, 0.362196, - 0.0848364, 0.483688, 0.0678028, 0.363847, - 0.0935002, 0.484947, 0.0758086, 0.365972, - 0.102471, 0.486588, 0.0844173, 0.368741, - 0.111751, 0.488787, 0.0937199, 0.372146, - 0.121334, 0.491405, 0.103732, 0.377114, - 0.131147, 0.495604, 0.114608, 0.38226, - 0.141213, 0.499436, 0.126345, 0.389609, - 0.151632, 0.505334, 0.139116, 0.397925, - 0.162073, 0.51168, 0.152995, 0.407824, - 0.172819, 0.518876, 0.168071, 0.420014, - 0.183929, 0.527639, 0.184495, 0.434266, - 0.195032, 0.537588, 0.20232, 0.447352, - 0.205792, 0.544379, 0.221189, 0.463726, - 0.216704, 0.553422, 0.241616, 0.481406, - 0.227531, 0.562074, 0.263298, 0.498707, - 0.238017, 0.568227, 0.286116, 0.518039, - 0.247936, 0.574473, 0.3101, 0.538277, - 0.257437, 0.579191, 0.335401, 0.561166, - 0.266829, 0.584807, 0.362246, 0.583189, - 0.275329, 0.586476, 0.390609, 0.606024, - 0.28234, 0.585578, 0.420998, 0.632419, - 0.287924, 0.584496, 0.454357, 0.656128, - 0.291972, 0.577766, 0.488233, 0.679953, - 0.29456, 0.56875, 0.523248, 0.704654, - 0.295816, 0.558388, 0.559168, 0.729016, - 0.295157, 0.544826, 0.595326, 0.752062, - 0.292779, 0.528273, 0.631864, 0.773138, - 0.288681, 0.508482, 0.667793, 0.794869, - 0.283358, 0.487341, 0.704035, 0.815101, - 0.27608, 0.46354, 0.739925, 0.834212, - 0.26767, 0.438672, 0.775539, 0.852368, - 0.257397, 0.411239, 0.810895, 0.870207, - 0.245689, 0.3829, 0.846472, 0.884063, - 0.231452, 0.351496, 0.881788, 0.898284, - 0.215561, 0.31895, 0.917438, 0.912964, - 0.198208, 0.287367, 0.952422, 0.924666, - 0.180426, 0.254487, 0.987551, 0.934429, - 0.161525, 0.222226, 1.02142, 0.943485, - 0.141197, 0.191143, 1.05218, 0.9521, - 0.120085, 0.161112, 1.07937, 0.957876, - 0.0975881, 0.130982, 1.10403, 0.966943, - 0.0726842, 0.0990553, 1.12616, 0.978313, - 0.0483705, 0.0662818, 1.14619, 0.990048, - 0.0239072, 0.0329243, 1.16413, 0.999984, 0.000461885, - 7.72859e-05, 1.18099, 0.321287, - 9.35049e-06, 0.455413, 6.59662e-06, 0.332595, - 0.000237513, 0.471437, 0.000167562, 0.332729, - 0.000949964, 0.471618, 0.000670192, 0.332305, - 0.00213618, 0.471028, 0.00150712, 0.332326, - 0.00379765, 0.471055, 0.00267959, 0.332344, - 0.00593353, 0.471072, 0.00418751, 0.332356, - 0.00854349, 0.471077, 0.00603172, 0.332403, - 0.0116268, 0.471121, 0.00821362, 0.332461, - 0.0151824, 0.47117, 0.0107357, 0.332552, - 0.0192088, 0.471251, 0.0136014, 0.332657, - 0.0237024, 0.47133, 0.0168152, 0.332835, - 0.0286615, 0.471487, 0.0203853, 0.333083, - 0.0340765, 0.471708, 0.0243212, 0.333547, - 0.0398563, 0.47219, 0.0286518, 0.333989, - 0.0460916, 0.472587, 0.0333763, 0.334532, - 0.0527897, 0.473054, 0.0385084, 0.335167, - 0.0599284, 0.473568, 0.0440638, 0.33608, - 0.0673514, 0.474362, 0.0500962, 0.337146, - 0.0752237, 0.475231, 0.0566022, 0.338462, - 0.083418, 0.476282, 0.0636272, 0.34014, - 0.0919382, 0.477615, 0.0712153, 0.342341, - 0.100741, 0.479404, 0.079417, 0.345088, - 0.109905, 0.481618, 0.0882631, 0.349049, - 0.119369, 0.485081, 0.0978851, 0.353939, - 0.129033, 0.489317, 0.108336, 0.359893, - 0.139038, 0.494309, 0.119698, 0.366945, - 0.149411, 0.499983, 0.132024, 0.375814, - 0.159843, 0.507185, 0.145558, 0.387112, - 0.170664, 0.516392, 0.160433, 0.40023, - 0.181897, 0.526519, 0.176648, 0.412555, - 0.192785, 0.53423, 0.193922, 0.427023, - 0.203663, 0.542741, 0.212662, 0.443685, - 0.214695, 0.552066, 0.232944, 0.461499, - 0.225561, 0.560762, 0.254495, 0.480975, - 0.236257, 0.569421, 0.277531, 0.501, - 0.24639, 0.576101, 0.301724, 0.521691, - 0.256101, 0.581493, 0.327112, 0.543478, - 0.265289, 0.585221, 0.353917, 0.566094, - 0.273938, 0.587614, 0.381941, 0.589578, - 0.281679, 0.587991, 0.41172, 0.614583, - 0.287655, 0.585928, 0.444148, 0.641813, - 0.292228, 0.582092, 0.478617, 0.666189, - 0.295172, 0.57398, 0.51397, 0.690475, - 0.29648, 0.561676, 0.550118, 0.715543, - 0.296203, 0.548758, 0.586933, 0.740405, - 0.293999, 0.532792, 0.62384, 0.762183, - 0.28998, 0.512735, 0.660723, 0.786069, - 0.28478, 0.492402, 0.69807, 0.806812, - 0.277568, 0.469058, 0.734422, 0.826987, - 0.268951, 0.443017, 0.770946, 0.844588, - 0.259049, 0.415501, 0.80699, 0.863725, - 0.2471, 0.387328, 0.842107, 0.879137, - 0.234157, 0.356108, 0.878078, 0.894634, - 0.218719, 0.324315, 0.914058, 0.909162, - 0.201293, 0.291813, 0.949922, 0.92072, - 0.18267, 0.258474, 0.985337, 0.93158, - 0.163212, 0.225593, 1.0205, 0.941238, - 0.142771, 0.193986, 1.05273, 0.949293, - 0.120956, 0.163392, 1.08075, 0.956226, - 0.0985743, 0.132934, 1.10559, 0.96546, - 0.075118, 0.101255, 1.12823, 0.977403, - 0.0497921, 0.0675441, 1.149, 0.989648, - 0.0241574, 0.0334681, 1.16765, 1.00001, 0.0005762, - 0.000184807, 1.18519, 0.303474, - 9.16603e-06, 0.4542, 6.1243e-06, 0.308894, - 0.000232869, 0.462306, 0.000155592, 0.309426, - 0.000931661, 0.463093, 0.000622499, 0.308643, - 0.0020949, 0.461933, 0.00139979, 0.308651, - 0.0037242, 0.461941, 0.00248874, 0.308662, - 0.00581873, 0.46195, 0.00388933, 0.308687, - 0.00837818, 0.461974, 0.00560247, 0.308728, - 0.0114016, 0.462011, 0.00762948, 0.308789, - 0.0148884, 0.462067, 0.00997326, 0.308882, - 0.0188369, 0.462151, 0.0126375, 0.309007, - 0.0232436, 0.462263, 0.0156271, 0.30918, - 0.0281054, 0.462417, 0.0189498, 0.309442, - 0.0334065, 0.462667, 0.0226167, 0.309901, - 0.0390589, 0.463162, 0.0266614, 0.310331, - 0.0452042, 0.463555, 0.0310715, 0.310858, - 0.0517735, 0.464019, 0.0358698, 0.311576, - 0.0587359, 0.464669, 0.0410848, 0.312436, - 0.0660383, 0.465406, 0.0467453, 0.313526, - 0.0737266, 0.466339, 0.0528718, 0.314903, - 0.0817574, 0.467504, 0.0595039, 0.316814, - 0.090167, 0.469226, 0.0666888, 0.318965, - 0.0987555, 0.470981, 0.0744658, 0.322077, - 0.107792, 0.473814, 0.082912, 0.325947, - 0.117098, 0.477241, 0.0920846, 0.331008, - 0.126602, 0.48184, 0.102137, 0.337893, - 0.136619, 0.488334, 0.113135, 0.345106, - 0.146838, 0.494415, 0.12511, 0.355111, - 0.157357, 0.503275, 0.138356, 0.365095, - 0.167955, 0.510966, 0.152686, 0.378344, - 0.179157, 0.521508, 0.16856, 0.391599, - 0.190143, 0.530455, 0.18561, 0.407786, - 0.20123, 0.541275, 0.204308, 0.425294, - 0.212456, 0.551784, 0.224623, 0.444021, - 0.223568, 0.561493, 0.246172, 0.463418, - 0.234154, 0.569886, 0.268979, 0.484077, - 0.244546, 0.577116, 0.293411, 0.505513, - 0.254301, 0.582914, 0.318936, 0.527672, - 0.263564, 0.587208, 0.345856, 0.550565, - 0.272332, 0.589277, 0.374054, 0.573656, - 0.280011, 0.588426, 0.403276, 0.59827, - 0.286924, 0.587504, 0.43474, 0.624731, - 0.291994, 0.583401, 0.468767, 0.652396, - 0.295159, 0.576997, 0.504411, 0.67732, - 0.296954, 0.565863, 0.54114, 0.703147, - 0.296877, 0.552316, 0.57816, 0.728715, - 0.295147, 0.536773, 0.616124, 0.752448, - 0.291275, 0.51771, 0.653885, 0.775169, - 0.285905, 0.496087, 0.691537, 0.799307, - 0.279064, 0.474232, 0.729251, 0.819482, - 0.270294, 0.447676, 0.766267, 0.837659, - 0.260032, 0.419656, 0.802616, 0.856903, - 0.248497, 0.391328, 0.838583, 0.873325, - 0.235252, 0.360285, 0.874711, 0.889788, - 0.221126, 0.329215, 0.91077, 0.904486, - 0.204304, 0.296392, 0.94653, 0.917711, - 0.185562, 0.262159, 0.983828, 0.928969, - 0.165635, 0.229142, 1.01955, 0.939707, - 0.14442, 0.19673, 1.05317, 0.948167, - 0.122147, 0.165095, 1.0823, 0.955222, - 0.099098, 0.13451, 1.10791, 0.964401, - 0.0755332, 0.102476, 1.1312, 0.976605, - 0.0513817, 0.0689667, 1.15218, 0.989085, - 0.0258499, 0.034506, 1.17129, 0.999908, 0.000617773, - 0.000271268, 1.18961, 0.285803, - 9.05752e-06, 0.452348, 5.72272e-06, 0.284689, - 0.00022732, 0.450581, 0.000143626, 0.285263, - 0.000910214, 0.451482, 0.000575099, 0.285302, - 0.00204784, 0.451553, 0.00129395, 0.285318, - 0.00364057, 0.451574, 0.0023006, 0.28533, - 0.00568813, 0.451585, 0.00359547, 0.285361, - 0.00819001, 0.451618, 0.00517934, 0.285397, - 0.0111458, 0.45165, 0.007054, 0.285447, - 0.0145536, 0.451688, 0.00922167, 0.285527, - 0.0184127, 0.451758, 0.0116869, 0.285688, - 0.0227207, 0.451929, 0.0144555, 0.28584, - 0.0274712, 0.452055, 0.0175341, 0.286136, - 0.0326278, 0.452369, 0.0209406, 0.286574, - 0.0381792, 0.452853, 0.0246965, 0.287012, - 0.0441879, 0.453272, 0.0287996, 0.287542, - 0.0506096, 0.453752, 0.033268, 0.288299, - 0.0573634, 0.454488, 0.0381504, 0.289186, - 0.0645458, 0.455294, 0.0434447, 0.290302, - 0.0720405, 0.456301, 0.0491973, 0.291776, - 0.0799046, 0.457648, 0.0554453, 0.29372, - 0.088117, 0.459483, 0.0622311, 0.296052, - 0.0965328, 0.461571, 0.0695992, 0.299563, - 0.105409, 0.465085, 0.077658, 0.30335, - 0.114553, 0.468506, 0.0864176, 0.309167, - 0.123917, 0.474423, 0.0961078, 0.31529, - 0.13381, 0.47995, 0.106643, 0.324163, - 0.144021, 0.488592, 0.118322, 0.333272, - 0.154382, 0.496461, 0.131133, 0.344224, - 0.165015, 0.50562, 0.145208, 0.357733, - 0.176168, 0.516719, 0.16073, 0.373046, - 0.187468, 0.528513, 0.177807, 0.38788, - 0.198488, 0.537713, 0.196072, 0.405133, - 0.209545, 0.547999, 0.21605, 0.423845, - 0.220724, 0.55759, 0.237484, 0.443777, - 0.231518, 0.566246, 0.26039, 0.464824, - 0.242035, 0.574326, 0.284835, 0.486635, - 0.251898, 0.58037, 0.310518, 0.51012, - 0.261304, 0.58568, 0.337678, 0.535301, - 0.270384, 0.590197, 0.366242, 0.559193, - 0.27841, 0.590569, 0.395873, 0.583544, - 0.285325, 0.588161, 0.426857, 0.608834, - 0.291113, 0.584249, 0.459477, 0.635753, - 0.294882, 0.57763, 0.494734, 0.664367, - 0.297088, 0.569479, 0.532023, 0.689688, - 0.297364, 0.555064, 0.569629, 0.715732, - 0.295949, 0.539522, 0.608124, 0.741307, - 0.292259, 0.521613, 0.646231, 0.764949, - 0.287063, 0.49969, 0.684938, 0.788599, - 0.28012, 0.476747, 0.723548, 0.81048, - 0.27153, 0.45116, 0.761135, 0.831372, - 0.261289, 0.424101, 0.798916, 0.850092, - 0.249559, 0.39443, 0.835952, 0.867777, - 0.236348, 0.363849, 0.871606, 0.884632, - 0.221569, 0.332477, 0.907843, 0.90047, - 0.20618, 0.300667, 0.944187, 0.914524, - 0.188771, 0.266552, 0.981371, 0.926892, - 0.168362, 0.232349, 1.01841, 0.937951, - 0.146761, 0.199359, 1.05308, 0.947236, - 0.123813, 0.1675, 1.0839, 0.954367, - 0.099984, 0.136166, 1.11047, 0.963907, - 0.0759278, 0.103808, 1.13414, 0.976218, - 0.0511367, 0.0697061, 1.15575, 0.988772, - 0.0267415, 0.0352529, 1.17531, 0.999888, - 0.000520778, 0.000289926, 1.19389, 0.263546, - 8.83274e-06, 0.441896, 5.26783e-06, 0.262352, - 0.000221849, 0.439889, 0.000132311, 0.262325, - 0.000886683, 0.439848, 0.000528824, 0.26228, - 0.00199476, 0.439765, 0.00118975, 0.262372, - 0.00354671, 0.439922, 0.00211568, 0.26239, - 0.00554141, 0.439941, 0.00330652, 0.262412, - 0.00797888, 0.439961, 0.00476346, 0.262453, - 0.0108584, 0.440002, 0.00648818, 0.262528, - 0.0141788, 0.440085, 0.0084835, 0.262615, - 0.017938, 0.440166, 0.0107533, 0.262744, - 0.0221346, 0.440291, 0.0133044, 0.262939, - 0.026762, 0.440493, 0.0161445, 0.263277, - 0.0317573, 0.440889, 0.0192974, 0.26368, - 0.0371832, 0.441338, 0.0227699, 0.264106, - 0.0430371, 0.441753, 0.0265698, 0.264624, - 0.0493035, 0.442227, 0.0307178, 0.265378, - 0.0558669, 0.442985, 0.0352616, 0.266253, - 0.0628718, 0.443795, 0.0401968, 0.267478, - 0.0701569, 0.445008, 0.04559, 0.269062, - 0.077845, 0.446599, 0.0514539, 0.270926, - 0.0857941, 0.448349, 0.0578382, 0.273693, - 0.0940773, 0.451221, 0.0648363, 0.276746, - 0.102704, 0.454097, 0.0724389, 0.281693, - 0.111735, 0.459517, 0.0808744, 0.287335, - 0.121004, 0.46531, 0.0901551, 0.29448, - 0.130734, 0.472605, 0.100371, 0.30257, - 0.140777, 0.480251, 0.111644, 0.312465, - 0.15111, 0.489444, 0.124111, 0.324856, - 0.16189, 0.500919, 0.137979, 0.33774, - 0.172946, 0.511317, 0.153163, 0.35255, - 0.184152, 0.522684, 0.169817, 0.367786, - 0.19522, 0.53248, 0.187886, 0.385474, - 0.20632, 0.543326, 0.207634, 0.404976, - 0.217744, 0.554109, 0.229165, 0.425203, - 0.228691, 0.563395, 0.252068, 0.446704, - 0.239299, 0.571565, 0.276471, 0.468951, - 0.249348, 0.577935, 0.302323, 0.493487, - 0.258933, 0.584309, 0.329882, 0.517861, - 0.268009, 0.58773, 0.358525, 0.543309, - 0.276238, 0.589612, 0.388585, 0.569704, - 0.28356, 0.589294, 0.419787, 0.594871, - 0.289497, 0.585137, 0.452114, 0.622555, - 0.294452, 0.580356, 0.486466, 0.651167, - 0.296918, 0.57185, 0.523079, 0.677332, - 0.297647, 0.558428, 0.5611, 0.703718, - 0.296321, 0.542232, 0.599592, 0.730262, - 0.293339, 0.524541, 0.639138, 0.754304, - 0.288036, 0.502691, 0.677978, 0.778051, - 0.281018, 0.479212, 0.716537, 0.801557, - 0.272414, 0.454071, 0.75586, 0.822559, - 0.262419, 0.425952, 0.794477, 0.843051, - 0.250702, 0.397313, 0.832664, 0.86232, - 0.237264, 0.366534, 0.869876, 0.879044, - 0.222716, 0.334816, 0.906973, 0.896362, - 0.206827, 0.303143, 0.943558, 0.910342, - 0.189659, 0.269699, 0.979759, 0.924119, - 0.171108, 0.236411, 1.01718, 0.935374, - 0.149579, 0.202224, 1.05289, 0.944295, - 0.126295, 0.16989, 1.08496, 0.952227, - 0.101511, 0.138089, 1.11256, 0.962041, - 0.0766392, 0.105053, 1.1375, 0.97528, - 0.0511967, 0.070329, 1.15983, 0.988476, - 0.025463, 0.0351268, 1.17987, 0.999962, 2.86808e-05, 1.45564e-05, 1.19901, 0.227089, - 8.41413e-06, 0.404216, 4.72707e-06, 0.239725, - 0.000215083, 0.426708, 0.000120833, 0.239904, - 0.000860718, 0.427028, 0.000483555, 0.239911, - 0.00193661, 0.427039, 0.00108806, 0.239914, - 0.00344276, 0.42704, 0.00193457, 0.239933, - 0.00537907, 0.427064, 0.00302363, 0.239944, - 0.00774482, 0.427065, 0.00435604, 0.239993, - 0.01054, 0.427122, 0.00593398, 0.240052, - 0.0137626, 0.427179, 0.00775987, 0.240148, - 0.0174115, 0.427279, 0.00983854, 0.240278, - 0.021484, 0.42741, 0.0121763, 0.240472, - 0.0259729, 0.427618, 0.0147827, 0.240839, - 0.0308131, 0.428086, 0.0176837, 0.241201, - 0.0360893, 0.428482, 0.0208775, 0.241626, - 0.0417723, 0.428907, 0.0243821, 0.242207, - 0.0478337, 0.42952, 0.0282228, 0.24298, - 0.0542199, 0.430332, 0.0324333, 0.243881, - 0.0610015, 0.431222, 0.0370252, 0.245123, - 0.0680874, 0.432512, 0.0420535, 0.24667, - 0.0755482, 0.434088, 0.0475414, 0.248779, - 0.0832873, 0.436323, 0.0535542, 0.251665, - 0.0913546, 0.439509, 0.0601716, 0.255305, - 0.0998489, 0.443478, 0.0674282, 0.260049, - 0.108576, 0.448713, 0.0754673, 0.266192, - 0.117754, 0.455524, 0.084339, 0.273158, - 0.127294, 0.4627, 0.0941683, 0.282131, - 0.137311, 0.472068, 0.10515, 0.293332, - 0.147736, 0.483565, 0.117402, 0.304667, - 0.158357, 0.493702, 0.130824, 0.317785, - 0.169274, 0.504708, 0.145724, 0.333245, - 0.180595, 0.517107, 0.16215, 0.349843, - 0.191892, 0.528849, 0.180149, 0.367944, - 0.203168, 0.540301, 0.199746, 0.387579, - 0.214443, 0.551514, 0.221047, 0.408247, - 0.225624, 0.560906, 0.243981, 0.43014, - 0.236422, 0.56959, 0.268513, 0.452669, - 0.24654, 0.576098, 0.294409, 0.476196, - 0.256157, 0.580925, 0.322002, 0.501157, - 0.265289, 0.584839, 0.351052, 0.527632, - 0.273671, 0.587614, 0.3812, 0.555754, - 0.281254, 0.589119, 0.412994, 0.581682, - 0.287448, 0.585204, 0.445498, 0.608196, - 0.292614, 0.579006, 0.479505, 0.635661, - 0.296068, 0.571297, 0.514643, 0.664999, - 0.297395, 0.560855, 0.552213, 0.691039, - 0.296645, 0.544525, 0.591365, 0.7179, - 0.293785, 0.526535, 0.630883, 0.744059, - 0.289089, 0.50545, 0.670932, 0.76863, - 0.282239, 0.482514, 0.710904, 0.793273, - 0.273688, 0.457246, 0.750259, 0.814731, - 0.26328, 0.428872, 0.78948, 0.835603, - 0.251526, 0.399384, 0.828597, 0.85489, - 0.238339, 0.368811, 0.866892, 0.872828, - 0.223607, 0.336617, 0.90563, 0.889462, - 0.207538, 0.303997, 0.943538, 0.904929, - 0.190297, 0.270812, 0.980591, 0.919101, - 0.172034, 0.237453, 1.01935, 0.930536, - 0.152058, 0.204431, 1.05498, 0.941223, - 0.129515, 0.172495, 1.08717, 0.94982, - 0.104263, 0.140175, 1.11551, 0.960592, - 0.0781944, 0.106465, 1.14098, 0.974629, - 0.051688, 0.0711592, 1.16418, 0.98811, - 0.0253929, 0.0354432, 1.18465, 1.00004, 0.000804378, - 0.000330876, 1.20462, 0.214668, - 8.21282e-06, 0.406619, 4.33582e-06, 0.218053, - 0.000208144, 0.413025, 0.000109887, 0.217987, - 0.000832212, 0.412901, 0.000439362, 0.217971, - 0.00187246, 0.412876, 0.000988623, 0.217968, - 0.00332855, 0.41286, 0.00175772, 0.217985, - 0.00520055, 0.412882, 0.00274729, 0.218014, - 0.00748814, 0.412916, 0.00395842, 0.218054, - 0.0101901, 0.412957, 0.00539274, 0.218106, - 0.0133057, 0.413005, 0.00705348, 0.218217, - 0.0168342, 0.413139, 0.00894581, 0.218338, - 0.0207707, 0.413258, 0.0110754, 0.21855, - 0.0251001, 0.413509, 0.0134551, 0.218913, - 0.0297861, 0.413992, 0.0161081, 0.219265, - 0.0348956, 0.414383, 0.0190307, 0.219696, - 0.0403909, 0.414839, 0.0222458, 0.220329, - 0.0462003, 0.415567, 0.025792, 0.220989, - 0.0524208, 0.41621, 0.0296637, 0.222027, - 0.058948, 0.417385, 0.0339323, 0.223301, - 0.0658208, 0.418779, 0.0386055, 0.224988, - 0.0730347, 0.420665, 0.0437355, 0.227211, - 0.0805274, 0.423198, 0.0493844, 0.230131, - 0.088395, 0.426566, 0.0556135, 0.233908, - 0.0966208, 0.43091, 0.0624829, 0.239092, - 0.105223, 0.437148, 0.0701636, 0.245315, - 0.11424, 0.444302, 0.0786949, 0.253166, - 0.12368, 0.453262, 0.0882382, 0.262374, - 0.133569, 0.463211, 0.0988682, 0.273145, - 0.143836, 0.474271, 0.110727, 0.285512, - 0.154577, 0.4863, 0.123945, 0.299512, - 0.165501, 0.498817, 0.138581, 0.314287, - 0.176698, 0.510341, 0.154676, 0.331083, - 0.188066, 0.522583, 0.172459, 0.349615, - 0.199597, 0.534879, 0.191979, 0.369318, - 0.210843, 0.546083, 0.21309, 0.390377, - 0.222068, 0.5562, 0.235998, 0.412411, - 0.233059, 0.564704, 0.260518, 0.435715, - 0.24357, 0.572314, 0.286795, 0.461196, - 0.253356, 0.579395, 0.314559, 0.485587, - 0.262362, 0.581985, 0.343581, 0.511908, - 0.270895, 0.584347, 0.374367, 0.539798, - 0.278452, 0.58505, 0.406015, 0.567974, - 0.284877, 0.583344, 0.439168, 0.594303, - 0.290124, 0.577348, 0.473005, 0.622951, - 0.294183, 0.570751, 0.508534, 0.652404, - 0.296389, 0.561541, 0.544764, 0.679291, - 0.296605, 0.546426, 0.582927, 0.706437, - 0.294095, 0.528599, 0.622681, 0.734485, - 0.28978, 0.508676, 0.663567, 0.758841, - 0.283363, 0.484768, 0.704092, 0.78537, - 0.275015, 0.460434, 0.745101, 0.807315, - 0.264689, 0.432166, 0.784712, 0.8271, - 0.252597, 0.401807, 0.824241, 0.849191, - 0.239154, 0.371458, 0.863803, 0.867046, - 0.224451, 0.338873, 0.903063, 0.8852, - 0.208342, 0.306175, 0.942763, 0.901771, - 0.190684, 0.272759, 0.981559, 0.915958, - 0.172105, 0.239306, 1.02048, 0.928046, - 0.152214, 0.206071, 1.05765, 0.939961, - 0.130247, 0.17367, 1.08999, 0.948711, - 0.10672, 0.142201, 1.11829, 0.959305, - 0.0808688, 0.108454, 1.14467, 0.973009, - 0.0539145, 0.0728109, 1.16839, 0.987631, - 0.0262947, 0.0360625, 1.19004, 0.999978, 0.00132758, - 0.000559424, 1.21058, 0.193925, - 7.93421e-06, 0.391974, 3.92537e-06, 0.196746, - 0.000200315, 0.397675, 9.91033e-05, 0.19667, - 0.000801099, 0.397521, 0.000396342, 0.196633, - 0.00180246, 0.397445, 0.000891829, 0.196654, - 0.00320443, 0.397482, 0.00158582, 0.196659, - 0.00500647, 0.39748, 0.00247867, 0.196683, - 0.0072086, 0.397506, 0.00357167, 0.196728, - 0.00981001, 0.397562, 0.00486675, 0.196792, - 0.0128096, 0.397633, 0.00636707, 0.19689, - 0.0162055, 0.397746, 0.00807752, 0.197017, - 0.0199943, 0.397884, 0.0100052, 0.19729, - 0.024139, 0.39827, 0.0121691, 0.197583, - 0.0286671, 0.398639, 0.0145755, 0.197927, - 0.0335858, 0.399034, 0.0172355, 0.198383, - 0.0388806, 0.399554, 0.0201718, 0.199002, - 0.0444736, 0.400289, 0.0234194, 0.199739, - 0.0504583, 0.401111, 0.026984, 0.200784, - 0.056729, 0.402349, 0.0309217, 0.202075, - 0.0633643, 0.403841, 0.0352496, 0.203898, - 0.0703247, 0.406076, 0.0400313, 0.206199, - 0.0775565, 0.408841, 0.0453282, 0.209252, - 0.085184, 0.41259, 0.0511794, 0.213638, - 0.0931994, 0.418288, 0.0577459, 0.21881, - 0.101617, 0.424681, 0.0650508, 0.225642, - 0.11052, 0.433429, 0.0732759, 0.233717, - 0.119772, 0.442897, 0.0824683, 0.242823, - 0.129505, 0.452888, 0.0927484, 0.254772, - 0.139906, 0.466407, 0.104417, 0.266603, - 0.150402, 0.477413, 0.117211, 0.28073, - 0.161395, 0.490519, 0.131598, 0.295399, - 0.172465, 0.50201, 0.147407, 0.312705, - 0.183982, 0.515311, 0.165031, 0.331335, - 0.195532, 0.52786, 0.184336, 0.351037, - 0.206971, 0.5392, 0.205361, 0.372175, - 0.218117, 0.54941, 0.228043, 0.394548, - 0.229327, 0.558642, 0.25267, 0.419598, - 0.240052, 0.567861, 0.279071, 0.443922, - 0.249937, 0.573332, 0.306882, 0.471495, - 0.259407, 0.58013, 0.33661, 0.496769, - 0.267749, 0.580564, 0.367328, 0.524951, - 0.275524, 0.581696, 0.399753, 0.55318, - 0.282148, 0.579885, 0.433134, 0.581577, - 0.287533, 0.575471, 0.467534, 0.609231, - 0.291612, 0.567445, 0.502943, 0.637478, - 0.293911, 0.557657, 0.53871, 0.667795, - 0.295096, 0.546535, 0.576568, 0.694272, - 0.294073, 0.529561, 0.614929, 0.722937, - 0.290386, 0.510561, 0.655909, 0.749682, - 0.284481, 0.487846, 0.697663, 0.774754, - 0.276188, 0.462487, 0.738515, 0.799301, - 0.266215, 0.43481, 0.779802, 0.820762, - 0.254116, 0.404879, 0.820045, 0.843231, - 0.240393, 0.374559, 0.860294, 0.861857, - 0.225503, 0.341582, 0.900965, 0.880815, - 0.209382, 0.308778, 0.941727, 0.89766, - 0.19155, 0.275232, 0.980916, 0.912926, - 0.172346, 0.240938, 1.02162, 0.926391, - 0.151799, 0.207223, 1.0597, 0.938429, - 0.129968, 0.17484, 1.09291, 0.947834, - 0.10651, 0.142984, 1.12248, 0.958432, - 0.0824098, 0.109902, 1.149, 0.972402, - 0.0565242, 0.0744454, 1.1733, 0.987191, - 0.028427, 0.0373794, 1.19538, 0.999975, 3.85685e-05, - 4.203e-05, 1.21676, 0.178114, - 7.66075e-06, 0.385418, 3.54027e-06, 0.176074, - 0.000191966, 0.381002, 8.87135e-05, 0.17601, - 0.000767549, 0.380861, 0.000354715, 0.17598, - 0.00172696, 0.380798, 0.000798168, 0.175994, - 0.00307012, 0.380824, 0.00141928, 0.176017, - 0.00479684, 0.380858, 0.00221859, 0.176019, - 0.00690648, 0.380839, 0.00319714, 0.176072, - 0.00939888, 0.380913, 0.0043572, 0.176131, - 0.0122726, 0.380979, 0.005702, 0.176239, - 0.0155264, 0.38112, 0.00723689, 0.176371, - 0.0191551, 0.381272, 0.00896907, 0.176638, - 0.023117, 0.381669, 0.0109194, 0.176912, - 0.0274633, 0.382015, 0.0130903, 0.177279, - 0.032173, 0.382476, 0.0154949, 0.17774, - 0.0372219, 0.383041, 0.0181669, 0.178344, - 0.0426132, 0.38378, 0.0211209, 0.179153, - 0.0483309, 0.384773, 0.0243899, 0.180197, - 0.0543447, 0.386076, 0.0280062, 0.181581, - 0.0607122, 0.387809, 0.032004, 0.18344, - 0.0673855, 0.390205, 0.036453, 0.186139, - 0.0743989, 0.393944, 0.0414162, 0.189432, - 0.0817731, 0.39832, 0.0469394, 0.193795, - 0.0895464, 0.404188, 0.0531442, 0.199641, - 0.0978264, 0.4121, 0.0601374, 0.206679, - 0.106499, 0.421425, 0.0680078, 0.214865, - 0.115654, 0.431504, 0.076919, 0.224406, - 0.125268, 0.442526, 0.0868835, 0.235876, - 0.135475, 0.455465, 0.0981875, 0.248335, - 0.146023, 0.4681, 0.110759, 0.262868, - 0.157016, 0.482069, 0.124885, 0.278962, - 0.168245, 0.496182, 0.140645, 0.295082, - 0.17958, 0.507401, 0.157838, 0.313738, - 0.191227, 0.520252, 0.17695, 0.333573, - 0.202718, 0.531708, 0.197817, 0.356433, - 0.214424, 0.544509, 0.220785, 0.378853, - 0.225492, 0.55373, 0.245306, 0.402717, - 0.236236, 0.561348, 0.271593, 0.428375, - 0.246568, 0.568538, 0.299776, 0.454724, - 0.255941, 0.573462, 0.329433, 0.482291, - 0.264511, 0.576356, 0.360598, 0.509706, - 0.272129, 0.576446, 0.393204, 0.538805, - 0.278979, 0.575298, 0.427227, 0.568919, - 0.284528, 0.572154, 0.462157, 0.596804, - 0.288801, 0.564691, 0.497997, 0.625987, - 0.291334, 0.555134, 0.534467, 0.656414, - 0.292722, 0.545051, 0.571736, 0.683916, - 0.292185, 0.528813, 0.610158, 0.711809, - 0.290043, 0.51106, 0.649061, 0.739547, - 0.285246, 0.490103, 0.690081, 0.766914, - 0.277647, 0.465523, 0.732554, 0.791375, - 0.267603, 0.437718, 0.773982, 0.814772, - 0.256109, 0.40882, 0.81609, 0.836691, - 0.242281, 0.377823, 0.856849, 0.856984, - 0.227155, 0.34496, 0.898363, 0.876332, - 0.210395, 0.311335, 0.939471, 0.894988, - 0.192612, 0.277703, 0.980799, 0.911113, - 0.173236, 0.243019, 1.02215, 0.924092, - 0.152258, 0.209037, 1.06139, 0.936828, - 0.129575, 0.175909, 1.09635, 0.946869, - 0.10594, 0.143852, 1.12707, 0.958284, - 0.081318, 0.110289, 1.15419, 0.972325, - 0.0556133, 0.0747232, 1.17909, 0.986878, - 0.0297899, 0.0383149, 1.20163, 0.999936, - 0.00197169, 0.000912402, 1.22338, 0.151174, - 7.20365e-06, 0.351531, 3.09789e-06, 0.155594, - 0.00018279, 0.361806, 7.8608e-05, 0.156099, - 0.000731569, 0.362982, 0.000314615, 0.156053, - 0.00164578, 0.362869, 0.000707845, 0.156093, - 0.0029261, 0.362961, 0.00125884, 0.156099, - 0.00457155, 0.362959, 0.00196783, 0.15612, - 0.00658224, 0.362982, 0.00283622, 0.156168, - 0.00895774, 0.363048, 0.00386625, 0.156221, - 0.0116962, 0.363101, 0.00506109, 0.156324, - 0.0147973, 0.363241, 0.00642675, 0.156476, - 0.0182503, 0.363448, 0.00797175, 0.156731, - 0.0220266, 0.36384, 0.00971484, 0.156994, - 0.026176, 0.364179, 0.0116575, 0.157341, - 0.0306701, 0.36462, 0.0138207, 0.157867, - 0.0354591, 0.365364, 0.0162356, 0.15846, - 0.0406141, 0.366111, 0.0189092, 0.159308, - 0.0460519, 0.367248, 0.021885, 0.160426, - 0.0518096, 0.368767, 0.0252004, 0.161877, - 0.0578906, 0.370745, 0.0288825, 0.163995, - 0.0642812, 0.373831, 0.0330139, 0.16655, - 0.0710067, 0.377366, 0.0376283, 0.170237, - 0.0781522, 0.382799, 0.0428493, 0.175096, - 0.0857172, 0.389915, 0.0487324, 0.181069, - 0.0938025, 0.398487, 0.0554214, 0.188487, - 0.102363, 0.408799, 0.0630189, 0.197029, - 0.111343, 0.419991, 0.071634, 0.206684, - 0.120812, 0.431455, 0.0812797, 0.218698, - 0.131033, 0.445746, 0.0923651, 0.230726, - 0.141373, 0.457471, 0.104545, 0.245516, - 0.152387, 0.472388, 0.118449, 0.261551, - 0.163628, 0.486671, 0.133923, 0.277437, - 0.174814, 0.49762, 0.150849, 0.296662, - 0.186713, 0.51162, 0.169924, 0.31795, - 0.198513, 0.525435, 0.190848, 0.339422, - 0.210119, 0.536267, 0.213504, 0.362143, - 0.221354, 0.545982, 0.237947, 0.387198, - 0.23224, 0.555364, 0.264427, 0.412349, - 0.24257, 0.561489, 0.292519, 0.439274, - 0.252284, 0.566903, 0.322561, 0.466779, - 0.261023, 0.569614, 0.353952, 0.496011, - 0.26899, 0.571589, 0.387278, 0.524964, - 0.275498, 0.570325, 0.421356, 0.556518, - 0.281449, 0.568792, 0.457314, 0.584363, - 0.285526, 0.560268, 0.493199, 0.614214, - 0.28844, 0.55205, 0.530276, 0.645684, - 0.289777, 0.541906, 0.56855, 0.673446, - 0.289722, 0.526464, 0.606927, 0.701924, - 0.287792, 0.509872, 0.645945, 0.73037, - 0.284315, 0.490649, 0.685564, 0.757405, - 0.278804, 0.467964, 0.726511, 0.784025, - 0.269543, 0.441468, 0.768601, 0.808255, - 0.258117, 0.41216, 0.811321, 0.830739, - 0.244728, 0.380606, 0.853496, 0.851914, - 0.229428, 0.348111, 0.895374, 0.872586, - 0.212508, 0.314732, 0.937674, 0.891581, - 0.194025, 0.280338, 0.979869, 0.907641, - 0.174711, 0.245203, 1.02253, 0.922233, - 0.153509, 0.21077, 1.06371, 0.935878, - 0.130418, 0.177399, 1.09972, 0.946338, - 0.105558, 0.144507, 1.13124, 0.957265, - 0.080059, 0.110508, 1.15973, 0.971668, - 0.0539766, 0.0742311, 1.18515, 0.9866, - 0.0277101, 0.0375224, 1.20858, 1.00021, - 0.000515531, 0.000135226, 1.23135, 0.137468, - 6.86011e-06, 0.345041, 2.73315e-06, 0.13703, - 0.000173378, 0.343936, 6.90761e-05, 0.136986, - 0.000693048, 0.34383, 0.000276126, 0.136964, - 0.00155931, 0.343761, 0.000621337, 0.137003, - 0.00277211, 0.343863, 0.00110494, 0.137012, - 0.00433103, 0.343868, 0.00172744, 0.137043, - 0.00623606, 0.343916, 0.00249022, 0.13709, - 0.0084868, 0.343986, 0.00339559, 0.137145, - 0.0110814, 0.344045, 0.00444687, 0.137242, - 0.0140187, 0.344177, 0.00565007, 0.137431, - 0.0172713, 0.344491, 0.00701868, 0.137644, - 0.0208605, 0.344805, 0.00856042, 0.13791, - 0.024792, 0.345172, 0.0102863, 0.138295, - 0.0290461, 0.345734, 0.0122185, 0.138764, - 0.0335957, 0.346371, 0.0143771, 0.139415, - 0.038467, 0.347298, 0.0167894, 0.140272, - 0.0436176, 0.348527, 0.0194895, 0.141457, - 0.0491016, 0.350276, 0.0225043, 0.14303, - 0.0548764, 0.352646, 0.0258962, 0.145289, - 0.0610096, 0.356206, 0.0297168, 0.148502, - 0.0674777, 0.361488, 0.0340562, 0.152188, - 0.074345, 0.367103, 0.0389534, 0.157359, - 0.0817442, 0.375247, 0.0445541, 0.16379, - 0.0896334, 0.385064, 0.0509535, 0.171376, - 0.098005, 0.396082, 0.0582611, 0.179901, - 0.106817, 0.407418, 0.06654, 0.189892, - 0.116239, 0.420031, 0.075994, 0.201838, - 0.12627, 0.434321, 0.0867239, 0.214311, - 0.136701, 0.447631, 0.0987517, 0.228902, - 0.147616, 0.462046, 0.112353, 0.245107, - 0.158871, 0.476942, 0.127605, 0.262292, - 0.170261, 0.490285, 0.144469, 0.281215, - 0.182017, 0.503783, 0.163282, 0.301058, - 0.193729, 0.515505, 0.183873, 0.322752, - 0.205512, 0.52682, 0.206466, 0.347547, - 0.217214, 0.539473, 0.231194, 0.370969, - 0.227966, 0.546625, 0.257288, 0.397533, - 0.238555, 0.55472, 0.285789, 0.42398, - 0.248278, 0.559468, 0.315746, 0.452928, - 0.257422, 0.564095, 0.347724, 0.482121, - 0.265306, 0.565426, 0.380922, 0.510438, - 0.272043, 0.563205, 0.415639, 0.541188, - 0.277614, 0.561087, 0.451702, 0.571667, - 0.281927, 0.554922, 0.48845, 0.602432, - 0.285015, 0.546838, 0.526442, 0.634126, - 0.286512, 0.537415, 0.564896, 0.662816, - 0.286388, 0.522906, 0.604037, 0.692411, - 0.284734, 0.507003, 0.643795, 0.720946, - 0.281297, 0.488398, 0.68298, 0.748293, - 0.276262, 0.466353, 0.723466, 0.776931, - 0.269978, 0.443573, 0.764565, 0.801065, - 0.260305, 0.415279, 0.805838, 0.825843, - 0.247426, 0.384773, 0.849985, 0.84807, - 0.232437, 0.352555, 0.893174, 0.869122, - 0.215806, 0.318642, 0.936564, 0.888963, - 0.197307, 0.28381, 0.980253, 0.905547, - 0.177203, 0.247888, 1.02463, 0.918554, - 0.155542, 0.212904, 1.06714, 0.931395, - 0.131948, 0.1787, 1.10451, 0.941749, - 0.106723, 0.145902, 1.13694, 0.954551, - 0.0804939, 0.111193, 1.1666, 0.970279, - 0.0534239, 0.0744697, 1.19249, 0.986117, - 0.0257452, 0.0368788, 1.21665, 0.999938, 0.00190634, - 0.0010291, 1.23981, 0.118493, - 6.47439e-06, 0.32272, 2.3772e-06, 0.118765, - 0.000163023, 0.323456, 5.98573e-05, 0.118772, - 0.00065212, 0.323477, 0.000239447, 0.118843, - 0.00146741, 0.323657, 0.000538881, 0.118804, - 0.00260846, 0.323553, 0.00095826, 0.118826, - 0.00407576, 0.323595, 0.00149845, 0.118846, - 0.00586826, 0.323617, 0.00216047, 0.118886, - 0.00798578, 0.32367, 0.00294679, 0.118947, - 0.0104273, 0.323753, 0.00386124, 0.119055, - 0.0131909, 0.323922, 0.00490999, 0.119241, - 0.0162444, 0.324251, 0.00610804, 0.11944, - 0.0196339, 0.324544, 0.00745805, 0.119739, - 0.0233378, 0.325026, 0.00897805, 0.12011, - 0.0273179, 0.325586, 0.0106895, 0.120571, - 0.0316143, 0.326231, 0.0126073, 0.12124, - 0.0361939, 0.327264, 0.0147654, 0.122162, - 0.0410511, 0.328733, 0.0172001, 0.123378, - 0.0462233, 0.330659, 0.0199375, 0.125183, - 0.0517109, 0.333754, 0.0230498, 0.127832, - 0.0575652, 0.338507, 0.026597, 0.130909, - 0.0637441, 0.343666, 0.0306345, 0.135221, - 0.0704302, 0.351063, 0.035273, 0.14082, - 0.0776364, 0.360604, 0.0406137, 0.146781, - 0.0852293, 0.369638, 0.0466788, 0.155121, - 0.0935351, 0.3827, 0.0537628, 0.16398, - 0.102234, 0.39522, 0.0617985, 0.173926, - 0.111465, 0.40793, 0.07097, 0.185137, - 0.121296, 0.42105, 0.0813426, 0.19826, - 0.13169, 0.435735, 0.0931596, 0.212938, - 0.142614, 0.450932, 0.106547, 0.229046, - 0.153884, 0.465726, 0.121575, 0.246246, - 0.165382, 0.479461, 0.138286, 0.264637, - 0.176806, 0.492106, 0.15666, 0.284959, - 0.188793, 0.504774, 0.17728, 0.308157, - 0.200763, 0.518805, 0.19988, 0.330951, - 0.21239, 0.528231, 0.224293, 0.3549, - 0.223521, 0.536376, 0.250541, 0.381502, - 0.234169, 0.544846, 0.278902, 0.409529, - 0.244077, 0.551717, 0.309227, 0.437523, - 0.253363, 0.55517, 0.341426, 0.467624, - 0.261659, 0.557772, 0.37518, 0.497268, - 0.268498, 0.556442, 0.41007, 0.528294, - 0.274018, 0.553915, 0.446445, 0.559053, - 0.278169, 0.549153, 0.483779, 0.589329, - 0.281229, 0.539878, 0.522249, 0.622503, - 0.282902, 0.53162, 0.561754, 0.652382, - 0.282815, 0.518119, 0.601544, 0.681847, - 0.281247, 0.502187, 0.641574, 0.712285, - 0.277986, 0.484824, 0.682633, 0.740094, - 0.273017, 0.463483, 0.723426, 0.768478, - 0.266692, 0.441299, 0.763747, 0.794556, - 0.258358, 0.415238, 0.805565, 0.819408, - 0.248807, 0.386912, 0.847254, 0.843411, - 0.236214, 0.356165, 0.891091, 0.862397, - 0.219794, 0.320562, 0.936174, 0.883113, - 0.201768, 0.285322, 0.982562, 0.90023, - 0.181672, 0.249713, 1.02862, 0.915192, - 0.159279, 0.214546, 1.07163, 0.928458, - 0.134725, 0.180285, 1.10995, 0.94069, - 0.10913, 0.147119, 1.14354, 0.953409, - 0.0821315, 0.112492, 1.17372, 0.969537, - 0.0542677, 0.0752014, 1.20043, 0.985612, - 0.0259096, 0.0370361, 1.22528, 0.999835, 0.00298198, - 0.00151801, 1.24959, 0.10097, - 6.02574e-06, 0.300277, 2.02619e-06, 0.101577, - 0.000152164, 0.302077, 5.11662e-05, 0.101572, - 0.000608889, 0.302066, 0.000204751, 0.101566, - 0.00136997, 0.302047, 0.000460753, 0.101592, - 0.00243557, 0.302114, 0.000819497, 0.101608, - 0.0038053, 0.30214, 0.00128154, 0.101627, - 0.00547906, 0.30216, 0.0018483, 0.101669, - 0.00745647, 0.302224, 0.00252223, 0.101732, - 0.00973615, 0.302318, 0.00330716, 0.101844, - 0.0123097, 0.302513, 0.00421061, 0.102025, - 0.0151681, 0.30285, 0.00524481, 0.102224, - 0.0183334, 0.303166, 0.0064154, 0.102515, - 0.0217819, 0.303654, 0.00774063, 0.102886, - 0.0255067, 0.304243, 0.0092398, 0.103395, - 0.029514, 0.305089, 0.0109339, 0.104109, - 0.0337912, 0.306301, 0.0128561, 0.105074, - 0.0383565, 0.30798, 0.0150338, 0.10654, - 0.0432132, 0.310726, 0.0175228, 0.108478, - 0.0484244, 0.314351, 0.0203648, 0.111015, - 0.0539339, 0.319032, 0.0236325, 0.114682, - 0.0598885, 0.32605, 0.0274188, 0.11911, - 0.0663375, 0.334109, 0.0317905, 0.124736, - 0.0733011, 0.344013, 0.0368502, 0.131479, - 0.0807744, 0.355358, 0.0427104, 0.139283, - 0.0888204, 0.367614, 0.0494788, 0.148054, - 0.0973394, 0.380072, 0.0572367, 0.159037, - 0.10665, 0.395678, 0.0662704, 0.169794, - 0.116221, 0.40795, 0.0763192, 0.18314, - 0.126632, 0.423546, 0.087956, 0.197515, - 0.137383, 0.438213, 0.101042, 0.213514, - 0.148641, 0.453248, 0.115827, 0.23065, - 0.160117, 0.46688, 0.132283, 0.249148, - 0.171807, 0.479962, 0.150644, 0.270219, - 0.183695, 0.494618, 0.171073, 0.292338, - 0.195574, 0.506937, 0.193378, 0.314999, - 0.207205, 0.516463, 0.217585, 0.340991, - 0.218955, 0.528123, 0.24428, 0.367982, - 0.229917, 0.537025, 0.272784, 0.39432, - 0.239737, 0.541627, 0.302742, 0.423364, - 0.249048, 0.546466, 0.335112, 0.453751, - 0.257329, 0.549466, 0.369032, 0.48416, - 0.264623, 0.549503, 0.404577, 0.515262, - 0.270411, 0.547008, 0.441337, 0.547036, - 0.274581, 0.542249, 0.479162, 0.576614, - 0.277266, 0.533015, 0.517904, 0.611143, - 0.279144, 0.525512, 0.558508, 0.640989, - 0.279001, 0.51154, 0.598995, 0.671182, - 0.277324, 0.495641, 0.639935, 0.700848, - 0.273908, 0.477526, 0.681017, 0.729862, - 0.269063, 0.457955, 0.722764, 0.758273, - 0.262282, 0.434846, 0.764349, 0.784121, - 0.254281, 0.409203, 0.806206, 0.809798, - 0.24505, 0.382694, 0.848617, 0.834953, - 0.233861, 0.354034, 0.892445, 0.856817, - 0.221308, 0.321764, 0.936263, 0.877609, - 0.205996, 0.288118, 0.982401, 0.897489, - 0.186702, 0.253277, 1.02975, 0.913792, - 0.164618, 0.217963, 1.07488, 0.92785, - 0.140023, 0.183221, 1.11487, 0.940378, - 0.11328, 0.149385, 1.14947, 0.95273, - 0.0853958, 0.114152, 1.1807, 0.969059, - 0.0568698, 0.0769845, 1.20912, 0.985574, - 0.0276502, 0.0381186, 1.23498, 0.999943, 0.00239052, - 0.00126861, 1.25987, 0.0852715, - 5.60067e-06, 0.279021, 1.71162e-06, 0.0854143, - 0.000140871, 0.279483, 4.30516e-05, 0.0854191, - 0.000563385, 0.2795, 0.000172184, 0.0854188, - 0.00126753, 0.279493, 0.000387464, 0.0854229, - 0.00225337, 0.279501, 0.00068918, 0.0854443, - 0.00352086, 0.279549, 0.00107803, 0.0854697, - 0.00506962, 0.279591, 0.00155536, 0.0855093, - 0.00689873, 0.279652, 0.00212354, 0.0855724, - 0.00900821, 0.279752, 0.00278703, 0.0856991, - 0.0113799, 0.280011, 0.0035551, 0.085855, - 0.0140314, 0.280297, 0.00443449, 0.0860682, - 0.016963, 0.280682, 0.00543636, 0.086344, - 0.0201438, 0.281159, 0.0065788, 0.0867426, - 0.0235999, 0.281886, 0.00787977, 0.087239, - 0.0273069, 0.282745, 0.0093606, 0.0879815, - 0.031269, 0.284139, 0.011056, 0.0891258, - 0.035531, 0.28647, 0.0130065, 0.0906909, - 0.0400947, 0.289708, 0.0152495, 0.0927624, - 0.0449638, 0.293904, 0.0178454, 0.0958376, - 0.0502427, 0.300471, 0.0208915, 0.0995827, - 0.0559514, 0.30806, 0.0244247, 0.104526, - 0.0622152, 0.317874, 0.0285721, 0.110532, - 0.0690046, 0.329332, 0.0334227, 0.117385, - 0.0763068, 0.341217, 0.0390466, 0.12522, - 0.084184, 0.353968, 0.0455786, 0.134037, - 0.0925248, 0.366797, 0.0530773, 0.144014, - 0.101487, 0.380209, 0.0617424, 0.156013, - 0.111273, 0.395956, 0.071777, 0.168872, - 0.121431, 0.41053, 0.0830905, 0.183089, - 0.132105, 0.425073, 0.0959341, 0.198763, - 0.143286, 0.439833, 0.110448, 0.216159, - 0.154841, 0.454507, 0.126769, 0.234859, - 0.166588, 0.468368, 0.14495, 0.255879, - 0.178626, 0.482846, 0.165233, 0.27677, - 0.190218, 0.493489, 0.187217, 0.301184, - 0.202227, 0.506549, 0.211659, 0.325852, - 0.213764, 0.5158, 0.237922, 0.352824, - 0.22487, 0.525442, 0.26632, 0.380882, - 0.235246, 0.532487, 0.296691, 0.410137, - 0.244847, 0.537703, 0.329179, 0.439787, - 0.253122, 0.540361, 0.363135, 0.472291, - 0.260517, 0.542734, 0.399222, 0.501856, - 0.266519, 0.538826, 0.436352, 0.534816, - 0.270905, 0.535152, 0.474505, 0.565069, - 0.273826, 0.525979, 0.513988, 0.597154, - 0.275333, 0.516394, 0.554852, 0.630473, - 0.275314, 0.506206, 0.596592, 0.660574, - 0.273323, 0.489769, 0.638117, 0.692015, - 0.270008, 0.472578, 0.680457, 0.720647, - 0.265001, 0.452134, 0.723008, 0.750528, - 0.258311, 0.430344, 0.765954, 0.777568, - 0.250046, 0.405624, 0.809012, 0.80387, - 0.240114, 0.378339, 0.852425, 0.828439, - 0.228737, 0.349877, 0.895346, 0.851472, - 0.216632, 0.318968, 0.940695, 0.873906, - 0.202782, 0.287489, 0.987235, 0.89467, - 0.187059, 0.254394, 1.03348, 0.912281, - 0.168818, 0.221294, 1.07812, 0.927358, - 0.146494, 0.18675, 1.11928, 0.940385, - 0.120009, 0.152322, 1.15609, 0.952672, - 0.0917183, 0.117514, 1.18875, 0.968496, - 0.0620321, 0.0797405, 1.21821, 0.985236, - 0.0314945, 0.0402383, 1.24523, 0.99998, - 0.000575153, 0.000110644, 1.27133, 0.0702429, - 5.12222e-06, 0.255273, 1.40947e-06, 0.0702981, - 0.000128826, 0.255469, 3.54488e-05, 0.0703691, - 0.000515562, 0.255727, 0.000141874, 0.0703805, - 0.00116, 0.255754, 0.00031929, 0.0703961, - 0.00206224, 0.255813, 0.000567999, 0.0704102, - 0.00322223, 0.255839, 0.00088871, 0.0704298, - 0.00463928, 0.255863, 0.00128272, 0.0704759, - 0.00631375, 0.255953, 0.00175283, 0.0705434, - 0.00824317, 0.256079, 0.00230342, 0.0706693, - 0.010412, 0.25636, 0.0029443, 0.0708189, - 0.0128439, 0.256647, 0.00368031, 0.0710364, - 0.0155177, 0.257084, 0.00452614, 0.0713223, - 0.0184374, 0.257637, 0.00549706, 0.0717182, - 0.0216002, 0.258416, 0.00661246, 0.072321, - 0.0249966, 0.259699, 0.00790147, 0.0731446, - 0.0286566, 0.261475, 0.0093884, 0.0743352, - 0.0325888, 0.264132, 0.0111186, 0.0760676, - 0.036843, 0.26815, 0.013145, 0.078454, - 0.0414292, 0.273636, 0.0155251, 0.0818618, - 0.0464634, 0.281653, 0.0183525, 0.0857382, - 0.0519478, 0.289992, 0.0216642, 0.0908131, - 0.0579836, 0.30066, 0.0255956, 0.0967512, - 0.0645124, 0.312204, 0.0301954, 0.103717, - 0.0716505, 0.325001, 0.0356017, 0.111596, - 0.0793232, 0.338129, 0.041896, 0.120933, - 0.087645, 0.352853, 0.0492447, 0.130787, - 0.096492, 0.366192, 0.0576749, 0.142311, - 0.105973, 0.380864, 0.0673969, 0.155344, - 0.116182, 0.396575, 0.0785899, 0.169535, - 0.126815, 0.411443, 0.0912377, 0.185173, - 0.138015, 0.426256, 0.105607, 0.201755, - 0.149325, 0.439607, 0.121551, 0.221334, - 0.161207, 0.455467, 0.139608, 0.241461, - 0.173162, 0.469096, 0.159591, 0.26294, - 0.18504, 0.481014, 0.18156, 0.286776, - 0.196881, 0.493291, 0.205781, 0.311596, - 0.208311, 0.503556, 0.231819, 0.338667, - 0.219671, 0.513268, 0.260274, 0.366021, - 0.230451, 0.519414, 0.290862, 0.395875, - 0.240131, 0.526766, 0.323196, 0.425564, - 0.248566, 0.52905, 0.357071, 0.457094, - 0.256195, 0.530796, 0.393262, 0.488286, - 0.262331, 0.528703, 0.430797, 0.522291, - 0.267141, 0.52727, 0.470231, 0.554172, - 0.270411, 0.519848, 0.510477, 0.586427, - 0.271986, 0.510307, 0.551594, 0.619638, - 0.27192, 0.499158, 0.593849, 0.650656, - 0.269817, 0.483852, 0.636314, 0.68284, - 0.266267, 0.467515, 0.679679, 0.714356, - 0.26113, 0.44931, 0.723884, 0.742717, - 0.254067, 0.425789, 0.767245, 0.770894, - 0.245652, 0.401144, 0.811819, 0.797358, - 0.235554, 0.374224, 0.856315, 0.823377, - 0.223896, 0.346167, 0.901077, 0.847456, - 0.210865, 0.316056, 0.946502, 0.870697, - 0.196574, 0.284503, 0.993711, 0.891068, - 0.180814, 0.251628, 1.04134, 0.909267, - 0.163314, 0.219065, 1.08609, 0.925653, - 0.143304, 0.186446, 1.12702, 0.940017, - 0.121322, 0.153416, 1.16371, 0.952398, - 0.0973872, 0.120334, 1.19712, 0.967568, - 0.0698785, 0.08352, 1.22791, 0.984772, - 0.0390031, 0.0439209, 1.25672, 1.00026, - 0.0070087, 0.00315668, 1.28428, 0.0556653, - 4.59654e-06, 0.227325, 1.12556e-06, 0.0565238, - 0.000116382, 0.230826, 2.84985e-05, 0.0565717, - 0.000465666, 0.231026, 0.000114036, 0.0565859, - 0.00104773, 0.231079, 0.000256656, 0.0565761, - 0.00186255, 0.231025, 0.00045663, 0.0565913, - 0.00291002, 0.231058, 0.000714664, 0.0566108, - 0.00418998, 0.231085, 0.00103224, 0.0566532, - 0.00570206, 0.231169, 0.00141202, 0.0567473, - 0.00743666, 0.231417, 0.00186018, 0.0568567, - 0.00940298, 0.231661, 0.00238264, 0.0569859, - 0.0115991, 0.231895, 0.00298699, 0.0572221, - 0.0140096, 0.232456, 0.00368957, 0.057519, - 0.0166508, 0.233096, 0.00450303, 0.0579534, - 0.01951, 0.234094, 0.00544945, 0.0585922, - 0.0225991, 0.235629, 0.00655564, 0.0595647, - 0.0259416, 0.238106, 0.00785724, 0.0609109, - 0.0295661, 0.241557, 0.00939127, 0.0628751, - 0.0335126, 0.246652, 0.0112198, 0.0656908, - 0.0378604, 0.254091, 0.0134168, 0.0691347, - 0.0426543, 0.262666, 0.0160374, 0.0732165, - 0.0478967, 0.272029, 0.0191514, 0.0782863, - 0.0536716, 0.283007, 0.0228597, 0.0843973, - 0.0600683, 0.295732, 0.0272829, 0.0913598, - 0.0670095, 0.308779, 0.032484, 0.0994407, - 0.0745516, 0.322886, 0.0385886, 0.108189, - 0.082712, 0.336408, 0.0457133, 0.118574, - 0.0914927, 0.351692, 0.0539832, 0.129989, - 0.100854, 0.366502, 0.0635162, 0.142722, - 0.110837, 0.381675, 0.0744386, 0.156654, - 0.121353, 0.3963, 0.0868483, 0.172151, - 0.132414, 0.411477, 0.100963, 0.188712, - 0.143809, 0.42508, 0.116795, 0.208093, - 0.155765, 0.441328, 0.134715, 0.227936, - 0.167608, 0.454328, 0.154396, 0.249495, - 0.179579, 0.467235, 0.176179, 0.27362, - 0.191488, 0.480248, 0.200193, 0.296371, - 0.202618, 0.487886, 0.225775, 0.324234, - 0.214133, 0.499632, 0.25441, 0.353049, - 0.225212, 0.509532, 0.285077, 0.381785, - 0.234875, 0.514265, 0.317047, 0.414038, - 0.244205, 0.521282, 0.351874, 0.445251, - 0.252145, 0.522931, 0.388279, 0.476819, - 0.258433, 0.520947, 0.425825, 0.509209, - 0.263411, 0.517669, 0.465104, 0.542759, - 0.266732, 0.512841, 0.505741, 0.574822, - 0.268263, 0.503317, 0.547611, 0.609324, - 0.268489, 0.493035, 0.590953, 0.641772, - 0.266941, 0.478816, 0.63488, 0.674049, - 0.263297, 0.462863, 0.679072, 0.705071, - 0.257618, 0.442931, 0.723487, 0.734709, - 0.250625, 0.421299, 0.768708, 0.763704, - 0.24179, 0.397085, 0.814375, 0.791818, - 0.231115, 0.370577, 0.859907, 0.817439, - 0.21922, 0.34232, 0.906715, 0.843202, - 0.205658, 0.312627, 0.953943, 0.866639, - 0.190563, 0.280933, 1.00185, 0.888129, - 0.173978, 0.248393, 1.05105, 0.907239, - 0.155485, 0.216007, 1.09704, 0.923893, - 0.134782, 0.183233, 1.13857, 0.938882, - 0.11249, 0.150376, 1.17539, 0.952464, - 0.0890706, 0.117177, 1.20924, 0.968529, - 0.0646523, 0.0813095, 1.24055, 0.984763, - 0.038606, 0.0439378, 1.27018, 1.00053, - 0.01238, 0.00598668, 1.29873, 0.0437928, - 4.09594e-06, 0.204012, 8.79224e-07, 0.0440166, - 0.000103395, 0.205049, 2.21946e-05, 0.0440529, - 0.000413633, 0.205225, 8.87981e-05, 0.0440493, - 0.000930594, 0.2052, 0.000199858, 0.0439884, - 0.00165352, 0.204901, 0.000355495, 0.0440716, - 0.0025849, 0.205255, 0.000556983, 0.0440968, - 0.00372222, 0.205311, 0.000805326, 0.0441359, - 0.00506478, 0.205391, 0.00110333, 0.0442231, - 0.00660384, 0.205638, 0.00145768, 0.0443254, - 0.00835246, 0.205877, 0.00187275, 0.0444832, - 0.0102992, 0.20627, 0.00235938, 0.0447001, - 0.0124449, 0.206796, 0.0029299, 0.0450168, - 0.0147935, 0.207593, 0.0036005, 0.0454816, - 0.017336, 0.208819, 0.00439246, 0.0462446, - 0.0201156, 0.211036, 0.00533864, 0.0473694, - 0.0231568, 0.214388, 0.00646984, 0.0490191, - 0.0264941, 0.219357, 0.00783856, 0.0512776, - 0.030184, 0.226061, 0.00950182, 0.0541279, - 0.0342661, 0.234094, 0.0115156, 0.0578989, - 0.0388539, 0.244297, 0.0139687, 0.0620835, - 0.0438735, 0.254457, 0.0169015, 0.0673497, - 0.04951, 0.266706, 0.0204554, 0.0731759, - 0.0556263, 0.278753, 0.0246606, 0.0803937, - 0.0624585, 0.29309, 0.0297126, 0.0879287, - 0.0697556, 0.305856, 0.0355868, 0.0970669, - 0.0778795, 0.321059, 0.0425768, 0.106508, - 0.0863541, 0.333873, 0.05056, 0.11776, - 0.0955935, 0.349008, 0.0598972, 0.130081, - 0.105438, 0.363776, 0.0706314, 0.144454, - 0.115899, 0.380112, 0.0828822, 0.1596, - 0.126827, 0.394843, 0.0967611, 0.176097, - 0.138161, 0.409033, 0.112381, 0.194726, - 0.149904, 0.424257, 0.129952, 0.213944, - 0.161675, 0.436945, 0.149333, 0.235516, - 0.173659, 0.450176, 0.170892, 0.260564, - 0.185963, 0.466305, 0.194984, 0.285183, - 0.197582, 0.477328, 0.220805, 0.311095, - 0.208697, 0.486566, 0.248694, 0.338924, - 0.219519, 0.494811, 0.279015, 0.369757, - 0.229766, 0.504065, 0.311725, 0.3996, - 0.238879, 0.507909, 0.345844, 0.430484, - 0.246802, 0.509805, 0.381749, 0.46413, - 0.253924, 0.511436, 0.420251, 0.497077, - 0.259319, 0.508787, 0.459957, 0.530434, - 0.263297, 0.50394, 0.501356, 0.565725, - 0.265619, 0.49804, 0.544252, 0.599254, - 0.265842, 0.487346, 0.587856, 0.631251, - 0.263978, 0.472975, 0.631969, 0.663972, - 0.26043, 0.457135, 0.677471, 0.697724, - 0.255358, 0.439844, 0.723744, 0.727725, - 0.248308, 0.417872, 0.770653, 0.756417, - 0.239181, 0.39273, 0.817357, 0.785419, - 0.22814, 0.367839, 0.864221, 0.81266, - 0.215681, 0.339449, 0.912701, 0.839391, - 0.201623, 0.309279, 0.962419, 0.86366, - 0.185624, 0.278029, 1.0122, 0.885028, - 0.16797, 0.245294, 1.06186, 0.904639, - 0.148336, 0.212689, 1.10934, 0.922048, - 0.12637, 0.179616, 1.15063, 0.936952, - 0.102928, 0.146749, 1.18885, 0.951895, - 0.0785268, 0.112733, 1.22352, 0.967198, - 0.0530153, 0.0760056, 1.25681, 0.984405, - 0.02649, 0.0383183, 1.28762, 1.00021, 0.00070019, - 0.00020039, 1.31656, 0.0325964, - 3.55447e-06, 0.176706, 6.55682e-07, 0.0329333, - 8.99174e-05, 0.178527, 1.65869e-05, 0.0329181, - 0.000359637, 0.178453, 6.63498e-05, 0.0329085, - 0.000808991, 0.178383, 0.000149332, 0.0329181, - 0.00143826, 0.178394, 0.000265873, 0.0329425, - 0.00224678, 0.178517, 0.000416597, 0.0329511, - 0.00323575, 0.17849, 0.000603299, 0.033011, - 0.00439875, 0.178695, 0.000829422, 0.0330733, - 0.00574059, 0.178843, 0.00109908, 0.0331857, - 0.00725896, 0.179176, 0.00141933, 0.0333445, - 0.00895289, 0.179618, 0.0017999, 0.0335674, - 0.0108219, 0.180238, 0.00225316, 0.033939, - 0.0128687, 0.181417, 0.00279765, 0.0345239, - 0.015114, 0.183395, 0.0034564, 0.0354458, - 0.017596, 0.186616, 0.00425864, 0.0368313, - 0.0203524, 0.191547, 0.00524936, 0.0386115, - 0.0234105, 0.197508, 0.00647033, 0.0410303, - 0.0268509, 0.205395, 0.00798121, 0.0442245, - 0.0307481, 0.215365, 0.0098557, 0.0478659, - 0.0350863, 0.225595, 0.0121417, 0.0522416, - 0.0399506, 0.236946, 0.0149385, 0.0574513, - 0.045357, 0.249442, 0.0183189, 0.0631208, - 0.0512863, 0.261222, 0.0223644, 0.0701124, - 0.0579273, 0.275418, 0.0272418, 0.0777331, - 0.0650652, 0.288989, 0.0329458, 0.0862709, - 0.0728813, 0.302546, 0.0396819, 0.096103, - 0.081363, 0.317164, 0.04757, 0.106976, - 0.0904463, 0.331733, 0.0567012, 0.119175, - 0.100105, 0.34661, 0.067202, 0.132919, - 0.110375, 0.362249, 0.0792588, 0.147727, - 0.121115, 0.376978, 0.0928672, 0.163618, - 0.132299, 0.390681, 0.108228, 0.182234, - 0.143887, 0.406571, 0.125502, 0.201809, - 0.155827, 0.42042, 0.144836, 0.225041, - 0.168357, 0.438411, 0.166706, 0.247621, - 0.18004, 0.450368, 0.189909, 0.27097, - 0.191536, 0.460083, 0.215251, 0.296658, - 0.203024, 0.469765, 0.243164, 0.325892, - 0.214056, 0.481837, 0.273388, 0.35406, - 0.224104, 0.487474, 0.305344, 0.384372, - 0.233489, 0.492773, 0.339741, 0.41749, - 0.241874, 0.498451, 0.376287, 0.45013, - 0.248834, 0.499632, 0.414195, 0.481285, - 0.254658, 0.495233, 0.454077, 0.519183, - 0.259367, 0.496401, 0.496352, 0.551544, - 0.261818, 0.487686, 0.538798, 0.587349, - 0.262964, 0.479453, 0.583626, 0.621679, - 0.262128, 0.467709, 0.629451, 0.654991, - 0.258998, 0.452123, 0.67566, 0.686873, - 0.254119, 0.433495, 0.723248, 0.719801, - 0.246946, 0.413657, 0.771156, 0.750355, - 0.237709, 0.390366, 0.81989, 0.780033, - 0.226549, 0.364947, 0.868601, 0.809254, - 0.214186, 0.337256, 0.920034, 0.836576, - 0.199639, 0.307395, 0.971706, 0.861774, - 0.183169, 0.275431, 1.02479, 0.885707, - 0.165111, 0.243431, 1.07837, 0.904742, - 0.144363, 0.210921, 1.12783, 0.915604, - 0.121305, 0.17647, 1.17254, 0.930959, - 0.0962119, 0.143106, 1.21012, 0.948404, - 0.069969, 0.108112, 1.24474, 0.967012, - 0.0427586, 0.0708478, 1.27718, 0.984183, - 0.0147043, 0.032335, 1.3083, 0.999577, 0.0142165, - 0.00726867, 1.3382, 0.0229227, - 2.99799e-06, 0.148623, 4.62391e-07, 0.0232194, - 7.58796e-05, 0.15054, 1.17033e-05, 0.0232315, - 0.000303636, 0.15063, 4.68397e-05, 0.0232354, - 0.000683189, 0.150624, 0.000105472, 0.0232092, - 0.0012136, 0.150445, 0.000187744, 0.0232523, - 0.00189765, 0.150679, 0.000294847, 0.0232828, - 0.00273247, 0.150789, 0.000428013, 0.0233371, - 0.00371287, 0.150995, 0.000591134, 0.0234015, - 0.00484794, 0.15118, 0.000787642, 0.023514, - 0.00612877, 0.151562, 0.00102547, 0.023679, - 0.00756125, 0.152116, 0.00131351, 0.0239559, - 0.00914651, 0.153162, 0.00166594, 0.0244334, - 0.010904, 0.155133, 0.00210182, 0.025139, - 0.0128615, 0.158035, 0.00264406, 0.0262598, - 0.0150628, 0.162751, 0.00332923, 0.0277875, - 0.0175532, 0.168944, 0.00419773, 0.0298472, - 0.0203981, 0.176835, 0.00530034, 0.0325444, - 0.023655, 0.186686, 0.00669777, 0.0355581, - 0.0272982, 0.196248, 0.00842661, 0.0392841, - 0.0314457, 0.207352, 0.0105854, 0.0436815, - 0.0361157, 0.219279, 0.0132458, 0.0485272, - 0.0412932, 0.230728, 0.0164736, 0.0541574, - 0.0470337, 0.242994, 0.0203715, 0.0609479, - 0.0535002, 0.257042, 0.0250953, 0.0685228, - 0.0605409, 0.27102, 0.0306856, 0.0768042, - 0.0680553, 0.28406, 0.037193, 0.0864844, - 0.0765011, 0.299186, 0.0449795, 0.0969415, - 0.0852674, 0.3132, 0.0538316, 0.108478, - 0.0947333, 0.327138, 0.0641149, 0.121705, - 0.10481, 0.342345, 0.0759185, 0.136743, - 0.115474, 0.358472, 0.0894116, 0.152986, - 0.126536, 0.374067, 0.104562, 0.170397, - 0.138061, 0.388267, 0.121632, 0.191392, - 0.150203, 0.406467, 0.140996, 0.211566, - 0.161751, 0.418641, 0.161696, 0.233567, - 0.173407, 0.430418, 0.184557, 0.257769, - 0.185397, 0.44277, 0.210092, 0.28531, - 0.197048, 0.457191, 0.237827, 0.311726, - 0.20784, 0.464712, 0.267253, 0.340537, - 0.218345, 0.472539, 0.299332, 0.372921, - 0.228306, 0.482331, 0.333988, 0.402924, - 0.236665, 0.484378, 0.369722, 0.434475, - 0.244097, 0.484717, 0.407836, 0.469736, - 0.250547, 0.487093, 0.448465, 0.505045, - 0.25511, 0.485575, 0.490263, 0.540262, - 0.258444, 0.481225, 0.534495, 0.576347, - 0.259903, 0.473481, 0.579451, 0.608656, - 0.259572, 0.4603, 0.625604, 0.646679, - 0.257908, 0.450341, 0.674511, 0.679902, - 0.253663, 0.431561, 0.723269, 0.714159, - 0.247419, 0.412684, 0.773263, 0.745345, - 0.239122, 0.389388, 0.824182, 0.778248, - 0.228837, 0.365361, 0.876634, 0.807208, - 0.216197, 0.337667, 0.92945, 0.835019, - 0.201772, 0.307197, 0.985261, 0.860261, - 0.185291, 0.274205, 1.04299, 0.877601, - 0.165809, 0.240178, 1.09816, 0.898211, - 0.143897, 0.207571, 1.14694, 0.915789, - 0.119513, 0.174904, 1.19008, 0.931831, - 0.0932919, 0.141423, 1.2297, 0.949244, - 0.0656528, 0.105603, 1.26553, 0.967527, - 0.0370262, 0.0679551, 1.29986, 0.984139, - 0.00730117, 0.0283133, 1.33252, 0.999713, 0.0234648, - 0.0121785, 1.36397, 0.0152135, - 2.45447e-06, 0.122795, 3.04092e-07, 0.0151652, - 6.15778e-05, 0.122399, 7.6292e-06, 0.0151181, - 0.000245948, 0.122023, 3.04802e-05, 0.0151203, - 0.000553394, 0.12203, 6.86634e-05, 0.015125, - 0.000983841, 0.122037, 0.000122463, 0.0151427, - 0.00153774, 0.12214, 0.000192706, 0.0151708, - 0.0022103, 0.122237, 0.000281219, 0.0152115, - 0.00300741, 0.12238, 0.000390804, 0.0152877, - 0.00392494, 0.1227, 0.000526317, 0.015412, - 0.00496597, 0.123244, 0.00069443, 0.0156201, - 0.00613314, 0.124228, 0.00090547, 0.0159658, - 0.00744113, 0.125945, 0.0011732, 0.0165674, - 0.00892546, 0.129098, 0.00151888, 0.017487, - 0.010627, 0.133865, 0.00197007, 0.018839, - 0.0126043, 0.140682, 0.0025637, 0.020554, - 0.0148814, 0.148534, 0.00333637, 0.0226727, - 0.0175123, 0.157381, 0.00433738, 0.0251879, - 0.0205266, 0.166685, 0.00561664, 0.0283635, - 0.0240319, 0.177796, 0.00725563, 0.0318694, - 0.0279432, 0.188251, 0.00928811, 0.0361044, - 0.0324313, 0.200038, 0.011835, 0.0406656, - 0.0373527, 0.210685, 0.0149146, 0.0463846, - 0.0430132, 0.224182, 0.0187254, 0.0525696, - 0.0491013, 0.23634, 0.0232283, 0.0598083, - 0.0559175, 0.250013, 0.0286521, 0.0679437, - 0.0633657, 0.263981, 0.0350634, 0.0771181, - 0.0714602, 0.278072, 0.0425882, 0.0881273, - 0.0803502, 0.29511, 0.0514487, 0.0996628, - 0.0896903, 0.309976, 0.0615766, 0.112702, - 0.099644, 0.325611, 0.0732139, 0.126488, - 0.109829, 0.339321, 0.0862324, 0.142625, - 0.120859, 0.35574, 0.101275, 0.15953, - 0.131956, 0.369845, 0.117892, 0.176991, - 0.143145, 0.38146, 0.136205, 0.199715, - 0.155292, 0.40052, 0.157252, 0.220787, - 0.167066, 0.412055, 0.179966, 0.243697, - 0.178396, 0.423133, 0.204418, 0.272106, - 0.190433, 0.439524, 0.232141, 0.297637, - 0.201265, 0.447041, 0.261109, 0.325273, - 0.211834, 0.454488, 0.292627, 0.357219, - 0.221889, 0.465004, 0.326669, 0.387362, - 0.230729, 0.468527, 0.362426, 0.423131, - 0.23924, 0.475836, 0.401533, 0.45543, - 0.246067, 0.475017, 0.441902, 0.493393, - 0.251557, 0.478017, 0.484239, 0.526253, - 0.255571, 0.4709, 0.528586, 0.560554, - 0.257752, 0.463167, 0.574346, 0.599306, - 0.258076, 0.456452, 0.621655, 0.634541, - 0.256471, 0.443725, 0.670492, 0.668907, - 0.253283, 0.428719, 0.721943, 0.705619, - 0.247562, 0.411348, 0.772477, 0.739034, - 0.240626, 0.388939, 0.8264, 0.771408, - 0.231493, 0.36425, 0.881702, 0.803312, - 0.220125, 0.337321, 0.9385, 0.828457, - 0.206645, 0.305364, 0.997437, 0.854819, - 0.190664, 0.273715, 1.05693, 0.878666, - 0.171429, 0.242218, 1.11251, 0.898404, - 0.149235, 0.209556, 1.16398, 0.917416, - 0.12435, 0.176863, 1.21014, 0.933133, - 0.0972703, 0.142775, 1.25178, 0.95066, - 0.0683607, 0.106735, 1.29028, 0.968589, - 0.0378724, 0.0681609, 1.32703, 0.984776, - 0.00605712, 0.0273966, 1.36158, 0.99994, 0.0263276, - 0.0138124, 1.3943, 0.00867437, - 1.86005e-06, 0.0928979, 1.73682e-07, 0.00864003, - 4.66389e-05, 0.0925237, 4.35505e-06, 0.00864593, - 0.000186594, 0.0925806, 1.74322e-05, 0.00864095, - 0.000419639, 0.0924903, 3.92862e-05, 0.00863851, - 0.000746272, 0.0924589, 7.02598e-05, 0.00868531, - 0.00116456, 0.0929, 0.000111188, 0.00869667, - 0.00167711, 0.0928529, 0.000163867, 0.00874332, - 0.00228051, 0.0930914, 0.00023104, 0.00882709, - 0.00297864, 0.0935679, 0.00031741, 0.00898874, - 0.00377557, 0.0946165, 0.000430186, 0.00929346, - 0.00469247, 0.0967406, 0.000580383, 0.00978271, - 0.00575491, 0.100084, 0.000783529, 0.0105746, - 0.00701514, 0.105447, 0.00106304, 0.0116949, - 0.00851797, 0.112494, 0.00144685, 0.0130419, - 0.0102757, 0.119876, 0.00196439, 0.0148375, - 0.012381, 0.129034, 0.00266433, 0.0168725, - 0.01482, 0.137812, 0.00358364, 0.0193689, - 0.0176563, 0.147696, 0.00478132, 0.0222691, - 0.0209211, 0.157795, 0.00631721, 0.0256891, - 0.0246655, 0.168431, 0.00826346, 0.0294686, - 0.0288597, 0.178587, 0.0106714, 0.0340412, - 0.0336441, 0.190251, 0.0136629, 0.0393918, - 0.039033, 0.202999, 0.0173272, 0.0453947, - 0.0450087, 0.215655, 0.0217448, 0.0521936, - 0.0515461, 0.228686, 0.0269941, 0.0600279, - 0.058817, 0.242838, 0.033272, 0.0692398, - 0.0667228, 0.258145, 0.0406457, 0.0793832, - 0.0752401, 0.273565, 0.0492239, 0.0902297, - 0.0841851, 0.287735, 0.0590105, 0.102014, - 0.0936479, 0.301161, 0.0702021, 0.116054, - 0.103967, 0.317438, 0.0832001, 0.13191, - 0.114622, 0.334166, 0.0977951, 0.148239, - 0.125452, 0.348192, 0.113985, 0.165809, - 0.136453, 0.361094, 0.131928, 0.184616, - 0.147648, 0.373534, 0.151811, 0.207491, - 0.159607, 0.39101, 0.174476, 0.230106, - 0.171119, 0.402504, 0.198798, 0.257036, - 0.182906, 0.418032, 0.225796, 0.281172, - 0.193605, 0.425468, 0.254027, 0.312034, - 0.204771, 0.440379, 0.285713, 0.340402, - 0.214988, 0.445406, 0.319196, 0.370231, - 0.224711, 0.44968, 0.35537, 0.407105, - 0.233516, 0.460747, 0.393838, 0.439037, - 0.240801, 0.460624, 0.433747, 0.47781, - 0.24762, 0.465957, 0.477234, 0.510655, - 0.251823, 0.460054, 0.52044, 0.550584, - 0.255552, 0.459172, 0.567853, 0.585872, - 0.257036, 0.450311, 0.615943, 0.620466, - 0.257535, 0.437763, 0.667693, 0.660496, - 0.255248, 0.426639, 0.718988, 0.695578, - 0.251141, 0.409185, 0.772503, 0.732176, - 0.244718, 0.39015, 0.827023, 0.760782, - 0.236782, 0.362594, 0.885651, 0.79422, - 0.225923, 0.33711, 0.943756, 0.824521, - 0.213855, 0.308272, 1.00874, 0.854964, - 0.197723, 0.278529, 1.06764, 0.878065, - 0.179209, 0.246208, 1.12836, 0.899834, - 0.157569, 0.21329, 1.18318, 0.918815, - 0.133206, 0.181038, 1.23161, 0.934934, - 0.106545, 0.146993, 1.27644, 0.952115, - 0.0780574, 0.111175, 1.31842, 0.96906, - 0.0478279, 0.0728553, 1.35839, 0.985178, - 0.0160014, 0.032579, 1.39697, 1.00039, 0.0173126, - 0.0095256, 1.43312, 0.00384146, - 1.24311e-06, 0.0613583, 7.78271e-08, 0.00390023, - 3.14043e-05, 0.0622919, 1.96626e-06, 0.00389971, - 0.000125622, 0.0622632, 7.87379e-06, 0.00389491, - 0.000282352, 0.0620659, 1.778e-05, 0.00391618, - 0.000502512, 0.0624687, 3.20918e-05, 0.00392662, - 0.000784458, 0.0625113, 5.15573e-05, 0.00396053, - 0.00112907, 0.0628175, 7.78668e-05, 0.00401911, - 0.00153821, 0.0633286, 0.000113811, 0.00414994, - 0.0020208, 0.0646443, 0.00016445, 0.00441223, - 0.00260007, 0.0673886, 0.000237734, 0.00484427, - 0.0033097, 0.0716528, 0.000345929, 0.00549109, - 0.00418966, 0.0774998, 0.000505987, 0.00636293, - 0.00527331, 0.0844758, 0.000739208, 0.00746566, - 0.00660428, 0.0921325, 0.00107347, 0.00876625, - 0.00818826, 0.0997067, 0.00153691, 0.0103125, - 0.0100811, 0.107433, 0.00217153, 0.0123309, - 0.0123643, 0.117088, 0.00303427, 0.0146274, - 0.0150007, 0.126438, 0.00416018, 0.0172295, - 0.0180531, 0.135672, 0.00561513, 0.0204248, - 0.0215962, 0.146244, 0.007478, 0.0241597, - 0.0256234, 0.157481, 0.00981046, 0.0284693, - 0.0302209, 0.169125, 0.0127148, 0.033445, - 0.0353333, 0.181659, 0.0162453, 0.0391251, - 0.0410845, 0.1944, 0.0205417, 0.0454721, - 0.0473451, 0.207082, 0.0256333, 0.0530983, - 0.0542858, 0.221656, 0.0317036, 0.0615356, - 0.0618384, 0.236036, 0.0388319, 0.0703363, - 0.0697631, 0.248398, 0.046974, 0.0810391, - 0.0784757, 0.263611, 0.0565246, 0.0920144, - 0.0873488, 0.275857, 0.0671724, 0.105584, - 0.0973652, 0.292555, 0.0798105, 0.119506, - 0.107271, 0.306333, 0.0935945, 0.134434, - 0.117608, 0.318888, 0.109106, 0.153399, - 0.128938, 0.337552, 0.127074, 0.171258, - 0.139944, 0.349955, 0.14643, 0.191059, - 0.151288, 0.361545, 0.168, 0.215069, - 0.163018, 0.378421, 0.192082, 0.237838, - 0.174226, 0.38879, 0.217838, 0.266965, - 0.186063, 0.405857, 0.246931, 0.292827, - 0.196909, 0.414146, 0.277505, 0.324352, - 0.207473, 0.426955, 0.310711, 0.354427, - 0.217713, 0.433429, 0.346794, 0.389854, - 0.227183, 0.443966, 0.385237, 0.420749, - 0.235131, 0.44471, 0.424955, 0.459597, - 0.242786, 0.451729, 0.468446, 0.495316, - 0.248767, 0.45072, 0.513422, 0.534903, - 0.253351, 0.450924, 0.560618, 0.572369, - 0.256277, 0.445266, 0.609677, 0.612383, - 0.2576, 0.438798, 0.660995, 0.644037, - 0.256931, 0.421693, 0.713807, 0.686749, - 0.254036, 0.4109, 0.767616, 0.719814, - 0.249785, 0.390151, 0.82533, 0.754719, - 0.244283, 0.367847, 0.888311, 0.792022, - 0.235076, 0.345013, 0.948177, 0.822404, - 0.225061, 0.316193, 1.01661, 0.853084, - 0.211113, 0.287013, 1.08075, 0.879871, - 0.19449, 0.255424, 1.14501, 0.901655, - 0.174023, 0.222879, 1.20203, 0.919957, - 0.1509, 0.18989, 1.25698, 0.938412, - 0.124923, 0.15606, 1.30588, 0.953471, - 0.0968139, 0.120512, 1.3529, 0.970451, - 0.066734, 0.0828515, 1.3986, 0.985522, - 0.034734, 0.0424458, 1.44148, 1.00099, - 0.00102222, 0.000678929, 1.48398, 0.000965494, - 6.27338e-07, 0.0306409, 1.97672e-08, 0.00099168, - 1.58573e-05, 0.0314638, 4.99803e-07, 0.000991068, - 6.34012e-05, 0.031363, 2.00682e-06, 0.000974567, - 0.00014144, 0.03036, 4.57312e-06, 0.000998079, - 0.000252812, 0.031496, 8.60131e-06, 0.00102243, - 0.000396506, 0.0319955, 1.48288e-05, 0.00107877, - 0.000577593, 0.0331376, 2.49141e-05, 0.00121622, - 0.000816816, 0.0359396, 4.23011e-05, 0.0014455, - 0.00113761, 0.0399652, 7.24613e-05, 0.00178791, - 0.00156959, 0.0450556, 0.000123929, 0.00225668, - 0.00214064, 0.0508025, 0.000208531, 0.00285627, - 0.00287655, 0.0568443, 0.000341969, 0.0035991, - 0.00380271, 0.0630892, 0.000544158, 0.00455524, - 0.00496264, 0.0702204, 0.000842423, 0.00569143, - 0.0063793, 0.0773426, 0.00126704, 0.00716928, - 0.00813531, 0.0860839, 0.00186642, 0.00885307, - 0.0101946, 0.0944079, 0.00267014, 0.0109316, - 0.0126386, 0.103951, 0.00374033, 0.0133704, - 0.0154876, 0.113786, 0.0051304, 0.0161525, - 0.0187317, 0.123477, 0.00688858, 0.0194267, - 0.0224652, 0.133986, 0.00910557, 0.0230967, - 0.0265976, 0.143979, 0.0118074, 0.0273627, - 0.0312848, 0.154645, 0.0151266, 0.0323898, - 0.0365949, 0.166765, 0.0191791, 0.0379225, - 0.0422914, 0.177932, 0.0239236, 0.0447501, - 0.0487469, 0.19167, 0.0296568, 0.0519391, - 0.0556398, 0.203224, 0.0362924, 0.0599464, - 0.0631646, 0.215652, 0.0440585, 0.0702427, - 0.0714308, 0.232089, 0.0531619, 0.0806902, - 0.0800605, 0.245258, 0.0634564, 0.0923194, - 0.0892815, 0.258609, 0.0752481, 0.106938, - 0.09931, 0.276654, 0.0888914, 0.121238, - 0.109575, 0.289847, 0.104055, 0.138817, - 0.120461, 0.307566, 0.121266, 0.15595, - 0.131209, 0.320117, 0.139944, 0.178418, - 0.143049, 0.339677, 0.161591, 0.197875, - 0.154074, 0.349886, 0.184303, 0.224368, - 0.166307, 0.369352, 0.210669, 0.252213, - 0.178051, 0.386242, 0.238895, 0.277321, - 0.189335, 0.395294, 0.269182, 0.310332, - 0.200683, 0.412148, 0.302508, 0.338809, - 0.210856, 0.418266, 0.337264, 0.372678, - 0.220655, 0.428723, 0.374881, 0.405632, - 0.230053, 0.433887, 0.415656, 0.442293, - 0.237993, 0.439911, 0.457982, 0.477256, - 0.244897, 0.440175, 0.502831, 0.515592, - 0.250657, 0.441079, 0.550277, 0.550969, - 0.255459, 0.435219, 0.601102, 0.592883, - 0.257696, 0.432882, 0.651785, 0.629092, - 0.259894, 0.421054, 0.708961, 0.672033, - 0.258592, 0.41177, 0.763806, 0.709147, - 0.256525, 0.395267, 0.824249, 0.745367, - 0.254677, 0.375013, 0.8951, 0.784715, - 0.247892, 0.353906, 0.959317, 0.818107, - 0.240162, 0.327801, 1.03153, 0.847895, - 0.229741, 0.298821, 1.10601, 0.879603, - 0.213084, 0.269115, 1.164, 0.902605, - 0.195242, 0.236606, 1.22854, 0.922788, - 0.174505, 0.203442, 1.29017, 0.944831, - 0.150169, 0.169594, 1.34157, 0.959656, - 0.124099, 0.135909, 1.3956, 0.972399, - 0.0960626, 0.0990563, 1.45128, 0.986549, - 0.0657097, 0.0602348, 1.50312, 1.00013, - 0.0333558, 0.0186694, 1.55364, 6.19747e-06, - 1e-07, 0.00778326, 7.96756e-11, 2.37499e-08, - 9.99999e-08, 2.82592e-05, 1.14596e-10, 1.00292e-06, - 1.66369e-06, 0.000250354, 6.77492e-09, 3.50752e-06, - 6.37769e-06, 0.000357289, 6.31655e-08, 8.26445e-06, - 1.74689e-05, 0.000516179, 3.1851e-07, 2.42481e-05, - 4.50868e-05, 0.0010223, 1.30577e-06, 4.55631e-05, - 8.9044e-05, 0.00144302, 3.74587e-06, 9.71222e-05, - 0.000178311, 0.00241912, 1.02584e-05, 0.000171403, - 0.000313976, 0.00354938, 2.36481e-05, 0.000292747, - 0.000520026, 0.00513765, 4.96014e-05, 0.000789827, - 0.00118187, 0.0238621, 0.000139056, 0.00114093, - 0.00171827, 0.0286691, 0.000244093, 0.00176119, - 0.00249667, 0.0368565, 0.000420623, 0.0022233, - 0.00333742, 0.0400469, 0.00065673, 0.00343382, - 0.00481976, 0.0535751, 0.00109323, 0.00427602, - 0.00600755, 0.057099, 0.00155268, 0.00461435, - 0.00737637, 0.0551084, 0.00215031, 0.00695698, - 0.00971401, 0.0715767, 0.00316529, 0.00867619, - 0.0120943, 0.0793314, 0.00436995, 0.0106694, - 0.0148202, 0.0869391, 0.0058959, 0.0140351, - 0.0183501, 0.101572, 0.00798757, 0.0168939, - 0.022006, 0.11018, 0.0104233, 0.020197, - 0.0261568, 0.119041, 0.0134167, 0.0254702, - 0.0312778, 0.135404, 0.0173009, 0.0298384, - 0.0362469, 0.1437, 0.0215428, 0.035159, - 0.042237, 0.15512, 0.0268882, 0.0427685, - 0.0488711, 0.17128, 0.033235, 0.0494848, - 0.0557997, 0.181813, 0.0404443, 0.0592394, - 0.0635578, 0.198745, 0.0490043, 0.0681463, - 0.071838, 0.210497, 0.0588239, 0.0804753, - 0.0809297, 0.228864, 0.0702835, 0.0942205, - 0.0906488, 0.247008, 0.0834012, 0.106777, - 0.100216, 0.258812, 0.0975952, 0.124471, - 0.110827, 0.278617, 0.114162, 0.138389, - 0.121193, 0.287049, 0.131983, 0.159543, - 0.13253, 0.307151, 0.152541, 0.176432, - 0.143611, 0.31564, 0.174673, 0.201723, - 0.15548, 0.33538, 0.199842, 0.229721, - 0.167166, 0.355256, 0.227097, 0.250206, - 0.178238, 0.360047, 0.256014, 0.282118, - 0.189905, 0.378761, 0.28855, 0.312821, - 0.201033, 0.39181, 0.323348, 0.341482, - 0.211584, 0.397716, 0.360564, 0.377368, - 0.221314, 0.410141, 0.400004, 0.418229, - 0.230474, 0.423485, 0.442371, 0.444881, - 0.239443, 0.418874, 0.488796, 0.488899, - 0.245987, 0.427545, 0.535012, 0.520317, - 0.253948, 0.422147, 0.589678, 0.568566, - 0.256616, 0.42719, 0.637683, 0.599607, - 0.26376, 0.415114, 0.703363, 0.64222, - 0.268687, 0.408715, 0.771363, 0.685698, - 0.2694, 0.399722, 0.83574, 0.732327, - 0.266642, 0.388651, 0.897764, 0.769873, - 0.267712, 0.369198, 0.983312, 0.806733, - 0.263479, 0.346802, 1.06222, 0.843466, - 0.254575, 0.321368, 1.13477, 0.873008, - 0.242749, 0.29211, 1.20712, 0.908438, - 0.22725, 0.262143, 1.27465, 0.936321, - 0.207621, 0.228876, 1.33203, 0.950353, - 0.187932, 0.19484, 1.40439, 0.96442, - 0.165154, 0.163178, 1.4732, 0.979856, - 0.139302, 0.127531, 1.53574, 0.982561, - 0.11134, 0.0903457, 1.59982, 0.996389, - 0.0808124, 0.0489007, 1.6577]

			const LTC_MAT_2 = [1, 0, 0, 0, 1, 7.91421e-31, 0, 0, 1, 1.04392e-24, 0, 0, 1, 3.49405e-21, 0, 0, 1, 1.09923e-18, 0, 0, 1, 9.47414e-17, 0, 0, 1, 3.59627e-15, 0, 0, 1, 7.72053e-14, 0, 0, 1, 1.08799e-12, 0, 0, 1, 1.10655e-11, 0, 0, 1, 8.65818e-11, 0, 0, 0.999998, 5.45037e-10, 0, 0, 0.999994, 2.85095e-09, 0, 0, 0.999989, 1.26931e-08, 0, 0, 0.999973, 4.89938e-08, 0, 0, 0.999947, 1.66347e-07, 0, 0, 0.999894, 5.02694e-07, 0, 0, 0.999798, 1.36532e-06, 0, 0, 0.999617, 3.35898e-06, 0, 0, 0.999234, 7.52126e-06, 0, 0, 0.998258, 1.52586e-05, 0, 0, 0.99504, 2.66207e-05, 0, 0, 0.980816, 2.36802e-05, 0, 0, 0.967553, 2.07684e-06, 0, 0, 0.966877, 4.03733e-06, 0, 0, 0.965752, 7.41174e-06, 0, 0, 0.96382, 1.27746e-05, 0, 0, 0.960306, 2.02792e-05, 0, 0, 0.953619, 2.80232e-05, 0, 0, 0.941103, 2.78816e-05, 0, 0, 0.926619, 1.60221e-05, 0, 0, 0.920983, 2.35164e-05, 0, 0, 0.912293, 3.11924e-05, 0, 0.0158731, 0.899277, 3.48118e-05, 0, 0.0476191, 0.880884, 2.6041e-05, 0, 0.0793651, 0.870399, 3.38726e-05, 0, 0.111111, 0.856138, 3.92906e-05, 0, 0.142857, 0.837436, 3.72874e-05, 0, 0.174603, 0.820973, 3.92558e-05, 0, 0.206349, 0.803583, 4.34658e-05, 0, 0.238095, 0.782168, 4.0256e-05, 0, 0.269841, 0.764107, 4.48159e-05, 0, 0.301587, 0.743092, 4.57627e-05, 0, 0.333333, 0.721626, 4.55314e-05, 0, 0.365079, 0.700375, 4.77335e-05, 0, 0.396825, 0.677334, 4.61072e-05, 0, 0.428571, 0.655702, 4.84393e-05, 0, 0.460317, 0.632059, 4.64583e-05, 0, 0.492064, 0.610125, 4.83923e-05, 0, 0.52381, 0.58653, 4.64342e-05, 0, 0.555556, 0.564508, 4.77033e-05, 0, 0.587302, 0.541405, 4.59263e-05, 0, 0.619048, 0.519556, 4.6412e-05, 0, 0.650794, 0.497292, 4.48913e-05, 0, 0.68254, 0.475898, 4.45789e-05, 0, 0.714286, 0.454722, 4.33496e-05, 0, 0.746032, 0.434042, 4.23054e-05, 0, 0.777778, 0.414126, 4.13737e-05, 0, 0.809524, 0.394387, 3.97265e-05, 0, 0.84127, 0.375841, 3.90709e-05, 0, 0.873016, 0.357219, 3.69938e-05, 0, 0.904762, 0.340084, 3.65618e-05, 0, 0.936508, 0.322714, 3.42533e-05, 0, 0.968254, 0.306974, 3.39596e-05, 0, 1, 1, 1.01524e-18, 0, 0, 1, 1.0292e-18, 0, 0, 1, 1.30908e-18, 0, 0, 1, 4.73331e-18, 0, 0, 1, 6.25319e-17, 0, 0, 1, 1.07932e-15, 0, 0, 1, 1.63779e-14, 0, 0, 1, 2.03198e-13, 0, 0, 1, 2.04717e-12, 0, 0, 0.999999, 1.68995e-11, 0, 0, 0.999998, 1.15855e-10, 0, 0, 0.999996, 6.6947e-10, 0, 0, 0.999991, 3.30863e-09, 0, 0, 0.999983, 1.41737e-08, 0, 0, 0.999968, 5.32626e-08, 0, 0, 0.99994, 1.77431e-07, 0, 0, 0.999891, 5.28835e-07, 0, 0, 0.999797, 1.42169e-06, 0, 0, 0.999617, 3.47057e-06, 0, 0, 0.999227, 7.7231e-06, 0, 0, 0.998239, 1.55753e-05, 0, 0, 0.994937, 2.68495e-05, 0, 0, 0.980225, 2.13742e-05, 0, 0, 0.967549, 2.1631e-06, 0, 0, 0.966865, 4.17989e-06, 0, 0, 0.965739, 7.63341e-06, 0, 0, 0.963794, 1.30892e-05, 0, 0, 0.960244, 2.06456e-05, 0, 0, 0.953495, 2.82016e-05, 0, 0.000148105, 0.940876, 2.71581e-05, 0, 0.002454, 0.926569, 1.64159e-05, 0, 0.00867491, 0.920905, 2.39521e-05, 0, 0.01956, 0.912169, 3.15127e-05, 0, 0.035433, 0.899095, 3.46626e-05, 0, 0.056294, 0.882209, 2.90223e-05, 0, 0.0818191, 0.870272, 3.42992e-05, 0, 0.111259, 0.855977, 3.94164e-05, 0, 0.142857, 0.837431, 3.72343e-05, 0, 0.174603, 0.820826, 3.96691e-05, 0, 0.206349, 0.803408, 4.35395e-05, 0, 0.238095, 0.782838, 4.19579e-05, 0, 0.269841, 0.763941, 4.50953e-05, 0, 0.301587, 0.742904, 4.55847e-05, 0, 0.333333, 0.721463, 4.58833e-05, 0, 0.365079, 0.700197, 4.77159e-05, 0, 0.396825, 0.677501, 4.70641e-05, 0, 0.428571, 0.655527, 4.84732e-05, 0, 0.460317, 0.6324, 4.76834e-05, 0, 0.492064, 0.609964, 4.84213e-05, 0, 0.52381, 0.586839, 4.75541e-05, 0, 0.555556, 0.564353, 4.76951e-05, 0, 0.587302, 0.541589, 4.67611e-05, 0, 0.619048, 0.519413, 4.63493e-05, 0, 0.650794, 0.497337, 4.53994e-05, 0, 0.68254, 0.475797, 4.45308e-05, 0, 0.714286, 0.454659, 4.35787e-05, 0, 0.746032, 0.434065, 4.24839e-05, 0, 0.777778, 0.414018, 4.1436e-05, 0, 0.809524, 0.39455, 4.01902e-05, 0, 0.84127, 0.375742, 3.90813e-05, 0, 0.873016, 0.357501, 3.77116e-05, 0, 0.904762, 0.339996, 3.6535e-05, 0, 0.936508, 0.323069, 3.51265e-05, 0, 0.968254, 0.306897, 3.39112e-05, 0, 1, 1, 1.0396e-15, 0, 0, 1, 1.04326e-15, 0, 0, 1, 1.10153e-15, 0, 0, 1, 1.44668e-15, 0, 0, 1, 3.4528e-15, 0, 0, 1, 1.75958e-14, 0, 0, 1, 1.2627e-13, 0, 0, 1, 9.36074e-13, 0, 0, 1, 6.45742e-12, 0, 0, 0.999998, 4.01228e-11, 0, 0, 0.999997, 2.22338e-10, 0, 0, 0.999995, 1.0967e-09, 0, 0, 0.999991, 4.82132e-09, 0, 0, 0.999981, 1.89434e-08, 0, 0, 0.999967, 6.67716e-08, 0, 0, 0.999938, 2.12066e-07, 0, 0, 0.999886, 6.0977e-07, 0, 0, 0.999792, 1.59504e-06, 0, 0, 0.999608, 3.81191e-06, 0, 0, 0.999209, 8.33727e-06, 0, 0, 0.998179, 1.65288e-05, 0, 0, 0.994605, 2.74387e-05, 0, 0, 0.979468, 1.67316e-05, 0, 0, 0.967529, 2.42877e-06, 0, 0, 0.966836, 4.61696e-06, 0, 0, 0.96569, 8.30977e-06, 0, 0, 0.963706, 1.40427e-05, 0, 2.44659e-06, 0.960063, 2.17353e-05, 0, 0.000760774, 0.953113, 2.86606e-05, 0, 0.00367261, 0.940192, 2.47691e-05, 0, 0.00940263, 0.927731, 1.95814e-05, 0, 0.018333, 0.920669, 2.52531e-05, 0, 0.0306825, 0.911799, 3.24277e-05, 0, 0.0465556, 0.89857, 3.40982e-05, 0, 0.0659521, 0.883283, 3.19622e-05, 0, 0.0887677, 0.86989, 3.5548e-05, 0, 0.114784, 0.855483, 3.97143e-05, 0, 0.143618, 0.837987, 3.91665e-05, 0, 0.174606, 0.820546, 4.11306e-05, 0, 0.206349, 0.802878, 4.36753e-05, 0, 0.238095, 0.783402, 4.44e-05, 0, 0.269841, 0.763439, 4.58726e-05, 0, 0.301587, 0.742925, 4.67097e-05, 0, 0.333333, 0.721633, 4.78887e-05, 0, 0.365079, 0.69985, 4.81251e-05, 0, 0.396825, 0.67783, 4.91811e-05, 0, 0.428571, 0.655126, 4.88199e-05, 0, 0.460318, 0.632697, 4.96025e-05, 0, 0.492064, 0.609613, 4.8829e-05, 0, 0.52381, 0.587098, 4.92754e-05, 0, 0.555556, 0.564119, 4.82625e-05, 0, 0.587302, 0.541813, 4.82807e-05, 0, 0.619048, 0.519342, 4.71552e-05, 0, 0.650794, 0.497514, 4.66765e-05, 0, 0.68254, 0.475879, 4.55582e-05, 0, 0.714286, 0.454789, 4.46007e-05, 0, 0.746032, 0.434217, 4.35382e-05, 0, 0.777778, 0.414086, 4.21753e-05, 0, 0.809524, 0.394744, 4.12093e-05, 0, 0.84127, 0.375782, 3.96634e-05, 0, 0.873016, 0.357707, 3.86419e-05, 0, 0.904762, 0.340038, 3.70345e-05, 0, 0.936508, 0.323284, 3.59725e-05, 0, 0.968254, 0.306954, 3.436e-05, 0, 1, 1, 5.99567e-14, 0, 0, 1, 6.00497e-14, 0, 0, 1, 6.14839e-14, 0, 0, 1, 6.86641e-14, 0, 0, 1, 9.72658e-14, 0, 0, 1, 2.21271e-13, 0, 0, 1, 8.33195e-13, 0, 0, 1, 4.03601e-12, 0, 0, 0.999999, 2.06001e-11, 0, 0, 0.999998, 1.01739e-10, 0, 0, 0.999997, 4.70132e-10, 0, 0, 0.999993, 2.00436e-09, 0, 0, 0.999988, 7.83682e-09, 0, 0, 0.999979, 2.80338e-08, 0, 0, 0.999962, 9.17033e-08, 0, 0, 0.999933, 2.74514e-07, 0, 0, 0.999881, 7.53201e-07, 0, 0, 0.999783, 1.89826e-06, 0, 0, 0.999594, 4.40279e-06, 0, 0, 0.999178, 9.3898e-06, 0, 0, 0.998073, 1.81265e-05, 0, 0, 0.993993, 2.80487e-05, 0, 0, 0.979982, 1.49422e-05, 0, 0, 0.968145, 3.78481e-06, 0, 0, 0.966786, 5.3771e-06, 0, 0, 0.965611, 9.47508e-06, 0, 3.88934e-05, 0.963557, 1.56616e-05, 0, 0.0009693, 0.959752, 2.35144e-05, 0, 0.00370329, 0.952461, 2.91568e-05, 0, 0.00868428, 0.940193, 2.40102e-05, 0, 0.0161889, 0.929042, 2.31235e-05, 0, 0.0263948, 0.920266, 2.73968e-05, 0, 0.0394088, 0.911178, 3.37915e-05, 0, 0.0552818, 0.897873, 3.33629e-05, 0, 0.0740138, 0.884053, 3.51405e-05, 0, 0.0955539, 0.869455, 3.78034e-05, 0, 0.119795, 0.854655, 3.99378e-05, 0, 0.14656, 0.838347, 4.19108e-05, 0, 0.175573, 0.820693, 4.40831e-05, 0, 0.206388, 0.802277, 4.45599e-05, 0, 0.238095, 0.783634, 4.72691e-05, 0, 0.269841, 0.763159, 4.76984e-05, 0, 0.301587, 0.742914, 4.91487e-05, 0, 0.333333, 0.721662, 5.02312e-05, 0, 0.365079, 0.699668, 5.02817e-05, 0, 0.396825, 0.677839, 5.1406e-05, 0, 0.428571, 0.655091, 5.11095e-05, 0, 0.460317, 0.632665, 5.16067e-05, 0, 0.492064, 0.609734, 5.12255e-05, 0, 0.52381, 0.587043, 5.10263e-05, 0, 0.555556, 0.564298, 5.0565e-05, 0, 0.587302, 0.541769, 4.97951e-05, 0, 0.619048, 0.519529, 4.92698e-05, 0, 0.650794, 0.497574, 4.82066e-05, 0, 0.68254, 0.476028, 4.73689e-05, 0, 0.714286, 0.454961, 4.61941e-05, 0, 0.746032, 0.434341, 4.50618e-05, 0, 0.777778, 0.414364, 4.38355e-05, 0, 0.809524, 0.394832, 4.24196e-05, 0, 0.84127, 0.376109, 4.12563e-05, 0, 0.873016, 0.35779, 3.96226e-05, 0, 0.904762, 0.340379, 3.84886e-05, 0, 0.936508, 0.323385, 3.68214e-05, 0, 0.968254, 0.307295, 3.56636e-05, 0, 1, 1, 1.06465e-12, 0, 0, 1, 1.06555e-12, 0, 0, 1, 1.07966e-12, 0, 0, 1, 1.14601e-12, 0, 0, 1, 1.37123e-12, 0, 0, 1, 2.1243e-12, 0, 0, 0.999999, 4.89653e-12, 0, 0, 0.999999, 1.60283e-11, 0, 0, 0.999998, 6.2269e-11, 0, 0, 0.999997, 2.51859e-10, 0, 0, 0.999996, 9.96192e-10, 0, 0, 0.999992, 3.74531e-09, 0, 0, 0.999986, 1.32022e-08, 0, 0, 0.999975, 4.33315e-08, 0, 0, 0.999959, 1.31956e-07, 0, 0, 0.999927, 3.72249e-07, 0, 0, 0.999871, 9.72461e-07, 0, 0, 0.999771, 2.35343e-06, 0, 0, 0.999572, 5.2768e-06, 0, 0, 0.999133, 1.09237e-05, 0, 0, 0.997912, 2.03675e-05, 0, 0, 0.993008, 2.79396e-05, 0, 0, 0.980645, 1.39604e-05, 0, 0, 0.970057, 6.46596e-06, 0, 0, 0.966717, 6.5089e-06, 0, 4.74145e-05, 0.965497, 1.11863e-05, 0, 0.00089544, 0.96334, 1.79857e-05, 0, 0.0032647, 0.959294, 2.59045e-05, 0, 0.0075144, 0.951519, 2.92327e-05, 0, 0.0138734, 0.940517, 2.49769e-05, 0, 0.0224952, 0.93014, 2.6803e-05, 0, 0.0334828, 0.91972, 3.03656e-05, 0, 0.0468973, 0.910294, 3.53323e-05, 0, 0.0627703, 0.897701, 3.51002e-05, 0, 0.0811019, 0.884522, 3.88104e-05, 0, 0.10186, 0.869489, 4.12932e-05, 0, 0.124985, 0.853983, 4.15781e-05, 0, 0.150372, 0.838425, 4.54066e-05, 0, 0.177868, 0.820656, 4.71624e-05, 0, 0.207245, 0.801875, 4.75243e-05, 0, 0.238143, 0.783521, 5.05621e-05, 0, 0.269841, 0.763131, 5.0721e-05, 0, 0.301587, 0.74261, 5.23293e-05, 0, 0.333333, 0.72148, 5.28699e-05, 0, 0.365079, 0.699696, 5.38677e-05, 0, 0.396825, 0.677592, 5.39255e-05, 0, 0.428571, 0.65525, 5.46367e-05, 0, 0.460317, 0.632452, 5.41348e-05, 0, 0.492064, 0.609903, 5.44976e-05, 0, 0.52381, 0.586928, 5.36201e-05, 0, 0.555556, 0.564464, 5.35185e-05, 0, 0.587302, 0.541801, 5.24949e-05, 0, 0.619048, 0.519681, 5.1812e-05, 0, 0.650794, 0.497685, 5.07687e-05, 0, 0.68254, 0.47622, 4.96243e-05, 0, 0.714286, 0.455135, 4.85714e-05, 0, 0.746032, 0.4346, 4.71847e-05, 0, 0.777778, 0.414564, 4.59294e-05, 0, 0.809524, 0.395165, 4.44705e-05, 0, 0.84127, 0.376333, 4.30772e-05, 0, 0.873016, 0.358197, 4.16229e-05, 0, 0.904762, 0.34064, 4.01019e-05, 0, 0.936508, 0.323816, 3.86623e-05, 0, 0.968254, 0.307581, 3.70933e-05, 0, 1, 1, 9.91541e-12, 0, 0, 1, 9.92077e-12, 0, 0, 1, 1.00041e-11, 0, 0, 1, 1.0385e-11, 0, 0, 1, 1.15777e-11, 0, 0, 1, 1.50215e-11, 0, 0, 0.999999, 2.54738e-11, 0, 0, 0.999999, 5.98822e-11, 0, 0, 0.999998, 1.79597e-10, 0, 0, 0.999997, 6.02367e-10, 0, 0, 0.999994, 2.06835e-09, 0, 0, 0.99999, 6.94952e-09, 0, 0, 0.999984, 2.23363e-08, 0, 0, 0.999972, 6.78578e-08, 0, 0, 0.999952, 1.93571e-07, 0, 0, 0.999919, 5.16594e-07, 0, 0, 0.99986, 1.28739e-06, 0, 0, 0.999753, 2.99298e-06, 0, 0, 0.999546, 6.48258e-06, 0, 0, 0.999074, 1.29985e-05, 0, 0, 0.997671, 2.32176e-05, 0, 0, 0.991504, 2.56701e-05, 0, 0, 0.981148, 1.31141e-05, 0, 0, 0.971965, 8.69048e-06, 0, 2.80182e-05, 0.966624, 8.08301e-06, 0, 0.000695475, 0.965344, 1.35235e-05, 0, 0.00265522, 0.963048, 2.10592e-05, 0, 0.00622975, 0.958673, 2.87473e-05, 0, 0.0116234, 0.950262, 2.81379e-05, 0, 0.018976, 0.940836, 2.71089e-05, 0, 0.0283844, 0.930996, 3.0926e-05, 0, 0.0399151, 0.919848, 3.48359e-05, 0, 0.0536063, 0.909136, 3.66092e-05, 0, 0.0694793, 0.897554, 3.84162e-05, 0, 0.0875342, 0.884691, 4.30971e-05, 0, 0.107749, 0.869414, 4.47803e-05, 0, 0.130087, 0.853462, 4.52858e-05, 0, 0.154481, 0.838187, 4.95769e-05, 0, 0.180833, 0.820381, 5.02709e-05, 0, 0.209005, 0.801844, 5.22713e-05, 0, 0.238791, 0.783061, 5.41505e-05, 0, 0.269869, 0.763205, 5.53712e-05, 0, 0.301587, 0.742362, 5.64909e-05, 0, 0.333333, 0.721393, 5.72646e-05, 0, 0.365079, 0.699676, 5.81012e-05, 0, 0.396825, 0.677395, 5.8096e-05, 0, 0.428571, 0.655208, 5.85766e-05, 0, 0.460317, 0.632451, 5.83602e-05, 0, 0.492064, 0.609839, 5.80234e-05, 0, 0.52381, 0.587093, 5.77161e-05, 0, 0.555556, 0.564467, 5.68447e-05, 0, 0.587302, 0.542043, 5.63166e-05, 0, 0.619048, 0.519826, 5.5156e-05, 0, 0.650794, 0.497952, 5.41682e-05, 0, 0.68254, 0.476477, 5.28971e-05, 0, 0.714286, 0.455412, 5.14952e-05, 0, 0.746032, 0.434926, 5.02222e-05, 0, 0.777778, 0.4149, 4.85779e-05, 0, 0.809524, 0.395552, 4.72242e-05, 0, 0.84127, 0.376712, 4.54891e-05, 0, 0.873016, 0.358622, 4.40924e-05, 0, 0.904762, 0.341048, 4.22984e-05, 0, 0.936508, 0.324262, 4.08582e-05, 0, 0.968254, 0.308013, 3.90839e-05, 0, 1, 1, 6.13913e-11, 0, 0, 1, 6.14145e-11, 0, 0, 1, 6.17708e-11, 0, 0, 1, 6.33717e-11, 0, 0, 1, 6.81648e-11, 0, 0, 1, 8.08291e-11, 0, 0, 1, 1.14608e-10, 0, 0, 0.999998, 2.10507e-10, 0, 0, 0.999997, 4.99595e-10, 0, 0, 0.999995, 1.39897e-09, 0, 0, 0.999994, 4.19818e-09, 0, 0, 0.999988, 1.27042e-08, 0, 0, 0.999979, 3.75153e-08, 0, 0, 0.999965, 1.06206e-07, 0, 0, 0.999945, 2.85381e-07, 0, 0, 0.999908, 7.23611e-07, 0, 0, 0.999846, 1.7255e-06, 0, 0, 0.999733, 3.86104e-06, 0, 0, 0.999511, 8.08493e-06, 0, 0, 0.998993, 1.56884e-05, 0, 0, 0.997326, 2.65538e-05, 0, 0, 0.989706, 2.06466e-05, 0, 0, 0.981713, 1.30756e-05, 0, 7.0005e-06, 0.973636, 1.06473e-05, 0, 0.000464797, 0.966509, 1.0194e-05, 0, 0.00201743, 0.965149, 1.65881e-05, 0, 0.00497549, 0.962669, 2.49147e-05, 0, 0.00953262, 0.95786, 3.17449e-05, 0, 0.0158211, 0.949334, 2.81045e-05, 0, 0.0239343, 0.941041, 3.03263e-05, 0, 0.0339372, 0.931575, 3.56754e-05, 0, 0.0458738, 0.920102, 3.97075e-05, 0, 0.059772, 0.908002, 3.84886e-05, 0, 0.075645, 0.897269, 4.3027e-05, 0, 0.0934929, 0.884559, 4.79925e-05, 0, 0.113302, 0.869161, 4.8246e-05, 0, 0.135045, 0.853342, 5.09505e-05, 0, 0.158678, 0.837633, 5.42846e-05, 0, 0.184136, 0.820252, 5.54139e-05, 0, 0.211325, 0.801872, 5.81412e-05, 0, 0.240113, 0.782418, 5.85535e-05, 0, 0.270306, 0.7631, 6.10923e-05, 0, 0.301594, 0.742183, 6.13678e-05, 0, 0.333333, 0.721098, 6.27275e-05, 0, 0.365079, 0.699512, 6.29413e-05, 0, 0.396825, 0.677372, 6.36351e-05, 0, 0.428571, 0.655059, 6.33555e-05, 0, 0.460317, 0.632567, 6.36513e-05, 0, 0.492064, 0.609784, 6.28965e-05, 0, 0.52381, 0.587237, 6.25546e-05, 0, 0.555556, 0.564525, 6.15825e-05, 0, 0.587302, 0.542181, 6.05048e-05, 0, 0.619048, 0.520017, 5.96329e-05, 0, 0.650794, 0.498204, 5.81516e-05, 0, 0.68254, 0.476742, 5.69186e-05, 0, 0.714286, 0.455803, 5.53833e-05, 0, 0.746032, 0.435251, 5.37807e-05, 0, 0.777778, 0.415374, 5.22025e-05, 0, 0.809524, 0.395921, 5.03421e-05, 0, 0.84127, 0.377253, 4.88211e-05, 0, 0.873016, 0.359021, 4.68234e-05, 0, 0.904762, 0.341637, 4.53269e-05, 0, 0.936508, 0.3247, 4.33014e-05, 0, 0.968254, 0.308625, 4.18007e-05, 0, 1, 1, 2.86798e-10, 0, 0, 1, 2.86877e-10, 0, 0, 1, 2.88094e-10, 0, 0, 1, 2.93506e-10, 0, 0, 1, 3.09262e-10, 0, 0, 0.999999, 3.48593e-10, 0, 0, 0.999999, 4.44582e-10, 0, 0, 0.999998, 6.88591e-10, 0, 0, 0.999996, 1.34391e-09, 0, 0, 0.999993, 3.17438e-09, 0, 0, 0.999989, 8.35609e-09, 0, 0, 0.999983, 2.28677e-08, 0, 0, 0.999974, 6.23361e-08, 0, 0, 0.999959, 1.65225e-07, 0, 0, 0.999936, 4.19983e-07, 0, 0, 0.999896, 1.01546e-06, 0, 0, 0.99983, 2.32376e-06, 0, 0, 0.999709, 5.0156e-06, 0, 0, 0.999469, 1.0167e-05, 0, 0, 0.998886, 1.90775e-05, 0, 0, 0.996819, 3.00511e-05, 0, 0, 0.988837, 1.85092e-05, 0, 1.68222e-07, 0.982178, 1.34622e-05, 0, 0.000259622, 0.975017, 1.25961e-05, 0, 0.00142595, 0.967101, 1.3507e-05, 0, 0.00382273, 0.964905, 2.05003e-05, 0, 0.00764164, 0.96218, 2.9546e-05, 0, 0.0130121, 0.956821, 3.43738e-05, 0, 0.0200253, 0.948829, 3.05063e-05, 0, 0.0287452, 0.941092, 3.46487e-05, 0, 0.039218, 0.931883, 4.12061e-05, 0, 0.0514748, 0.920211, 4.44651e-05, 0, 0.0655351, 0.907307, 4.31252e-05, 0, 0.0814082, 0.89684, 4.90382e-05, 0, 0.0990939, 0.884119, 5.3334e-05, 0, 0.118583, 0.869148, 5.4114e-05, 0, 0.139856, 0.853377, 5.78536e-05, 0, 0.162882, 0.836753, 5.92285e-05, 0, 0.187615, 0.820063, 6.22787e-05, 0, 0.213991, 0.801694, 6.45492e-05, 0, 0.241918, 0.782116, 6.5353e-05, 0, 0.271267, 0.762673, 6.74344e-05, 0, 0.301847, 0.742133, 6.82788e-05, 0, 0.333333, 0.720779, 6.91959e-05, 0, 0.365079, 0.699386, 6.96817e-05, 0, 0.396826, 0.67732, 6.99583e-05, 0, 0.428572, 0.654888, 6.98447e-05, 0, 0.460318, 0.632499, 6.94063e-05, 0, 0.492064, 0.609825, 6.91612e-05, 0, 0.52381, 0.587287, 6.81576e-05, 0, 0.555556, 0.564743, 6.74138e-05, 0, 0.587302, 0.542409, 6.61617e-05, 0, 0.619048, 0.520282, 6.47785e-05, 0, 0.650794, 0.498506, 6.33836e-05, 0, 0.68254, 0.477102, 6.15905e-05, 0, 0.714286, 0.456167, 6.01013e-05, 0, 0.746032, 0.435728, 5.81457e-05, 0, 0.777778, 0.415809, 5.64215e-05, 0, 0.809524, 0.396517, 5.44997e-05, 0, 0.84127, 0.377737, 5.25061e-05, 0, 0.873016, 0.359698, 5.06831e-05, 0, 0.904762, 0.342164, 4.8568e-05, 0, 0.936508, 0.325417, 4.67826e-05, 0, 0.968254, 0.309186, 4.46736e-05, 0, 1, 1, 1.09018e-09, 0, 0, 1, 1.0904e-09, 0, 0, 1, 1.09393e-09, 0, 0, 1, 1.1095e-09, 0, 0, 1, 1.154e-09, 0, 0, 1, 1.26089e-09, 0, 0, 0.999999, 1.5059e-09, 0, 0, 0.999997, 2.07899e-09, 0, 0, 0.999994, 3.48164e-09, 0, 0, 0.999993, 7.05728e-09, 0, 0, 0.999987, 1.63692e-08, 0, 0, 0.999981, 4.06033e-08, 0, 0, 0.999969, 1.0245e-07, 0, 0, 0.999953, 2.55023e-07, 0, 0, 0.999925, 6.1511e-07, 0, 0, 0.999881, 1.42218e-06, 0, 0, 0.99981, 3.13086e-06, 0, 0, 0.99968, 6.53119e-06, 0, 0, 0.999418, 1.2832e-05, 0, 0, 0.998748, 2.32497e-05, 0, 0, 0.996066, 3.29522e-05, 0, 0, 0.988379, 1.79613e-05, 0, 0.000108799, 0.982567, 1.43715e-05, 0, 0.000921302, 0.976097, 1.48096e-05, 0, 0.00280738, 0.968475, 1.78905e-05, 0, 0.00596622, 0.964606, 2.53921e-05, 0, 0.0105284, 0.961564, 3.48623e-05, 0, 0.0165848, 0.955517, 3.57612e-05, 0, 0.0242, 0.948381, 3.43493e-05, 0, 0.03342, 0.941095, 4.05849e-05, 0, 0.0442777, 0.931923, 4.75394e-05, 0, 0.0567958, 0.91996, 4.84328e-05, 0, 0.0709879, 0.907419, 5.02146e-05, 0, 0.086861, 0.89618, 5.61654e-05, 0, 0.104415, 0.88337, 5.87612e-05, 0, 0.123643, 0.869046, 6.18057e-05, 0, 0.144531, 0.853278, 6.57392e-05, 0, 0.167057, 0.836091, 6.6303e-05, 0, 0.191188, 0.819644, 7.04445e-05, 0, 0.216878, 0.801246, 7.14071e-05, 0, 0.244062, 0.782031, 7.40093e-05, 0, 0.272649, 0.762066, 7.4685e-05, 0, 0.302509, 0.741964, 7.66647e-05, 0, 0.333442, 0.720554, 7.66328e-05, 0, 0.365079, 0.699098, 7.77857e-05, 0, 0.396826, 0.677189, 7.74633e-05, 0, 0.428572, 0.65484, 7.76235e-05, 0, 0.460318, 0.632496, 7.70316e-05, 0, 0.492064, 0.609908, 7.62669e-05, 0, 0.52381, 0.587312, 7.53972e-05, 0, 0.555556, 0.564938, 7.39994e-05, 0, 0.587302, 0.542577, 7.28382e-05, 0, 0.619048, 0.52062, 7.1112e-05, 0, 0.650794, 0.498819, 6.94004e-05, 0, 0.68254, 0.477555, 6.75575e-05, 0, 0.714286, 0.456568, 6.53449e-05, 0, 0.746032, 0.436278, 6.36068e-05, 0, 0.777778, 0.41637, 6.13466e-05, 0, 0.809524, 0.397144, 5.94177e-05, 0, 0.84127, 0.378412, 5.70987e-05, 0, 0.873016, 0.360376, 5.50419e-05, 0, 0.904762, 0.342906, 5.27422e-05, 0, 0.936508, 0.326136, 5.06544e-05, 0, 0.968254, 0.30997, 4.84307e-05, 0, 1, 1, 3.54014e-09, 0, 0, 1, 3.54073e-09, 0, 0, 1, 3.54972e-09, 0, 0, 1, 3.58929e-09, 0, 0, 1, 3.70093e-09, 0, 0, 0.999999, 3.96194e-09, 0, 0, 0.999998, 4.53352e-09, 0, 0, 0.999997, 5.78828e-09, 0, 0, 0.999994, 8.63812e-09, 0, 0, 0.999991, 1.53622e-08, 0, 0, 0.999985, 3.16356e-08, 0, 0, 0.999977, 7.12781e-08, 0, 0, 0.999964, 1.66725e-07, 0, 0, 0.999945, 3.90501e-07, 0, 0, 0.999912, 8.95622e-07, 0, 0, 0.999866, 1.98428e-06, 0, 0, 0.999786, 4.21038e-06, 0, 0, 0.999647, 8.50239e-06, 0, 0, 0.999356, 1.62059e-05, 0, 0, 0.998563, 2.82652e-05, 0, 0, 0.994928, 3.36309e-05, 0, 2.44244e-05, 0.987999, 1.78458e-05, 0, 0.000523891, 0.982893, 1.59162e-05, 0, 0.00194729, 0.977044, 1.78056e-05, 0, 0.00451099, 0.969972, 2.30624e-05, 0, 0.00835132, 0.964237, 3.13922e-05, 0, 0.013561, 0.960791, 4.06145e-05, 0, 0.0202056, 0.954292, 3.72796e-05, 0, 0.0283321, 0.948052, 4.03199e-05, 0, 0.0379739, 0.940938, 4.79537e-05, 0, 0.0491551, 0.931689, 5.45292e-05, 0, 0.0618918, 0.91987, 5.4038e-05, 0, 0.0761941, 0.907665, 5.89909e-05, 0, 0.0920672, 0.895281, 6.42651e-05, 0, 0.109511, 0.882621, 6.59707e-05, 0, 0.12852, 0.86873, 7.09973e-05, 0, 0.149085, 0.853008, 7.42221e-05, 0, 0.171189, 0.835944, 7.61754e-05, 0, 0.194809, 0.818949, 7.97052e-05, 0, 0.21991, 0.800951, 8.12434e-05, 0, 0.246447, 0.781847, 8.38075e-05, 0, 0.274352, 0.761649, 8.4501e-05, 0, 0.303535, 0.74152, 8.60258e-05, 0, 0.333857, 0.720495, 8.66233e-05, 0, 0.365104, 0.698742, 8.68326e-05, 0, 0.396826, 0.677096, 8.7133e-05, 0, 0.428572, 0.654782, 8.63497e-05, 0, 0.460318, 0.632335, 8.60206e-05, 0, 0.492064, 0.610031, 8.49337e-05, 0, 0.52381, 0.587457, 8.38279e-05, 0, 0.555556, 0.56513, 8.2309e-05, 0, 0.587302, 0.542877, 8.03542e-05, 0, 0.619048, 0.5209, 7.86928e-05, 0, 0.650794, 0.499291, 7.65171e-05, 0, 0.68254, 0.477971, 7.44753e-05, 0, 0.714286, 0.457221, 7.2209e-05, 0, 0.746032, 0.436803, 6.97448e-05, 0, 0.777778, 0.417083, 6.75333e-05, 0, 0.809524, 0.397749, 6.48058e-05, 0, 0.84127, 0.379177, 6.25759e-05, 0, 0.873016, 0.361061, 5.98584e-05, 0, 0.904762, 0.343713, 5.75797e-05, 0, 0.936508, 0.326894, 5.49999e-05, 0, 0.968254, 0.310816, 5.27482e-05, 0, 1, 1, 1.0153e-08, 0, 0, 1, 1.01544e-08, 0, 0, 1, 1.01751e-08, 0, 0, 1, 1.02662e-08, 0, 0, 1, 1.0521e-08, 0, 0, 0.999999, 1.11049e-08, 0, 0, 0.999999, 1.23408e-08, 0, 0, 0.999996, 1.4924e-08, 0, 0, 0.999992, 2.04471e-08, 0, 0, 0.999989, 3.26539e-08, 0, 0, 0.99998, 6.03559e-08, 0, 0, 0.999971, 1.23936e-07, 0, 0, 0.999955, 2.69058e-07, 0, 0, 0.999933, 5.93604e-07, 0, 0, 0.999901, 1.29633e-06, 0, 0, 0.999847, 2.75621e-06, 0, 0, 0.999761, 5.64494e-06, 0, 0, 0.999607, 1.10485e-05, 0, 0, 0.999282, 2.04388e-05, 0, 0, 0.99831, 3.41084e-05, 0, 2.2038e-07, 0.993288, 2.94949e-05, 0, 0.000242388, 0.987855, 1.92736e-05, 0, 0.0012503, 0.983167, 1.82383e-05, 0, 0.0032745, 0.977908, 2.18633e-05, 0, 0.00646321, 0.971194, 2.90662e-05, 0, 0.0109133, 0.963867, 3.86401e-05, 0, 0.0166927, 0.95982, 4.62827e-05, 0, 0.0238494, 0.953497, 4.20705e-05, 0, 0.0324178, 0.947621, 4.77743e-05, 0, 0.0424225, 0.940611, 5.68258e-05, 0, 0.0538808, 0.931174, 6.18061e-05, 0, 0.0668047, 0.919919, 6.27098e-05, 0, 0.0812014, 0.907856, 6.94714e-05, 0, 0.0970745, 0.894509, 7.35008e-05, 0, 0.114424, 0.881954, 7.63369e-05, 0, 0.133246, 0.868309, 8.21896e-05, 0, 0.153534, 0.852511, 8.3769e-05, 0, 0.175275, 0.835821, 8.81615e-05, 0, 0.198453, 0.817981, 8.96368e-05, 0, 0.223042, 0.800504, 9.30906e-05, 0, 0.249009, 0.78141, 9.45056e-05, 0, 0.276304, 0.761427, 9.63605e-05, 0, 0.304862, 0.74094, 9.68088e-05, 0, 0.334584, 0.720233, 9.81481e-05, 0, 0.365322, 0.698592, 9.79122e-05, 0, 0.396826, 0.676763, 9.81057e-05, 0, 0.428571, 0.654808, 9.73956e-05, 0, 0.460318, 0.632326, 9.62619e-05, 0, 0.492064, 0.610049, 9.52996e-05, 0, 0.52381, 0.58763, 9.33334e-05, 0, 0.555556, 0.565261, 9.17573e-05, 0, 0.587302, 0.543244, 8.96636e-05, 0, 0.619048, 0.521273, 8.73304e-05, 0, 0.650794, 0.499818, 8.52648e-05, 0, 0.68254, 0.478536, 8.23961e-05, 0, 0.714286, 0.457826, 7.9939e-05, 0, 0.746032, 0.437549, 7.7126e-05, 0, 0.777778, 0.41776, 7.43043e-05, 0, 0.809524, 0.39863, 7.16426e-05, 0, 0.84127, 0.379954, 6.86456e-05, 0, 0.873016, 0.362025, 6.60514e-05, 0, 0.904762, 0.344581, 6.30755e-05, 0, 0.936508, 0.327909, 6.05439e-05, 0, 0.968254, 0.311736, 5.76345e-05, 0, 1, 1, 2.63344e-08, 0, 0, 1, 2.63373e-08, 0, 0, 1, 2.63815e-08, 0, 0, 1, 2.65753e-08, 0, 0, 1, 2.71132e-08, 0, 0, 0.999999, 2.83279e-08, 0, 0, 0.999997, 3.0833e-08, 0, 0, 0.999995, 3.58711e-08, 0, 0, 0.999992, 4.61266e-08, 0, 0, 0.999985, 6.7574e-08, 0, 0, 0.999977, 1.1358e-07, 0, 0, 0.999966, 2.13657e-07, 0, 0, 0.999948, 4.31151e-07, 0, 0, 0.999923, 8.96656e-07, 0, 0, 0.999884, 1.86603e-06, 0, 0, 0.999826, 3.81115e-06, 0, 0, 0.999732, 7.54184e-06, 0, 0, 0.999561, 1.43192e-05, 0, 0, 0.999191, 2.57061e-05, 0, 0, 0.997955, 4.05724e-05, 0, 7.44132e-05, 0.992228, 2.76537e-05, 0, 0.000716477, 0.987638, 2.08885e-05, 0, 0.0022524, 0.983395, 2.15226e-05, 0, 0.00484816, 0.978614, 2.70795e-05, 0, 0.00860962, 0.972389, 3.65282e-05, 0, 0.0136083, 0.964392, 4.74747e-05, 0, 0.0198941, 0.95861, 5.09141e-05, 0, 0.0275023, 0.952806, 4.8963e-05, 0, 0.0364584, 0.94712, 5.71119e-05, 0, 0.04678, 0.940104, 6.71704e-05, 0, 0.0584799, 0.930398, 6.87586e-05, 0, 0.0715665, 0.919866, 7.38161e-05, 0, 0.086045, 0.907853, 8.13235e-05, 0, 0.101918, 0.894078, 8.34582e-05, 0, 0.119186, 0.881177, 8.92093e-05, 0, 0.137845, 0.867575, 9.44548e-05, 0, 0.157891, 0.852107, 9.69607e-05, 0, 0.179316, 0.835502, 0.000101456, 0, 0.202106, 0.81756, 0.000103256, 0, 0.226243, 0.79984, 0.000106954, 0, 0.251704, 0.780998, 0.000108066, 0, 0.278451, 0.761132, 0.000110111, 0, 0.306436, 0.740429, 0.000110459, 0, 0.335586, 0.719836, 0.000111219, 0, 0.365796, 0.698467, 0.00011145, 0, 0.3969, 0.676446, 0.000110393, 0, 0.428571, 0.654635, 0.000110035, 0, 0.460318, 0.632411, 0.000108548, 0, 0.492064, 0.609986, 0.000106963, 0, 0.52381, 0.587872, 0.000105238, 0, 0.555556, 0.565528, 0.000102665, 0, 0.587302, 0.543563, 0.000100543, 0, 0.619048, 0.52176, 9.76182e-05, 0, 0.650794, 0.500188, 9.47099e-05, 0, 0.68254, 0.479204, 9.19929e-05, 0, 0.714286, 0.458413, 8.86139e-05, 0, 0.746032, 0.438314, 8.57839e-05, 0, 0.777778, 0.418573, 8.2411e-05, 0, 0.809524, 0.39947, 7.92211e-05, 0, 0.84127, 0.380892, 7.59546e-05, 0, 0.873016, 0.362953, 7.27571e-05, 0, 0.904762, 0.345601, 6.95738e-05, 0, 0.936508, 0.328895, 6.64907e-05, 0, 0.968254, 0.312808, 6.34277e-05, 0, 1, 1, 6.28647e-08, 0, 0, 1, 6.28705e-08, 0, 0, 1, 6.29587e-08, 0, 0, 1, 6.33441e-08, 0, 0, 0.999999, 6.44087e-08, 0, 0, 0.999998, 6.67856e-08, 0, 0, 0.999997, 7.15889e-08, 0, 0, 0.999995, 8.09577e-08, 0, 0, 0.999989, 9.92764e-08, 0, 0, 0.999983, 1.35834e-07, 0, 0, 0.999974, 2.10482e-07, 0, 0, 0.999959, 3.65215e-07, 0, 0, 0.999939, 6.86693e-07, 0, 0, 0.999911, 1.3472e-06, 0, 0, 0.999868, 2.6731e-06, 0, 0, 0.999804, 5.24756e-06, 0, 0, 0.9997, 1.00403e-05, 0, 0, 0.99951, 1.85019e-05, 0, 0, 0.999078, 3.22036e-05, 0, 6.20676e-06, 0.997428, 4.70002e-05, 0, 0.000341552, 0.99162, 2.87123e-05, 0, 0.00143727, 0.987479, 2.34706e-05, 0, 0.00349201, 0.983582, 2.60083e-05, 0, 0.0066242, 0.979186, 3.37927e-05, 0, 0.0109113, 0.97325, 4.54689e-05, 0, 0.0164064, 0.965221, 5.73759e-05, 0, 0.0231463, 0.957262, 5.44114e-05, 0, 0.0311571, 0.952211, 5.87006e-05, 0, 0.0404572, 0.946631, 6.92256e-05, 0, 0.0510592, 0.939391, 7.87819e-05, 0, 0.0629723, 0.929795, 7.92368e-05, 0, 0.0762025, 0.91965, 8.75075e-05, 0, 0.090753, 0.907737, 9.50903e-05, 0, 0.106626, 0.893899, 9.72963e-05, 0, 0.123822, 0.880239, 0.00010459, 0, 0.142337, 0.866562, 0.000107689, 0, 0.16217, 0.85164, 0.000113081, 0, 0.183314, 0.835021, 0.000116636, 0, 0.20576, 0.817311, 0.000120074, 0, 0.229496, 0.798845, 0.000121921, 0, 0.254502, 0.780479, 0.00012475, 0, 0.280753, 0.760694, 0.000125255, 0, 0.308212, 0.740142, 0.000126719, 0, 0.336825, 0.719248, 0.00012636, 0, 0.366517, 0.698209, 0.000126712, 0, 0.397167, 0.676398, 0.000125769, 0, 0.428578, 0.654378, 0.000124432, 0, 0.460318, 0.632484, 0.000123272, 0, 0.492064, 0.610113, 0.00012085, 0, 0.52381, 0.587931, 0.000118411, 0, 0.555556, 0.565872, 0.00011569, 0, 0.587302, 0.543814, 0.000112521, 0, 0.619048, 0.522265, 0.000109737, 0, 0.650794, 0.500835, 0.000106228, 0, 0.68254, 0.479818, 0.000102591, 0, 0.714286, 0.459258, 9.91288e-05, 0, 0.746032, 0.439061, 9.52325e-05, 0, 0.777778, 0.419552, 9.1895e-05, 0, 0.809524, 0.400399, 8.79051e-05, 0, 0.84127, 0.381976, 8.44775e-05, 0, 0.873016, 0.364009, 8.06316e-05, 0, 0.904762, 0.346761, 7.71848e-05, 0, 0.936508, 0.330049, 7.35429e-05, 0, 0.968254, 0.314018, 7.02103e-05, 0, 1, 1, 1.39968e-07, 0, 0, 1, 1.39979e-07, 0, 0, 1, 1.40145e-07, 0, 0, 1, 1.4087e-07, 0, 0, 0.999999, 1.42865e-07, 0, 0, 0.999998, 1.47279e-07, 0, 0, 0.999997, 1.56057e-07, 0, 0, 0.999992, 1.7276e-07, 0, 0, 0.999989, 2.04352e-07, 0, 0, 0.99998, 2.6494e-07, 0, 0, 0.999969, 3.83435e-07, 0, 0, 0.999953, 6.18641e-07, 0, 0, 0.999929, 1.08755e-06, 0, 0, 0.999898, 2.01497e-06, 0, 0, 0.999849, 3.81346e-06, 0, 0, 0.999778, 7.19815e-06, 0, 0, 0.999661, 1.33215e-05, 0, 0, 0.999451, 2.38313e-05, 0, 0, 0.998936, 4.01343e-05, 0, 0.000113724, 0.99662, 5.17346e-05, 0, 0.000820171, 0.991094, 3.04323e-05, 0, 0.00238143, 0.987487, 2.81757e-05, 0, 0.00493527, 0.983731, 3.20048e-05, 0, 0.00856859, 0.979647, 4.23905e-05, 0, 0.0133393, 0.973837, 5.62935e-05, 0, 0.0192863, 0.96584, 6.77442e-05, 0, 0.0264369, 0.956309, 6.23073e-05, 0, 0.03481, 0.951523, 7.04131e-05, 0, 0.0444184, 0.946003, 8.36594e-05, 0, 0.0552713, 0.938454, 9.11736e-05, 0, 0.0673749, 0.929279, 9.38264e-05, 0, 0.0807329, 0.919239, 0.000103754, 0, 0.0953479, 0.907293, 0.000109928, 0, 0.111221, 0.893936, 0.000115257, 0, 0.128352, 0.879674, 0.000122265, 0, 0.14674, 0.865668, 0.000125733, 0, 0.166382, 0.850998, 0.000132305, 0, 0.187276, 0.834498, 0.000134844, 0, 0.209413, 0.816903, 0.000139276, 0, 0.232786, 0.798235, 0.000140984, 0, 0.257382, 0.779724, 0.00014378, 0, 0.283181, 0.760251, 0.000144623, 0, 0.310156, 0.739808, 0.000145228, 0, 0.338269, 0.718762, 0.00014539, 0, 0.367461, 0.697815, 0.000144432, 0, 0.397646, 0.67631, 0.000143893, 0, 0.428685, 0.654278, 0.000141846, 0, 0.460318, 0.632347, 0.00013935, 0, 0.492064, 0.610296, 0.000137138, 0, 0.52381, 0.588039, 0.000133806, 0, 0.555556, 0.566218, 0.000130755, 0, 0.587302, 0.544346, 0.000127128, 0, 0.619048, 0.522701, 0.000123002, 0, 0.650794, 0.501542, 0.000119443, 0, 0.68254, 0.480508, 0.000115055, 0, 0.714286, 0.460092, 0.000111032, 0, 0.746032, 0.440021, 0.000106635, 0, 0.777778, 0.420446, 0.000102162, 0, 0.809524, 0.401512, 9.8184e-05, 0, 0.84127, 0.38299, 9.36497e-05, 0, 0.873016, 0.365232, 8.9813e-05, 0, 0.904762, 0.347865, 8.53073e-05, 0, 0.936508, 0.331342, 8.17068e-05, 0, 0.968254, 0.315202, 7.73818e-05, 0, 1, 1, 2.9368e-07, 0, 0, 1, 2.937e-07, 0, 0, 1, 2.93998e-07, 0, 0, 1, 2.95298e-07, 0, 0, 0.999999, 2.98865e-07, 0, 0, 0.999998, 3.067e-07, 0, 0, 0.999995, 3.22082e-07, 0, 0, 0.999992, 3.50767e-07, 0, 0, 0.999986, 4.03538e-07, 0, 0, 0.999976, 5.01372e-07, 0, 0, 0.999964, 6.8562e-07, 0, 0, 0.999945, 1.0374e-06, 0, 0, 0.999919, 1.71269e-06, 0, 0, 0.999882, 3.00175e-06, 0, 0, 0.999829, 5.42144e-06, 0, 0, 0.999749, 9.84182e-06, 0, 0, 0.99962, 1.76213e-05, 0, 0, 0.999382, 3.05995e-05, 0, 1.38418e-05, 0.998751, 4.96686e-05, 0, 0.000389844, 0.995344, 5.10733e-05, 0, 0.00150343, 0.990768, 3.45829e-05, 0, 0.00352451, 0.987464, 3.42841e-05, 0, 0.00655379, 0.983846, 3.99072e-05, 0, 0.0106554, 0.980007, 5.33219e-05, 0, 0.0158723, 0.974494, 6.96992e-05, 0, 0.0222333, 0.96622, 7.76754e-05, 0, 0.029758, 0.956273, 7.47718e-05, 0, 0.0384596, 0.950952, 8.64611e-05, 0, 0.0483473, 0.945215, 0.000100464, 0, 0.0594266, 0.937287, 0.000103729, 0, 0.0717019, 0.928649, 0.000111665, 0, 0.0851752, 0.918791, 0.00012353, 0, 0.0998479, 0.906685, 0.000127115, 0, 0.115721, 0.893706, 0.00013628, 0, 0.132794, 0.879248, 0.000142427, 0, 0.151067, 0.864685, 0.000148091, 0, 0.170538, 0.850032, 0.000153517, 0, 0.191204, 0.833853, 0.000157322, 0, 0.213063, 0.816353, 0.000161086, 0, 0.236107, 0.797834, 0.000164111, 0, 0.260329, 0.778831, 0.000165446, 0, 0.285714, 0.759756, 0.000167492, 0, 0.312243, 0.739419, 0.000166928, 0, 0.339887, 0.718491, 0.000167, 0, 0.368604, 0.697392, 0.000165674, 0, 0.398329, 0.676102, 0.000163815, 0, 0.428961, 0.654243, 0.000162003, 0, 0.460331, 0.632176, 0.000158831, 0, 0.492064, 0.610407, 0.000155463, 0, 0.52381, 0.588394, 0.000152062, 0, 0.555556, 0.56645, 0.000147665, 0, 0.587302, 0.5449, 0.00014375, 0, 0.619048, 0.523276, 0.000138905, 0, 0.650794, 0.502179, 0.000134189, 0, 0.68254, 0.481359, 0.000129392, 0, 0.714286, 0.46092, 0.000124556, 0, 0.746032, 0.441084, 0.00011957, 0, 0.777778, 0.421517, 0.000114652, 0, 0.809524, 0.402721, 0.000109688, 0, 0.84127, 0.384222, 0.000104667, 0, 0.873016, 0.366534, 9.99633e-05, 0, 0.904762, 0.349205, 9.50177e-05, 0, 0.936508, 0.332702, 9.07301e-05, 0, 0.968254, 0.316599, 8.59769e-05, 0, 1, 1, 5.85473e-07, 0, 0, 1, 5.85507e-07, 0, 0, 1, 5.8602e-07, 0, 0, 0.999999, 5.88259e-07, 0, 0, 0.999999, 5.94381e-07, 0, 0, 0.999998, 6.07754e-07, 0, 0, 0.999995, 6.33729e-07, 0, 0, 0.99999, 6.8137e-07, 0, 0, 0.999984, 7.67003e-07, 0, 0, 0.999973, 9.21212e-07, 0, 0, 0.999959, 1.20218e-06, 0, 0, 0.999936, 1.72024e-06, 0, 0, 0.999907, 2.68088e-06, 0, 0, 0.999866, 4.45512e-06, 0, 0, 0.999806, 7.68481e-06, 0, 0, 0.999716, 1.342e-05, 0, 0, 0.999576, 2.32473e-05, 0, 0, 0.9993, 3.91694e-05, 0, 0.000129917, 0.998498, 6.08429e-05, 0, 0.000845035, 0.994132, 4.89743e-05, 0, 0.00237616, 0.99031, 3.84644e-05, 0, 0.00484456, 0.987409, 4.21768e-05, 0, 0.00832472, 0.983981, 5.04854e-05, 0, 0.0128643, 0.980268, 6.71028e-05, 0, 0.0184947, 0.974875, 8.52749e-05, 0, 0.025237, 0.966063, 8.5531e-05, 0, 0.0331046, 0.956779, 9.00588e-05, 0, 0.0421067, 0.950259, 0.00010577, 0, 0.0522487, 0.944239, 0.000119458, 0, 0.0635343, 0.936341, 0.000122164, 0, 0.0759654, 0.928047, 0.000134929, 0, 0.0895434, 0.918065, 0.000145544, 0, 0.104269, 0.906267, 0.000150531, 0, 0.120142, 0.893419, 0.000161652, 0, 0.137163, 0.878758, 0.00016593, 0, 0.15533, 0.863699, 0.000174014, 0, 0.174645, 0.848876, 0.000177877, 0, 0.195106, 0.833032, 0.000184049, 0, 0.21671, 0.815557, 0.000186088, 0, 0.239454, 0.797323, 0.00019054, 0, 0.263332, 0.778124, 0.000191765, 0, 0.288336, 0.758929, 0.000192535, 0, 0.314451, 0.738979, 0.000192688, 0, 0.341658, 0.718213, 0.000191522, 0, 0.369924, 0.696947, 0.000190491, 0, 0.399202, 0.675807, 0.000187913, 0, 0.429416, 0.654147, 0.000184451, 0, 0.460447, 0.63229, 0.000181442, 0, 0.492064, 0.610499, 0.000177139, 0, 0.523809, 0.588747, 0.000172596, 0, 0.555555, 0.566783, 0.000167457, 0, 0.587301, 0.545359, 0.000162518, 0, 0.619048, 0.523984, 0.000156818, 0, 0.650794, 0.502917, 0.000151884, 0, 0.68254, 0.482294, 0.000145514, 0, 0.714286, 0.461945, 0.000140199, 0, 0.746032, 0.442133, 0.000134101, 0, 0.777778, 0.422705, 0.000128374, 0, 0.809524, 0.403916, 0.000122996, 0, 0.84127, 0.38554, 0.000116808, 0, 0.873016, 0.367909, 0.000111973, 0, 0.904762, 0.350651, 0.000105938, 0, 0.936508, 0.334208, 0.000101355, 0, 0.968254, 0.318123, 9.57629e-05, 0, 1, 1, 1.11633e-06, 0, 0, 1, 1.11639e-06, 0, 0, 1, 1.11725e-06, 0, 0, 1, 1.12096e-06, 0, 0, 0.999999, 1.1311e-06, 0, 0, 0.999997, 1.15315e-06, 0, 0, 0.999995, 1.1956e-06, 0, 0, 0.999989, 1.27239e-06, 0, 0, 0.999981, 1.40772e-06, 0, 0, 0.999969, 1.64541e-06, 0, 0, 0.999952, 2.06607e-06, 0, 0, 0.999928, 2.81783e-06, 0, 0, 0.999895, 4.16835e-06, 0, 0, 0.999848, 6.58728e-06, 0, 0, 0.999781, 1.08648e-05, 0, 0, 0.999682, 1.82579e-05, 0, 0, 0.999523, 3.06003e-05, 0, 1.59122e-05, 0.999205, 4.99862e-05, 0, 0.000391184, 0.998131, 7.3306e-05, 0, 0.00147534, 0.993334, 5.13229e-05, 0, 0.0034227, 0.99016, 4.67783e-05, 0, 0.00632232, 0.987321, 5.23413e-05, 0, 0.0102295, 0.984099, 6.4267e-05, 0, 0.0151794, 0.980432, 8.43042e-05, 0, 0.0211947, 0.974976, 0.000102819, 0, 0.0282899, 0.966429, 9.96234e-05, 0, 0.0364739, 0.957633, 0.000111074, 0, 0.0457522, 0.949422, 0.000128644, 0, 0.0561278, 0.943045, 0.000140076, 0, 0.0676023, 0.935448, 0.000146349, 0, 0.0801762, 0.927225, 0.000161854, 0, 0.0938499, 0.917033, 0.000169135, 0, 0.108623, 0.905762, 0.000179987, 0, 0.124496, 0.892879, 0.000189832, 0, 0.141469, 0.878435, 0.000195881, 0, 0.159541, 0.863114, 0.00020466, 0, 0.178713, 0.84776, 0.000209473, 0, 0.198985, 0.832084, 0.000214861, 0, 0.220355, 0.814915, 0.000217695, 0, 0.242823, 0.796711, 0.000220313, 0, 0.266385, 0.777603, 0.00022313, 0, 0.291036, 0.757991, 0.000222471, 0, 0.316767, 0.738371, 0.000222869, 0, 0.343563, 0.717872, 0.000221243, 0, 0.371402, 0.696619, 0.000218089, 0, 0.400248, 0.675379, 0.00021562, 0, 0.430047, 0.65411, 0.00021169, 0, 0.460709, 0.63241, 0.000206947, 0, 0.492079, 0.61046, 0.000201709, 0, 0.52381, 0.58903, 0.000196753, 0, 0.555556, 0.567267, 0.000189637, 0, 0.587302, 0.545886, 0.000184735, 0, 0.619048, 0.524714, 0.000177257, 0, 0.650794, 0.503789, 0.000171424, 0, 0.68254, 0.483204, 0.000164688, 0, 0.714286, 0.462976, 0.000157172, 0, 0.746032, 0.443294, 0.000151341, 0, 0.777778, 0.423988, 0.000143737, 0, 0.809524, 0.405325, 0.000138098, 0, 0.84127, 0.386981, 0.000130698, 0, 0.873016, 0.369436, 0.000125276, 0, 0.904762, 0.35219, 0.000118349, 0, 0.936508, 0.335804, 0.00011312, 0, 0.968254, 0.319749, 0.000106687, 0, 1, 1, 2.04685e-06, 0, 0, 1, 2.04694e-06, 0, 0, 1, 2.04831e-06, 0, 0, 0.999999, 2.05428e-06, 0, 0, 0.999999, 2.07056e-06, 0, 0, 0.999997, 2.10581e-06, 0, 0, 0.999993, 2.1732e-06, 0, 0, 0.999987, 2.29365e-06, 0, 0, 0.999979, 2.50243e-06, 0, 0, 0.999965, 2.86127e-06, 0, 0, 0.999947, 3.48028e-06, 0, 0, 0.999918, 4.55588e-06, 0, 0, 0.999881, 6.43303e-06, 0, 0, 0.999828, 9.70064e-06, 0, 0, 0.999753, 1.53233e-05, 0, 0, 0.999642, 2.4793e-05, 0, 0, 0.999464, 4.02032e-05, 0, 0.000122947, 0.999089, 6.35852e-05, 0, 0.000807414, 0.997567, 8.57026e-05, 0, 0.00227206, 0.992903, 5.94912e-05, 0, 0.00462812, 0.990011, 5.78515e-05, 0, 0.00794162, 0.987192, 6.5399e-05, 0, 0.0122534, 0.98418, 8.19675e-05, 0, 0.0175888, 0.980491, 0.000105514, 0, 0.0239635, 0.974779, 0.000121532, 0, 0.031387, 0.96675, 0.000119144, 0, 0.0398644, 0.958248, 0.000136125, 0, 0.0493982, 0.948884, 0.000155408, 0, 0.0599896, 0.941673, 0.000162281, 0, 0.0716382, 0.934521, 0.000176754, 0, 0.0843437, 0.926205, 0.000192873, 0, 0.0981056, 0.916089, 0.000200038, 0, 0.112923, 0.904963, 0.000213624, 0, 0.128796, 0.892089, 0.000221834, 0, 0.145725, 0.878028, 0.000232619, 0, 0.163709, 0.86249, 0.000238632, 0, 0.182749, 0.846587, 0.000247002, 0, 0.202847, 0.830988, 0.000250702, 0, 0.224001, 0.814165, 0.000255562, 0, 0.246214, 0.796135, 0.000257505, 0, 0.269482, 0.777052, 0.000258625, 0, 0.293805, 0.757201, 0.000258398, 0, 0.319176, 0.737655, 0.000256714, 0, 0.345587, 0.717477, 0.000255187, 0, 0.373021, 0.696433, 0.000251792, 0, 0.401454, 0.675084, 0.000247223, 0, 0.430844, 0.653907, 0.000242213, 0, 0.461125, 0.632561, 0.000237397, 0, 0.492187, 0.610658, 0.000229313, 0, 0.52381, 0.589322, 0.000224402, 0, 0.555556, 0.567857, 0.000216116, 0, 0.587302, 0.54652, 0.000209124, 0, 0.619048, 0.525433, 0.000201601, 0, 0.650794, 0.504679, 0.000192957, 0, 0.68254, 0.484203, 0.000186052, 0, 0.714286, 0.464203, 0.000177672, 0, 0.746032, 0.444549, 0.000170005, 0, 0.777778, 0.425346, 0.000162401, 0, 0.809524, 0.406706, 0.0001544, 0, 0.84127, 0.388576, 0.000147437, 0, 0.873016, 0.37094, 0.000139493, 0, 0.904762, 0.353996, 0.000133219, 0, 0.936508, 0.337391, 0.000125573, 0, 0.968254, 0.321648, 0.000119867, 0, 1, 1, 3.62511e-06, 0, 0, 1, 3.62525e-06, 0, 0, 1, 3.62739e-06, 0, 0, 0.999999, 3.63673e-06, 0, 0, 0.999998, 3.66214e-06, 0, 0, 0.999996, 3.71698e-06, 0, 0, 0.999992, 3.82116e-06, 0, 0, 0.999986, 4.00554e-06, 0, 0, 0.999976, 4.32058e-06, 0, 0, 0.999961, 4.85194e-06, 0, 0, 0.999938, 5.74808e-06, 0, 0, 0.999908, 7.26643e-06, 0, 0, 0.999865, 9.84707e-06, 0, 0, 0.999807, 1.42217e-05, 0, 0, 0.999723, 2.15581e-05, 0, 0, 0.999602, 3.36114e-05, 0, 1.19113e-05, 0.999398, 5.27353e-05, 0, 0.000355813, 0.998946, 8.05809e-05, 0, 0.00137768, 0.996647, 9.42908e-05, 0, 0.00322469, 0.992298, 6.68733e-05, 0, 0.00597897, 0.989802, 7.16564e-05, 0, 0.00968903, 0.987019, 8.21355e-05, 0, 0.0143845, 0.984219, 0.000104555, 0, 0.0200831, 0.980425, 0.000131245, 0, 0.0267948, 0.974241, 0.000139613, 0, 0.034525, 0.967006, 0.000145931, 0, 0.0432757, 0.95893, 0.000167153, 0, 0.0530471, 0.949157, 0.000188146, 0, 0.0638386, 0.94062, 0.000194625, 0, 0.0756487, 0.933509, 0.000213721, 0, 0.0884762, 0.925088, 0.000229616, 0, 0.10232, 0.915178, 0.000239638, 0, 0.117178, 0.904093, 0.000254814, 0, 0.133051, 0.891337, 0.000263685, 0, 0.149939, 0.877326, 0.000274789, 0, 0.167841, 0.861794, 0.000280534, 0, 0.18676, 0.845758, 0.000289534, 0, 0.206696, 0.829792, 0.000294446, 0, 0.22765, 0.813037, 0.000296877, 0, 0.249625, 0.795285, 0.000300217, 0, 0.27262, 0.776323, 0.000299826, 0, 0.296636, 0.756673, 0.000299787, 0, 0.321671, 0.736856, 0.000297867, 0, 0.347718, 0.716883, 0.000294052, 0, 0.374768, 0.696089, 0.000289462, 0, 0.402804, 0.67505, 0.000285212, 0, 0.431796, 0.653509, 0.00027653, 0, 0.461695, 0.63258, 0.000271759, 0, 0.49242, 0.61104, 0.000262811, 0, 0.523822, 0.589567, 0.000255151, 0, 0.555556, 0.568322, 0.000246434, 0, 0.587302, 0.547235, 0.000237061, 0, 0.619048, 0.52616, 0.000228343, 0, 0.650794, 0.505716, 0.000219236, 0, 0.68254, 0.485274, 0.000209595, 0, 0.714286, 0.465411, 0.000201011, 0, 0.746032, 0.445854, 0.00019109, 0, 0.777778, 0.426911, 0.000182897, 0, 0.809524, 0.408222, 0.000173569, 0, 0.84127, 0.390307, 0.000165496, 0, 0.873016, 0.372624, 0.000156799, 0, 0.904762, 0.355804, 0.00014917, 0, 0.936508, 0.33924, 0.000140907, 0, 0.968254, 0.323534, 0.000134062, 0, 1, 1, 6.22487e-06, 0, 0, 1, 6.2251e-06, 0, 0, 1, 6.22837e-06, 0, 0, 0.999999, 6.24259e-06, 0, 0, 0.999998, 6.28127e-06, 0, 0, 0.999996, 6.36451e-06, 0, 0, 0.999991, 6.5218e-06, 0, 0, 0.999984, 6.79782e-06, 0, 0, 0.999973, 7.26361e-06, 0, 0, 0.999955, 8.03644e-06, 0, 0, 0.999931, 9.31397e-06, 0, 0, 0.999896, 1.14299e-05, 0, 0, 0.999847, 1.49402e-05, 0, 0, 0.999784, 2.07461e-05, 0, 0, 0.999692, 3.02493e-05, 0, 0, 0.999554, 4.54957e-05, 0, 9.97275e-05, 0.999326, 6.90762e-05, 0, 0.000724813, 0.998757, 0.000101605, 0, 0.0020972, 0.995367, 9.58745e-05, 0, 0.00432324, 0.99209, 8.32808e-05, 0, 0.00746347, 0.989517, 8.87601e-05, 0, 0.0115534, 0.987008, 0.00010564, 0, 0.0166134, 0.98421, 0.000133179, 0, 0.0226552, 0.98021, 0.000161746, 0, 0.0296838, 0.973676, 0.000161821, 0, 0.0377016, 0.967052, 0.000178635, 0, 0.0467079, 0.959385, 0.000206765, 0, 0.0567013, 0.949461, 0.00022476, 0, 0.0676796, 0.939578, 0.00023574, 0, 0.0796403, 0.932416, 0.00025893, 0, 0.0925812, 0.923759, 0.000271228, 0, 0.106501, 0.914223, 0.000289165, 0, 0.121397, 0.902942, 0.000301156, 0, 0.13727, 0.890419, 0.000313852, 0, 0.15412, 0.876639, 0.000324408, 0, 0.171946, 0.861316, 0.00033249, 0, 0.190751, 0.84496, 0.000338497, 0, 0.210537, 0.828427, 0.000345861, 0, 0.231305, 0.811871, 0.000347863, 0, 0.253057, 0.794397, 0.000350225, 0, 0.275797, 0.775726, 0.000349915, 0, 0.299525, 0.75617, 0.000347297, 0, 0.324242, 0.736091, 0.000344232, 0, 0.349947, 0.716213, 0.000340835, 0, 0.376633, 0.695736, 0.000332369, 0, 0.404289, 0.674961, 0.000327943, 0, 0.432895, 0.653518, 0.000318533, 0, 0.462415, 0.632574, 0.000310391, 0, 0.492788, 0.61134, 0.000300755, 0, 0.523909, 0.590017, 0.000290506, 0, 0.555556, 0.568752, 0.000280446, 0, 0.587302, 0.548061, 0.000269902, 0, 0.619048, 0.52711, 0.000258815, 0, 0.650794, 0.506682, 0.000248481, 0, 0.68254, 0.486524, 0.000237141, 0, 0.714286, 0.466812, 0.000226872, 0, 0.746032, 0.44732, 0.000216037, 0, 0.777778, 0.428473, 0.000205629, 0, 0.809524, 0.409921, 0.000195691, 0, 0.84127, 0.392028, 0.000185457, 0, 0.873016, 0.374606, 0.000176436, 0, 0.904762, 0.357601, 0.000166508, 0, 0.936508, 0.341348, 0.000158385, 0, 0.968254, 0.32542, 0.000149203, 0, 1, 1, 1.03967e-05, 0, 0, 1, 1.0397e-05, 0, 0, 1, 1.04019e-05, 0, 0, 0.999999, 1.04231e-05, 0, 0, 0.999998, 1.04806e-05, 0, 0, 0.999995, 1.06042e-05, 0, 0, 0.999991, 1.08366e-05, 0, 0, 0.999982, 1.12415e-05, 0, 0, 0.999968, 1.19174e-05, 0, 0, 0.99995, 1.30227e-05, 0, 0, 0.999922, 1.48176e-05, 0, 0, 0.999884, 1.77303e-05, 0, 0, 0.99983, 2.24564e-05, 0, 0, 0.999758, 3.00966e-05, 0, 0, 0.999654, 4.23193e-05, 0, 5.49083e-06, 0.999503, 6.14848e-05, 0, 0.000296087, 0.999237, 9.03576e-05, 0, 0.00123144, 0.998491, 0.0001271, 0, 0.00295954, 0.994594, 0.000107754, 0, 0.00555829, 0.99178, 0.000103025, 0, 0.00907209, 0.989265, 0.00011154, 0, 0.0135257, 0.986998, 0.000136296, 0, 0.0189327, 0.984137, 0.000169154, 0, 0.0252993, 0.979798, 0.000196671, 0, 0.0326272, 0.97337, 0.000196678, 0, 0.0409157, 0.967239, 0.000223121, 0, 0.0501623, 0.959543, 0.000253809, 0, 0.0603638, 0.949466, 0.000265972, 0, 0.0715171, 0.939074, 0.000288372, 0, 0.0836187, 0.931118, 0.000310983, 0, 0.0966657, 0.922525, 0.000325561, 0, 0.110656, 0.912983, 0.000345725, 0, 0.125588, 0.901617, 0.0003556, 0, 0.141461, 0.889487, 0.000374012, 0, 0.158275, 0.875787, 0.000383445, 0, 0.176031, 0.860654, 0.000393972, 0, 0.19473, 0.844417, 0.000400311, 0, 0.214374, 0.82741, 0.000405004, 0, 0.234967, 0.810545, 0.000407378, 0, 0.256512, 0.793312, 0.000407351, 0, 0.279011, 0.774847, 0.000406563, 0, 0.302468, 0.755621, 0.000404903, 0, 0.326887, 0.735511, 0.000397486, 0, 0.352266, 0.715435, 0.00039357, 0, 0.378605, 0.695403, 0.000384739, 0, 0.405897, 0.674681, 0.000376108, 0, 0.43413, 0.65359, 0.000365997, 0, 0.463277, 0.632471, 0.000354957, 0, 0.493295, 0.61151, 0.000343593, 0, 0.524106, 0.59064, 0.000331841, 0, 0.555561, 0.569386, 0.000318891, 0, 0.587302, 0.548785, 0.0003072, 0, 0.619048, 0.528146, 0.00029361, 0, 0.650794, 0.507872, 0.000281709, 0, 0.68254, 0.487805, 0.000268627, 0, 0.714286, 0.468196, 0.000255887, 0, 0.746032, 0.448922, 0.000243997, 0, 0.777778, 0.430093, 0.000231662, 0, 0.809524, 0.411845, 0.000220339, 0, 0.84127, 0.393808, 0.000208694, 0, 0.873016, 0.376615, 0.000198045, 0, 0.904762, 0.359655, 0.000187375, 0, 0.936508, 0.343452, 0.000177371, 0, 0.968254, 0.32765, 0.000167525, 0, 1, 1, 1.69351e-05, 0, 0, 1, 1.69356e-05, 0, 0, 1, 1.69427e-05, 0, 0, 0.999999, 1.69736e-05, 0, 0, 0.999998, 1.70575e-05, 0, 0, 0.999995, 1.72372e-05, 0, 0, 0.99999, 1.75739e-05, 0, 0, 0.999979, 1.81568e-05, 0, 0, 0.999966, 1.91206e-05, 0, 0, 0.999944, 2.0677e-05, 0, 0, 0.999912, 2.31644e-05, 0, 0, 0.999869, 2.71268e-05, 0, 0, 0.999811, 3.34272e-05, 0, 0, 0.99973, 4.33979e-05, 0, 0, 0.999617, 5.90083e-05, 0, 6.80315e-05, 0.999445, 8.29497e-05, 0, 0.000612796, 0.999138, 0.000118019, 0, 0.00187408, 0.998095, 0.000156712, 0, 0.00395791, 0.993919, 0.000125054, 0, 0.00692144, 0.991333, 0.000126091, 0, 0.0107962, 0.989226, 0.000144912, 0, 0.0155986, 0.986954, 0.000175737, 0, 0.0213364, 0.983982, 0.000213883, 0, 0.0280114, 0.979128, 0.000234526, 0, 0.0356226, 0.973327, 0.000243725, 0, 0.0441668, 0.967416, 0.0002773, 0, 0.0536399, 0.959729, 0.000308799, 0, 0.0640376, 0.949758, 0.000322447, 0, 0.0753554, 0.939173, 0.000350021, 0, 0.0875893, 0.9296, 0.000370089, 0, 0.100736, 0.921181, 0.000391365, 0, 0.114793, 0.91164, 0.000413636, 0, 0.129759, 0.900435, 0.000427068, 0, 0.145632, 0.888183, 0.000441046, 0, 0.162412, 0.874772, 0.000454968, 0, 0.180101, 0.859566, 0.000461882, 0, 0.1987, 0.843579, 0.000471556, 0, 0.218213, 0.826453, 0.000474335, 0, 0.238641, 0.809164, 0.000477078, 0, 0.259989, 0.792179, 0.00047755, 0, 0.282262, 0.773866, 0.000472573, 0, 0.305464, 0.754944, 0.000469765, 0, 0.329599, 0.735133, 0.000462371, 0, 0.35467, 0.714858, 0.000453674, 0, 0.380678, 0.694829, 0.000443888, 0, 0.407622, 0.674453, 0.000432052, 0, 0.435493, 0.653685, 0.000420315, 0, 0.464275, 0.632666, 0.000406829, 0, 0.493938, 0.611676, 0.000392234, 0, 0.524422, 0.591193, 0.000379208, 0, 0.555624, 0.570145, 0.00036319, 0, 0.587302, 0.549566, 0.000349111, 0, 0.619048, 0.529278, 0.000334166, 0, 0.650794, 0.509026, 0.000318456, 0, 0.68254, 0.489186, 0.00030449, 0, 0.714286, 0.469662, 0.000289051, 0, 0.746032, 0.450691, 0.000275494, 0, 0.777778, 0.431841, 0.000261437, 0, 0.809524, 0.413752, 0.000247846, 0, 0.84127, 0.395951, 0.000235085, 0, 0.873016, 0.378633, 0.000222245, 0, 0.904762, 0.36194, 0.000210533, 0, 0.936508, 0.345599, 0.000198494, 0, 0.968254, 0.329999, 0.000188133, 0, 1, 1, 2.69663e-05, 0, 0, 1, 2.6967e-05, 0, 0, 1, 2.69772e-05, 0, 0, 0.999999, 2.70214e-05, 0, 0, 0.999998, 2.71415e-05, 0, 0, 0.999994, 2.7398e-05, 0, 0, 0.999988, 2.78771e-05, 0, 0, 0.999977, 2.87019e-05, 0, 0, 0.999961, 3.00544e-05, 0, 0, 0.999937, 3.22138e-05, 0, 0, 0.999904, 3.56163e-05, 0, 0, 0.999854, 4.09465e-05, 0, 0, 0.99979, 4.92651e-05, 0, 0, 0.999699, 6.21722e-05, 0, 8.8288e-07, 0.999572, 8.19715e-05, 0, 0.000223369, 0.999381, 0.000111689, 0, 0.00105414, 0.999016, 0.000153862, 0, 0.0026493, 0.997437, 0.000187667, 0, 0.00508608, 0.993545, 0.000155672, 0, 0.00840554, 0.991135, 0.000161455, 0, 0.012629, 0.989157, 0.000188241, 0, 0.0177661, 0.986874, 0.000226229, 0, 0.0238198, 0.983714, 0.000268668, 0, 0.0307887, 0.978301, 0.000277109, 0, 0.0386688, 0.973227, 0.000303446, 0, 0.0474554, 0.967317, 0.000341851, 0, 0.0571428, 0.959477, 0.000370885, 0, 0.0677256, 0.950012, 0.000392753, 0, 0.0791988, 0.939484, 0.00042781, 0, 0.0915576, 0.928135, 0.000443866, 0, 0.104798, 0.919819, 0.000472959, 0, 0.118918, 0.910049, 0.000491551, 0, 0.133915, 0.899181, 0.000512616, 0, 0.149788, 0.886881, 0.000523563, 0, 0.166537, 0.87359, 0.000540183, 0, 0.184164, 0.858613, 0.000547386, 0, 0.202669, 0.842809, 0.000554809, 0, 0.222056, 0.825727, 0.000558316, 0, 0.242329, 0.808086, 0.000557824, 0, 0.263492, 0.790728, 0.000556346, 0, 0.285551, 0.772987, 0.000552672, 0, 0.30851, 0.7541, 0.000543738, 0, 0.332376, 0.734669, 0.000536107, 0, 0.357153, 0.714411, 0.000523342, 0, 0.382845, 0.694196, 0.000512238, 0, 0.409454, 0.674252, 0.000497465, 0, 0.436977, 0.65357, 0.000481096, 0, 0.465404, 0.632999, 0.000467054, 0, 0.494713, 0.611994, 0.000448771, 0, 0.524864, 0.591604, 0.000431889, 0, 0.555779, 0.571134, 0.000415238, 0, 0.587302, 0.550528, 0.000396369, 0, 0.619048, 0.530292, 0.000379477, 0, 0.650794, 0.510364, 0.000361488, 0, 0.68254, 0.490749, 0.000343787, 0, 0.714286, 0.471266, 0.000327822, 0, 0.746032, 0.452462, 0.000310626, 0, 0.777778, 0.433907, 0.000295352, 0, 0.809524, 0.415659, 0.000279179, 0, 0.84127, 0.398138, 0.000264685, 0, 0.873016, 0.380833, 0.000249905, 0, 0.904762, 0.364247, 0.000236282, 0, 0.936508, 0.348041, 0.000222905, 0, 0.968254, 0.332389, 0.000210522, 0, 1, 1, 4.20604e-05, 0, 0, 1, 4.20614e-05, 0, 0, 1, 4.20757e-05, 0, 0, 0.999999, 4.2138e-05, 0, 0, 0.999997, 4.23067e-05, 0, 0, 0.999993, 4.26668e-05, 0, 0, 0.999986, 4.33372e-05, 0, 0, 0.999974, 4.44857e-05, 0, 0, 0.999956, 4.63554e-05, 0, 0, 0.99993, 4.93105e-05, 0, 0, 0.999892, 5.39077e-05, 0, 0, 0.999838, 6.10005e-05, 0, 0, 0.999767, 7.18822e-05, 0, 0, 0.999666, 8.84581e-05, 0, 3.65471e-05, 0.999525, 0.000113398, 0, 0.000485623, 0.999311, 0.000150043, 0, 0.00162096, 0.998865, 0.000200063, 0, 0.00355319, 0.996278, 0.000211014, 0, 0.00633818, 0.992956, 0.000189672, 0, 0.0100043, 0.991017, 0.000210262, 0, 0.0145648, 0.989055, 0.000244292, 0, 0.0200237, 0.986741, 0.000290481, 0, 0.0263798, 0.983288, 0.000334303, 0, 0.033629, 0.977784, 0.000340307, 0, 0.0417652, 0.973037, 0.000377864, 0, 0.0507821, 0.967181, 0.0004239, 0, 0.060673, 0.958971, 0.000443854, 0, 0.0714314, 0.950093, 0.000483039, 0, 0.0830518, 0.939552, 0.000517934, 0, 0.0955288, 0.927678, 0.000539449, 0, 0.108859, 0.918278, 0.000568604, 0, 0.123038, 0.908449, 0.000588505, 0, 0.138065, 0.897713, 0.000612473, 0, 0.153938, 0.885533, 0.000625575, 0, 0.170657, 0.872131, 0.00063854, 0, 0.188224, 0.857517, 0.000647034, 0, 0.20664, 0.841796, 0.00065209, 0, 0.225909, 0.824726, 0.0006544, 0, 0.246035, 0.807297, 0.000655744, 0, 0.267022, 0.789058, 0.000646716, 0, 0.288878, 0.77189, 0.000643898, 0, 0.311607, 0.753082, 0.000629973, 0, 0.335216, 0.7341, 0.000621564, 0, 0.359713, 0.714094, 0.000605171, 0, 0.385103, 0.693839, 0.000588752, 0, 0.41139, 0.673891, 0.000573294, 0, 0.438576, 0.653565, 0.000552682, 0, 0.466656, 0.633326, 0.000533446, 0, 0.495617, 0.612582, 0.000514635, 0, 0.525431, 0.59205, 0.00049303, 0, 0.556041, 0.571918, 0.000471842, 0, 0.587338, 0.551572, 0.000451713, 0, 0.619048, 0.531553, 0.000430049, 0, 0.650794, 0.51175, 0.000410445, 0, 0.68254, 0.49238, 0.000390098, 0, 0.714286, 0.473143, 0.000370033, 0, 0.746032, 0.45423, 0.000351205, 0, 0.777778, 0.435963, 0.000332049, 0, 0.809524, 0.41787, 0.000315021, 0, 0.84127, 0.400387, 0.000297315, 0, 0.873016, 0.383332, 0.000281385, 0, 0.904762, 0.366665, 0.000265397, 0, 0.936508, 0.350633, 0.000250601, 0, 0.968254, 0.334964, 0.00023589, 0, 1, 1, 6.43736e-05, 0, 0, 1, 6.4375e-05, 0, 0, 1, 6.43947e-05, 0, 0, 0.999999, 6.4481e-05, 0, 0, 0.999997, 6.47143e-05, 0, 0, 0.999994, 6.52119e-05, 0, 0, 0.999985, 6.61359e-05, 0, 0, 0.999972, 6.77116e-05, 0, 0, 0.999952, 7.02599e-05, 0, 0, 0.999922, 7.42517e-05, 0, 0, 0.99988, 8.03906e-05, 0, 0, 0.99982, 8.97315e-05, 0, 0, 0.999741, 0.000103838, 0, 0, 0.999629, 0.00012496, 0, 0.000149024, 0.999474, 0.000156161, 0, 0.000861027, 0.999229, 0.000201034, 0, 0.00231198, 0.998662, 0.000259069, 0, 0.00458147, 0.995299, 0.000245439, 0, 0.00770895, 0.992732, 0.00024498, 0, 0.0117126, 0.990847, 0.000273211, 0, 0.0165989, 0.988911, 0.000316492, 0, 0.0223674, 0.98654, 0.00037161, 0, 0.0290135, 0.982636, 0.000410352, 0, 0.0365309, 0.977346, 0.000421756, 0, 0.0449117, 0.972909, 0.000475578, 0, 0.0541481, 0.966821, 0.000522482, 0, 0.0642326, 0.958686, 0.000545008, 0, 0.075158, 0.949754, 0.000589286, 0, 0.0869181, 0.939184, 0.000619995, 0, 0.0995074, 0.927505, 0.000654266, 0, 0.112922, 0.916606, 0.000682362, 0, 0.127157, 0.906707, 0.000704286, 0, 0.142212, 0.895937, 0.000725909, 0, 0.158085, 0.883913, 0.000743939, 0, 0.174776, 0.870642, 0.000755157, 0, 0.192287, 0.856241, 0.000764387, 0, 0.210619, 0.84069, 0.000771032, 0, 0.229775, 0.823728, 0.000765906, 0, 0.249761, 0.806481, 0.000767604, 0, 0.270582, 0.787924, 0.000754385, 0, 0.292243, 0.770588, 0.000749668, 0, 0.314753, 0.751991, 0.000731613, 0, 0.338118, 0.733407, 0.000717655, 0, 0.362347, 0.713688, 0.000700604, 0, 0.387447, 0.693595, 0.000678765, 0, 0.413424, 0.673426, 0.000657042, 0, 0.440284, 0.65359, 0.000635892, 0, 0.468027, 0.633576, 0.000611569, 0, 0.496645, 0.613144, 0.000586011, 0, 0.526122, 0.592711, 0.000563111, 0, 0.556417, 0.572722, 0.000537699, 0, 0.587451, 0.552762, 0.000512556, 0, 0.619048, 0.532985, 0.000489757, 0, 0.650794, 0.513219, 0.000464139, 0, 0.68254, 0.493992, 0.000442193, 0, 0.714286, 0.47509, 0.000418629, 0, 0.746032, 0.456287, 0.000397045, 0, 0.777778, 0.438152, 0.000375504, 0, 0.809524, 0.420294, 0.00035492, 0, 0.84127, 0.402749, 0.000335327, 0, 0.873016, 0.385879, 0.000316422, 0, 0.904762, 0.369352, 0.000298333, 0, 0.936508, 0.353301, 0.000281417, 0, 0.968254, 0.337781, 0.000265203, 0, 1, 1, 9.68267e-05, 0, 0, 1, 9.68284e-05, 0, 0, 1, 9.68556e-05, 0, 0, 0.999999, 9.69733e-05, 0, 0, 0.999997, 9.72913e-05, 0, 0, 0.999993, 9.79688e-05, 0, 0, 0.999984, 9.92239e-05, 0, 0, 0.999969, 0.000101356, 0, 0, 0.999946, 0.000104784, 0, 0, 0.999913, 0.000110111, 0, 0, 0.999868, 0.000118217, 0, 0, 0.999801, 0.000130396, 0, 0, 0.999712, 0.000148523, 0, 1.24907e-05, 0.999589, 0.000175233, 0, 0.000355405, 0.999416, 0.000213999, 0, 0.0013528, 0.999136, 0.000268529, 0, 0.00312557, 0.998367, 0.000333088, 0, 0.00573045, 0.994701, 0.000304757, 0, 0.00919397, 0.992497, 0.000318031, 0, 0.0135261, 0.990608, 0.000353863, 0, 0.0187278, 0.988715, 0.000409044, 0, 0.0247947, 0.986241, 0.000472967, 0, 0.0317196, 0.981696, 0.000495104, 0, 0.039494, 0.977097, 0.000532873, 0, 0.0481087, 0.972583, 0.000594447, 0, 0.0575549, 0.966142, 0.000636867, 0, 0.0678242, 0.95823, 0.000669899, 0, 0.0789089, 0.949677, 0.000719499, 0, 0.0908023, 0.939226, 0.000750584, 0, 0.103499, 0.927501, 0.000793183, 0, 0.116993, 0.915199, 0.00081995, 0, 0.131282, 0.90498, 0.000847654, 0, 0.146364, 0.894243, 0.000868929, 0, 0.162237, 0.882154, 0.000884278, 0, 0.178902, 0.869161, 0.000898108, 0, 0.196358, 0.854751, 0.000901254, 0, 0.21461, 0.839368, 0.00090679, 0, 0.23366, 0.822874, 0.000901541, 0, 0.253512, 0.805514, 0.000897297, 0, 0.274174, 0.78716, 0.000881856, 0, 0.29565, 0.769061, 0.000870032, 0, 0.31795, 0.751, 0.000851719, 0, 0.341081, 0.732614, 0.000830671, 0, 0.365053, 0.713171, 0.000806569, 0, 0.389874, 0.693472, 0.00078338, 0, 0.415553, 0.673528, 0.000756404, 0, 0.442098, 0.653397, 0.000726872, 0, 0.469512, 0.633781, 0.000700494, 0, 0.497794, 0.613877, 0.00067105, 0, 0.526935, 0.593506, 0.000640361, 0, 0.556908, 0.573667, 0.000613502, 0, 0.587657, 0.553932, 0.000583177, 0, 0.61906, 0.534345, 0.000554375, 0, 0.650794, 0.515042, 0.000527811, 0, 0.68254, 0.495674, 0.000499367, 0, 0.714286, 0.477132, 0.00047429, 0, 0.746032, 0.458609, 0.000447726, 0, 0.777778, 0.440354, 0.000424205, 0, 0.809524, 0.422765, 0.000399549, 0, 0.84127, 0.405472, 0.000378315, 0, 0.873016, 0.388482, 0.000355327, 0, 0.904762, 0.372191, 0.000336122, 0, 0.936508, 0.356099, 0.000315247, 0, 0.968254, 0.340737, 0.00029794, 0, 1, 1, 0.000143327, 0, 0, 1, 0.00014333, 0, 0, 1, 0.000143366, 0, 0, 0.999999, 0.000143524, 0, 0, 0.999996, 0.000143952, 0, 0, 0.999991, 0.000144862, 0, 0, 0.999981, 0.000146544, 0, 0, 0.999966, 0.000149391, 0, 0, 0.999941, 0.000153946, 0, 0, 0.999905, 0.000160971, 0, 0, 0.999852, 0.000171562, 0, 0, 0.99978, 0.00018729, 0, 0, 0.999681, 0.000210386, 0, 8.26239e-05, 0.999546, 0.000243906, 0, 0.000664807, 0.999352, 0.000291739, 0, 0.00196192, 0.999027, 0.000357419, 0, 0.00405941, 0.997886, 0.000422349, 0, 0.00699664, 0.99419, 0.000385008, 0, 0.0107896, 0.99214, 0.000409775, 0, 0.0154415, 0.990274, 0.000456418, 0, 0.0209488, 0.988455, 0.000527008, 0, 0.0273037, 0.985804, 0.000597685, 0, 0.0344969, 0.98103, 0.000613124, 0, 0.0425183, 0.976674, 0.000668321, 0, 0.0513575, 0.972021, 0.000736985, 0, 0.0610046, 0.965274, 0.000773789, 0, 0.0714508, 0.958046, 0.000830852, 0, 0.0826877, 0.949333, 0.000875766, 0, 0.0947085, 0.939135, 0.000917088, 0, 0.107507, 0.927119, 0.000952244, 0, 0.121078, 0.91469, 0.000990626, 0, 0.135419, 0.903006, 0.00101304, 0, 0.150526, 0.892368, 0.00103834, 0, 0.166399, 0.880231, 0.00105002, 0, 0.183038, 0.867432, 0.00106331, 0, 0.200443, 0.853208, 0.00106783, 0, 0.218618, 0.837956, 0.00106458, 0, 0.237566, 0.821772, 0.00105945, 0, 0.257291, 0.804328, 0.00104685, 0, 0.2778, 0.786465, 0.00103178, 0, 0.2991, 0.768004, 0.00101077, 0, 0.321199, 0.74972, 0.000985504, 0, 0.344106, 0.731682, 0.000962893, 0, 0.36783, 0.712813, 0.000932146, 0, 0.392383, 0.693139, 0.00089871, 0, 0.417774, 0.673566, 0.000869678, 0, 0.444013, 0.653483, 0.000835525, 0, 0.471107, 0.633891, 0.000799853, 0, 0.49906, 0.614433, 0.000766838, 0, 0.527869, 0.594586, 0.000732227, 0, 0.557517, 0.574769, 0.000696442, 0, 0.587966, 0.555149, 0.000663935, 0, 0.61913, 0.535898, 0.000629826, 0, 0.650794, 0.516753, 0.000596486, 0, 0.68254, 0.497816, 0.000567078, 0, 0.714286, 0.479034, 0.000534399, 0, 0.746032, 0.460975, 0.000507013, 0, 0.777778, 0.442935, 0.000477421, 0, 0.809524, 0.425263, 0.000451101, 0, 0.84127, 0.408248, 0.000424964, 0, 0.873016, 0.391339, 0.00039993, 0, 0.904762, 0.37513, 0.000377619, 0, 0.936508, 0.359172, 0.000354418, 0, 0.968254, 0.343876, 0.000334823, 0, 1, 1, 0.000209042, 0, 0, 1, 0.000209045, 0, 0, 1, 0.000209093, 0, 0, 0.999999, 0.000209304, 0, 0, 0.999996, 0.000209871, 0, 0, 0.999991, 0.000211078, 0, 0, 0.999979, 0.000213304, 0, 0, 0.999963, 0.000217061, 0, 0, 0.999933, 0.000223042, 0, 0, 0.999894, 0.000232206, 0, 0, 0.999837, 0.000245901, 0, 0, 0.999756, 0.000266023, 0, 1.02927e-06, 0.999648, 0.000295204, 0, 0.000233468, 0.999499, 0.000336958, 0, 0.00108237, 0.999283, 0.000395563, 0, 0.00268832, 0.998896, 0.000473785, 0, 0.00511138, 0.997006, 0.000520008, 0, 0.00837705, 0.993819, 0.000497261, 0, 0.0124928, 0.991632, 0.000523722, 0, 0.0174561, 0.989875, 0.000587258, 0, 0.0232596, 0.988109, 0.000676329, 0, 0.0298932, 0.985155, 0.000747701, 0, 0.0373453, 0.980479, 0.000768803, 0, 0.0456045, 0.976271, 0.000841054, 0, 0.0546593, 0.971347, 0.000911469, 0, 0.0644994, 0.964528, 0.000953057, 0, 0.0751152, 0.957632, 0.00102221, 0, 0.0864981, 0.948681, 0.00106122, 0, 0.0986407, 0.938716, 0.00111857, 0, 0.111537, 0.926629, 0.00114762, 0, 0.125182, 0.914025, 0.00118995, 0, 0.139571, 0.901026, 0.00121228, 0, 0.154703, 0.890358, 0.00123946, 0, 0.170576, 0.878283, 0.0012527, 0, 0.18719, 0.865459, 0.00125536, 0, 0.204547, 0.851407, 0.00126134, 0, 0.222648, 0.836276, 0.00124759, 0, 0.241498, 0.820436, 0.00124443, 0, 0.261101, 0.803253, 0.00122071, 0, 0.281465, 0.785562, 0.00120107, 0, 0.302595, 0.76718, 0.00117762, 0, 0.324501, 0.748551, 0.00114289, 0, 0.347192, 0.730564, 0.00110872, 0, 0.370679, 0.712253, 0.00107636, 0, 0.394973, 0.692867, 0.00103646, 0, 0.420085, 0.673695, 0.000996793, 0, 0.446027, 0.653912, 0.00095675, 0, 0.47281, 0.634129, 0.000916739, 0, 0.500441, 0.615004, 0.000874401, 0, 0.528921, 0.595587, 0.000833411, 0, 0.558244, 0.575965, 0.000794556, 0, 0.588384, 0.5566, 0.00075196, 0, 0.619281, 0.537428, 0.000716381, 0, 0.650795, 0.518623, 0.000676558, 0, 0.68254, 0.499964, 0.00064074, 0, 0.714286, 0.481356, 0.000605984, 0, 0.746032, 0.463279, 0.000570256, 0, 0.777778, 0.445673, 0.000540138, 0, 0.809524, 0.428032, 0.000507299, 0, 0.84127, 0.411112, 0.000479553, 0, 0.873016, 0.394444, 0.000450737, 0, 0.904762, 0.378247, 0.000424269, 0, 0.936508, 0.362415, 0.000399111, 0, 0.968254, 0.347103, 0.000375274, 0, 1, 1, 0.000300729, 0, 0, 1, 0.000300733, 0, 0, 1, 0.000300797, 0, 0, 0.999998, 0.000301072, 0, 0, 0.999996, 0.000301817, 0, 0, 0.999989, 0.000303398, 0, 0, 0.999977, 0.000306309, 0, 0, 0.999958, 0.000311209, 0, 0, 0.999927, 0.000318975, 0, 0, 0.999884, 0.000330804, 0, 0, 0.99982, 0.00034834, 0, 0, 0.999733, 0.000373854, 0, 3.26995e-05, 0.999613, 0.000410424, 0, 0.000477174, 0.999447, 0.000462047, 0, 0.00161099, 0.999204, 0.000533322, 0, 0.00353153, 0.998725, 0.000624964, 0, 0.00627965, 0.995871, 0.000631786, 0, 0.0098693, 0.993194, 0.000632017, 0, 0.0143011, 0.991541, 0.00068923, 0, 0.019568, 0.989773, 0.000766892, 0, 0.0256593, 0.987647, 0.000863668, 0, 0.0325625, 0.984193, 0.000922089, 0, 0.0402647, 0.980016, 0.000970749, 0, 0.0487532, 0.975859, 0.00106027, 0, 0.058016, 0.970514, 0.00112239, 0, 0.0680419, 0.963625, 0.00117212, 0, 0.0788208, 0.956959, 0.00125211, 0, 0.0903439, 0.947956, 0.00129411, 0, 0.102604, 0.93809, 0.00135879, 0, 0.115594, 0.92659, 0.00139309, 0, 0.129309, 0.913829, 0.00143253, 0, 0.143745, 0.90005, 0.00145809, 0, 0.158901, 0.888129, 0.0014748, 0, 0.174774, 0.87607, 0.00148756, 0, 0.191365, 0.863461, 0.00148714, 0, 0.208674, 0.849594, 0.00148892, 0, 0.226705, 0.834531, 0.00146496, 0, 0.245461, 0.81903, 0.0014579, 0, 0.264947, 0.802122, 0.00143039, 0, 0.28517, 0.78445, 0.00139717, 0, 0.306137, 0.766434, 0.00136312, 0, 0.327857, 0.747816, 0.00132597, 0, 0.350341, 0.729519, 0.00128323, 0, 0.373598, 0.711454, 0.00123803, 0, 0.397642, 0.692699, 0.00119097, 0, 0.422485, 0.673723, 0.00114565, 0, 0.448139, 0.654386, 0.00109552, 0, 0.474619, 0.634673, 0.00104553, 0, 0.501933, 0.615554, 0.00099985, 0, 0.530089, 0.596462, 0.000948207, 0, 0.559087, 0.577385, 0.000902299, 0, 0.588913, 0.558257, 0.000856448, 0, 0.619525, 0.5392, 0.000810395, 0, 0.650826, 0.520543, 0.000768558, 0, 0.68254, 0.502206, 0.0007239, 0, 0.714286, 0.48402, 0.000685794, 0, 0.746032, 0.465779, 0.00064471, 0, 0.777778, 0.448455, 0.000609583, 0, 0.809524, 0.431091, 0.00057227, 0, 0.84127, 0.414147, 0.00054042, 0, 0.873016, 0.39765, 0.000506545, 0, 0.904762, 0.381576, 0.000477635, 0, 0.936508, 0.365881, 0.000448446, 0, 0.968254, 0.350582, 0.000421424, 0, 1, 1, 0.000427144, 0, 0, 1, 0.000427151, 0, 0, 1, 0.000427232, 0, 0, 0.999998, 0.00042759, 0, 0, 0.999995, 0.000428555, 0, 0, 0.999988, 0.000430603, 0, 0, 0.999976, 0.000434368, 0, 0, 0.999952, 0.000440688, 0, 0, 0.999919, 0.000450667, 0, 0, 0.999871, 0.00046578, 0, 0, 0.999801, 0.000488024, 0, 0, 0.999704, 0.000520092, 0, 0.000129791, 0.999572, 0.000565553, 0, 0.000821056, 0.999389, 0.000628906, 0, 0.00225241, 0.999114, 0.000714911, 0, 0.00449109, 0.998488, 0.000819218, 0, 0.00756249, 0.995234, 0.00080415, 0, 0.0114716, 0.993021, 0.000830181, 0, 0.0162131, 0.991407, 0.000902645, 0, 0.021776, 0.989625, 0.000996934, 0, 0.0281471, 0.987064, 0.00109707, 0, 0.0353118, 0.983265, 0.00114353, 0, 0.0432562, 0.979535, 0.0012272, 0, 0.0519665, 0.975224, 0.00132642, 0, 0.0614298, 0.969574, 0.00138092, 0, 0.0716348, 0.963021, 0.00145896, 0, 0.0825709, 0.956046, 0.00152834, 0, 0.094229, 0.947136, 0.00158217, 0, 0.106602, 0.937313, 0.0016347, 0, 0.119682, 0.926073, 0.00168383, 0, 0.133465, 0.913121, 0.00171627, 0, 0.147947, 0.899165, 0.00174229, 0, 0.163125, 0.885891, 0.00176137, 0, 0.178998, 0.873783, 0.00176406, 0, 0.195566, 0.861331, 0.00176156, 0, 0.21283, 0.847569, 0.00175346, 0, 0.230793, 0.832785, 0.00172753, 0, 0.249459, 0.817442, 0.00170204, 0, 0.268832, 0.800613, 0.00166576, 0, 0.28892, 0.783597, 0.00162909, 0, 0.30973, 0.76571, 0.0015826, 0, 0.331271, 0.747021, 0.00153106, 0, 0.353554, 0.728593, 0.00148036, 0, 0.37659, 0.710661, 0.00142808, 0, 0.400391, 0.692426, 0.00136906, 0, 0.424973, 0.673623, 0.00131066, 0, 0.450347, 0.65494, 0.00125569, 0, 0.476531, 0.635448, 0.00119517, 0, 0.503535, 0.616221, 0.00113828, 0, 0.531372, 0.597531, 0.0010816, 0, 0.560047, 0.578795, 0.00102673, 0, 0.589554, 0.559892, 0.000970985, 0, 0.619869, 0.541307, 0.000919773, 0, 0.650923, 0.522608, 0.000868479, 0, 0.68254, 0.504484, 0.00082137, 0, 0.714286, 0.486603, 0.000772916, 0, 0.746032, 0.468802, 0.000730353, 0, 0.777778, 0.451172, 0.000684955, 0, 0.809524, 0.434348, 0.000647565, 0, 0.84127, 0.417445, 0.000605863, 0, 0.873016, 0.401077, 0.000571885, 0, 0.904762, 0.385039, 0.000536034, 0, 0.936508, 0.369483, 0.000504227, 0, 0.968254, 0.354272, 0.000473165, 0, 1, 1, 0.000599525, 0, 0, 1, 0.000599533, 0, 0, 1, 0.000599639, 0, 0, 0.999998, 0.000600097, 0, 0, 0.999994, 0.000601336, 0, 0, 0.999987, 0.000603958, 0, 0, 0.999972, 0.000608775, 0, 0, 0.999949, 0.000616842, 0, 0, 0.999912, 0.000629534, 0, 0, 0.999857, 0.000648658, 0, 0, 0.999781, 0.000676615, 0, 5.38873e-06, 0.999674, 0.000716574, 0, 0.000308602, 0.999528, 0.000772641, 0, 0.00127003, 0.999326, 0.000849806, 0, 0.00300783, 0.999009, 0.000952682, 0, 0.00556637, 0.998112, 0.00106394, 0, 0.00895889, 0.994496, 0.00102228, 0, 0.0131827, 0.992806, 0.00108586, 0, 0.0182277, 0.991211, 0.0011759, 0, 0.0240795, 0.989415, 0.00128955, 0, 0.030723, 0.986499, 0.00139038, 0, 0.0381418, 0.982679, 0.00144539, 0, 0.046321, 0.978839, 0.00153954, 0, 0.0552459, 0.974295, 0.00164417, 0, 0.0649034, 0.968784, 0.00171517, 0, 0.0752814, 0.962324, 0.00180282, 0, 0.0863693, 0.954956, 0.00186387, 0, 0.0981578, 0.94624, 0.00193817, 0, 0.110639, 0.936517, 0.00198156, 0, 0.123806, 0.925186, 0.00203042, 0, 0.137655, 0.91252, 0.0020664, 0, 0.15218, 0.898441, 0.00207822, 0, 0.16738, 0.884394, 0.0020992, 0, 0.183253, 0.871273, 0.00208748, 0, 0.199799, 0.859057, 0.00208686, 0, 0.21702, 0.845243, 0.00205519, 0, 0.234918, 0.830723, 0.00202868, 0, 0.253496, 0.815801, 0.00199501, 0, 0.272761, 0.79914, 0.00194193, 0, 0.292719, 0.782372, 0.00188824, 0, 0.313377, 0.76482, 0.00183695, 0, 0.334745, 0.746586, 0.00177418, 0, 0.356833, 0.7281, 0.00170628, 0, 0.379654, 0.709842, 0.00164063, 0, 0.403221, 0.692019, 0.00157355, 0, 0.427548, 0.67364, 0.00150262, 0, 0.452651, 0.655277, 0.00143473, 0, 0.478545, 0.636438, 0.00136371, 0, 0.505246, 0.617364, 0.00129911, 0, 0.532768, 0.598603, 0.00123014, 0, 0.561122, 0.580195, 0.00116587, 0, 0.590309, 0.561786, 0.00110398, 0, 0.620318, 0.543377, 0.00104148, 0, 0.651102, 0.525093, 0.000983984, 0, 0.682545, 0.506791, 0.00092667, 0, 0.714286, 0.489291, 0.000874326, 0, 0.746032, 0.471811, 0.000821734, 0, 0.777778, 0.454435, 0.000774698, 0, 0.809524, 0.437493, 0.000727302, 0, 0.84127, 0.420977, 0.000684039, 0, 0.873016, 0.404729, 0.00064373, 0, 0.904762, 0.388756, 0.00060285, 0, 0.936508, 0.373344, 0.00056765, 0, 0.968254, 0.358191, 0.000531929, 0, 1, 1, 0.000832169, 0, 0, 1, 0.000832178, 0, 0, 1, 0.00083231, 0, 0, 0.999998, 0.000832893, 0, 0, 0.999995, 0.000834465, 0, 0, 0.999985, 0.000837791, 0, 0, 0.999969, 0.000843893, 0, 0, 0.999944, 0.000854086, 0, 0, 0.999903, 0.000870071, 0, 0, 0.999843, 0.000894042, 0, 0, 0.999759, 0.000928865, 0, 5.31805e-05, 0.999643, 0.000978242, 0, 0.000579365, 0.99948, 0.00104684, 0, 0.00182774, 0.999255, 0.00114012, 0, 0.00387804, 0.998885, 0.00126188, 0, 0.00675709, 0.997405, 0.00135888, 0, 0.010468, 0.99424, 0.00133626, 0, 0.0150018, 0.992458, 0.00140905, 0, 0.0203443, 0.990929, 0.00152305, 0, 0.0264786, 0.989116, 0.00165882, 0, 0.0333875, 0.985624, 0.00174128, 0, 0.0410536, 0.982003, 0.00182108, 0, 0.0494609, 0.978336, 0.00194498, 0, 0.0585941, 0.973184, 0.00202708, 0, 0.0684396, 0.9678, 0.00212166, 0, 0.0789851, 0.961348, 0.00221366, 0, 0.0902199, 0.953841, 0.00228219, 0, 0.102134, 0.94534, 0.00235662, 0, 0.114721, 0.935552, 0.00240572, 0, 0.127972, 0.924064, 0.00244405, 0, 0.141884, 0.911827, 0.00247557, 0, 0.156451, 0.897731, 0.00248374, 0, 0.171672, 0.883409, 0.00249863, 0, 0.187545, 0.868625, 0.00246688, 0, 0.20407, 0.856529, 0.00246523, 0, 0.221249, 0.842999, 0.00242368, 0, 0.239083, 0.828505, 0.00237354, 0, 0.257578, 0.813825, 0.00232588, 0, 0.276738, 0.797813, 0.00226731, 0, 0.296569, 0.781097, 0.00219704, 0, 0.31708, 0.764038, 0.00212394, 0, 0.338281, 0.746067, 0.00204786, 0, 0.360181, 0.727687, 0.00196728, 0, 0.382794, 0.709571, 0.00188779, 0, 0.406133, 0.691503, 0.00180532, 0, 0.430213, 0.673673, 0.00171849, 0, 0.45505, 0.655732, 0.00164147, 0, 0.480662, 0.637399, 0.00155858, 0, 0.507065, 0.618616, 0.00147641, 0, 0.534278, 0.60005, 0.00140125, 0, 0.562313, 0.581713, 0.00132441, 0, 0.59118, 0.563546, 0.00125014, 0, 0.620875, 0.545605, 0.00118249, 0, 0.651373, 0.527559, 0.0011116, 0, 0.682593, 0.509764, 0.00104979, 0, 0.714286, 0.49193, 0.000985977, 0, 0.746032, 0.475011, 0.000928592, 0, 0.777778, 0.457878, 0.000873466, 0, 0.809524, 0.440979, 0.000819585, 0, 0.84127, 0.424613, 0.000772365, 0, 0.873016, 0.408549, 0.000722195, 0, 0.904762, 0.392771, 0.000680014, 0, 0.936508, 0.377317, 0.000636797, 0, 0.968254, 0.362352, 0.000598318, 0, 1, 1, 0.00114313, 0, 0, 1, 0.00114314, 0, 0, 0.999999, 0.00114331, 0, 0, 0.999998, 0.00114404, 0, 0, 0.999994, 0.00114601, 0, 0, 0.999984, 0.00115019, 0, 0, 0.999967, 0.00115784, 0, 0, 0.999937, 0.0011706, 0, 0, 0.999894, 0.00119054, 0, 0, 0.999828, 0.00122031, 0, 0, 0.999735, 0.00126331, 0, 0.000169263, 0.999606, 0.00132382, 0, 0.000949167, 0.999426, 0.0014071, 0, 0.00249668, 0.999173, 0.00151895, 0, 0.00486392, 0.99873, 0.00166102, 0, 0.00806323, 0.996243, 0.0017023, 0, 0.0120895, 0.993779, 0.00172782, 0, 0.0169288, 0.9919, 0.0018108, 0, 0.0225633, 0.990524, 0.00196028, 0, 0.028974, 0.98868, 0.00212014, 0, 0.036142, 0.984663, 0.00217598, 0, 0.044049, 0.981457, 0.00230563, 0, 0.0526781, 0.977608, 0.00243966, 0, 0.0620137, 0.972215, 0.00251336, 0, 0.0720418, 0.966798, 0.0026285, 0, 0.0827499, 0.960241, 0.00271409, 0, 0.0941271, 0.952489, 0.00278381, 0, 0.106164, 0.944127, 0.00285399, 0, 0.118852, 0.934282, 0.00290994, 0, 0.132185, 0.923271, 0.00294558, 0, 0.146157, 0.910803, 0.00296269, 0, 0.160766, 0.896705, 0.00296803, 0, 0.176007, 0.88238, 0.00296637, 0, 0.19188, 0.867116, 0.00293163, 0, 0.208385, 0.853636, 0.00289418, 0, 0.225523, 0.840469, 0.00284663, 0, 0.243296, 0.82639, 0.00278594, 0, 0.261709, 0.811759, 0.00271618, 0, 0.280767, 0.796113, 0.00263187, 0, 0.300476, 0.779518, 0.00254589, 0, 0.320845, 0.763142, 0.00246003, 0, 0.341883, 0.745464, 0.00236529, 0, 0.363601, 0.727491, 0.00226536, 0, 0.386011, 0.709414, 0.00216375, 0, 0.409128, 0.691396, 0.00207127, 0, 0.432967, 0.67368, 0.00197106, 0, 0.457545, 0.656049, 0.00187022, 0, 0.482881, 0.638188, 0.00177605, 0, 0.508992, 0.620177, 0.00168482, 0, 0.535899, 0.601506, 0.00158909, 0, 0.563619, 0.58362, 0.00150583, 0, 0.592165, 0.565496, 0.00141791, 0, 0.621544, 0.54789, 0.00133693, 0, 0.651743, 0.530323, 0.00126038, 0, 0.682709, 0.512795, 0.00118556, 0, 0.714286, 0.495199, 0.00111527, 0, 0.746032, 0.478101, 0.0010489, 0, 0.777778, 0.461511, 0.000984264, 0, 0.809524, 0.444879, 0.00092591, 0, 0.84127, 0.428424, 0.000866582, 0, 0.873016, 0.412495, 0.000814463, 0, 0.904762, 0.396975, 0.000764498, 0, 0.936508, 0.381614, 0.000715967, 0, 0.968254, 0.366732, 0.000672483, 0, 1, 1, 0.00155501, 0, 0, 1, 0.00155503, 0, 0, 1, 0.00155524, 0, 0, 0.999998, 0.00155615, 0, 0, 0.999994, 0.0015586, 0, 0, 0.999983, 0.00156379, 0, 0, 0.999963, 0.0015733, 0, 0, 0.999932, 0.00158911, 0, 0, 0.999882, 0.00161376, 0, 0, 0.99981, 0.00165041, 0, 1.00875e-05, 0.999708, 0.00170304, 0, 0.000367658, 0.999565, 0.00177658, 0, 0.0014234, 0.999368, 0.00187688, 0, 0.00327939, 0.999081, 0.00200989, 0, 0.00596629, 0.99852, 0.00217177, 0, 0.0094852, 0.99549, 0.0021745, 0, 0.013824, 0.993252, 0.00222357, 0, 0.0189642, 0.991727, 0.00235022, 0, 0.0248856, 0.989951, 0.00250561, 0, 0.0315669, 0.988029, 0.00268829, 0, 0.0389882, 0.984029, 0.0027496, 0, 0.0471302, 0.980683, 0.00289793, 0, 0.0559754, 0.976554, 0.00303315, 0, 0.0655081, 0.97139, 0.00313257, 0, 0.0757138, 0.965544, 0.00323656, 0, 0.08658, 0.95912, 0.00333432, 0, 0.0980954, 0.951183, 0.0034039, 0, 0.110251, 0.942974, 0.00347515, 0, 0.123038, 0.932642, 0.00350381, 0, 0.13645, 0.922158, 0.00354519, 0, 0.150482, 0.909404, 0.00353851, 0, 0.165129, 0.896071, 0.0035435, 0, 0.18039, 0.881206, 0.00349936, 0, 0.196263, 0.866077, 0.00347256, 0, 0.212748, 0.85093, 0.003415, 0, 0.229847, 0.837703, 0.00333367, 0, 0.247561, 0.823878, 0.003249, 0, 0.265895, 0.809449, 0.00316347, 0, 0.284854, 0.794379, 0.00306351, 0, 0.304445, 0.778138, 0.0029499, 0, 0.324675, 0.761997, 0.00284099, 0, 0.345555, 0.744938, 0.00272104, 0, 0.367095, 0.727212, 0.00260715, 0, 0.389309, 0.709549, 0.00248855, 0, 0.41221, 0.691704, 0.00236783, 0, 0.435814, 0.673689, 0.00225178, 0, 0.460138, 0.656453, 0.00213765, 0, 0.485203, 0.639128, 0.00202178, 0, 0.511028, 0.621512, 0.00191443, 0, 0.537634, 0.603598, 0.00180977, 0, 0.565041, 0.58559, 0.00170456, 0, 0.593268, 0.567852, 0.00160927, 0, 0.622327, 0.5503, 0.00151395, 0, 0.652217, 0.533033, 0.00142499, 0, 0.682907, 0.515942, 0.00133955, 0, 0.714296, 0.498814, 0.0012602, 0, 0.746032, 0.481595, 0.00118188, 0, 0.777778, 0.465117, 0.00111171, 0, 0.809524, 0.448865, 0.00104091, 0, 0.84127, 0.432711, 0.000976618, 0, 0.873016, 0.416822, 0.00091859, 0, 0.904762, 0.401272, 0.000857704, 0, 0.936508, 0.386226, 0.000807172, 0, 0.968254, 0.371321, 0.00075464, 0, 1, 1, 0.00209596, 0, 0, 1, 0.00209598, 0, 0, 1, 0.00209624, 0, 0, 0.999997, 0.00209736, 0, 0, 0.999991, 0.00210039, 0, 0, 0.999979, 0.00210678, 0, 0, 0.999959, 0.00211847, 0, 0, 0.999925, 0.0021379, 0, 0, 0.99987, 0.00216809, 0, 0, 0.999791, 0.00221281, 0, 6.81487e-05, 0.999677, 0.00227669, 0, 0.000658161, 0.999521, 0.00236533, 0, 0.00200635, 0.999301, 0.00248514, 0, 0.0041779, 0.998977, 0.00264185, 0, 0.00718648, 0.998191, 0.00281695, 0, 0.0110239, 0.994801, 0.00278518, 0, 0.015672, 0.993091, 0.00288774, 0, 0.0211091, 0.991571, 0.00303931, 0, 0.0273123, 0.9897, 0.00321643, 0, 0.034259, 0.987023, 0.00337332, 0, 0.0419282, 0.983289, 0.00346146, 0, 0.0502998, 0.979892, 0.00363704, 0, 0.0593562, 0.975111, 0.00373601, 0, 0.069081, 0.970351, 0.0038842, 0, 0.0794598, 0.964131, 0.00397053, 0, 0.0904798, 0.957747, 0.00408078, 0, 0.10213, 0.949536, 0.00413533, 0, 0.1144, 0.941372, 0.00420305, 0, 0.127284, 0.931049, 0.00422815, 0, 0.140772, 0.920647, 0.00425048, 0, 0.154862, 0.908033, 0.0042281, 0, 0.169548, 0.895028, 0.00422026, 0, 0.184828, 0.879968, 0.00415042, 0, 0.200701, 0.864875, 0.00408821, 0, 0.217167, 0.84918, 0.00400909, 0, 0.234227, 0.834934, 0.00391178, 0, 0.251884, 0.821397, 0.00380066, 0, 0.270141, 0.807135, 0.00367974, 0, 0.289004, 0.792363, 0.00355172, 0, 0.308479, 0.776661, 0.003411, 0, 0.328575, 0.760705, 0.00328123, 0, 0.349301, 0.744408, 0.00314003, 0, 0.370668, 0.726994, 0.0029906, 0, 0.392689, 0.709598, 0.00285034, 0, 0.415379, 0.692112, 0.00271179, 0, 0.438754, 0.674435, 0.00257185, 0, 0.46283, 0.65676, 0.00243425, 0, 0.48763, 0.639982, 0.00230351, 0, 0.513173, 0.622983, 0.0021777, 0, 0.539482, 0.605471, 0.00204991, 0, 0.566579, 0.58796, 0.00193759, 0, 0.594488, 0.570463, 0.00181976, 0, 0.623226, 0.553058, 0.00171497, 0, 0.6528, 0.535894, 0.00161109, 0, 0.683198, 0.519089, 0.00151394, 0, 0.714354, 0.502454, 0.00142122, 0, 0.746032, 0.485681, 0.00133488, 0, 0.777778, 0.468935, 0.00124975, 0, 0.809524, 0.452951, 0.00117309, 0, 0.84127, 0.437139, 0.00110155, 0, 0.873016, 0.421446, 0.00103124, 0, 0.904762, 0.405951, 0.000966387, 0, 0.936508, 0.391003, 0.000908119, 0, 0.968254, 0.376198, 0.000848057, 0, 1, 1, 0.00280076, 0, 0, 1, 0.00280078, 0, 0, 0.999999, 0.00280109, 0, 0, 0.999997, 0.00280246, 0, 0, 0.999992, 0.00280616, 0, 0, 0.999979, 0.00281396, 0, 0, 0.999956, 0.00282822, 0, 0, 0.999916, 0.00285186, 0, 0, 0.999857, 0.0028885, 0, 0, 0.999768, 0.00294259, 0, 0.000196026, 0.999645, 0.00301946, 0, 0.00104842, 0.99947, 0.00312541, 0, 0.00270199, 0.999229, 0.00326733, 0, 0.00519449, 0.998852, 0.00344992, 0, 0.00852602, 0.997558, 0.00361052, 0, 0.0126804, 0.994417, 0.0035898, 0, 0.017635, 0.992824, 0.00372393, 0, 0.023365, 0.991344, 0.00390695, 0, 0.0298456, 0.989337, 0.00410392, 0, 0.0370529, 0.985811, 0.00420987, 0, 0.0449651, 0.982772, 0.00437488, 0, 0.0535615, 0.979001, 0.00455069, 0, 0.0628243, 0.974102, 0.00464462, 0, 0.0727368, 0.969197, 0.00480577, 0, 0.0832844, 0.962759, 0.00487818, 0, 0.0944545, 0.956207, 0.00498176, 0, 0.106236, 0.947909, 0.00503392, 0, 0.118619, 0.939596, 0.00507474, 0, 0.131595, 0.929642, 0.00509798, 0, 0.145159, 0.918807, 0.00508476, 0, 0.159305, 0.906921, 0.00505634, 0, 0.174028, 0.893312, 0.00498845, 0, 0.189327, 0.878933, 0.0049133, 0, 0.2052, 0.863986, 0.0048259, 0, 0.221647, 0.847936, 0.00470848, 0, 0.23867, 0.832253, 0.00456889, 0, 0.25627, 0.818619, 0.00442726, 0, 0.274453, 0.804788, 0.00427677, 0, 0.293222, 0.790241, 0.00411906, 0, 0.312585, 0.775162, 0.00394833, 0, 0.33255, 0.759463, 0.00377366, 0, 0.353126, 0.743598, 0.00361026, 0, 0.374324, 0.72697, 0.00343627, 0, 0.396158, 0.709646, 0.00326422, 0, 0.418641, 0.69277, 0.00309717, 0, 0.44179, 0.675371, 0.0029356, 0, 0.465624, 0.657863, 0.00277712, 0, 0.490163, 0.640772, 0.00261738, 0, 0.515429, 0.624441, 0.0024737, 0, 0.541445, 0.607497, 0.00233125, 0, 0.568236, 0.590438, 0.00218994, 0, 0.595828, 0.573224, 0.0020664, 0, 0.624242, 0.556168, 0.00193526, 0, 0.653496, 0.539232, 0.00182463, 0, 0.683588, 0.522352, 0.00170735, 0, 0.714482, 0.506172, 0.00160555, 0, 0.746032, 0.489842, 0.00150451, 0, 0.777778, 0.473463, 0.00140938, 0, 0.809524, 0.457266, 0.00132568, 0, 0.84127, 0.441609, 0.0012376, 0, 0.873016, 0.426348, 0.00116265, 0, 0.904762, 0.411002, 0.00108935, 0, 0.936508, 0.396045, 0.00101946, 0, 0.968254, 0.381448, 0.000955665, 0, 1, 1, 0.0037121, 0, 0, 1, 0.00371213, 0, 0, 1, 0.00371251, 0, 0, 0.999997, 0.00371417, 0, 0, 0.99999, 0.00371863, 0, 0, 0.999977, 0.00372807, 0, 0, 0.99995, 0.00374529, 0, 0, 0.999908, 0.0037738, 0, 0, 0.999843, 0.00381789, 0, 1.23596e-05, 0.999745, 0.00388273, 0, 0.000407442, 0.999608, 0.00397443, 0, 0.0015447, 0.999415, 0.00409998, 0, 0.00351385, 0.999143, 0.00426662, 0, 0.0063316, 0.9987, 0.00447625, 0, 0.00998679, 0.996363, 0.00455323, 0, 0.0144569, 0.994021, 0.00461052, 0, 0.0197151, 0.992372, 0.00476359, 0, 0.0257344, 0.991007, 0.00499101, 0, 0.0324882, 0.988767, 0.0051972, 0, 0.0399517, 0.984872, 0.00528407, 0, 0.0481022, 0.982004, 0.00548926, 0, 0.0569191, 0.977714, 0.00564385, 0, 0.0663839, 0.973076, 0.0057693, 0, 0.0764801, 0.967565, 0.0058924, 0, 0.0871928, 0.961384, 0.00599629, 0, 0.0985095, 0.954435, 0.00605998, 0, 0.110419, 0.946303, 0.0061133, 0, 0.122912, 0.937662, 0.00612028, 0, 0.13598, 0.927867, 0.00612209, 0, 0.149617, 0.916475, 0.00604813, 0, 0.163817, 0.90541, 0.00603088, 0, 0.178577, 0.891591, 0.00592218, 0, 0.193894, 0.877573, 0.00578854, 0, 0.209767, 0.862511, 0.00566648, 0, 0.226196, 0.846861, 0.00551481, 0, 0.243182, 0.83068, 0.00533754, 0, 0.260728, 0.815725, 0.00515487, 0, 0.278837, 0.802321, 0.0049655, 0, 0.297515, 0.787826, 0.00475421, 0, 0.316768, 0.773454, 0.00456002, 0, 0.336605, 0.758224, 0.00434727, 0, 0.357034, 0.74265, 0.00414444, 0, 0.378067, 0.726729, 0.00393738, 0, 0.399717, 0.710155, 0.00373575, 0, 0.421998, 0.693312, 0.00353736, 0, 0.444928, 0.67653, 0.00334368, 0, 0.468523, 0.659444, 0.00315981, 0, 0.492806, 0.642051, 0.00297809, 0, 0.517798, 0.625758, 0.00280592, 0, 0.543525, 0.609615, 0.00264254, 0, 0.570012, 0.592919, 0.00248459, 0, 0.597288, 0.576298, 0.00233327, 0, 0.625379, 0.559489, 0.00219519, 0, 0.654307, 0.542891, 0.00205441, 0, 0.684084, 0.526255, 0.00193385, 0, 0.714693, 0.509853, 0.00180745, 0, 0.746044, 0.494131, 0.00169817, 0, 0.777778, 0.478114, 0.0015913, 0, 0.809524, 0.462274, 0.00148981, 0, 0.84127, 0.446412, 0.00139537, 0, 0.873016, 0.431274, 0.00130984, 0, 0.904762, 0.41635, 0.00122403, 0, 0.936508, 0.401476, 0.00114809, 0, 0.968254, 0.386993, 0.00107563, 0, 1, 1, 0.00488216, 0, 0, 1, 0.0048822, 0, 0, 1, 0.00488265, 0, 0, 0.999997, 0.00488463, 0, 0, 0.999988, 0.00488999, 0, 0, 0.999974, 0.00490129, 0, 0, 0.999946, 0.00492191, 0, 0, 0.999897, 0.00495598, 0, 0, 0.999825, 0.00500855, 0, 7.44791e-05, 0.999718, 0.00508559, 0, 0.000712744, 0.999565, 0.005194, 0, 0.00215249, 0.999352, 0.00534147, 0, 0.00444576, 0.999046, 0.00553523, 0, 0.00759218, 0.998492, 0.00577016, 0, 0.0115714, 0.995564, 0.00578487, 0, 0.0163557, 0.993339, 0.00586414, 0, 0.021915, 0.991834, 0.00606002, 0, 0.0282201, 0.990496, 0.00633312, 0, 0.0352433, 0.987826, 0.00651941, 0, 0.042959, 0.98383, 0.00660842, 0, 0.0513439, 0.98109, 0.00685523, 0, 0.0603772, 0.976131, 0.00695778, 0, 0.0700402, 0.971922, 0.00714236, 0, 0.0803163, 0.965901, 0.00721437, 0, 0.0911908, 0.959606, 0.00732017, 0, 0.102651, 0.952504, 0.00735788, 0, 0.114686, 0.944365, 0.00738493, 0, 0.127286, 0.935652, 0.00737969, 0, 0.140443, 0.925813, 0.00733612, 0, 0.154151, 0.914397, 0.00723094, 0, 0.168405, 0.903257, 0.00714002, 0, 0.183201, 0.890015, 0.00700149, 0, 0.198536, 0.876014, 0.00682813, 0, 0.214409, 0.861436, 0.00665567, 0, 0.23082, 0.845752, 0.00644526, 0, 0.24777, 0.829169, 0.00621635, 0, 0.265263, 0.813435, 0.00597789, 0, 0.283301, 0.799701, 0.00575694, 0, 0.301889, 0.785726, 0.00549866, 0, 0.321035, 0.77152, 0.0052503, 0, 0.340746, 0.75683, 0.00499619, 0, 0.361032, 0.741951, 0.0047543, 0, 0.381904, 0.726367, 0.0045084, 0, 0.403374, 0.710537, 0.00426784, 0, 0.425457, 0.693965, 0.00403487, 0, 0.448169, 0.677724, 0.0038075, 0, 0.47153, 0.66117, 0.00359431, 0, 0.495561, 0.644274, 0.00338354, 0, 0.520284, 0.627449, 0.00318163, 0, 0.545725, 0.611645, 0.00299672, 0, 0.571911, 0.595614, 0.00281016, 0, 0.598873, 0.579426, 0.00264252, 0, 0.62664, 0.563016, 0.00247509, 0, 0.655239, 0.546728, 0.00232647, 0, 0.684692, 0.530539, 0.00217803, 0, 0.714999, 0.514164, 0.00204216, 0, 0.746106, 0.498344, 0.00191403, 0, 0.777778, 0.482957, 0.00179203, 0, 0.809524, 0.467336, 0.00167695, 0, 0.84127, 0.451994, 0.00157567, 0, 0.873016, 0.436514, 0.00147113, 0, 0.904762, 0.42178, 0.00138034, 0, 0.936508, 0.407271, 0.00129219, 0, 0.968254, 0.392822, 0.0012098, 0, 1, 1, 0.00637427, 0, 0, 1, 0.00637431, 0, 0, 0.999999, 0.00637485, 0, 0, 0.999996, 0.00637721, 0, 0, 0.999987, 0.00638357, 0, 0, 0.999971, 0.006397, 0, 0, 0.999939, 0.00642142, 0, 0, 0.999888, 0.00646177, 0, 0, 0.999807, 0.00652387, 0, 0.000207916, 0.999689, 0.00661454, 0, 0.00112051, 0.99952, 0.00674155, 0, 0.00287719, 0.999283, 0.00691313, 0, 0.00550145, 0.998936, 0.00713598, 0, 0.00897928, 0.998165, 0.00738501, 0, 0.0132829, 0.994847, 0.00734388, 0, 0.01838, 0.993182, 0.00749991, 0, 0.0242381, 0.991665, 0.0077246, 0, 0.030826, 0.989708, 0.00797579, 0, 0.0381152, 0.986663, 0.00813011, 0, 0.0460794, 0.983288, 0.00830365, 0, 0.0546951, 0.980104, 0.00853496, 0, 0.0639411, 0.974855, 0.00861045, 0, 0.0737988, 0.97045, 0.00879133, 0, 0.0842516, 0.964509, 0.00886377, 0, 0.0952848, 0.957594, 0.00890346, 0, 0.106886, 0.950546, 0.00893289, 0, 0.119044, 0.942225, 0.00890074, 0, 0.131749, 0.933365, 0.00886826, 0, 0.144994, 0.923202, 0.0087316, 0, 0.158772, 0.912605, 0.00863082, 0, 0.173078, 0.901099, 0.00847403, 0, 0.187908, 0.888177, 0.00825838, 0, 0.203261, 0.873955, 0.00801834, 0, 0.219134, 0.860091, 0.00779026, 0, 0.235527, 0.84434, 0.00752478, 0, 0.252443, 0.828517, 0.00724074, 0, 0.269883, 0.81239, 0.00693769, 0, 0.287851, 0.79721, 0.00664817, 0, 0.306352, 0.783489, 0.00634763, 0, 0.325393, 0.769514, 0.00604221, 0, 0.344981, 0.755419, 0.00573568, 0, 0.365126, 0.741083, 0.00544359, 0, 0.385839, 0.726059, 0.00515515, 0, 0.407132, 0.710809, 0.00487139, 0, 0.42902, 0.695052, 0.00459846, 0, 0.45152, 0.678886, 0.00433412, 0, 0.474651, 0.663042, 0.00407981, 0, 0.498433, 0.646634, 0.00384264, 0, 0.52289, 0.630117, 0.00360897, 0, 0.548048, 0.613804, 0.00338863, 0, 0.573936, 0.598338, 0.00318486, 0, 0.600584, 0.582687, 0.00298377, 0, 0.628027, 0.566809, 0.00280082, 0, 0.656295, 0.550817, 0.00262255, 0, 0.685417, 0.534937, 0.00245835, 0, 0.715406, 0.519151, 0.00230574, 0, 0.74624, 0.503118, 0.0021549, 0, 0.777778, 0.487723, 0.00202008, 0, 0.809524, 0.472725, 0.00189355, 0, 0.84127, 0.457599, 0.00177108, 0, 0.873016, 0.442558, 0.00165843, 0, 0.904762, 0.427624, 0.00155494, 0, 0.936508, 0.413171, 0.00145273, 0, 0.968254, 0.399122, 0.00136454, 0, 1, 1, 0.00826496, 0, 0, 1, 0.00826499, 0, 0, 1, 0.00826564, 0, 0, 0.999996, 0.00826842, 0, 0, 0.999987, 0.00827589, 0, 0, 0.999967, 0.00829167, 0, 0, 0.999933, 0.00832037, 0, 0, 0.999876, 0.00836768, 0, 1.09338e-05, 0.999786, 0.00844031, 0, 0.000427145, 0.999655, 0.00854603, 0, 0.0016384, 0.999468, 0.00869337, 0, 0.00372392, 0.999203, 0.008891, 0, 0.00668513, 0.998803, 0.00914387, 0, 0.0104968, 0.99748, 0.00935838, 0, 0.015125, 0.994446, 0.00933309, 0, 0.0205338, 0.99292, 0.00953084, 0, 0.0266884, 0.991414, 0.0097893, 0, 0.0335565, 0.989049, 0.0100228, 0, 0.0411086, 0.98582, 0.0101664, 0, 0.0493181, 0.982441, 0.0103582, 0, 0.0581613, 0.978595, 0.0105292, 0, 0.0676169, 0.973495, 0.0106274, 0, 0.0776661, 0.968405, 0.0107261, 0, 0.0882926, 0.962717, 0.0108234, 0, 0.0994817, 0.955478, 0.0108102, 0, 0.111221, 0.948275, 0.0107914, 0, 0.123499, 0.940006, 0.0107161, 0, 0.136308, 0.930831, 0.0106309, 0, 0.149639, 0.920648, 0.0104083, 0, 0.163485, 0.910205, 0.0102312, 0, 0.177843, 0.898445, 0.0100051, 0, 0.192707, 0.885986, 0.00971928, 0, 0.208077, 0.872204, 0.00940747, 0, 0.22395, 0.858436, 0.0091085, 0, 0.240326, 0.843454, 0.00876595, 0, 0.257208, 0.827437, 0.00839794, 0, 0.274596, 0.811488, 0.00803692, 0, 0.292496, 0.796039, 0.00767352, 0, 0.310911, 0.781083, 0.0073097, 0, 0.329849, 0.767642, 0.00694032, 0, 0.349316, 0.753901, 0.00657476, 0, 0.369323, 0.740131, 0.00622699, 0, 0.38988, 0.725845, 0.0058838, 0, 0.410999, 0.710991, 0.00555586, 0, 0.432696, 0.696002, 0.00523089, 0, 0.454987, 0.680461, 0.00492494, 0, 0.47789, 0.664875, 0.00463464, 0, 0.501426, 0.649273, 0.00435422, 0, 0.52562, 0.63302, 0.0040875, 0, 0.550498, 0.61705, 0.00384075, 0, 0.576089, 0.601154, 0.00359557, 0, 0.602427, 0.586008, 0.00337636, 0, 0.629544, 0.570699, 0.00316019, 0, 0.657479, 0.555166, 0.00296033, 0, 0.686264, 0.539645, 0.00277552, 0, 0.715924, 0.524159, 0.00259499, 0, 0.746459, 0.508682, 0.00243257, 0, 0.777789, 0.493163, 0.00227851, 0, 0.809524, 0.478004, 0.00213083, 0, 0.84127, 0.46347, 0.00199502, 0, 0.873016, 0.448778, 0.00186967, 0, 0.904762, 0.434105, 0.00174732, 0, 0.936508, 0.419576, 0.00163861, 0, 0.968254, 0.405541, 0.00153341, 0, 1, 1, 0.0106462, 0, 0, 1, 0.0106462, 0, 0, 0.999999, 0.010647, 0, 0, 0.999995, 0.0106502, 0, 0, 0.999985, 0.0106589, 0, 0, 0.999964, 0.0106773, 0, 0, 0.999925, 0.0107106, 0, 0, 0.999861, 0.0107655, 0, 7.12986e-05, 0.999763, 0.0108497, 0, 0.000743959, 0.999616, 0.0109716, 0, 0.00227361, 0.999408, 0.0111408, 0, 0.0046983, 0.999112, 0.0113659, 0, 0.00800158, 0.998637, 0.0116475, 0, 0.0121493, 0.996223, 0.0117231, 0, 0.0171023, 0.994006, 0.0118064, 0, 0.0228218, 0.992444, 0.0120254, 0, 0.0292711, 0.991028, 0.0123314, 0, 0.036417, 0.98803, 0.0124954, 0, 0.0442295, 0.984816, 0.0126538, 0, 0.0526815, 0.981399, 0.0128537, 0, 0.0617492, 0.977085, 0.0129694, 0, 0.0714114, 0.972154, 0.013091, 0, 0.0816495, 0.966617, 0.0131166, 0, 0.0924472, 0.960628, 0.0131583, 0, 0.10379, 0.953295, 0.0131094, 0, 0.115665, 0.94575, 0.0129966, 0, 0.128062, 0.937654, 0.0128796, 0, 0.140972, 0.927716, 0.0126477, 0, 0.154387, 0.917932, 0.0123889, 0, 0.168301, 0.907719, 0.012131, 0, 0.182709, 0.89584, 0.0118013, 0, 0.197608, 0.883526, 0.0114145, 0, 0.212994, 0.870301, 0.0110075, 0, 0.228867, 0.856272, 0.0106019, 0, 0.245227, 0.842251, 0.0101938, 0, 0.262074, 0.826466, 0.00973254, 0, 0.279412, 0.810859, 0.0092846, 0, 0.297244, 0.795051, 0.00883304, 0, 0.315575, 0.780053, 0.00840272, 0, 0.334412, 0.76575, 0.00796438, 0, 0.35376, 0.752298, 0.00752526, 0, 0.373631, 0.739153, 0.00711486, 0, 0.394034, 0.725514, 0.00670361, 0, 0.414983, 0.711473, 0.00632656, 0, 0.436491, 0.696936, 0.00595206, 0, 0.458575, 0.682126, 0.00559191, 0, 0.481253, 0.667027, 0.00525362, 0, 0.504547, 0.651875, 0.00493805, 0, 0.528481, 0.636463, 0.00462848, 0, 0.553081, 0.620641, 0.00433936, 0, 0.578377, 0.604931, 0.00407, 0, 0.604404, 0.589549, 0.00380864, 0, 0.631197, 0.574712, 0.00357049, 0, 0.658795, 0.559775, 0.00334466, 0, 0.687238, 0.544514, 0.00312505, 0, 0.716559, 0.529555, 0.00293199, 0, 0.746776, 0.514402, 0.00274204, 0, 0.777849, 0.499302, 0.00256647, 0, 0.809524, 0.484114, 0.00239901, 0, 0.84127, 0.469308, 0.00225148, 0, 0.873016, 0.455133, 0.00210178, 0, 0.904762, 0.440939, 0.0019727, 0, 0.936508, 0.426627, 0.00184382, 0, 0.968254, 0.412509, 0.00172548, 0, 1, 1, 0.013628, 0, 0, 1, 0.0136281, 0, 0, 0.999999, 0.0136289, 0, 0, 0.999995, 0.0136327, 0, 0, 0.999983, 0.0136427, 0, 0, 0.99996, 0.0136638, 0, 0, 0.999917, 0.0137022, 0, 0, 0.999846, 0.0137652, 0, 0.000204597, 0.999736, 0.0138615, 0, 0.00116837, 0.999573, 0.0140007, 0, 0.00303325, 0.99934, 0.0141927, 0, 0.00580613, 0.999004, 0.0144457, 0, 0.00945626, 0.998407, 0.0147489, 0, 0.0139421, 0.995464, 0.014731, 0, 0.0192202, 0.993328, 0.0148283, 0, 0.0252495, 0.991799, 0.0150797, 0, 0.0319921, 0.990397, 0.0154316, 0, 0.0394138, 0.986835, 0.0155005, 0, 0.0474843, 0.983938, 0.0157308, 0, 0.0561763, 0.980154, 0.0158753, 0, 0.0654661, 0.975659, 0.0159581, 0, 0.0753326, 0.970171, 0.0159832, 0, 0.0857571, 0.964803, 0.0160084, 0, 0.0967236, 0.958366, 0.0159484, 0, 0.108218, 0.950613, 0.0158001, 0, 0.120227, 0.942874, 0.0155845, 0, 0.132741, 0.935005, 0.0154292, 0, 0.145751, 0.924991, 0.0150742, 0, 0.159249, 0.914814, 0.0146757, 0, 0.17323, 0.904743, 0.0143097, 0, 0.187687, 0.893216, 0.0138695, 0, 0.202619, 0.880769, 0.0133706, 0, 0.218021, 0.868136, 0.0128606, 0, 0.233894, 0.85469, 0.0123403, 0, 0.250238, 0.840593, 0.0118091, 0, 0.267052, 0.825808, 0.011253, 0, 0.284341, 0.81009, 0.0107099, 0, 0.302106, 0.79504, 0.0101636, 0, 0.320354, 0.779757, 0.00964041, 0, 0.33909, 0.764697, 0.00911896, 0, 0.358322, 0.750913, 0.00859533, 0, 0.378059, 0.738175, 0.00811592, 0, 0.398311, 0.725242, 0.00764504, 0, 0.41909, 0.711864, 0.00718885, 0, 0.440412, 0.698009, 0.00675843, 0, 0.462292, 0.683841, 0.00634984, 0, 0.484748, 0.669391, 0.00595502, 0, 0.507802, 0.654731, 0.00558671, 0, 0.531477, 0.639805, 0.00523578, 0, 0.555802, 0.624789, 0.00490834, 0, 0.580805, 0.609325, 0.00459448, 0, 0.606522, 0.593975, 0.00430342, 0, 0.63299, 0.578983, 0.00403019, 0, 0.66025, 0.564442, 0.0037707, 0, 0.688346, 0.549835, 0.0035316, 0, 0.717319, 0.535039, 0.00330255, 0, 0.7472, 0.520403, 0.00308932, 0, 0.777982, 0.505687, 0.00289335, 0, 0.809524, 0.490939, 0.00270818, 0, 0.84127, 0.476233, 0.0025343, 0, 0.873016, 0.461624, 0.00237097, 0, 0.904762, 0.447833, 0.00222065, 0, 0.936508, 0.433992, 0.00207561, 0, 0.968254, 0.420147, 0.00194955, 0, 1, 1, 0.0173415, 0, 0, 1, 0.0173416, 0, 0, 0.999999, 0.0173426, 0, 0, 0.999995, 0.0173468, 0, 0, 0.999983, 0.0173582, 0, 0, 0.999954, 0.0173822, 0, 0, 0.999908, 0.0174258, 0, 6.69501e-06, 0.999828, 0.0174973, 0, 0.000427399, 0.999705, 0.0176063, 0, 0.00171019, 0.999524, 0.0177631, 0, 0.0039248, 0.999263, 0.0179781, 0, 0.00705382, 0.998878, 0.018258, 0, 0.0110552, 0.998012, 0.0185551, 0, 0.0158812, 0.994614, 0.0184264, 0, 0.0214852, 0.993132, 0.0186385, 0, 0.0278239, 0.991563, 0.0189067, 0, 0.0348585, 0.989298, 0.0191577, 0, 0.0425544, 0.986036, 0.0192522, 0, 0.050881, 0.982558, 0.0194063, 0, 0.059811, 0.978531, 0.019486, 0, 0.0693209, 0.974198, 0.0195847, 0, 0.0793895, 0.968148, 0.0194749, 0, 0.0899984, 0.962565, 0.0194277, 0, 0.101132, 0.956041, 0.0192991, 0, 0.112775, 0.947749, 0.0189893, 0, 0.124917, 0.94018, 0.018704, 0, 0.137547, 0.93165, 0.0183458, 0, 0.150655, 0.921798, 0.0178775, 0, 0.164236, 0.911573, 0.0173618, 0, 0.178281, 0.901569, 0.0168482, 0, 0.192788, 0.890341, 0.016265, 0, 0.207752, 0.877835, 0.0156199, 0, 0.223171, 0.865472, 0.0149516, 0, 0.239044, 0.852905, 0.0143274, 0, 0.255371, 0.838906, 0.0136643, 0, 0.272153, 0.824888, 0.0129903, 0, 0.289393, 0.809977, 0.0123218, 0, 0.307093, 0.794697, 0.0116572, 0, 0.325259, 0.780028, 0.0110307, 0, 0.343896, 0.765124, 0.0104236, 0, 0.363012, 0.750411, 0.0098219, 0, 0.382617, 0.737264, 0.00924397, 0, 0.402719, 0.724799, 0.00868719, 0, 0.423332, 0.712253, 0.00816476, 0, 0.444469, 0.699267, 0.00767262, 0, 0.466146, 0.685618, 0.00719746, 0, 0.488383, 0.671736, 0.00673916, 0, 0.511199, 0.657777, 0.00631937, 0, 0.534618, 0.643497, 0.00592411, 0, 0.558668, 0.62889, 0.00553928, 0, 0.58338, 0.614299, 0.0051934, 0, 0.608787, 0.599197, 0.00485985, 0, 0.634929, 0.584175, 0.00454357, 0, 0.661849, 0.569541, 0.00425787, 0, 0.689594, 0.555193, 0.00397905, 0, 0.718211, 0.540947, 0.00372364, 0, 0.747742, 0.526593, 0.00348599, 0, 0.778205, 0.512335, 0.00326103, 0, 0.80953, 0.498017, 0.00305137, 0, 0.84127, 0.483609, 0.00285485, 0, 0.873016, 0.469368, 0.00267472, 0, 0.904762, 0.455037, 0.00249945, 0, 0.936508, 0.441493, 0.00234792, 0, 0.968254, 0.428147, 0.00219936, 0, 1, 1, 0.0219422, 0, 0, 1, 0.0219423, 0, 0, 0.999998, 0.0219434, 0, 0, 0.999993, 0.0219481, 0, 0, 0.999981, 0.021961, 0, 0, 0.999949, 0.0219879, 0, 0, 0.999896, 0.0220367, 0, 5.93194e-05, 0.999808, 0.0221167, 0, 0.00075364, 0.99967, 0.0222383, 0, 0.00237884, 0.999466, 0.0224125, 0, 0.00495612, 0.999174, 0.0226495, 0, 0.00844887, 0.998725, 0.0229525, 0, 0.0128058, 0.996979, 0.0231123, 0, 0.0179742, 0.994317, 0.0230742, 0, 0.0239047, 0.992781, 0.0232895, 0, 0.0305526, 0.991191, 0.0235734, 0, 0.0378786, 0.987787, 0.0236152, 0, 0.0458475, 0.985092, 0.0237994, 0, 0.0544287, 0.981121, 0.0238553, 0, 0.0635952, 0.976924, 0.0238706, 0, 0.0733233, 0.97218, 0.0238704, 0, 0.0835922, 0.965956, 0.0236598, 0, 0.0943839, 0.959998, 0.0234735, 0, 0.105682, 0.953245, 0.0232277, 0, 0.117474, 0.944445, 0.0226973, 0, 0.129747, 0.937087, 0.0223527, 0, 0.142491, 0.928341, 0.0218144, 0, 0.155697, 0.9184, 0.0211516, 0, 0.169358, 0.907959, 0.0204553, 0, 0.183469, 0.89808, 0.0197673, 0, 0.198024, 0.887047, 0.0189915, 0, 0.21302, 0.875221, 0.0182082, 0, 0.228455, 0.86269, 0.0173584, 0, 0.244329, 0.850735, 0.0165718, 0, 0.260639, 0.837545, 0.0157524, 0, 0.277389, 0.823639, 0.0149482, 0, 0.29458, 0.809699, 0.0141431, 0, 0.312216, 0.794797, 0.0133527, 0, 0.3303, 0.780578, 0.0126193, 0, 0.34884, 0.766019, 0.0118914, 0, 0.367842, 0.751447, 0.0111839, 0, 0.387315, 0.737275, 0.010514, 0, 0.40727, 0.724545, 0.00987277, 0, 0.427717, 0.712644, 0.00926569, 0, 0.448671, 0.700432, 0.00869029, 0, 0.470149, 0.687664, 0.00814691, 0, 0.492167, 0.674288, 0.00763012, 0, 0.514746, 0.660966, 0.00714437, 0, 0.537911, 0.647264, 0.00668457, 0, 0.561688, 0.633431, 0.00626581, 0, 0.586108, 0.619133, 0.00585593, 0, 0.611206, 0.604935, 0.00548188, 0, 0.637022, 0.590236, 0.00513288, 0, 0.663599, 0.575473, 0.0047906, 0, 0.690989, 0.561228, 0.00448895, 0, 0.719242, 0.547054, 0.00420233, 0, 0.748411, 0.533175, 0.00392869, 0, 0.778531, 0.519163, 0.00367445, 0, 0.809583, 0.505328, 0.00344097, 0, 0.84127, 0.491446, 0.00322003, 0, 0.873016, 0.477356, 0.00301283, 0, 0.904762, 0.46356, 0.00282592, 0, 0.936508, 0.449623, 0.00264956, 0, 0.968254, 0.436068, 0.00246956, 0, 1, 1, 0.0276135, 0, 0, 1, 0.0276136, 0, 0, 0.999998, 0.0276148, 0, 0, 0.999993, 0.0276201, 0, 0, 0.999976, 0.0276342, 0, 0, 0.999945, 0.027664, 0, 0, 0.999884, 0.0277179, 0, 0.00018679, 0.999784, 0.027806, 0, 0.00119607, 0.99963, 0.0279394, 0, 0.00318407, 0.999401, 0.0281295, 0, 0.00613601, 0.999066, 0.0283858, 0, 0.00999963, 0.998524, 0.0287027, 0, 0.0147164, 0.995702, 0.0286256, 0, 0.0202295, 0.993593, 0.0286733, 0, 0.0264876, 0.992067, 0.0288989, 0, 0.0334452, 0.990548, 0.0292135, 0, 0.0410621, 0.986775, 0.0291296, 0, 0.0493032, 0.984054, 0.0293099, 0, 0.0581381, 0.979481, 0.0291881, 0, 0.0675397, 0.975297, 0.0291598, 0, 0.0774848, 0.96981, 0.028954, 0, 0.0879528, 0.963524, 0.028628, 0, 0.0989258, 0.957398, 0.0283135, 0, 0.110388, 0.950088, 0.0278469, 0, 0.122327, 0.941538, 0.0271798, 0, 0.134729, 0.933332, 0.0265388, 0, 0.147587, 0.924392, 0.0257776, 0, 0.160889, 0.914581, 0.024916, 0, 0.174631, 0.904347, 0.0240242, 0, 0.188806, 0.894324, 0.0231229, 0, 0.203409, 0.883724, 0.022153, 0, 0.218437, 0.872207, 0.0211355, 0, 0.233888, 0.859927, 0.0201048, 0, 0.249761, 0.848373, 0.0191263, 0, 0.266056, 0.836023, 0.0181306, 0, 0.282774, 0.82289, 0.0171718, 0, 0.299917, 0.809324, 0.0162196, 0, 0.317488, 0.795361, 0.0152622, 0, 0.335493, 0.781253, 0.01439, 0, 0.353936, 0.767338, 0.013533, 0, 0.372825, 0.753156, 0.0127244, 0, 0.392168, 0.739122, 0.0119454, 0, 0.411976, 0.725358, 0.0112054, 0, 0.432259, 0.712949, 0.010487, 0, 0.453032, 0.701621, 0.00984032, 0, 0.47431, 0.689703, 0.00921495, 0, 0.496111, 0.677216, 0.00862492, 0, 0.518456, 0.664217, 0.00806882, 0, 0.541367, 0.65137, 0.00755922, 0, 0.564872, 0.638, 0.00705705, 0, 0.589001, 0.62453, 0.00661266, 0, 0.613789, 0.610601, 0.00618432, 0, 0.639277, 0.59676, 0.00578033, 0, 0.66551, 0.582433, 0.00540927, 0, 0.692539, 0.568026, 0.00506104, 0, 0.720422, 0.55414, 0.0047353, 0, 0.749216, 0.540178, 0.00442889, 0, 0.778974, 0.526513, 0.00414363, 0, 0.809711, 0.512954, 0.00388237, 0, 0.84127, 0.499403, 0.00362875, 0, 0.873016, 0.486026, 0.00340827, 0, 0.904762, 0.472345, 0.00318598, 0, 0.936508, 0.458828, 0.00297635, 0, 0.968254, 0.445379, 0.00279447, 0, 1, 1, 0.0345716, 0, 0, 1, 0.0345717, 0, 0, 0.999999, 0.034573, 0, 0, 0.999991, 0.0345787, 0, 0, 0.999974, 0.0345941, 0, 0, 0.999937, 0.0346263, 0, 1.88589e-06, 0.999869, 0.0346847, 0, 0.000409238, 0.999757, 0.0347798, 0, 0.0017674, 0.999582, 0.0349233, 0, 0.00413658, 0.999322, 0.0351265, 0, 0.00747408, 0.998939, 0.0353967, 0, 0.0117157, 0.998219, 0.0357018, 0, 0.0167966, 0.994974, 0.0354726, 0, 0.0226572, 0.993201, 0.0355621, 0, 0.0292445, 0.991573, 0.0357641, 0, 0.0365123, 0.989301, 0.0359252, 0, 0.0444203, 0.985712, 0.0358017, 0, 0.0529334, 0.982411, 0.0358353, 0, 0.0620214, 0.977827, 0.035617, 0, 0.0716574, 0.973278, 0.0354398, 0, 0.0818186, 0.967397, 0.0350483, 0, 0.0924846, 0.960696, 0.0344795, 0, 0.103638, 0.954349, 0.0339861, 0, 0.115263, 0.946066, 0.0331323, 0, 0.127348, 0.938012, 0.032359, 0, 0.13988, 0.929413, 0.0314413, 0, 0.152849, 0.920355, 0.0304103, 0, 0.166248, 0.910586, 0.0292785, 0, 0.18007, 0.900609, 0.0281391, 0, 0.194308, 0.890093, 0.0269103, 0, 0.208958, 0.880013, 0.0257269, 0, 0.224018, 0.869001, 0.0244671, 0, 0.239485, 0.85751, 0.0232252, 0, 0.255359, 0.84582, 0.0220117, 0, 0.271638, 0.834383, 0.0208274, 0, 0.288324, 0.822158, 0.0196628, 0, 0.305419, 0.809056, 0.0185306, 0, 0.322927, 0.795832, 0.0174174, 0, 0.340851, 0.782547, 0.0163758, 0, 0.359199, 0.7689, 0.015391, 0, 0.377975, 0.755526, 0.0144488, 0, 0.397189, 0.741681, 0.0135372, 0, 0.416851, 0.728178, 0.0126957, 0, 0.436971, 0.714642, 0.0118812, 0, 0.457564, 0.702756, 0.0111165, 0, 0.478644, 0.69175, 0.0104145, 0, 0.500229, 0.680159, 0.00974439, 0, 0.522339, 0.668073, 0.00911926, 0, 0.544997, 0.655405, 0.00851393, 0, 0.56823, 0.642921, 0.00797637, 0, 0.592068, 0.629993, 0.00745119, 0, 0.616546, 0.616828, 0.00696972, 0, 0.641705, 0.603305, 0.00652425, 0, 0.66759, 0.589833, 0.00610188, 0, 0.694255, 0.575945, 0.00570834, 0, 0.72176, 0.561745, 0.00533384, 0, 0.750168, 0.548277, 0.00500001, 0, 0.779545, 0.534467, 0.00467582, 0, 0.809933, 0.521032, 0.00438092, 0, 0.841272, 0.507877, 0.00410348, 0, 0.873016, 0.494654, 0.00383618, 0, 0.904762, 0.481592, 0.00358699, 0, 0.936508, 0.468509, 0.00337281, 0, 0.968254, 0.455293, 0.00316196, 0, 1, 1, 0.0430698, 0, 0, 1, 0.0430699, 0, 0, 0.999998, 0.0430713, 0, 0, 0.999991, 0.0430773, 0, 0, 0.99997, 0.0430936, 0, 0, 0.999928, 0.0431277, 0, 4.06396e-05, 0.999852, 0.0431893, 0, 0.000744376, 0.999724, 0.0432895, 0, 0.0024806, 0.999527, 0.0434397, 0, 0.00524779, 0.99923, 0.0436507, 0, 0.00898164, 0.998783, 0.0439255, 0, 0.0136083, 0.997507, 0.0441104, 0, 0.0190582, 0.994418, 0.0438225, 0, 0.0252694, 0.992864, 0.0439396, 0, 0.0321879, 0.991127, 0.0440962, 0, 0.039767, 0.987331, 0.0438408, 0, 0.0479667, 0.984819, 0.0438991, 0, 0.056752, 0.980384, 0.0435906, 0, 0.0660929, 0.975846, 0.0432543, 0, 0.075963, 0.970748, 0.0428293, 0, 0.0863398, 0.964303, 0.042153, 0, 0.0972035, 0.95772, 0.0414111, 0, 0.108537, 0.950747, 0.0405893, 0, 0.120325, 0.942533, 0.0394887, 0, 0.132554, 0.934045, 0.0383544, 0, 0.145215, 0.924942, 0.037057, 0, 0.158296, 0.915811, 0.0356993, 0, 0.17179, 0.90612, 0.0342401, 0, 0.185691, 0.896434, 0.0328078, 0, 0.199993, 0.886021, 0.031288, 0, 0.214691, 0.876081, 0.0297776, 0, 0.229782, 0.865608, 0.0282334, 0, 0.245265, 0.854924, 0.026749, 0, 0.261138, 0.843607, 0.02526, 0, 0.277401, 0.832456, 0.0238214, 0, 0.294056, 0.821342, 0.0224682, 0, 0.311104, 0.809303, 0.0211297, 0, 0.328548, 0.796468, 0.0198387, 0, 0.346394, 0.784046, 0.0186227, 0, 0.364645, 0.771262, 0.0174561, 0, 0.38331, 0.758118, 0.0163806, 0, 0.402396, 0.745075, 0.0153287, 0, 0.421912, 0.731926, 0.0143647, 0, 0.44187, 0.71863, 0.0134363, 0, 0.462283, 0.705414, 0.0125603, 0, 0.483165, 0.693792, 0.0117508, 0, 0.504535, 0.683108, 0.0110016, 0, 0.52641, 0.67183, 0.0102757, 0, 0.548816, 0.66015, 0.00962044, 0, 0.571776, 0.647907, 0.00898031, 0, 0.595323, 0.635734, 0.00840811, 0, 0.619489, 0.623208, 0.00786211, 0, 0.644317, 0.610438, 0.00734953, 0, 0.669852, 0.597345, 0.00687688, 0, 0.696148, 0.584138, 0.00643469, 0, 0.723267, 0.5707, 0.00602236, 0, 0.75128, 0.556966, 0.0056324, 0, 0.780258, 0.543607, 0.00528277, 0, 0.810268, 0.530213, 0.00493999, 0, 0.841311, 0.516912, 0.00462265, 0, 0.873016, 0.503916, 0.0043307, 0, 0.904762, 0.491146, 0.00406858, 0, 0.936508, 0.478439, 0.00381436, 0, 0.968254, 0.465834, 0.00358003, 0, 1, 1, 0.0534039, 0, 0, 1, 0.053404, 0, 0, 0.999998, 0.0534055, 0, 0, 0.999989, 0.0534116, 0, 0, 0.999968, 0.0534283, 0, 0, 0.999918, 0.0534633, 0, 0.000155895, 0.99983, 0.0535262, 0, 0.00120914, 0.999685, 0.0536281, 0, 0.00334944, 0.999461, 0.0537799, 0, 0.00653077, 0.999119, 0.0539902, 0, 0.0106718, 0.998582, 0.0542524, 0, 0.0156907, 0.995919, 0.0540318, 0, 0.0215147, 0.993735, 0.0538914, 0, 0.0280801, 0.992126, 0.0539557, 0, 0.0353323, 0.990266, 0.0540401, 0, 0.0432247, 0.986317, 0.0536064, 0, 0.0517172, 0.983213, 0.0534425, 0, 0.0607754, 0.978303, 0.0528622, 0, 0.0703698, 0.973665, 0.0523363, 0, 0.0804742, 0.968091, 0.0516165, 0, 0.0910667, 0.961026, 0.0505434, 0, 0.102128, 0.954333, 0.049523, 0, 0.113641, 0.946372, 0.0481698, 0, 0.125591, 0.938254, 0.0467674, 0, 0.137965, 0.929516, 0.0452341, 0, 0.150754, 0.920106, 0.0435083, 0, 0.163947, 0.910899, 0.0417399, 0, 0.177537, 0.901532, 0.0399389, 0, 0.191516, 0.891919, 0.0380901, 0, 0.205881, 0.882006, 0.0362341, 0, 0.220626, 0.871965, 0.0343444, 0, 0.235749, 0.862145, 0.0324832, 0, 0.251248, 0.852058, 0.0306681, 0, 0.267121, 0.84161, 0.0289097, 0, 0.283368, 0.830806, 0.0272079, 0, 0.299992, 0.820476, 0.0256089, 0, 0.316992, 0.809514, 0.0240394, 0, 0.334374, 0.797865, 0.0225379, 0, 0.35214, 0.785621, 0.0211235, 0, 0.370296, 0.773765, 0.0197908, 0, 0.388849, 0.761629, 0.0185235, 0, 0.407807, 0.748891, 0.0173358, 0, 0.427178, 0.736437, 0.0162305, 0, 0.446974, 0.723707, 0.0151778, 0, 0.467207, 0.710606, 0.0141791, 0, 0.487892, 0.698019, 0.0132592, 0, 0.509046, 0.686203, 0.0123887, 0, 0.530687, 0.675692, 0.0115976, 0, 0.552839, 0.664826, 0.0108325, 0, 0.575527, 0.65349, 0.0101348, 0, 0.59878, 0.641774, 0.00947756, 0, 0.622634, 0.629794, 0.00886058, 0, 0.647128, 0.617647, 0.00828526, 0, 0.672308, 0.60534, 0.00775312, 0, 0.698231, 0.592718, 0.00726033, 0, 0.724958, 0.579746, 0.00679731, 0, 0.752563, 0.566763, 0.00636111, 0, 0.781127, 0.553515, 0.00595228, 0, 0.810733, 0.540118, 0.00556876, 0, 0.841426, 0.527325, 0.00523051, 0, 0.873016, 0.514265, 0.00490712, 0, 0.904762, 0.501406, 0.00460297, 0, 0.936508, 0.488922, 0.00431247, 0, 0.968254, 0.476541, 0.0040472, 0, 1, 1, 0.0659184, 0, 0, 1, 0.0659185, 0, 0, 0.999998, 0.06592, 0, 0, 0.999988, 0.0659259, 0, 0, 0.999963, 0.0659423, 0, 0, 0.999907, 0.0659764, 0, 0.000374198, 0.999806, 0.0660376, 0, 0.00182071, 0.999639, 0.0661361, 0, 0.0043894, 0.999378, 0.0662814, 0, 0.00800055, 0.998985, 0.0664779, 0, 0.0125594, 0.998285, 0.0666914, 0, 0.0179786, 0.995071, 0.0661989, 0, 0.0241822, 0.993172, 0.0660454, 0, 0.031106, 0.991438, 0.0660105, 0, 0.0386952, 0.988428, 0.0656875, 0, 0.0469032, 0.985218, 0.0652913, 0, 0.0556905, 0.981128, 0.0647107, 0, 0.065023, 0.976015, 0.0638491, 0, 0.0748717, 0.97097, 0.062993, 0, 0.0852112, 0.964582, 0.0617927, 0, 0.0960199, 0.957383, 0.0603626, 0, 0.107279, 0.949969, 0.0588128, 0, 0.118971, 0.941843, 0.0570274, 0, 0.131084, 0.933624, 0.0551885, 0, 0.143604, 0.924543, 0.053122, 0, 0.156521, 0.914919, 0.0508897, 0, 0.169825, 0.905773, 0.0486418, 0, 0.18351, 0.896434, 0.0463364, 0, 0.197569, 0.887195, 0.0440623, 0, 0.211997, 0.877706, 0.0417799, 0, 0.226789, 0.867719, 0.03945, 0, 0.241944, 0.858587, 0.037243, 0, 0.257458, 0.849317, 0.0350956, 0, 0.273331, 0.839585, 0.0329852, 0, 0.289563, 0.829856, 0.0310028, 0, 0.306154, 0.819589, 0.0290953, 0, 0.323108, 0.809714, 0.0272738, 0, 0.340426, 0.79934, 0.0255631, 0, 0.358113, 0.788224, 0.0239175, 0, 0.376175, 0.776619, 0.0223831, 0, 0.394616, 0.76521, 0.0209298, 0, 0.413445, 0.753716, 0.0195786, 0, 0.432671, 0.741564, 0.0183001, 0, 0.452305, 0.729413, 0.0171259, 0, 0.472358, 0.717146, 0.0159933, 0, 0.492845, 0.70436, 0.0149495, 0, 0.513783, 0.69219, 0.0139681, 0, 0.535189, 0.680289, 0.0130577, 0, 0.557087, 0.669611, 0.0122198, 0, 0.5795, 0.659113, 0.0114174, 0, 0.602459, 0.648148, 0.0106729, 0, 0.625997, 0.636905, 0.00998997, 0, 0.650154, 0.625154, 0.00934313, 0, 0.674976, 0.613481, 0.00874839, 0, 0.700518, 0.60154, 0.00818265, 0, 0.726845, 0.58943, 0.00766889, 0, 0.754032, 0.576828, 0.00717153, 0, 0.782167, 0.564194, 0.00672696, 0, 0.811344, 0.551501, 0.00630863, 0, 0.841644, 0.538635, 0.00592177, 0, 0.873016, 0.525724, 0.00554888, 0, 0.904762, 0.513209, 0.00520225, 0, 0.936508, 0.500457, 0.00488231, 0, 0.968254, 0.48799, 0.00457153, 0, 1, 1, 0.0810131, 0, 0, 1, 0.0810133, 0, 0, 0.999997, 0.0810145, 0, 0, 0.999985, 0.08102, 0, 0, 0.999956, 0.0810347, 0, 1.95026e-05, 0.999893, 0.0810656, 0, 0.000719316, 0.999777, 0.0811205, 0, 0.00259774, 0.999583, 0.081208, 0, 0.00561807, 0.999281, 0.0813343, 0, 0.00967472, 0.998813, 0.0814969, 0, 0.0146627, 0.997597, 0.0815217, 0, 0.0204902, 0.994379, 0.0808502, 0, 0.0270802, 0.992744, 0.0806792, 0, 0.0343674, 0.990745, 0.0804589, 0, 0.0422974, 0.986646, 0.0796107, 0, 0.0508242, 0.983611, 0.0790913, 0, 0.0599087, 0.978869, 0.0780746, 0, 0.0695175, 0.973475, 0.0768218, 0, 0.0796223, 0.967845, 0.0754926, 0, 0.0901983, 0.960778, 0.0737063, 0, 0.101224, 0.953333, 0.0718052, 0, 0.112682, 0.945274, 0.0695946, 0, 0.124555, 0.936955, 0.0672492, 0, 0.136831, 0.928319, 0.0647732, 0, 0.149496, 0.919075, 0.0620947, 0, 0.162542, 0.909114, 0.0591816, 0, 0.175958, 0.900137, 0.0563917, 0, 0.189739, 0.891069, 0.0535392, 0, 0.203877, 0.882262, 0.0507642, 0, 0.218368, 0.873232, 0.0479793, 0, 0.233208, 0.864042, 0.045226, 0, 0.248393, 0.855002, 0.0425413, 0, 0.263923, 0.846569, 0.0400126, 0, 0.279796, 0.837714, 0.0375269, 0, 0.296012, 0.828918, 0.0352027, 0, 0.312573, 0.819783, 0.0330011, 0, 0.329479, 0.810129, 0.0308908, 0, 0.346734, 0.800866, 0.0289112, 0, 0.364342, 0.79093, 0.0270255, 0, 0.382307, 0.780593, 0.0252758, 0, 0.400637, 0.769511, 0.0236178, 0, 0.419337, 0.758558, 0.0220652, 0, 0.438418, 0.747632, 0.0206289, 0, 0.457889, 0.736146, 0.0192873, 0, 0.477761, 0.724093, 0.0180333, 0, 0.49805, 0.71234, 0.0168264, 0, 0.51877, 0.700201, 0.015746, 0, 0.53994, 0.687949, 0.0147027, 0, 0.561581, 0.676163, 0.0137512, 0, 0.583718, 0.665001, 0.0128655, 0, 0.60638, 0.65472, 0.0120366, 0, 0.629599, 0.644213, 0.0112604, 0, 0.653415, 0.633382, 0.0105413, 0, 0.677874, 0.62212, 0.00986498, 0, 0.70303, 0.610631, 0.00923308, 0, 0.728948, 0.599078, 0.00864206, 0, 0.755706, 0.587519, 0.00811784, 0, 0.783396, 0.575505, 0.00761237, 0, 0.812121, 0.563148, 0.00713949, 0, 0.841989, 0.550828, 0.00668379, 0, 0.873035, 0.538458, 0.00627715, 0, 0.904762, 0.525905, 0.00588336, 0, 0.936508, 0.513517, 0.00552687, 0, 0.968254, 0.501395, 0.00519681, 0, 1, 1, 0.0991506, 0, 0, 1, 0.0991504, 0, 0, 0.999996, 0.0991515, 0, 0, 0.999984, 0.0991558, 0, 0, 0.999947, 0.0991672, 0, 0.000114389, 0.999874, 0.0991912, 0, 0.00121503, 0.999739, 0.0992331, 0, 0.00356108, 0.999514, 0.0992983, 0, 0.00705578, 0.999159, 0.0993877, 0, 0.011574, 0.998586, 0.0994837, 0, 0.017003, 0.995731, 0.0988425, 0, 0.0232484, 0.993384, 0.098276, 0, 0.0302318, 0.991615, 0.0979269, 0, 0.0378884, 0.989029, 0.0973432, 0, 0.0461641, 0.985373, 0.0963539, 0, 0.0550136, 0.981278, 0.0952306, 0, 0.0643988, 0.975777, 0.0936233, 0, 0.0742868, 0.970526, 0.0920219, 0, 0.0846501, 0.963755, 0.0898912, 0, 0.0954644, 0.956676, 0.0876064, 0, 0.106709, 0.948099, 0.0847751, 0, 0.118367, 0.939718, 0.0818638, 0, 0.130423, 0.931305, 0.078857, 0, 0.142862, 0.922342, 0.0756127, 0, 0.155674, 0.912842, 0.0721473, 0, 0.168849, 0.903304, 0.0686195, 0, 0.182378, 0.89411, 0.0650589, 0, 0.196255, 0.885512, 0.0616022, 0, 0.210473, 0.877193, 0.0582434, 0, 0.225027, 0.86877, 0.0548979, 0, 0.239915, 0.860267, 0.0516095, 0, 0.255132, 0.851915, 0.048468, 0, 0.270678, 0.843912, 0.0454447, 0, 0.286551, 0.83604, 0.0425612, 0, 0.302751, 0.828245, 0.0398752, 0, 0.31928, 0.820159, 0.0373198, 0, 0.336138, 0.81167, 0.034916, 0, 0.35333, 0.802659, 0.0326402, 0, 0.370858, 0.793921, 0.0304901, 0, 0.388728, 0.784713, 0.0284857, 0, 0.406944, 0.774946, 0.0266186, 0, 0.425515, 0.76448, 0.0248593, 0, 0.444449, 0.753793, 0.0232114, 0, 0.463756, 0.743506, 0.0217039, 0, 0.483447, 0.732555, 0.0202841, 0, 0.503535, 0.720965, 0.0189648, 0, 0.524036, 0.709422, 0.0177189, 0, 0.544968, 0.697756, 0.0165626, 0, 0.56635, 0.685565, 0.015483, 0, 0.588208, 0.673987, 0.0144892, 0, 0.610569, 0.66244, 0.0135607, 0, 0.633466, 0.651675, 0.0126956, 0, 0.656936, 0.641598, 0.0118788, 0, 0.681025, 0.63121, 0.0111261, 0, 0.705788, 0.620514, 0.010437, 0, 0.731289, 0.609366, 0.00978747, 0, 0.757606, 0.598137, 0.00917257, 0, 0.784834, 0.586966, 0.00859778, 0, 0.813085, 0.575549, 0.00806803, 0, 0.842485, 0.563797, 0.00757294, 0, 0.87313, 0.551758, 0.00710592, 0, 0.904762, 0.539894, 0.0066841, 0, 0.936508, 0.527901, 0.00627901, 0, 0.968254, 0.515819, 0.00590506, 0, 1, 1, 0.120864, 0, 0, 1, 0.120864, 0, 0, 0.999996, 0.120864, 0, 0, 0.99998, 0.120867, 0, 0, 0.99994, 0.120872, 0, 0.000323781, 0.999852, 0.120884, 0, 0.00188693, 0.999693, 0.120903, 0, 0.00473489, 0.999426, 0.120929, 0, 0.00872704, 0.999002, 0.120955, 0, 0.0137237, 0.998235, 0.120918, 0, 0.0196068, 0.994608, 0.119764, 0, 0.0262803, 0.992997, 0.119265, 0, 0.0336657, 0.990968, 0.11863, 0, 0.0416987, 0.987002, 0.117261, 0, 0.0503261, 0.983524, 0.116009, 0, 0.0595035, 0.97875, 0.114252, 0, 0.0691935, 0.972652, 0.11193, 0, 0.0793645, 0.966613, 0.109555, 0, 0.0899894, 0.959275, 0.106612, 0, 0.101045, 0.951272, 0.103375, 0, 0.112512, 0.942323, 0.0996594, 0, 0.124372, 0.933679, 0.0958841, 0, 0.136611, 0.924822, 0.0919265, 0, 0.149216, 0.915742, 0.0878061, 0, 0.162176, 0.906348, 0.0834894, 0, 0.175482, 0.896883, 0.079085, 0, 0.189125, 0.88774, 0.0746745, 0, 0.203098, 0.87986, 0.0705773, 0, 0.217396, 0.871998, 0.0665005, 0, 0.232015, 0.864325, 0.0625413, 0, 0.24695, 0.856685, 0.0586781, 0, 0.2622, 0.84925, 0.0550063, 0, 0.277761, 0.841719, 0.0514727, 0, 0.293634, 0.834755, 0.0481398, 0, 0.309819, 0.827853, 0.0450172, 0, 0.326315, 0.820888, 0.0420969, 0, 0.343126, 0.813616, 0.0393702, 0, 0.360254, 0.805767, 0.0367771, 0, 0.377701, 0.797338, 0.0343274, 0, 0.395474, 0.789122, 0.0320529, 0, 0.413577, 0.780601, 0.0299485, 0, 0.432018, 0.771424, 0.0279812, 0, 0.450804, 0.761502, 0.0261054, 0, 0.469944, 0.751166, 0.0243942, 0, 0.489451, 0.741276, 0.0228087, 0, 0.509337, 0.730898, 0.0213265, 0, 0.529617, 0.719878, 0.0199307, 0, 0.550307, 0.708379, 0.0186574, 0, 0.571428, 0.697165, 0.0174446, 0, 0.593003, 0.685554, 0.0163144, 0, 0.615059, 0.673631, 0.015276, 0, 0.637628, 0.662385, 0.0143003, 0, 0.660746, 0.651059, 0.0134112, 0, 0.68446, 0.640451, 0.0125794, 0, 0.70882, 0.630536, 0.011793, 0, 0.733893, 0.620316, 0.0110547, 0, 0.759756, 0.609722, 0.0103668, 0, 0.786505, 0.598804, 0.00973009, 0, 0.814259, 0.587871, 0.00912812, 0, 0.843157, 0.577121, 0.00858916, 0, 0.87334, 0.566019, 0.00807333, 0, 0.904762, 0.554664, 0.00759687, 0, 0.936508, 0.543101, 0.00714759, 0, 0.968254, 0.531558, 0.00673418, 0, 1, 1, 0.146767, 0, 0, 1, 0.146767, 0, 0, 0.999997, 0.146767, 0, 0, 0.999977, 0.146765, 0, 3.20658e-06, 0.999929, 0.146762, 0, 0.000682576, 0.999823, 0.146753, 0, 0.00276402, 0.999633, 0.146735, 0, 0.00614771, 0.999314, 0.146699, 0, 0.0106613, 0.998796, 0.14662, 0, 0.0161546, 0.997124, 0.146107, 0, 0.0225063, 0.994062, 0.144857, 0, 0.0296198, 0.992154, 0.144011, 0, 0.037417, 0.989186, 0.142712, 0, 0.0458348, 0.985279, 0.140926, 0, 0.0548211, 0.980826, 0.13885, 0, 0.0643326, 0.975056, 0.136168, 0, 0.074333, 0.969005, 0.133217, 0, 0.0847917, 0.961554, 0.12959, 0, 0.0956828, 0.954206, 0.125886, 0, 0.106984, 0.945046, 0.121335, 0, 0.118675, 0.935678, 0.116492, 0, 0.130741, 0.926748, 0.111635, 0, 0.143166, 0.917764, 0.106625, 0, 0.155939, 0.908358, 0.101325, 0, 0.169049, 0.899219, 0.0960249, 0, 0.182487, 0.890089, 0.0906527, 0, 0.196245, 0.881488, 0.0853905, 0, 0.210317, 0.874031, 0.0804177, 0, 0.224697, 0.866932, 0.0756005, 0, 0.23938, 0.859976, 0.0709019, 0, 0.254364, 0.853375, 0.0664391, 0, 0.269646, 0.846971, 0.0622012, 0, 0.285223, 0.840483, 0.058129, 0, 0.301096, 0.833969, 0.0542762, 0, 0.317265, 0.82806, 0.0507042, 0, 0.333729, 0.822128, 0.047368, 0, 0.350491, 0.815989, 0.044272, 0, 0.367554, 0.809336, 0.0413444, 0, 0.38492, 0.802177, 0.038601, 0, 0.402594, 0.79441, 0.0360227, 0, 0.420582, 0.786573, 0.0336383, 0, 0.438891, 0.778619, 0.0314321, 0, 0.457527, 0.77, 0.029362, 0, 0.476499, 0.760698, 0.0274102, 0, 0.49582, 0.750932, 0.0256146, 0, 0.5155, 0.740993, 0.023974, 0, 0.535555, 0.731159, 0.0224182, 0, 0.556, 0.720836, 0.0209889, 0, 0.576855, 0.709913, 0.0196411, 0, 0.598143, 0.698415, 0.0183824, 0, 0.619888, 0.68745, 0.0172222, 0, 0.642123, 0.676154, 0.0161509, 0, 0.664883, 0.664383, 0.0151397, 0, 0.688211, 0.6533, 0.0141873, 0, 0.71216, 0.642072, 0.0133105, 0, 0.736792, 0.631412, 0.0124932, 0, 0.762186, 0.621622, 0.0117408, 0, 0.788439, 0.611681, 0.0110358, 0, 0.815672, 0.60142, 0.0103775, 0, 0.844034, 0.59083, 0.00975623, 0, 0.873699, 0.580254, 0.00918084, 0, 0.904765, 0.569841, 0.00864721, 0, 0.936508, 0.559224, 0.00815731, 0, 0.968254, 0.548315, 0.00767924, 0, 1, 1, 0.177563, 0, 0, 1, 0.177563, 0, 0, 0.999994, 0.177562, 0, 0, 0.999972, 0.177555, 0, 6.64171e-05, 0.999914, 0.177536, 0, 0.0012276, 0.999787, 0.177496, 0, 0.00388025, 0.999556, 0.17742, 0, 0.00783463, 0.999165, 0.177285, 0, 0.0128953, 0.9985, 0.177037, 0, 0.0189053, 0.995388, 0.175634, 0, 0.025742, 0.993102, 0.174375, 0, 0.033309, 0.990992, 0.173121, 0, 0.0415298, 0.986932, 0.170896, 0, 0.0503425, 0.982786, 0.16847, 0, 0.0596964, 0.977592, 0.165455, 0, 0.0695498, 0.971075, 0.161676, 0, 0.0798676, 0.963967, 0.157458, 0, 0.0906201, 0.956397, 0.152836, 0, 0.101783, 0.947489, 0.147467, 0, 0.113333, 0.937564, 0.14145, 0, 0.125254, 0.928182, 0.135383, 0, 0.137529, 0.919027, 0.129212, 0, 0.150144, 0.909618, 0.12276, 0, 0.163088, 0.900492, 0.116273, 0, 0.176351, 0.891671, 0.1098, 0, 0.189924, 0.883146, 0.103362, 0, 0.203799, 0.875151, 0.0970799, 0, 0.21797, 0.868338, 0.0911732, 0, 0.232433, 0.862033, 0.0854966, 0, 0.247182, 0.856107, 0.0800691, 0, 0.262216, 0.850644, 0.0749618, 0, 0.27753, 0.845261, 0.070079, 0, 0.293124, 0.839885, 0.0654321, 0, 0.308997, 0.834609, 0.0610975, 0, 0.325149, 0.829083, 0.0569741, 0, 0.341581, 0.82404, 0.0531736, 0, 0.358294, 0.818968, 0.049665, 0, 0.37529, 0.813496, 0.0463856, 0, 0.392573, 0.807533, 0.0433217, 0, 0.410148, 0.80099, 0.0404402, 0, 0.428019, 0.793891, 0.0377578, 0, 0.446192, 0.786281, 0.0352616, 0, 0.464676, 0.778773, 0.0329577, 0, 0.483478, 0.770737, 0.030808, 0, 0.502608, 0.762094, 0.0287964, 0, 0.522079, 0.752898, 0.0269254, 0, 0.541905, 0.743306, 0.0251926, 0, 0.5621, 0.733416, 0.023595, 0, 0.582684, 0.723742, 0.0221155, 0, 0.603677, 0.713542, 0.0207435, 0, 0.625106, 0.702755, 0.019434, 0, 0.646998, 0.691484, 0.0182046, 0, 0.66939, 0.680531, 0.0170771, 0, 0.692324, 0.66953, 0.0160339, 0, 0.715849, 0.658126, 0.0150677, 0, 0.740028, 0.646933, 0.0141551, 0, 0.764937, 0.636107, 0.0133179, 0, 0.790673, 0.625271, 0.0125284, 0, 0.817358, 0.615225, 0.0117937, 0, 0.84515, 0.605678, 0.0111181, 0, 0.874244, 0.59583, 0.0104759, 0, 0.904828, 0.585704, 0.00986672, 0, 0.936508, 0.575413, 0.00929712, 0, 0.968254, 0.565373, 0.00876713, 0, 1, 1, 0.214058, 0, 0, 0.999999, 0.214058, 0, 0, 0.999994, 0.214055, 0, 0, 0.999966, 0.214039, 0, 0.000259642, 0.999893, 0.213998, 0, 0.00200075, 0.999737, 0.21391, 0, 0.00527775, 0.999449, 0.213745, 0, 0.00983959, 0.99896, 0.213458, 0, 0.0154755, 0.9979, 0.212855, 0, 0.0220249, 0.994278, 0.210779, 0, 0.0293654, 0.992254, 0.20926, 0, 0.0374021, 0.98881, 0.206908, 0, 0.0460604, 0.984715, 0.204009, 0, 0.0552802, 0.979738, 0.200471, 0, 0.0650127, 0.972884, 0.195813, 0, 0.0752175, 0.965996, 0.190856, 0, 0.0858612, 0.957974, 0.185077, 0, 0.0969155, 0.949155, 0.17868, 0, 0.108356, 0.939288, 0.171513, 0, 0.120163, 0.928996, 0.163838, 0, 0.132319, 0.919563, 0.156246, 0, 0.144808, 0.910004, 0.148359, 0, 0.157618, 0.900791, 0.140417, 0, 0.170737, 0.892135, 0.132569, 0, 0.184155, 0.883803, 0.124741, 0, 0.197866, 0.876034, 0.117091, 0, 0.211861, 0.869219, 0.109835, 0, 0.226134, 0.863062, 0.102859, 0, 0.240682, 0.857795, 0.0962928, 0, 0.255499, 0.853009, 0.0900725, 0, 0.270583, 0.848603, 0.0842101, 0, 0.285931, 0.844335, 0.0786527, 0, 0.301542, 0.840208, 0.0734397, 0, 0.317415, 0.836035, 0.0685334, 0, 0.33355, 0.83172, 0.0639275, 0, 0.349948, 0.827135, 0.0595909, 0, 0.36661, 0.822797, 0.0556204, 0, 0.383539, 0.818387, 0.0519394, 0, 0.400738, 0.813565, 0.0485317, 0, 0.41821, 0.808142, 0.0453138, 0, 0.435961, 0.802212, 0.0423354, 0, 0.453997, 0.79573, 0.0395553, 0, 0.472324, 0.788741, 0.036988, 0, 0.490951, 0.781093, 0.0345688, 0, 0.509887, 0.773597, 0.0323297, 0, 0.529144, 0.765622, 0.0302719, 0, 0.548735, 0.757083, 0.0283477, 0, 0.568674, 0.747992, 0.0265562, 0, 0.588979, 0.738591, 0.0248844, 0, 0.609671, 0.728719, 0.0233342, 0, 0.630773, 0.719146, 0.0219081, 0, 0.652314, 0.709165, 0.0205711, 0, 0.674328, 0.69875, 0.0193248, 0, 0.696854, 0.687884, 0.0181582, 0, 0.719942, 0.676818, 0.0170746, 0, 0.743651, 0.666247, 0.0160718, 0, 0.768057, 0.655284, 0.0151262, 0, 0.793253, 0.64401, 0.0142561, 0, 0.819363, 0.633353, 0.0134327, 0, 0.846547, 0.622674, 0.012653, 0, 0.875017, 0.612265, 0.0119354, 0, 0.905021, 0.602455, 0.0112533, 0, 0.936508, 0.593147, 0.0106234, 0, 0.968254, 0.583592, 0.0100213, 0, 1, 1, 0.25717, 0, 0, 1, 0.25717, 0, 0, 0.999992, 0.257164, 0, 0, 0.999958, 0.257135, 0, 0.000641715, 0.999864, 0.25706, 0, 0.00305314, 0.999666, 0.256897, 0, 0.00700975, 0.999302, 0.256596, 0, 0.0122194, 0.998663, 0.25607, 0, 0.0184622, 0.995607, 0.254123, 0, 0.0255773, 0.993094, 0.252081, 0, 0.0334439, 0.9907, 0.249867, 0, 0.0419696, 0.98594, 0.246118, 0, 0.0510823, 0.981214, 0.242049, 0, 0.0607242, 0.974966, 0.236869, 0, 0.0708486, 0.967589, 0.230724, 0, 0.081417, 0.95915, 0.223635, 0, 0.0923974, 0.950257, 0.21596, 0, 0.103763, 0.940165, 0.207296, 0, 0.115491, 0.929396, 0.197901, 0, 0.127562, 0.919288, 0.188437, 0, 0.13996, 0.909428, 0.178762, 0, 0.15267, 0.900105, 0.169072, 0, 0.165679, 0.891418, 0.159478, 0, 0.178979, 0.883347, 0.15002, 0, 0.192558, 0.875992, 0.140813, 0, 0.20641, 0.869466, 0.13196, 0, 0.220529, 0.863699, 0.123501, 0, 0.234907, 0.858553, 0.115436, 0, 0.249542, 0.854379, 0.107901, 0, 0.264428, 0.850894, 0.10088, 0, 0.279564, 0.847632, 0.0942296, 0, 0.294947, 0.844571, 0.0879861, 0, 0.310575, 0.84163, 0.0821534, 0, 0.326448, 0.838542, 0.0766409, 0, 0.342566, 0.835412, 0.0715322, 0, 0.358929, 0.831899, 0.0666883, 0, 0.37554, 0.828177, 0.0622175, 0, 0.392399, 0.82416, 0.0580452, 0, 0.409511, 0.820393, 0.054267, 0, 0.426878, 0.816068, 0.0507172, 0, 0.444506, 0.811201, 0.0474041, 0, 0.4624, 0.805785, 0.0443174, 0, 0.480566, 0.799878, 0.0414562, 0, 0.499013, 0.793469, 0.0388147, 0, 0.517749, 0.786473, 0.0363453, 0, 0.536785, 0.778874, 0.0340225, 0, 0.556134, 0.771277, 0.0318599, 0, 0.575809, 0.763426, 0.0298859, 0, 0.595827, 0.755044, 0.0280357, 0, 0.616207, 0.746161, 0.0262979, 0, 0.636973, 0.737124, 0.0247295, 0, 0.65815, 0.72761, 0.0232514, 0, 0.679772, 0.717822, 0.0218755, 0, 0.701876, 0.708279, 0.0205942, 0, 0.724509, 0.698333, 0.0193947, 0, 0.74773, 0.68802, 0.0182717, 0, 0.771609, 0.677321, 0.0172044, 0, 0.79624, 0.666504, 0.0162122, 0, 0.821743, 0.656184, 0.0152924, 0, 0.84828, 0.64556, 0.0144326, 0, 0.876069, 0.634636, 0.0136157, 0, 0.905404, 0.624124, 0.0128612, 0, 0.936508, 0.613914, 0.0121435, 0, 0.968254, 0.603589, 0.0114887, 0, 1, 1, 0.307946, 0, 0, 0.999999, 0.307945, 0, 0, 0.999988, 0.307934, 0, 2.04479e-05, 0.999944, 0.307886, 0, 0.00127833, 0.999824, 0.307756, 0, 0.00445047, 0.999565, 0.30748, 0, 0.00914673, 0.999085, 0.306966, 0, 0.0150498, 0.998103, 0.306004, 0, 0.0219367, 0.994249, 0.303028, 0, 0.0296485, 0.991807, 0.300435, 0, 0.038068, 0.987773, 0.296554, 0, 0.0471062, 0.982673, 0.2916, 0, 0.0566942, 0.976623, 0.285641, 0, 0.0667768, 0.968757, 0.27815, 0, 0.0773099, 0.959849, 0.269529, 0, 0.088257, 0.950663, 0.260248, 0, 0.0995879, 0.940129, 0.249704, 0, 0.111277, 0.92895, 0.238291, 0, 0.123304, 0.917996, 0.226501, 0, 0.13565, 0.907813, 0.214669, 0, 0.148299, 0.898305, 0.202835, 0, 0.161237, 0.889626, 0.191158, 0, 0.174455, 0.88175, 0.179695, 0, 0.187941, 0.874715, 0.168548, 0, 0.201687, 0.868746, 0.15792, 0, 0.215687, 0.863703, 0.147807, 0, 0.229933, 0.859315, 0.138149, 0, 0.24442, 0.855538, 0.128993, 0, 0.259145, 0.852428, 0.120414, 0, 0.274103, 0.850168, 0.112498, 0, 0.289293, 0.848132, 0.105054, 0, 0.304711, 0.846291, 0.0981087, 0, 0.320357, 0.844431, 0.0915942, 0, 0.33623, 0.842493, 0.0855056, 0, 0.35233, 0.840368, 0.0798204, 0, 0.368658, 0.83798, 0.0745097, 0, 0.385214, 0.83523, 0.0695424, 0, 0.402002, 0.832091, 0.0649092, 0, 0.419023, 0.828667, 0.0606291, 0, 0.436282, 0.824805, 0.0566523, 0, 0.453782, 0.820988, 0.0530229, 0, 0.471529, 0.816635, 0.0496364, 0, 0.489528, 0.811725, 0.0464658, 0, 0.507788, 0.806316, 0.0435082, 0, 0.526317, 0.800469, 0.0407873, 0, 0.545124, 0.794107, 0.038255, 0, 0.564221, 0.787218, 0.0358825, 0, 0.583621, 0.779872, 0.0336785, 0, 0.603341, 0.772097, 0.0316379, 0, 0.623397, 0.764484, 0.0297379, 0, 0.643812, 0.756428, 0.0279581, 0, 0.664611, 0.748022, 0.0263153, 0, 0.685824, 0.739268, 0.0247799, 0, 0.707488, 0.73024, 0.0233385, 0, 0.729646, 0.720893, 0.0220035, 0, 0.752354, 0.71119, 0.0207555, 0, 0.77568, 0.701791, 0.0195843, 0, 0.799715, 0.692184, 0.0184891, 0, 0.824574, 0.682258, 0.0174541, 0, 0.850417, 0.67206, 0.0164873, 0, 0.877466, 0.661717, 0.0155959, 0, 0.90604, 0.651462, 0.0147519, 0, 0.936528, 0.641467, 0.0139727, 0, 0.968254, 0.631229, 0.0132363, 0, 1, 1, 0.367573, 0, 0, 0.999999, 0.367571, 0, 0, 0.999984, 0.367553, 0, 0.000183382, 0.999925, 0.367473, 0, 0.00225254, 0.999759, 0.367259, 0, 0.00628165, 0.99941, 0.366801, 0, 0.0117858, 0.998739, 0.365946, 0, 0.0184359, 0.995529, 0.363191, 0, 0.0260114, 0.992875, 0.360171, 0, 0.0343581, 0.989135, 0.355981, 0, 0.0433637, 0.984166, 0.350401, 0, 0.0529438, 0.977871, 0.343348, 0, 0.0630334, 0.96951, 0.334341, 0, 0.0735805, 0.959964, 0.323862, 0, 0.0845437, 0.950162, 0.312521, 0, 0.095889, 0.938882, 0.299577, 0, 0.107588, 0.926992, 0.285573, 0, 0.119617, 0.915589, 0.271212, 0, 0.131957, 0.904791, 0.256611, 0, 0.144591, 0.895177, 0.242224, 0, 0.157503, 0.886403, 0.227952, 0, 0.170682, 0.878957, 0.214192, 0, 0.184117, 0.872418, 0.200795, 0, 0.197799, 0.867029, 0.188015, 0, 0.21172, 0.862835, 0.175975, 0, 0.225873, 0.859411, 0.164526, 0, 0.240253, 0.856655, 0.153693, 0, 0.254854, 0.854519, 0.14352, 0, 0.269673, 0.852828, 0.13397, 0, 0.284707, 0.851412, 0.124984, 0, 0.299953, 0.850609, 0.116748, 0, 0.315408, 0.849855, 0.10905, 0, 0.331073, 0.849017, 0.101839, 0, 0.346946, 0.848079, 0.0951359, 0, 0.363028, 0.846911, 0.0888774, 0, 0.379318, 0.845445, 0.0830375, 0, 0.395818, 0.84362, 0.0775844, 0, 0.41253, 0.841411, 0.0725054, 0, 0.429457, 0.838768, 0.0677691, 0, 0.446602, 0.835801, 0.0634016, 0, 0.463968, 0.832341, 0.0593095, 0, 0.481561, 0.828424, 0.0555121, 0, 0.499386, 0.824312, 0.052024, 0, 0.51745, 0.819918, 0.0487865, 0, 0.535761, 0.815072, 0.0457801, 0, 0.554328, 0.809863, 0.0430184, 0, 0.573162, 0.804164, 0.0404245, 0, 0.592275, 0.798034, 0.0380146, 0, 0.611681, 0.791436, 0.0357436, 0, 0.631398, 0.784498, 0.0336475, 0, 0.651445, 0.777125, 0.0316666, 0, 0.671845, 0.769365, 0.0298122, 0, 0.692628, 0.761579, 0.0281001, 0, 0.713827, 0.753746, 0.0265049, 0, 0.735484, 0.745573, 0.0250067, 0, 0.75765, 0.737083, 0.0236026, 0, 0.78039, 0.728545, 0.0223302, 0, 0.803789, 0.719691, 0.0211243, 0, 0.82796, 0.710569, 0.0199983, 0, 0.853056, 0.701216, 0.0189569, 0, 0.879298, 0.692094, 0.0179702, 0, 0.907014, 0.682909, 0.0170418, 0, 0.936691, 0.673509, 0.0161732, 0, 0.968254, 0.663863, 0.0153406, 0, 1, 1, 0.437395, 0, 0, 0.999998, 0.437394, 0, 0, 0.99998, 0.437363, 0, 0.000616704, 0.999891, 0.437232, 0, 0.00367925, 0.999656, 0.436877, 0, 0.00867446, 0.999148, 0.436121, 0, 0.0150679, 0.997959, 0.434564, 0, 0.022531, 0.993464, 0.430134, 0, 0.0308507, 0.990606, 0.426077, 0, 0.0398805, 0.985027, 0.419397, 0, 0.0495148, 0.978491, 0.41118, 0, 0.0596749, 0.969643, 0.40048, 0, 0.0703001, 0.959189, 0.38769, 0, 0.0813427, 0.948223, 0.373575, 0, 0.0927641, 0.935955, 0.357622, 0, 0.104533, 0.923237, 0.34043, 0, 0.116624, 0.911074, 0.322735, 0, 0.129015, 0.899724, 0.30479, 0, 0.141687, 0.890189, 0.287392, 0, 0.154626, 0.881796, 0.270248, 0, 0.167818, 0.874781, 0.253659, 0, 0.181252, 0.869166, 0.237786, 0, 0.194918, 0.864725, 0.222618, 0, 0.208807, 0.861565, 0.208356, 0, 0.222913, 0.859284, 0.194867, 0, 0.237229, 0.857677, 0.18212, 0, 0.25175, 0.856714, 0.17018, 0, 0.266473, 0.856155, 0.158969, 0, 0.281392, 0.8558, 0.148413, 0, 0.296505, 0.855672, 0.138578, 0, 0.311811, 0.855538, 0.129345, 0, 0.327306, 0.855689, 0.120861, 0, 0.342991, 0.855767, 0.112969, 0, 0.358864, 0.855618, 0.105593, 0, 0.374925, 0.85525, 0.0987451, 0, 0.391176, 0.854583, 0.0923727, 0, 0.407616, 0.853534, 0.0864143, 0, 0.424249, 0.852061, 0.0808338, 0, 0.441076, 0.850253, 0.0756771, 0, 0.4581, 0.848004, 0.0708612, 0, 0.475324, 0.845333, 0.0663784, 0, 0.492754, 0.842376, 0.0622631, 0, 0.510394, 0.838956, 0.0584112, 0, 0.528251, 0.835121, 0.0548328, 0, 0.546331, 0.830842, 0.0514838, 0, 0.564644, 0.826212, 0.048355, 0, 0.583198, 0.821522, 0.0454714, 0, 0.602005, 0.816551, 0.0428263, 0, 0.621078, 0.811211, 0.0403612, 0, 0.640434, 0.805479, 0.038039, 0, 0.660089, 0.799409, 0.0358739, 0, 0.680066, 0.79306, 0.0338727, 0, 0.70039, 0.786395, 0.0319985, 0, 0.721094, 0.779416, 0.030241, 0, 0.742215, 0.77214, 0.0285951, 0, 0.7638, 0.764636, 0.0270747, 0, 0.785912, 0.756836, 0.0256354, 0, 0.808628, 0.749315, 0.0243027, 0, 0.832055, 0.741561, 0.0230497, 0, 0.856338, 0.733589, 0.0218801, 0, 0.88169, 0.725479, 0.020784, 0, 0.908441, 0.717255, 0.0197702, 0, 0.937125, 0.708829, 0.0188168, 0, 0.968254, 0.700191, 0.0179113, 0, 1, 1, 0.518937, 0, 0, 0.999998, 0.518933, 0, 0, 0.999967, 0.518883, 0, 0.00147741, 0.999832, 0.51866, 0, 0.00573221, 0.999466, 0.518057, 0, 0.011826, 0.998644, 0.516752, 0, 0.0192116, 0.994458, 0.512347, 0, 0.027573, 0.991223, 0.507675, 0, 0.0367099, 0.985515, 0.500188, 0, 0.046487, 0.978308, 0.490408, 0, 0.0568071, 0.968359, 0.477357, 0, 0.0675984, 0.95682, 0.461752, 0, 0.0788059, 0.943929, 0.443796, 0, 0.090386, 0.930224, 0.423893, 0, 0.102304, 0.916514, 0.402682, 0, 0.114532, 0.903653, 0.380914, 0, 0.127047, 0.892315, 0.359212, 0, 0.139828, 0.882942, 0.338102, 0, 0.152861, 0.875438, 0.31773, 0, 0.16613, 0.869642, 0.298186, 0, 0.179624, 0.865304, 0.279491, 0, 0.193332, 0.862382, 0.261804, 0, 0.207247, 0.860666, 0.245146, 0, 0.22136, 0.859788, 0.229406, 0, 0.235666, 0.859608, 0.214605, 0, 0.250158, 0.859912, 0.200691, 0, 0.264832, 0.86053, 0.187623, 0, 0.279684, 0.861368, 0.17539, 0, 0.294711, 0.862237, 0.163901, 0, 0.309911, 0.863127, 0.153175, 0, 0.32528, 0.863923, 0.143147, 0, 0.340819, 0.864567, 0.133781, 0, 0.356524, 0.865013, 0.125042, 0, 0.372397, 0.86539, 0.116952, 0, 0.388438, 0.865591, 0.109476, 0, 0.404645, 0.865517, 0.102542, 0, 0.421022, 0.865084, 0.0960688, 0, 0.437569, 0.864309, 0.0900499, 0, 0.454287, 0.863151, 0.0844328, 0, 0.471181, 0.861649, 0.0792218, 0, 0.488253, 0.859742, 0.0743482, 0, 0.505507, 0.857446, 0.0697963, 0, 0.522947, 0.854757, 0.0655364, 0, 0.54058, 0.851783, 0.061608, 0, 0.558412, 0.848516, 0.0579701, 0, 0.576449, 0.844897, 0.0545742, 0, 0.594701, 0.840956, 0.0514167, 0, 0.613178, 0.836676, 0.0484598, 0, 0.631892, 0.832075, 0.0456934, 0, 0.650856, 0.827191, 0.0431178, 0, 0.670088, 0.822295, 0.0407718, 0, 0.689606, 0.817294, 0.0386032, 0, 0.709434, 0.812013, 0.0365675, 0, 0.7296, 0.806465, 0.0346547, 0, 0.750138, 0.800691, 0.0328717, 0, 0.771093, 0.794709, 0.031211, 0, 0.792519, 0.788493, 0.0296504, 0, 0.814488, 0.782049, 0.0281782, 0, 0.837097, 0.775403, 0.0267965, 0, 0.860481, 0.76857, 0.0255002, 0, 0.884842, 0.761536, 0.0242759, 0, 0.910494, 0.754303, 0.0231142, 0, 0.937985, 0.74692, 0.0220305, 0, 0.968254, 0.739745, 0.0210192, 0, 1, 1, 0.613914, 0, 0, 0.999996, 0.613907, 0, 9.63597e-05, 0.999942, 0.613814, 0, 0.00301247, 0.999704, 0.613407, 0, 0.00870385, 0.999046, 0.612302, 0, 0.0160714, 0.995516, 0.608266, 0, 0.0245899, 0.991726, 0.602863, 0, 0.0339681, 0.985157, 0.593956, 0, 0.0440254, 0.97642, 0.581748, 0, 0.0546409, 0.964404, 0.565183, 0, 0.0657284, 0.950601, 0.545273, 0, 0.0772246, 0.935158, 0.522129, 0, 0.0890812, 0.919364, 0.496782, 0, 0.10126, 0.904754, 0.470571, 0, 0.113731, 0.89176, 0.444037, 0, 0.126469, 0.881492, 0.418322, 0, 0.139454, 0.873656, 0.393522, 0, 0.15267, 0.868053, 0.369795, 0, 0.166101, 0.864336, 0.347171, 0, 0.179736, 0.862259, 0.325737, 0, 0.193565, 0.861556, 0.305532, 0, 0.207578, 0.861776, 0.286416, 0, 0.221769, 0.862661, 0.268355, 0, 0.23613, 0.864015, 0.251334, 0, 0.250656, 0.865711, 0.235352, 0, 0.265343, 0.867519, 0.220302, 0, 0.280187, 0.869351, 0.206161, 0, 0.295183, 0.871144, 0.192908, 0, 0.31033, 0.872839, 0.180505, 0, 0.325624, 0.874307, 0.168848, 0, 0.341065, 0.875667, 0.158021, 0, 0.35665, 0.876758, 0.147877, 0, 0.37238, 0.87764, 0.138441, 0, 0.388253, 0.878237, 0.129627, 0, 0.404269, 0.878563, 0.121415, 0, 0.42043, 0.878572, 0.113741, 0, 0.436735, 0.87842, 0.106652, 0, 0.453187, 0.878057, 0.100097, 0, 0.469786, 0.877413, 0.0940128, 0, 0.486536, 0.87646, 0.0883462, 0, 0.503439, 0.875233, 0.0830924, 0, 0.520498, 0.8737, 0.0781975, 0, 0.537717, 0.871873, 0.07364, 0, 0.555102, 0.86978, 0.0694103, 0, 0.572657, 0.867405, 0.0654696, 0, 0.59039, 0.864751, 0.0617914, 0, 0.608307, 0.861818, 0.0583491, 0, 0.626419, 0.858645, 0.0551443, 0, 0.644733, 0.855307, 0.0521894, 0, 0.663264, 0.851736, 0.0494334, 0, 0.682025, 0.847927, 0.0468504, 0, 0.701032, 0.843888, 0.0444261, 0, 0.720308, 0.839629, 0.0421497, 0, 0.739875, 0.835158, 0.0400082, 0, 0.759764, 0.830509, 0.0380076, 0, 0.780014, 0.825714, 0.0361488, 0, 0.800673, 0.820729, 0.0343956, 0, 0.821803, 0.815751, 0.0327781, 0, 0.843492, 0.810752, 0.031275, 0, 0.86586, 0.805587, 0.0298542, 0, 0.889087, 0.800317, 0.0285397, 0, 0.913466, 0.79489, 0.0272948, 0, 0.93952, 0.789314, 0.0261139, 0, 0.96835, 0.783593, 0.0249938, 0, 1, 1, 0.724258, 0, 0, 0.999992, 0.724243, 0, 0.000726889, 0.99987, 0.724044, 0, 0.00569574, 0.999336, 0.72317, 0, 0.0131702, 0.996271, 0.719432, 0, 0.0220738, 0.991159, 0.712576, 0, 0.0319405, 0.982465, 0.700927, 0, 0.0425202, 0.97049, 0.684297, 0, 0.0536599, 0.953973, 0.661244, 0, 0.065258, 0.935546, 0.633804, 0, 0.0772427, 0.916596, 0.603071, 0, 0.0895616, 0.899353, 0.57105, 0, 0.102175, 0.885216, 0.539206, 0, 0.11505, 0.875076, 0.508714, 0, 0.128164, 0.868334, 0.479571, 0, 0.141495, 0.864414, 0.451796, 0, 0.155026, 0.862678, 0.425328, 0, 0.168745, 0.862835, 0.400352, 0, 0.182639, 0.864067, 0.376532, 0, 0.196699, 0.866086, 0.35391, 0, 0.210915, 0.868557, 0.332424, 0, 0.225282, 0.871271, 0.312053, 0, 0.239792, 0.874058, 0.292764, 0, 0.25444, 0.8768, 0.27453, 0, 0.269223, 0.87939, 0.257297, 0, 0.284135, 0.8819, 0.24114, 0, 0.299174, 0.884187, 0.225934, 0, 0.314337, 0.886262, 0.211669, 0, 0.329622, 0.888119, 0.198311, 0, 0.345026, 0.889709, 0.185783, 0, 0.360549, 0.891054, 0.174063, 0, 0.376189, 0.892196, 0.163143, 0, 0.391946, 0.893101, 0.152952, 0, 0.407819, 0.893803, 0.143475, 0, 0.423808, 0.894277, 0.134647, 0, 0.439914, 0.894532, 0.126434, 0, 0.456137, 0.894576, 0.1188, 0, 0.472479, 0.894393, 0.111694, 0, 0.48894, 0.893976, 0.105069, 0, 0.505523, 0.893346, 0.0989077, 0, 0.52223, 0.892502, 0.0931724, 0, 0.539064, 0.891441, 0.0878276, 0, 0.556028, 0.890276, 0.082903, 0, 0.573125, 0.888972, 0.0783505, 0, 0.590361, 0.887469, 0.0741083, 0, 0.607741, 0.885785, 0.0701633, 0, 0.62527, 0.883914, 0.0664835, 0, 0.642957, 0.881872, 0.0630567, 0, 0.660809, 0.879651, 0.0598527, 0, 0.678836, 0.877267, 0.0568615, 0, 0.69705, 0.874717, 0.05406, 0, 0.715465, 0.872012, 0.0514378, 0, 0.734098, 0.869157, 0.0489805, 0, 0.752968, 0.866155, 0.0466727, 0, 0.772101, 0.863014, 0.0445056, 0, 0.791529, 0.859748, 0.0424733, 0, 0.81129, 0.856416, 0.0405957, 0, 0.831438, 0.852958, 0.0388273, 0, 0.852044, 0.849382, 0.0371619, 0, 0.87321, 0.845694, 0.0355959, 0, 0.89509, 0.841893, 0.0341155, 0, 0.917932, 0.837981, 0.0327141, 0, 0.942204, 0.833963, 0.0313856, 0, 0.968981, 0.829847, 0.0301275, 0, 1, 1, 0.85214, 0, 0, 0.999969, 0.852095, 0, 0.00279627, 0.999483, 0.851408, 0, 0.0107635, 0.994545, 0.84579, 0, 0.0206454, 0.986188, 0.835231, 0, 0.0315756, 0.969847, 0.814687, 0, 0.0432021, 0.945951, 0.783735, 0, 0.0553396, 0.91917, 0.746074, 0, 0.0678766, 0.895488, 0.706938, 0, 0.0807395, 0.878232, 0.669534, 0, 0.0938767, 0.868252, 0.635168, 0, 0.10725, 0.863873, 0.603069, 0, 0.120832, 0.863369, 0.572514, 0, 0.134598, 0.86545, 0.543169, 0, 0.148533, 0.868803, 0.514578, 0, 0.16262, 0.872794, 0.486762, 0, 0.176849, 0.87702, 0.459811, 0, 0.19121, 0.881054, 0.433654, 0, 0.205694, 0.884974, 0.408574, 0, 0.220294, 0.888587, 0.384525, 0, 0.235005, 0.891877, 0.36156, 0, 0.24982, 0.894793, 0.339661, 0, 0.264737, 0.89743, 0.318913, 0, 0.279751, 0.899796, 0.299302, 0, 0.294859, 0.901943, 0.280843, 0, 0.310058, 0.903858, 0.263481, 0, 0.325346, 0.905574, 0.247197, 0, 0.340721, 0.907069, 0.231915, 0, 0.356181, 0.908379, 0.217614, 0, 0.371725, 0.90952, 0.20425, 0, 0.387353, 0.910483, 0.191758, 0, 0.403063, 0.91128, 0.180092, 0, 0.418854, 0.911936, 0.169222, 0, 0.434727, 0.912454, 0.159098, 0, 0.450682, 0.912835, 0.149668, 0, 0.466718, 0.913078, 0.140884, 0, 0.482837, 0.913192, 0.132709, 0, 0.499038, 0.913175, 0.125095, 0, 0.515324, 0.91304, 0.118012, 0, 0.531695, 0.912781, 0.111417, 0, 0.548153, 0.91241, 0.105281, 0, 0.5647, 0.911924, 0.0995691, 0, 0.581338, 0.911331, 0.0942531, 0, 0.59807, 0.910637, 0.0893076, 0, 0.6149, 0.90984, 0.0846998, 0, 0.63183, 0.908941, 0.0804044, 0, 0.648865, 0.907944, 0.0763984, 0, 0.666011, 0.906857, 0.0726638, 0, 0.683273, 0.90568, 0.0691783, 0, 0.700659, 0.904416, 0.0659222, 0, 0.718176, 0.903067, 0.0628782, 0, 0.735834, 0.901637, 0.0600307, 0, 0.753646, 0.900128, 0.0573647, 0, 0.771625, 0.898544, 0.0548668, 0, 0.78979, 0.89689, 0.052527, 0, 0.808162, 0.895165, 0.0503306, 0, 0.826771, 0.893371, 0.0482668, 0, 0.845654, 0.891572, 0.0463605, 0, 0.864863, 0.889763, 0.0445998, 0, 0.884472, 0.887894, 0.0429451, 0, 0.904592, 0.885967, 0.0413884, 0, 0.925407, 0.883984, 0.0399225, 0, 0.947271, 0.881945, 0.0385405, 0, 0.97105, 0.879854, 0.0372362, 0, 1, 0.999804, 0.995833, 0, 0, 0.938155, 0.933611, 0, 0.0158731, 0.864755, 0.854311, 0, 0.0317461, 0.888594, 0.865264, 0, 0.0476191, 0.905575, 0.863922, 0, 0.0634921, 0.915125, 0.850558, 0, 0.0793651, 0.920665, 0.829254, 0, 0.0952381, 0.924073, 0.802578, 0, 0.111111, 0.926304, 0.772211, 0, 0.126984, 0.927829, 0.739366, 0, 0.142857, 0.928924, 0.705033, 0, 0.15873, 0.92973, 0.670019, 0, 0.174603, 0.930339, 0.634993, 0, 0.190476, 0.930811, 0.600485, 0, 0.206349, 0.931191, 0.566897, 0, 0.222222, 0.93149, 0.534485, 0, 0.238095, 0.931737, 0.503429, 0, 0.253968, 0.931939, 0.473811, 0, 0.269841, 0.932108, 0.445668, 0, 0.285714, 0.93225, 0.418993, 0, 0.301587, 0.932371, 0.393762, 0, 0.31746, 0.932474, 0.369939, 0, 0.333333, 0.932562, 0.347479, 0, 0.349206, 0.932638, 0.326336, 0, 0.365079, 0.932703, 0.306462, 0, 0.380952, 0.93276, 0.287805, 0, 0.396825, 0.932809, 0.270313, 0, 0.412698, 0.932851, 0.253933, 0, 0.428571, 0.932887, 0.23861, 0, 0.444444, 0.932917, 0.224289, 0, 0.460317, 0.932943, 0.210917, 0, 0.47619, 0.932965, 0.19844, 0, 0.492063, 0.932982, 0.186807, 0, 0.507937, 0.932995, 0.175966, 0, 0.52381, 0.933005, 0.165869, 0, 0.539683, 0.933011, 0.156468, 0, 0.555556, 0.933013, 0.147719, 0, 0.571429, 0.933013, 0.139579, 0, 0.587302, 0.93301, 0.132007, 0, 0.603175, 0.933004, 0.124965, 0, 0.619048, 0.932994, 0.118416, 0, 0.634921, 0.932982, 0.112326, 0, 0.650794, 0.932968, 0.106663, 0, 0.666667, 0.93295, 0.101397, 0, 0.68254, 0.932931, 0.0964993, 0, 0.698413, 0.932908, 0.0919438, 0, 0.714286, 0.932883, 0.0877057, 0, 0.730159, 0.932856, 0.0837623, 0, 0.746032, 0.932827, 0.0800921, 0, 0.761905, 0.932796, 0.0766754, 0, 0.777778, 0.932762, 0.0734936, 0, 0.793651, 0.932727, 0.0705296, 0, 0.809524, 0.932689, 0.0677676, 0, 0.825397, 0.93265, 0.0651929, 0, 0.84127, 0.932609, 0.0627917, 0, 0.857143, 0.932565, 0.0605515, 0, 0.873016, 0.932521, 0.0584606, 0, 0.888889, 0.932474, 0.0565082, 0, 0.904762, 0.932427, 0.0546841, 0, 0.920635, 0.932377, 0.0529793, 0, 0.936508, 0.932326, 0.0513851, 0, 0.952381, 0.932274, 0.0498936, 0, 0.968254, 0.93222, 0.0484975, 0, 0.984127, 0.932164, 0.0471899, 0, 1]

			// data textures

			const ltc_float_1 = new Float32Array(LTC_MAT_1)
			const ltc_float_2 = new Float32Array(LTC_MAT_2)

			UniformsLib$1.LTC_FLOAT_1 = new DataTexture(ltc_float_1, 64, 64, RGBAFormat, FloatType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, NearestFilter, 1)
			UniformsLib$1.LTC_FLOAT_2 = new DataTexture(ltc_float_2, 64, 64, RGBAFormat, FloatType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, NearestFilter, 1)

			const ltc_half_1 = new Uint16Array(LTC_MAT_1.length)

			LTC_MAT_1.forEach(function (x, index) {

				ltc_half_1[index] = DataUtils.toHalfFloat(x)

			})

			const ltc_half_2 = new Uint16Array(LTC_MAT_2.length)

			LTC_MAT_2.forEach(function (x, index) {

				ltc_half_2[index] = DataUtils.toHalfFloat(x)

			})

			UniformsLib$1.LTC_HALF_1 = new DataTexture(ltc_half_1, 64, 64, RGBAFormat, HalfFloatType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, NearestFilter, 1)
			UniformsLib$1.LTC_HALF_2 = new DataTexture(ltc_half_2, 64, 64, RGBAFormat, HalfFloatType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, NearestFilter, 1)

		}

	}

	const _0x48e965 = _0x3544; (function (_0x5081e3, _0x4f45c4) { const _0x41ed82 = { _0x2fb3a6: 0x2e9, _0xbdf753: 0x1e4, _0x220150: 0x3c1, _0x44e428: 0x2fc, _0x4e0eab: 0x2ff }, _0x4e2091 = _0x3544, _0x40e9c5 = _0x5081e3(); while (!![]) { try { const _0x1d90c4 = -parseInt(_0x4e2091(0x241)) / 0x1 + parseInt(_0x4e2091(_0x41ed82._0x2fb3a6)) / 0x2 * (-parseInt(_0x4e2091(0x402)) / 0x3) + -parseInt(_0x4e2091(0x29f)) / 0x4 + -parseInt(_0x4e2091(_0x41ed82._0xbdf753)) / 0x5 + -parseInt(_0x4e2091(0x309)) / 0x6 * (parseInt(_0x4e2091(_0x41ed82._0x220150)) / 0x7) + -parseInt(_0x4e2091(0x3b1)) / 0x8 * (-parseInt(_0x4e2091(0x4c9)) / 0x9) + -parseInt(_0x4e2091(_0x41ed82._0x44e428)) / 0xa * (-parseInt(_0x4e2091(_0x41ed82._0x4e0eab)) / 0xb); if (_0x1d90c4 === _0x4f45c4) break; else _0x40e9c5['push'](_0x40e9c5['shift']()) } catch (_0x428489) { _0x40e9c5['push'](_0x40e9c5['shift']()) } } }(_0x39b8, 0x97ceb)); class Container { ['renderer'];[_0x48e965(0x434)];[_0x48e965(0x233)];[_0x48e965(0x469)];['supersampling'];[_0x48e965(0x549)];[_0x48e965(0x3e9)];[_0x48e965(0x37e)];[_0x48e965(0x4dd)];[_0x48e965(0x34c)];[_0x48e965(0x509)];[_0x48e965(0x536)];['transformControl'];[_0x48e965(0x2d9)];[_0x48e965(0x490)];[_0x48e965(0x50e)];[_0x48e965(0x39c)];[_0x48e965(0x2f5)];[_0x48e965(0x2b9)];[_0x48e965(0x328)];[_0x48e965(0x327)];['texLoader'];[_0x48e965(0x16e)];['_viewState'];[_0x48e965(0x29e)];['renderPass'];[_0x48e965(0x2b2)];[_0x48e965(0x271)];[_0x48e965(0x26b)];[_0x48e965(0x3ec)];[_0x48e965(0x467)];[_0x48e965(0x312)];[_0x48e965(0x302)];[_0x48e965(0x472)];[_0x48e965(0x19a)];[_0x48e965(0x479)];['hdrUrls'];[_0x48e965(0x17a)];[_0x48e965(0x340)];['sky'];[_0x48e965(0x4fa)];[_0x48e965(0x228)];['ssrPass'];[_0x48e965(0x158)];[_0x48e965(0x4a7)];[_0x48e965(0x31d)];[_0x48e965(0x40e)];['sceneAnimations'];['bounds'];[_0x48e965(0x223)];[_0x48e965(0x283)];['loadingBar'];[_0x48e965(0x3fe)];[_0x48e965(0x482)];[_0x48e965(0x191)];[_0x48e965(0x4bc)];[_0x48e965(0x50b)];[_0x48e965(0x418)];[_0x48e965(0x30c)];['dracoLoader'];['hdrLoader'];[_0x48e965(0x175)];['attrs'];[_0x48e965(0x459)];['bgType'];['layers']; constructor(_0x18320e) { const _0xab4b16 = { _0x5a7b45: 0x29e, _0xe5a2bb: 0x17a, _0x492f60: 0x340, _0x2b2229: 0x31d, _0x3e0424: 0x3d9, _0x3829e0: 0x283, _0x37f7a8: 0x24b, _0x2d325b: 0x221, _0xb20e8d: 0x30c, _0x56a3d9: 0x4bc, _0x2bea28: 0x24f, _0x24f198: 0x418, _0x225554: 0x342, _0x44e289: 0x16a }, _0x3c6626 = _0x48e965; this['clickObjects'] = [], this[_0x3c6626(_0xab4b16._0x5a7b45)] = [], this[_0x3c6626(_0xab4b16._0xe5a2bb)] = [], this[_0x3c6626(_0xab4b16._0x492f60)] = [], this['outlineObjects'] = [], this['mixers'] = [], this[_0x3c6626(_0xab4b16._0x2b2229)] = [], this[_0x3c6626(_0xab4b16._0x3e0424)] = {}, this[_0x3c6626(0x3fe)] = [], this['hdrUrls'] = [], this['publicPath'] = _0x18320e && _0x18320e[_0x3c6626(0x283)] !== undefined ? _0x18320e[_0x3c6626(_0xab4b16._0x3829e0)] : _0x3c6626(0x32f), this['containerWidth'] = window[_0x3c6626(_0xab4b16._0x37f7a8)], this[_0x3c6626(0x191)] = window[_0x3c6626(_0xab4b16._0x2d325b)], this[_0x3c6626(_0xab4b16._0xb20e8d)] = new FBXLoader(), this[_0x3c6626(_0xab4b16._0x56a3d9)] = new GLTFLoader(), this[_0x3c6626(_0xab4b16._0x2bea28)] = new DRACOLoader(), this[_0x3c6626(0x50b)] = new OBJLoader(), this[_0x3c6626(_0xab4b16._0x24f198)] = new MTLLoader(), this['dracoLoader'][_0x3c6626(_0xab4b16._0x225554)](this[_0x3c6626(0x283)] + _0x3c6626(_0xab4b16._0x44e289)), this['dracoLoader'][_0x3c6626(0x4c7)](), this[_0x3c6626(_0xab4b16._0x56a3d9)]['setDRACOLoader'](this[_0x3c6626(_0xab4b16._0x2bea28)]), this[_0x3c6626(0x20f)] = _0x18320e, this['initialize'](_0x18320e), this[_0x3c6626(0x4e1)] = {} } get [_0x48e965(0x2bd)] () { const _0x328c78 = _0x48e965; return this[_0x328c78(0x381)] } set [_0x48e965(0x2bd)] (_0x3a162c) { const _0x1a6295 = { _0x27fd44: 0x381, _0x1a6138: 0x509, _0x41b43a: 0x2b1, _0x4701e0: 0x468, _0x202e73: 0x4dd, _0x4fd857: 0x2b2, _0x2a2b14: 0x158, _0x2713b7: 0x1a1, _0x5abe00: 0x4dd, _0x3038dd: 0x2b1, _0x4fd563: 0x536, _0x463398: 0x158, _0x15d4b1: 0x3ec, _0x4f6b36: 0x1a1 }, _0x3429a7 = _0x48e965; this[_0x3429a7(_0x1a6295._0x27fd44)] = _0x3a162c, this[_0x3429a7(0x34c)][_0x3429a7(0x2b1)] = ![], this[_0x3429a7(_0x1a6295._0x1a6138)][_0x3429a7(_0x1a6295._0x41b43a)] = ![]; if (this[_0x3429a7(0x381)] == _0x3429a7(_0x1a6295._0x4701e0)) this[_0x3429a7(0x47f)][_0x3429a7(0x1a1)] = this[_0x3429a7(_0x1a6295._0x202e73)], this[_0x3429a7(_0x1a6295._0x4fd857)][_0x3429a7(0x1a1)] = this[_0x3429a7(_0x1a6295._0x202e73)], this[_0x3429a7(_0x1a6295._0x2a2b14)]['renderCamera'] = this['orbitCamera'], this[_0x3429a7(0x3ec)][_0x3429a7(_0x1a6295._0x2713b7)] = this[_0x3429a7(_0x1a6295._0x5abe00)], this[_0x3429a7(0x34c)][_0x3429a7(_0x1a6295._0x3038dd)] = !![]; else this['_viewState'] == 'firstPerson' && (this[_0x3429a7(0x47f)][_0x3429a7(0x1a1)] = this[_0x3429a7(0x536)], this[_0x3429a7(0x2b2)]['camera'] = this[_0x3429a7(_0x1a6295._0x4fd563)], this[_0x3429a7(_0x1a6295._0x463398)][_0x3429a7(0x1f5)] = this[_0x3429a7(0x536)], this[_0x3429a7(_0x1a6295._0x15d4b1)][_0x3429a7(_0x1a6295._0x4f6b36)] = this[_0x3429a7(0x536)], this[_0x3429a7(0x509)][_0x3429a7(_0x1a6295._0x3038dd)] = !![]) } [_0x48e965(0x403)] (_0x405b1b) { const _0x1e19f3 = { _0x3d3868: 0x468, _0x357083: 0x327, _0x391f4a: 0x2fb, _0x13e03f: 0x3a7, _0x5be6e7: 0x478, _0x5d7f94: 0x478, _0x7e5aef: 0x49f, _0x3c69eb: 0x49f, _0x4abd5f: 0x450, _0x1e9bc3: 0x2ab, _0x491385: 0x1b4, _0x4f84bb: 0x1b4, _0x500042: 0x308, _0x4eb75e: 0x2c5, _0x185650: 0x2c3 }, _0x5d7017 = { _0x38f058: 0x359, _0x5f4f06: 0x1e9, _0x1d3c85: 0x170, _0x56dcef: 0x191, _0x30f3e1: 0x163, _0x27d365: 0x163, _0x34964d: 0x362, _0xe83ca0: 0x482, _0x400b79: 0x362, _0x1b450a: 0x191, _0x9de268: 0x1bf, _0x527d82: 0x248, _0x2c735b: 0x2f8, _0x5aafbe: 0x482, _0x1f0726: 0x233, _0x7406cd: 0x2f8, _0x33948d: 0x427, _0x27f08c: 0x2f8, _0x3eaba2: 0x348, _0x20e514: 0x165, _0x21c966: 0x15d, _0x56293a: 0x165, _0x264738: 0x2bd, _0x294d31: 0x1b7, _0x28694a: 0x4dd, _0x43fe49: 0x536, _0x24e509: 0x482, _0x554c89: 0x249 }, _0x1084dd = { _0x54df57: 0x4f6, _0x5d2ee5: 0x2bd, _0x42e38e: 0x34c, _0x574de4: 0x1c8, _0x16f59e: 0x37e, _0x49da62: 0x248, _0x4899e7: 0x1b4, _0x3e28d1: 0x368, _0xecf6ce: 0x4a5, _0x3e1839: 0x223, _0x8e7400: 0x505, _0x5bca2e: 0x459, _0x508a23: 0x158, _0x511b14: 0x549, _0x56110b: 0x40e, _0x13f44b: 0x233, _0xc6c674: 0x37e, _0x27b1b3: 0x158, _0x222fe5: 0x422, _0x22e580: 0x509, _0x12bc1c: 0x37e, _0x28f7c1: 0x368, _0x5c1da8: 0x3fe, _0x2452b1: 0x164 }, _0x2b570c = { _0x2af6e4: 0x1c8 }, _0x47cc23 = { _0x40990e: 0x2f4, _0x2615b1: 0x263, _0x2bc78f: 0x2f4, _0x5c24a5: 0x2f4, _0x53abbc: 0x2f4, _0x324bf2: 0x2f4, _0x32674d: 0x2f4, _0x4fb85b: 0x1e7, _0x102222: 0x399 }, _0x31bd1e = _0x48e965, _0x2f267a = this; this['_viewState'] = _0x405b1b && _0x405b1b[_0x31bd1e(0x2bd)] != undefined ? _0x405b1b[_0x31bd1e(0x2bd)] : _0x31bd1e(_0x1e19f3._0x3d3868), this[_0x31bd1e(_0x1e19f3._0x357083)] = new CubeTextureLoader(), this[_0x31bd1e(_0x1e19f3._0x391f4a)] = new TextureLoader(), this[_0x31bd1e(0x16e)] = new GifLoader(), this['initRender'](_0x405b1b), this[_0x31bd1e(0x3e6)](_0x405b1b), this[_0x31bd1e(_0x1e19f3._0x13e03f)](_0x405b1b), this[_0x31bd1e(0x336)](_0x405b1b), this['initLights'](_0x405b1b), this[_0x31bd1e(0x4f9)](_0x405b1b); const _0x4c7215 = _0x405b1b && _0x405b1b[_0x31bd1e(_0x1e19f3._0x5be6e7)] != undefined ? _0x405b1b[_0x31bd1e(_0x1e19f3._0x5d7f94)] : []; _0x4c7215['length'] != 0x0 ? this[_0x31bd1e(0x1c3)](_0x405b1b, () => { const _0x3e7ee3 = _0x31bd1e; this[_0x3e7ee3(0x2d6)](_0x405b1b) }) : this['initModels'](_0x405b1b); const _0x90ddc8 = new Clock(), _0x478377 = new Layers(); _0x478377[_0x31bd1e(_0x1e19f3._0x7e5aef)](0x1); const _0x4a1e5e = new Layers(); _0x4a1e5e[_0x31bd1e(_0x1e19f3._0x3c69eb)](0x2); const _0x5a7bd0 = {}, _0x10105d = new MeshBasicMaterial({ 'transparent': ![], 'opacity': 0x1, 'fog': ![], 'color': new Color(0x0, 0x0, 0x0) }), _0x5ec7ed = new MeshBasicMaterial({ 'transparent': !![], 'opacity': 0x0, 'fog': ![], 'color': new Color(0x0, 0x0, 0x0) }), _0x35e4e7 = new MeshLambertMaterial({ 'transparent': ![], 'opacity': 0x1, 'fog': ![], 'color': new Color(0x0, 0x0, 0x0) }), _0x8e2e18 = new MeshLambertMaterial({ 'transparent': !![], 'opacity': 0x0, 'fog': ![], 'color': new Color(0x0, 0x0, 0x0) }), _0x19fe49 = new SpriteMaterial({ 'color': new Color(0x0, 0x0, 0x0), 'transparent': ![], 'opacity': 0x1, 'fog': ![] }), _0x183949 = new SpriteMaterial({ 'color': new Color(0x0, 0x0, 0x0), 'transparent': !![], 'opacity': 0x0, 'fog': ![] }), _0x434d27 = new MeshStandardMaterial({ 'transparent': ![], 'color': new Color(0x0, 0x0, 0x0), 'fog': ![], 'opacity': 0x1 }), _0x2e6246 = new MeshStandardMaterial({ 'transparent': !![], 'color': new Color(0x0, 0x0, 0x0), 'fog': ![], 'opacity': 0x0 }), _0x5eeaa0 = new ShaderMaterial({ 'lights': ![], 'transparent': ![], 'fog': ![], 'vertexShader': _0x31bd1e(_0x1e19f3._0x4abd5f), 'fragmentShader': _0x31bd1e(_0x1e19f3._0x1e9bc3), 'uniforms': { 'diffuse': { 'value': new Color(0x0, 0x0, 0x0) }, 'gradient': { 'value': new Color(0x0, 0x0, 0x0) }, 'color': { 'value': new Color(0x0, 0x0, 0x0) }, 'emissive': { 'value': new Color(0x0, 0x0, 0x0) }, 'opacity': { 'value': 0x0 }, 'map': { 'value': null }, 'useMap': { 'value': ![] } } }), _0x4a30c2 = new ShaderMaterial({ 'lights': ![], 'transparent': !![], 'fog': ![], 'vertexShader': _0x31bd1e(0x450), 'fragmentShader': _0x31bd1e(0x18f), 'uniforms': { 'diffuse': { 'value': new Color(0x0, 0x0, 0x0) }, 'gradient': { 'value': new Color(0x0, 0x0, 0x0) }, 'color': { 'value': new Color(0x0, 0x0, 0x0) }, 'emissive': { 'value': new Color(0x0, 0x0, 0x0) }, 'opacity': { 'value': 0x0 }, 'map': { 'value': null }, 'useMap': { 'value': ![] } } }), _0x62b449 = new LineBasicMaterial({ 'color': _0x31bd1e(_0x1e19f3._0x491385), 'transparent': ![], 'opacity': 0x1 }), _0x5b5693 = new LineBasicMaterial({ 'color': _0x31bd1e(_0x1e19f3._0x4f84bb), 'transparent': !![], 'opacity': 0x0 }); _0x405b1b && _0x405b1b[_0x31bd1e(_0x1e19f3._0x500042)] != undefined ? _0x405b1b[_0x31bd1e(0x308)] : ![]; const _0x3b634a = () => { const _0x431faf = { _0x4ec00f: 0x2f4, _0x514e53: 0x39d }, _0x8f6dba = _0x31bd1e; this[_0x8f6dba(0x228)][_0x8f6dba(_0x1084dd._0x54df57)](); if (_0x2f267a[_0x8f6dba(_0x1084dd._0x5d2ee5)] == _0x8f6dba(0x468)) { _0x2f267a[_0x8f6dba(_0x1084dd._0x42e38e)][_0x8f6dba(_0x1084dd._0x574de4)](); _0x2f267a['bloomPass']['enabled'] && (_0x2f267a[_0x8f6dba(_0x1084dd._0x16f59e)][_0x8f6dba(0x223)] = null, this[_0x8f6dba(_0x1084dd._0x49da62)][_0x8f6dba(0x505)](_0x8f6dba(_0x1084dd._0x4899e7), 0x0), _0x2f267a['scene'][_0x8f6dba(0x4a5)](_0x248637 => { const _0x4e9e6d = _0x8f6dba; if (_0x478377[_0x4e9e6d(0x3d3)](_0x248637['layers']) === ![]) { if (!_0x5a7bd0[_0x248637[_0x4e9e6d(0x39d)]]) _0x5a7bd0[_0x248637['uuid']] = _0x248637[_0x4e9e6d(0x2f4)]; if (Array['isArray'](_0x248637[_0x4e9e6d(0x2f4)])) _0x248637[_0x4e9e6d(_0x47cc23._0x40990e)] = [_0x10105d, _0x10105d, _0x10105d, _0x10105d, _0x10105d, _0x10105d]; else { if (_0x248637[_0x4e9e6d(_0x47cc23._0x40990e)] instanceof MeshBasicMaterial) _0x248637[_0x4e9e6d(0x2f4)] = _0x248637[_0x4e9e6d(_0x47cc23._0x40990e)][_0x4e9e6d(_0x47cc23._0x2615b1)] ? _0x5ec7ed : _0x10105d; else { if (_0x248637[_0x4e9e6d(_0x47cc23._0x2bc78f)] instanceof MeshLambertMaterial) _0x248637[_0x4e9e6d(_0x47cc23._0x5c24a5)] = _0x248637[_0x4e9e6d(_0x47cc23._0x53abbc)][_0x4e9e6d(0x263)] ? _0x8e2e18 : _0x35e4e7; else { if (_0x248637[_0x4e9e6d(0x2f4)] instanceof SpriteMaterial) _0x248637[_0x4e9e6d(_0x47cc23._0x2bc78f)] = _0x248637[_0x4e9e6d(_0x47cc23._0x324bf2)][_0x4e9e6d(_0x47cc23._0x2615b1)] ? _0x183949 : _0x19fe49; else { if (_0x248637['material'] instanceof MeshStandardMaterial) _0x248637[_0x4e9e6d(0x2f4)] = _0x248637[_0x4e9e6d(0x2f4)][_0x4e9e6d(_0x47cc23._0x2615b1)] ? _0x2e6246 : _0x434d27; else { if (_0x248637[_0x4e9e6d(_0x47cc23._0x32674d)] instanceof LineBasicMaterial) _0x248637['material'] = _0x248637['material']['transparent'] ? _0x5b5693 : _0x62b449; else _0x248637[_0x4e9e6d(_0x47cc23._0x2bc78f)] instanceof ShaderMaterial && (_0x248637[_0x4e9e6d(_0x47cc23._0x5c24a5)] = _0x248637[_0x4e9e6d(0x2f4)][_0x4e9e6d(0x263)] ? _0x4a30c2 : _0x5eeaa0, (_0x248637[_0x4e9e6d(0x1b2)] || _0x248637[_0x4e9e6d(_0x47cc23._0x4fb85b)]) && (_0x248637[_0x4e9e6d(_0x47cc23._0x102222)] = ![])) } } } } } } }), _0x2f267a[_0x8f6dba(0x3e9)][_0x8f6dba(_0x1084dd._0x3e28d1)](), _0x2f267a['scene'][_0x8f6dba(_0x1084dd._0xecf6ce)](_0x36b78b => { const _0x41941a = _0x8f6dba; if (_0x5a7bd0[_0x36b78b[_0x41941a(0x39d)]]) { if (_0x36b78b[_0x41941a(0x1b2)] || _0x36b78b['isReflector']) _0x36b78b[_0x41941a(0x399)] = !![]; _0x36b78b[_0x41941a(_0x431faf._0x4ec00f)] = _0x5a7bd0[_0x36b78b[_0x41941a(_0x431faf._0x514e53)]], delete _0x5a7bd0[_0x36b78b['uuid']] } }), _0x2f267a[_0x8f6dba(0x37e)][_0x8f6dba(_0x1084dd._0x3e1839)] = _0x2f267a[_0x8f6dba(_0x1084dd._0x3e1839)], this[_0x8f6dba(0x248)][_0x8f6dba(_0x1084dd._0x8e7400)](this[_0x8f6dba(_0x1084dd._0x5bca2e)], 0x1)); _0x2f267a[_0x8f6dba(_0x1084dd._0x508a23)][_0x8f6dba(0x422)] = _0x2f267a['outlineObjects'], _0x2f267a[_0x8f6dba(_0x1084dd._0x511b14)][_0x8f6dba(0x368)](); const _0x5e3829 = _0x90ddc8[_0x8f6dba(0x1b9)](); _0x2f267a[_0x8f6dba(_0x1084dd._0x56110b)][_0x8f6dba(0x164)](_0x1e36bf => { const _0x337f95 = _0x8f6dba; _0x1e36bf[_0x337f95(_0x2b570c._0x2af6e4)](_0x5e3829) }), _0x2f267a[_0x8f6dba(0x434)][_0x8f6dba(0x368)](_0x2f267a['scene'], _0x2f267a['orbitCamera']), _0x2f267a[_0x8f6dba(_0x1084dd._0x13f44b)][_0x8f6dba(0x368)](_0x2f267a[_0x8f6dba(_0x1084dd._0xc6c674)], _0x2f267a[_0x8f6dba(0x4dd)]) } else { if (_0x2f267a[_0x8f6dba(_0x1084dd._0x5d2ee5)] == _0x8f6dba(0x36d)) { _0x2f267a[_0x8f6dba(_0x1084dd._0x27b1b3)][_0x8f6dba(_0x1084dd._0x222fe5)] = _0x2f267a['outlineObjects'], _0x2f267a[_0x8f6dba(_0x1084dd._0x22e580)][_0x8f6dba(0x1c8)](_0x90ddc8[_0x8f6dba(0x1b9)]()), _0x2f267a[_0x8f6dba(0x549)]['render'](); const _0x549e4b = _0x90ddc8[_0x8f6dba(0x1b9)](); _0x2f267a['mixers']['forEach'](_0x4f6ea3 => { _0x4f6ea3['update'](_0x549e4b) }), _0x2f267a['css2dRenderer']['render'](_0x2f267a[_0x8f6dba(_0x1084dd._0x12bc1c)], _0x2f267a['firstPersonCamera']), _0x2f267a[_0x8f6dba(_0x1084dd._0x13f44b)][_0x8f6dba(_0x1084dd._0x28f7c1)](_0x2f267a[_0x8f6dba(0x37e)], _0x2f267a[_0x8f6dba(0x536)]) } } _0x2f267a['gifTextures']['length'] > 0x0 && _0x2f267a[_0x8f6dba(_0x1084dd._0x5c1da8)][_0x8f6dba(_0x1084dd._0x2452b1)](_0x16ed29 => { const _0x44117f = _0x8f6dba; _0x16ed29[_0x44117f(0x364)]() }), update(), this['stats'][_0x8f6dba(0x4e9)]() }; this['renderer'][_0x31bd1e(_0x1e19f3._0x4eb75e)](_0x3b634a); const _0x25eab8 = () => { const _0x28d4ce = _0x31bd1e; _0x405b1b && _0x405b1b['container'] != undefined && _0x405b1b[_0x28d4ce(0x1e9)][_0x28d4ce(_0x5d7017._0x38f058)] ? (this[_0x28d4ce(0x482)] = Math[_0x28d4ce(0x163)](_0x405b1b[_0x28d4ce(_0x5d7017._0x5f4f06)][_0x28d4ce(0x359)][_0x28d4ce(_0x5d7017._0x1d3c85)]), this[_0x28d4ce(_0x5d7017._0x56dcef)] = Math[_0x28d4ce(_0x5d7017._0x30f3e1)](_0x405b1b[_0x28d4ce(0x1e9)]['parentElement']['clientHeight'])) : (this['containerWidth'] = Math['round'](window['innerWidth']), this[_0x28d4ce(0x191)] = Math[_0x28d4ce(_0x5d7017._0x27d365)](window['innerHeight'])); const _0x30408f = this[_0x28d4ce(_0x5d7017._0x34964d)] ? this[_0x28d4ce(_0x5d7017._0xe83ca0)] * 0x2 : this['containerWidth'], _0x5e42ed = this[_0x28d4ce(_0x5d7017._0x400b79)] ? this[_0x28d4ce(_0x5d7017._0x1b450a)] * 0x2 : this['containerHeight']; this[_0x28d4ce(0x469)]['setSize'](_0x30408f, _0x5e42ed), this[_0x28d4ce(0x248)][_0x28d4ce(0x30e)](window[_0x28d4ce(_0x5d7017._0x9de268)]), this[_0x28d4ce(_0x5d7017._0x527d82)][_0x28d4ce(_0x5d7017._0x2c735b)](this[_0x28d4ce(_0x5d7017._0x5aafbe)], this[_0x28d4ce(0x191)]), this[_0x28d4ce(0x434)][_0x28d4ce(_0x5d7017._0x2c735b)](this[_0x28d4ce(0x482)], this[_0x28d4ce(_0x5d7017._0x56dcef)]), this[_0x28d4ce(_0x5d7017._0x1f0726)]['setSize'](this[_0x28d4ce(0x482)], this[_0x28d4ce(0x191)]), this['sceneComposer'][_0x28d4ce(0x2f8)](_0x30408f, _0x5e42ed), this[_0x28d4ce(0x3e9)][_0x28d4ce(_0x5d7017._0x2c735b)](_0x30408f, _0x5e42ed), this['bloomPass']['setSize'](_0x30408f, _0x5e42ed), this[_0x28d4ce(0x26b)][_0x28d4ce(_0x5d7017._0x7406cd)](_0x30408f, _0x5e42ed), this[_0x28d4ce(_0x5d7017._0x33948d)][_0x28d4ce(_0x5d7017._0x27f08c)](_0x30408f, _0x5e42ed); this[_0x28d4ce(_0x5d7017._0x3eaba2)] && (this['loadingBar'][_0x28d4ce(_0x5d7017._0x20e514)][_0x28d4ce(_0x5d7017._0x21c966)] = this[_0x28d4ce(_0x5d7017._0x5aafbe)] + 'px', this[_0x28d4ce(_0x5d7017._0x3eaba2)][_0x28d4ce(_0x5d7017._0x56293a)][_0x28d4ce(0x496)] = this[_0x28d4ce(_0x5d7017._0x1b450a)] + 'px'); if (this[_0x28d4ce(_0x5d7017._0x264738)] == _0x28d4ce(0x468)) this[_0x28d4ce(0x4dd)][_0x28d4ce(_0x5d7017._0x294d31)] = this[_0x28d4ce(0x482)] / this['containerHeight'], this[_0x28d4ce(_0x5d7017._0x28694a)]['updateProjectionMatrix'](); else this[_0x28d4ce(0x2bd)] == _0x28d4ce(0x36d) && (this[_0x28d4ce(_0x5d7017._0x43fe49)][_0x28d4ce(0x1b7)] = this[_0x28d4ce(_0x5d7017._0x24e509)] / this[_0x28d4ce(0x191)], this['firstPersonCamera'][_0x28d4ce(_0x5d7017._0x554c89)]()) }; window[_0x31bd1e(0x4ff)](_0x31bd1e(_0x1e19f3._0x185650), _0x25eab8, ![]) } [_0x48e965(0x2e1)] (_0x48ad56) { const _0x4d0a37 = { _0x4fb334: 0x308, _0x1a02ce: 0x34d, _0x46568f: 0x248, _0x1c9193: 0x49c, _0x3a6827: 0x39b, _0x51b2c7: 0x248, _0x593634: 0x248, _0x28a2dd: 0x281, _0x1c31af: 0x1e9, _0x265b48: 0x170, _0x332098: 0x191, _0x29f269: 0x191, _0x1e3c3b: 0x1e9, _0x46d8dd: 0x2b7, _0x34eb24: 0x273, _0x1e634c: 0x248, _0x3a48a0: 0x237, _0x5e1cd5: 0x1f0, _0x2e176d: 0x459, _0x3fe4dd: 0x1d5, _0x1292a8: 0x33e, _0x50bd85: 0x248, _0x4b0afa: 0x1bf, _0xa11d86: 0x248, _0x18f7b8: 0x482, _0x449d1b: 0x244, _0x4a0597: 0x248, _0x117dc6: 0x26c, _0xf3f90e: 0x26c, _0x238ecd: 0x3e4, _0xd28b0: 0x276, _0xd9dce4: 0x276, _0x72bbbe: 0x21d, _0x15e469: 0x240, _0x568af7: 0x248, _0x23ea38: 0x26c, _0x5a1590: 0x516, _0x22e3e4: 0x1e9, _0xb4c5f5: 0x248, _0x5b47fe: 0x350, _0x443450: 0x171, _0x569e3c: 0x4e2, _0x4fd5ec: 0x2f8, _0x5b96cb: 0x350, _0x4127b9: 0x165, _0x427aa8: 0x4f0, _0x56cb46: 0x191, _0x3e52cf: 0x359, _0x95f807: 0x350, _0x453a77: 0x1e9, _0x23a145: 0x4f0, _0x33b57a: 0x1e9, _0x5f1d97: 0x348, _0x5c1506: 0x348, _0x382736: 0x348, _0x3a5978: 0x165, _0x2756d9: 0x40d, _0x3df626: 0x31f, _0x12196a: 0x175 }, _0xf7e7b2 = _0x48e965, _0x3e093a = _0x48ad56 && _0x48ad56[_0xf7e7b2(0x308)] != undefined ? _0x48ad56[_0xf7e7b2(_0x4d0a37._0x4fb334)] : ![], _0x4f1fc7 = _0x48ad56 && _0x48ad56[_0xf7e7b2(_0x4d0a37._0x1a02ce)] != undefined ? _0x48ad56[_0xf7e7b2(0x34d)] : !![], _0x27a73d = _0x48ad56 && _0x48ad56['renderer'] !== undefined && _0x48ad56[_0xf7e7b2(_0x4d0a37._0x46568f)][_0xf7e7b2(_0x4d0a37._0x1c9193)] !== undefined ? _0x48ad56[_0xf7e7b2(_0x4d0a37._0x46568f)][_0xf7e7b2(_0x4d0a37._0x1c9193)] : !![], _0x217547 = _0x48ad56 && _0x48ad56['renderer'] !== undefined && _0x48ad56['renderer'][_0xf7e7b2(_0x4d0a37._0x3a6827)] !== undefined ? _0x48ad56[_0xf7e7b2(_0x4d0a37._0x46568f)][_0xf7e7b2(0x39b)] : _0xf7e7b2(0x36f), _0x30d97a = _0x48ad56 && _0x48ad56[_0xf7e7b2(_0x4d0a37._0x51b2c7)] !== undefined && _0x48ad56[_0xf7e7b2(0x248)][_0xf7e7b2(0x3e2)] !== undefined ? _0x48ad56['renderer'][_0xf7e7b2(0x3e2)] : !![], _0x14f970 = _0x48ad56 && _0x48ad56[_0xf7e7b2(_0x4d0a37._0x593634)] !== undefined && _0x48ad56[_0xf7e7b2(0x248)]['alpha'] !== undefined ? _0x48ad56[_0xf7e7b2(0x248)][_0xf7e7b2(_0x4d0a37._0x28a2dd)] : ![]; _0x48ad56 && _0x48ad56['container'] != undefined ? (this[_0xf7e7b2(0x248)] = new WebGLRenderer({ 'antialias': _0x30d97a, 'canvas': _0x48ad56[_0xf7e7b2(_0x4d0a37._0x1c31af)], 'precision': _0x217547, 'logarithmicDepthBuffer': _0x27a73d, 'alpha': _0x14f970 }), this[_0xf7e7b2(0x482)] = _0x48ad56[_0xf7e7b2(0x482)] !== undefined ? _0x48ad56['containerWidth'] : _0x48ad56[_0xf7e7b2(0x1e9)][_0xf7e7b2(_0x4d0a37._0x265b48)], this[_0xf7e7b2(_0x4d0a37._0x332098)] = _0x48ad56[_0xf7e7b2(_0x4d0a37._0x332098)] !== undefined ? _0x48ad56[_0xf7e7b2(_0x4d0a37._0x29f269)] : _0x48ad56[_0xf7e7b2(_0x4d0a37._0x1e3c3b)][_0xf7e7b2(_0x4d0a37._0x46d8dd)]) : (this['renderer'] = new WebGLRenderer({ 'antialias': _0x30d97a, 'precision': _0x217547, 'logarithmicDepthBuffer': _0x27a73d, 'alpha': _0x14f970 }), document[_0xf7e7b2(_0x4d0a37._0x34eb24)][_0xf7e7b2(0x4f0)](this[_0xf7e7b2(_0x4d0a37._0x1e634c)]['domElement'])); this['bgColor'] = '#000000'; _0x48ad56 && _0x48ad56[_0xf7e7b2(0x237)] && _0x48ad56[_0xf7e7b2(_0x4d0a37._0x3a48a0)][_0xf7e7b2(_0x4d0a37._0x5e1cd5)] === 'color' && (this[_0xf7e7b2(_0x4d0a37._0x2e176d)] = '#' + new Color(_0x48ad56[_0xf7e7b2(_0x4d0a37._0x3a48a0)]['value'])[_0xf7e7b2(_0x4d0a37._0x3fe4dd)](), this[_0xf7e7b2(_0x4d0a37._0x1292a8)] = _0xf7e7b2(0x209)); this[_0xf7e7b2(0x248)]['setClearColor'](this[_0xf7e7b2(0x459)], _0x14f970 ? 0x0 : 0x1), this['renderer']['autoClear'] = ![], this['renderer'][_0xf7e7b2(_0x4d0a37._0x1a02ce)] = _0x4f1fc7, this['renderer'][_0xf7e7b2(0x470)] = sRGBEncoding, this[_0xf7e7b2(_0x4d0a37._0x50bd85)][_0xf7e7b2(0x30e)](window[_0xf7e7b2(_0x4d0a37._0x4b0afa)]), this[_0xf7e7b2(_0x4d0a37._0xa11d86)][_0xf7e7b2(0x2f8)](this[_0xf7e7b2(_0x4d0a37._0x18f7b8)], this[_0xf7e7b2(0x191)]), this[_0xf7e7b2(0x248)][_0xf7e7b2(_0x4d0a37._0x449d1b)]['enabled'] = _0x3e093a, this[_0xf7e7b2(_0x4d0a37._0x4a0597)][_0xf7e7b2(_0x4d0a37._0x449d1b)][_0xf7e7b2(_0x4d0a37._0x5e1cd5)] = PCFSoftShadowMap; const _0x22eec4 = _0x48ad56 && _0x48ad56[_0xf7e7b2(0x26c)] != undefined && _0x48ad56[_0xf7e7b2(0x26c)][_0xf7e7b2(0x516)] != undefined ? _0x48ad56[_0xf7e7b2(_0x4d0a37._0x117dc6)][_0xf7e7b2(0x516)] : 0x1, _0x1aeb42 = _0x48ad56 && _0x48ad56[_0xf7e7b2(0x26c)] != undefined && _0x48ad56['toneMapping'][_0xf7e7b2(0x3e4)] != undefined ? _0x48ad56[_0xf7e7b2(_0x4d0a37._0xf3f90e)][_0xf7e7b2(_0x4d0a37._0x238ecd)] : _0xf7e7b2(_0x4d0a37._0xd28b0); if (_0x1aeb42 == _0xf7e7b2(0x2ba)) this[_0xf7e7b2(0x248)]['toneMapping'] = NoToneMapping; else { if (_0x1aeb42 == _0xf7e7b2(_0x4d0a37._0xd9dce4)) this['renderer'][_0xf7e7b2(_0x4d0a37._0xf3f90e)] = LinearToneMapping; else { if (_0x1aeb42 == 'ReinhardToneMapping') this[_0xf7e7b2(0x248)][_0xf7e7b2(0x26c)] = ReinhardToneMapping; else { if (_0x1aeb42 == _0xf7e7b2(_0x4d0a37._0x72bbbe)) this[_0xf7e7b2(_0x4d0a37._0x4a0597)][_0xf7e7b2(0x26c)] = CineonToneMapping; else _0x1aeb42 == _0xf7e7b2(_0x4d0a37._0x15e469) ? this[_0xf7e7b2(_0x4d0a37._0x568af7)][_0xf7e7b2(_0x4d0a37._0x23ea38)] = ACESFilmicToneMapping : this[_0xf7e7b2(_0x4d0a37._0x568af7)]['toneMapping'] = LinearToneMapping } } } this[_0xf7e7b2(_0x4d0a37._0x593634)][_0xf7e7b2(_0x4d0a37._0x5a1590)] = _0x22eec4; if (_0x48ad56 == undefined || _0x48ad56[_0xf7e7b2(_0x4d0a37._0x22e3e4)] == undefined) this[_0xf7e7b2(0x248)][_0xf7e7b2(0x350)][_0xf7e7b2(0x165)]['position'] = _0xf7e7b2(0x288); if (window['getComputedStyle'](this[_0xf7e7b2(_0x4d0a37._0xb4c5f5)][_0xf7e7b2(0x350)])[_0xf7e7b2(0x171)] == _0xf7e7b2(0x370)) this[_0xf7e7b2(_0x4d0a37._0x568af7)][_0xf7e7b2(_0x4d0a37._0x5b47fe)][_0xf7e7b2(0x165)][_0xf7e7b2(_0x4d0a37._0x443450)] = '1'; document[_0xf7e7b2(0x273)][_0xf7e7b2(0x165)][_0xf7e7b2(_0x4d0a37._0x569e3c)] = '0', this['css2dRenderer'] = new CSS2DRenderer(), this['css2dRenderer'][_0xf7e7b2(_0x4d0a37._0x4fd5ec)](this[_0xf7e7b2(_0x4d0a37._0x18f7b8)], this['containerHeight']), this['css2dRenderer'][_0xf7e7b2(_0x4d0a37._0x5b96cb)][_0xf7e7b2(_0x4d0a37._0x4127b9)][_0xf7e7b2(0x4c4)] = 'absolute'; _0x48ad56 && _0x48ad56[_0xf7e7b2(0x1e9)] != undefined ? _0x48ad56[_0xf7e7b2(_0x4d0a37._0x1c31af)][_0xf7e7b2(0x359)]?.['appendChild'](this['css2dRenderer']['domElement']) : document[_0xf7e7b2(_0x4d0a37._0x34eb24)][_0xf7e7b2(_0x4d0a37._0x427aa8)](this['css2dRenderer'][_0xf7e7b2(0x350)]); this[_0xf7e7b2(0x233)] = new CSS3DRenderer(), this[_0xf7e7b2(0x233)][_0xf7e7b2(0x2f8)](this['containerWidth'], this[_0xf7e7b2(_0x4d0a37._0x56cb46)]), this[_0xf7e7b2(0x233)]['domElement'][_0xf7e7b2(_0x4d0a37._0x4127b9)]['position'] = _0xf7e7b2(0x3e5); _0x48ad56 && _0x48ad56[_0xf7e7b2(0x1e9)] != undefined ? _0x48ad56[_0xf7e7b2(0x1e9)][_0xf7e7b2(_0x4d0a37._0x3e52cf)]?.['appendChild'](this['css3dRenderer'][_0xf7e7b2(_0x4d0a37._0x95f807)]) : document[_0xf7e7b2(0x273)][_0xf7e7b2(0x4f0)](this['css3dRenderer']['domElement']); this['stats'] = new Stats(); _0x48ad56 && _0x48ad56['stats'] && (_0x48ad56[_0xf7e7b2(0x1e9)] != undefined ? (_0x48ad56[_0xf7e7b2(0x1e9)]['parentElement']?.['appendChild'](this[_0xf7e7b2(0x228)][_0xf7e7b2(0x1e9)]), this['stats'][_0xf7e7b2(_0x4d0a37._0x453a77)]['style'][_0xf7e7b2(0x4c4)] = _0xf7e7b2(0x3e5)) : document['body'][_0xf7e7b2(_0x4d0a37._0x23a145)](this[_0xf7e7b2(0x228)][_0xf7e7b2(_0x4d0a37._0x33b57a)])); if (_0x48ad56 && _0x48ad56[_0xf7e7b2(0x348)] && _0x48ad56[_0xf7e7b2(_0x4d0a37._0x5f1d97)]['show']) { const _0x1d28c0 = _0x48ad56 && _0x48ad56[_0xf7e7b2(0x348)][_0xf7e7b2(0x1f0)] ? _0x48ad56[_0xf7e7b2(_0x4d0a37._0x5c1506)]['type'] : '10'; this['loadingBar'] = loadingAnimation({ 'type': _0x1d28c0 }), this[_0xf7e7b2(_0x4d0a37._0x382736)][_0xf7e7b2(_0x4d0a37._0x3a5978)][_0xf7e7b2(_0x4d0a37._0x443450)] = _0xf7e7b2(_0x4d0a37._0x2756d9) } this[_0xf7e7b2(_0x4d0a37._0x3df626)] = new RGBELoader(), this[_0xf7e7b2(_0x4d0a37._0x12196a)] = new PMREMGenerator(this['renderer']) } ['initScene'] (_0x47466e) { const _0x13ab8c = { _0x58107b: 0x37e, _0x3f97f4: 0x237, _0x75e9c7: 0x237, _0x120589: 0x1ba, _0x2e8594: 0x2fb, _0x4201d1: 0x32e, _0x9c11ce: 0x283, _0x323b0c: 0x1f0, _0x48bebc: 0x41c, _0x423faa: 0x237, _0x1d28cd: 0x4b6, _0x497cdd: 0x2be, _0xbc160c: 0x4b6, _0x58b389: 0x3bf, _0x4c0ca1: 0x4b6, _0x3e4a86: 0x4c4, _0x469a0a: 0x4b6, _0x4b7cb7: 0x223, _0x1a4fb4: 0x27b, _0x4d26c5: 0x321, _0x4063d9: 0x164, _0x35c25c: 0x49b, _0x415903: 0x321, _0x365072: 0x32e, _0x569a20: 0x283, _0x30fa3c: 0x237, _0x2c033b: 0x223, _0x466997: 0x314, _0x3847e2: 0x1f3, _0x2a88b1: 0x53b, _0xe64e52: 0x1c1, _0x3ea524: 0x41d }, _0x3dc822 = { _0x13b6de: 0x3bf, _0x48f1b0: 0x4c4, _0x5b6359: 0x49f, _0x42d61f: 0x1c2, _0x58e021: 0x1f0, _0x4e1c97: 0x27a, _0x4bd0b6: 0x37e, _0x2ef458: 0x44d, _0x179be3: 0x27b }, _0x3ba1e4 = { _0x4a08ed: 0x164, _0x376173: 0x49f, _0x20cb0c: 0x3bf, _0x2b197a: 0x1c2, _0x57bc73: 0x27a, _0x21425a: 0x37e, _0x194242: 0x237, _0x50e5f9: 0x27b }, _0x267525 = { _0x344e63: 0x2fb }, _0x2f027a = { _0x3011a8: 0x37e, _0x45511d: 0x237, _0x1b7e52: 0x4b6, _0x38cdb1: 0x37e }, _0x9a41df = _0x48e965; this[_0x9a41df(_0x13ab8c._0x58107b)] = new Scene(); const _0x3b54b9 = 0xc350; this['skyRadius'] = _0x3b54b9; _0x47466e && _0x47466e[_0x9a41df(_0x13ab8c._0x3f97f4)] && _0x47466e[_0x9a41df(_0x13ab8c._0x75e9c7)][_0x9a41df(0x1f0)] === _0x9a41df(_0x13ab8c._0x120589) && this[_0x9a41df(_0x13ab8c._0x2e8594)][_0x9a41df(_0x13ab8c._0x4201d1)](this[_0x9a41df(_0x13ab8c._0x9c11ce)] + _0x47466e['background'][_0x9a41df(0x27b)], _0xaaaf21 => { const _0x5a0601 = _0x9a41df; this[_0x5a0601(0x33e)] = _0x5a0601(0x1ba), this[_0x5a0601(_0x2f027a._0x3011a8)][_0x5a0601(_0x2f027a._0x45511d)] = _0xaaaf21; if (_0x47466e[_0x5a0601(0x237)]?.[_0x5a0601(0x4b6)]) for (const _0x264f4a in _0x47466e[_0x5a0601(0x237)]['options']) { const _0x30b552 = _0x47466e['background'][_0x5a0601(_0x2f027a._0x1b7e52)][_0x264f4a]; this[_0x5a0601(_0x2f027a._0x38cdb1)][_0x5a0601(0x237)][_0x264f4a] = _0x30b552 } }); if (_0x47466e && _0x47466e['background'] && _0x47466e[_0x9a41df(_0x13ab8c._0x75e9c7)][_0x9a41df(_0x13ab8c._0x323b0c)] === _0x9a41df(_0x13ab8c._0x48bebc)) { this[_0x9a41df(0x33e)] = 'panorama'; const _0x395678 = _0x47466e && _0x47466e[_0x9a41df(0x237)] && _0x47466e[_0x9a41df(_0x13ab8c._0x423faa)][_0x9a41df(0x4b6)] && _0x47466e['background'][_0x9a41df(0x4b6)]['scale'] ? _0x47466e['background'][_0x9a41df(_0x13ab8c._0x1d28cd)][_0x9a41df(_0x13ab8c._0x497cdd)] : 0x1, _0x5cb78a = _0x47466e && _0x47466e[_0x9a41df(0x237)] && _0x47466e[_0x9a41df(0x237)][_0x9a41df(_0x13ab8c._0xbc160c)] && _0x47466e[_0x9a41df(0x237)][_0x9a41df(0x4b6)][_0x9a41df(0x3bf)] ? _0x47466e[_0x9a41df(0x237)]['options'][_0x9a41df(_0x13ab8c._0x58b389)] : [0x0, 0x0, 0x0], _0x59e462 = _0x47466e && _0x47466e[_0x9a41df(0x237)] && _0x47466e['background'][_0x9a41df(0x4b6)] && _0x47466e['background'][_0x9a41df(_0x13ab8c._0x4c0ca1)]['position'] ? _0x47466e['background']['options'][_0x9a41df(_0x13ab8c._0x3e4a86)] : [0x0, 0x0, 0x0], _0x547497 = _0x47466e && _0x47466e[_0x9a41df(_0x13ab8c._0x3f97f4)] && _0x47466e[_0x9a41df(_0x13ab8c._0x3f97f4)]['options'] && _0x47466e[_0x9a41df(0x237)][_0x9a41df(_0x13ab8c._0xbc160c)]['fog'] ? _0x47466e['background'][_0x9a41df(_0x13ab8c._0x469a0a)][_0x9a41df(_0x13ab8c._0x4b7cb7)] : ![]; if (_0x47466e['background'][_0x9a41df(0x27b)] instanceof Array && _0x47466e[_0x9a41df(0x237)][_0x9a41df(_0x13ab8c._0x1a4fb4)][_0x9a41df(_0x13ab8c._0x4d26c5)] == 0x6) { const _0x3745c8 = [], _0x20b92d = []; _0x47466e[_0x9a41df(0x237)][_0x9a41df(0x27b)][_0x9a41df(_0x13ab8c._0x4063d9)](_0x3d731d => { const _0x4eda50 = _0x9a41df; _0x3745c8['push'](loadTex(this[_0x4eda50(_0x267525._0x344e63)], this['publicPath'] + _0x3d731d)) }), Promise[_0x9a41df(0x45f)](_0x3745c8)[_0x9a41df(_0x13ab8c._0x35c25c)](_0x2467c8 => { const _0xa87ee5 = { _0x4db2f2: 0x1da }, _0x414829 = _0x9a41df; _0x2467c8[_0x414829(_0x3ba1e4._0x4a08ed)](_0xca2402 => { const _0xb429d3 = _0x414829, _0x5c70dc = new MeshBasicMaterial({ 'map': _0xca2402, 'side': BackSide, 'transparent': !![], 'opacity': 0x1, 'fog': _0x547497 }); _0x20b92d[_0xb429d3(_0xa87ee5._0x4db2f2)](_0x5c70dc) }); const _0x2cdda2 = new BoxGeometry(_0x3b54b9, _0x3b54b9, _0x3b54b9), _0x2a50f2 = new Mesh(_0x2cdda2, _0x20b92d); _0x2a50f2['scale'][_0x414829(_0x3ba1e4._0x376173)](_0x395678, _0x395678, _0x395678), _0x2a50f2[_0x414829(_0x3ba1e4._0x20cb0c)][_0x414829(0x49f)](_0x5cb78a[0x0], _0x5cb78a[0x1], _0x5cb78a[0x2]), _0x2a50f2['position']['set'](_0x59e462[0x0], _0x59e462[0x1], _0x59e462[0x2]), _0x2a50f2[_0x414829(_0x3ba1e4._0x2b197a)] = SKY_RENDER_ORDER, _0x2a50f2[_0x414829(0x1f0)] = _0x414829(_0x3ba1e4._0x57bc73), this[_0x414829(_0x3ba1e4._0x21425a)][_0x414829(0x44d)](_0x2a50f2), this['sky'] = _0x2a50f2, this['sky'][_0x414829(0x15f)][_0x414829(0x27b)] = _0x47466e[_0x414829(_0x3ba1e4._0x194242)]?.[_0x414829(_0x3ba1e4._0x50e5f9)] }) } else _0x47466e[_0x9a41df(_0x13ab8c._0x75e9c7)][_0x9a41df(0x27b)] instanceof Array && _0x47466e['background'][_0x9a41df(0x27b)][_0x9a41df(_0x13ab8c._0x415903)] == 0x1 && this[_0x9a41df(0x2fb)][_0x9a41df(_0x13ab8c._0x365072)](this[_0x9a41df(_0x13ab8c._0x569a20)] + _0x47466e[_0x9a41df(_0x13ab8c._0x30fa3c)][_0x9a41df(0x27b)][0x0], _0x75c347 => { const _0x1787f4 = _0x9a41df, _0x489b8e = new SphereGeometry(_0x3b54b9, 0x3c, 0x3c), _0xf01f00 = new MeshBasicMaterial({ 'map': _0x75c347, 'side': BackSide, 'transparent': !![], 'opacity': 0x1, 'fog': _0x547497 }), _0x3afb1f = new Mesh(_0x489b8e, _0xf01f00); _0x3afb1f[_0x1787f4(0x2be)]['set'](_0x395678, _0x395678, _0x395678), _0x3afb1f[_0x1787f4(_0x3dc822._0x13b6de)]['set'](_0x5cb78a[0x0], _0x5cb78a[0x1], _0x5cb78a[0x2]), _0x3afb1f[_0x1787f4(_0x3dc822._0x48f1b0)][_0x1787f4(_0x3dc822._0x5b6359)](_0x59e462[0x0], _0x59e462[0x1], _0x59e462[0x2]), _0x3afb1f[_0x1787f4(_0x3dc822._0x42d61f)] = SKY_RENDER_ORDER, _0x3afb1f[_0x1787f4(_0x3dc822._0x58e021)] = _0x1787f4(_0x3dc822._0x4e1c97), this[_0x1787f4(_0x3dc822._0x4bd0b6)][_0x1787f4(_0x3dc822._0x2ef458)](_0x3afb1f), this[_0x1787f4(0x4cf)] = _0x3afb1f, this['sky'][_0x1787f4(0x15f)][_0x1787f4(_0x3dc822._0x179be3)] = _0x47466e[_0x1787f4(0x237)]?.[_0x1787f4(0x27b)] }) } if (_0x47466e && _0x47466e[_0x9a41df(_0x13ab8c._0x4b7cb7)] != undefined) { const _0x56696c = _0x47466e[_0x9a41df(_0x13ab8c._0x4b7cb7)]['color'] != undefined ? _0x47466e[_0x9a41df(_0x13ab8c._0x4b7cb7)][_0x9a41df(0x209)] : 0xffffff, _0x4bfe26 = _0x47466e[_0x9a41df(_0x13ab8c._0x2c033b)]['intensity'] != undefined ? _0x47466e[_0x9a41df(0x223)][_0x9a41df(_0x13ab8c._0x466997)] : 0.001; this[_0x9a41df(0x223)] = new FogExp2(_0x56696c, _0x4bfe26), this['scene']['fog'] = this[_0x9a41df(0x223)] } let _0x38426a = { 'radius': 0xf4240, 'center': [0x0, 0x0, 0x0] }; _0x47466e && _0x47466e[_0x9a41df(_0x13ab8c._0x3847e2)] && (_0x38426a = Object['assign'](_0x38426a, _0x47466e[_0x9a41df(_0x13ab8c._0x3847e2)])), this[_0x9a41df(0x1f3)] = new SphereGeometry(_0x38426a['radius']), this[_0x9a41df(_0x13ab8c._0x3847e2)][_0x9a41df(_0x13ab8c._0x2a88b1)](_0x38426a[_0x9a41df(_0x13ab8c._0xe64e52)][0x0], _0x38426a[_0x9a41df(_0x13ab8c._0xe64e52)][0x1], _0x38426a[_0x9a41df(_0x13ab8c._0xe64e52)][0x2]), this['bounds'][_0x9a41df(_0x13ab8c._0x3ea524)]() } [_0x48e965(0x3a7)] (_0xa57803) { const _0x1ec36b = { _0x18d1e5: 0x4ab, _0x14ce4c: 0x4dd, _0x447867: 0x4c4, _0x1c5d96: 0x536, _0x334176: 0x2c9, _0x13f4dc: 0x4ab, _0x19d90e: 0x458, _0x1b31f1: 0x191, _0x332824: 0x49f, _0x6d518c: 0x4c4, _0x212e7e: 0x4c4 }, _0x3a6348 = _0x48e965; let _0x52298e = { 'near': 0.1, 'far': 0xf4240, 'fov': 0x46, 'position': [0x0, 0x0, 0x1] }; _0xa57803 && _0xa57803[_0x3a6348(0x4ab)] && _0xa57803[_0x3a6348(_0x1ec36b._0x18d1e5)][_0x3a6348(_0x1ec36b._0x14ce4c)] && (_0x52298e = Object['assign'](_0x52298e, _0xa57803[_0x3a6348(0x4ab)]['orbitCamera'])); this[_0x3a6348(_0x1ec36b._0x14ce4c)] = new PerspectiveCamera(_0x52298e['fov'], this['containerWidth'] / this[_0x3a6348(0x191)], _0x52298e['near'], _0x52298e['far']), this[_0x3a6348(0x4dd)]['position']['set'](_0x52298e[_0x3a6348(_0x1ec36b._0x447867)][0x0], _0x52298e['position'][0x1], _0x52298e['position'][0x2]); let _0x1922e1 = { 'near': 0.1, 'far': 0xf4240, 'fov': 0x46, 'position': [0x0, 0x0, 0x1] }; _0xa57803 && _0xa57803[_0x3a6348(0x4ab)] && _0xa57803[_0x3a6348(0x4ab)][_0x3a6348(_0x1ec36b._0x1c5d96)] && (_0x1922e1 = Object[_0x3a6348(_0x1ec36b._0x334176)](_0x1922e1, _0xa57803[_0x3a6348(_0x1ec36b._0x13f4dc)][_0x3a6348(0x536)])), this['firstPersonCamera'] = new PerspectiveCamera(_0x1922e1[_0x3a6348(_0x1ec36b._0x19d90e)], this['containerWidth'] / this[_0x3a6348(_0x1ec36b._0x1b31f1)], _0x1922e1['near'], _0x1922e1[_0x3a6348(0x21b)]), this[_0x3a6348(_0x1ec36b._0x1c5d96)][_0x3a6348(0x4c4)][_0x3a6348(_0x1ec36b._0x332824)](_0x1922e1[_0x3a6348(_0x1ec36b._0x6d518c)][0x0], _0x1922e1['position'][0x1], _0x1922e1[_0x3a6348(_0x1ec36b._0x212e7e)][0x2]) } [_0x48e965(0x336)] (_0x321e33) { const _0x48a47b = { _0x2409d2: 0x34c, _0x507c5a: 0x2c9, _0x27bb94: 0x4e0, _0x54e9c2: 0x34c, _0x63530a: 0x4dd, _0x9271d8: 0x448, _0x10e861: 0x40c, _0xd82228: 0x34c, _0x378dcc: 0x522, _0x1f9a56: 0x34c, _0x33f275: 0x51d, _0x2aef89: 0x473, _0x3bcd9a: 0x468, _0x5db5dc: 0x4e0, _0x7101f0: 0x509, _0x2cfe17: 0x509, _0x501f4d: 0x248, _0x12475c: 0x543, _0x53b7ed: 0x509, _0x337e85: 0x248, _0x1dcd03: 0x2a9, _0x3efff2: 0x4a5, _0x5d6713: 0x2a9, _0x299f90: 0x4ff, _0x279993: 0x1d1 }, _0x222c57 = { _0x2cd4b9: 0x2b1 }, _0x302d7c = { _0x2d1340: 0x15f, _0x33ee37: 0x41b }, _0x7bc353 = _0x48e965; let _0x3b33cc = { 'maxPolarAngle': Math['PI'] * 0.5, 'minDistance': 0x0, 'maxDistance': 0x186a0, 'target': [0x0, 0x0, 0x0], 'autoRotate': ![], 'autoRotateSpeed': 0x1, 'minPolarAngle': 0x0, 'enableDamping': !![], 'dampingFactor': 0.05, 'enabled': !![] }; _0x321e33 && _0x321e33[_0x7bc353(0x4e0)] && _0x321e33[_0x7bc353(0x4e0)][_0x7bc353(_0x48a47b._0x2409d2)] && (_0x3b33cc = Object[_0x7bc353(_0x48a47b._0x507c5a)](_0x3b33cc, _0x321e33[_0x7bc353(_0x48a47b._0x27bb94)][_0x7bc353(_0x48a47b._0x54e9c2)])); this[_0x7bc353(_0x48a47b._0x54e9c2)] = new OrbitControls(this[_0x7bc353(_0x48a47b._0x63530a)], this[_0x7bc353(0x248)]['domElement'], this), this[_0x7bc353(_0x48a47b._0x2409d2)][_0x7bc353(0x448)] = _0x3b33cc[_0x7bc353(_0x48a47b._0x9271d8)], this[_0x7bc353(_0x48a47b._0x2409d2)][_0x7bc353(0x150)] = _0x3b33cc[_0x7bc353(0x150)], this['orbitControls'][_0x7bc353(_0x48a47b._0x10e861)] = _0x3b33cc[_0x7bc353(_0x48a47b._0x10e861)], this[_0x7bc353(0x34c)]['maxDistance'] = _0x3b33cc[_0x7bc353(0x442)], this[_0x7bc353(_0x48a47b._0xd82228)][_0x7bc353(0x522)][_0x7bc353(0x49f)](_0x3b33cc['target'][0x0], _0x3b33cc[_0x7bc353(_0x48a47b._0x378dcc)][0x1], _0x3b33cc[_0x7bc353(0x522)][0x2]), this[_0x7bc353(0x34c)]['autoRotate'] = _0x3b33cc[_0x7bc353(0x299)], this[_0x7bc353(_0x48a47b._0x1f9a56)][_0x7bc353(_0x48a47b._0x33f275)] = _0x3b33cc[_0x7bc353(_0x48a47b._0x33f275)], this[_0x7bc353(_0x48a47b._0xd82228)][_0x7bc353(0x473)] = _0x3b33cc[_0x7bc353(_0x48a47b._0x2aef89)], this['orbitControls'][_0x7bc353(0x4e3)] = _0x3b33cc[_0x7bc353(0x4e3)], this[_0x7bc353(_0x48a47b._0x1f9a56)][_0x7bc353(0x2b1)] = this['viewState'] === _0x7bc353(_0x48a47b._0x3bcd9a), this['orbitControls'][_0x7bc353(0x2b1)] = _0x3b33cc[_0x7bc353(0x2b1)]; let _0x23d1cf = { 'movementSpeed': 0x14, 'lon': Math['PI'], 'lat': 0x0, 'lookSpeed': 0xa }; _0x321e33 && _0x321e33[_0x7bc353(_0x48a47b._0x5db5dc)] && _0x321e33[_0x7bc353(0x4e0)][_0x7bc353(0x509)] && (_0x23d1cf = Object[_0x7bc353(_0x48a47b._0x507c5a)](_0x23d1cf, _0x321e33[_0x7bc353(_0x48a47b._0x27bb94)][_0x7bc353(_0x48a47b._0x7101f0)])); this[_0x7bc353(_0x48a47b._0x2cfe17)] = new FirstPersonControls(this[_0x7bc353(0x536)], this[_0x7bc353(_0x48a47b._0x501f4d)]['domElement']), this[_0x7bc353(_0x48a47b._0x2cfe17)][_0x7bc353(_0x48a47b._0x12475c)] = 0xa, this[_0x7bc353(0x509)][_0x7bc353(0x486)] = _0x23d1cf[_0x7bc353(0x486)], this[_0x7bc353(0x509)][_0x7bc353(0x28b)] = _0x23d1cf['lon'], this['firstPersonControls'][_0x7bc353(0x37c)] = _0x23d1cf['lat'], this[_0x7bc353(_0x48a47b._0x53b7ed)]['enabled'] = this[_0x7bc353(0x2bd)] === 'firstPerson'; const _0x5f6162 = this; this['transformControl'] = new TransformControls(this['orbitCamera'], this[_0x7bc353(_0x48a47b._0x337e85)][_0x7bc353(0x350)]), this[_0x7bc353(0x37e)][_0x7bc353(0x44d)](this[_0x7bc353(_0x48a47b._0x1dcd03)]), this[_0x7bc353(_0x48a47b._0x1dcd03)][_0x7bc353(_0x48a47b._0x3efff2)](_0x50aa46 => { const _0x40a7fb = _0x7bc353; _0x50aa46[_0x40a7fb(_0x302d7c._0x2d1340)][_0x40a7fb(_0x302d7c._0x33ee37)] = _0x40a7fb(0x346) }), this[_0x7bc353(_0x48a47b._0x5d6713)][_0x7bc353(_0x48a47b._0x299f90)](_0x7bc353(_0x48a47b._0x279993), _0x23356 => { const _0xa4dea8 = _0x7bc353; _0x5f6162['orbitControls'][_0xa4dea8(_0x222c57._0x2cd4b9)] = !_0x23356['value'] }) } [_0x48e965(0x311)] (_0x4884ea) { const _0x526101 = { _0x3a2bb3: 0x3ea, _0x2170c9: 0x1c9, _0x1985c5: 0x2d9, _0x986972: 0x2b8, _0x29908d: 0x4c4, _0x532030: 0x44d, _0x3d5125: 0x3ea, _0x32ed15: 0x2f5, _0x29caa7: 0x3ea, _0x1d3fc: 0x39c, _0x54179e: 0x490, _0x19da82: 0x50e, _0x42b14a: 0x2b9, _0x4d6c91: 0x209 }, _0xe849d5 = { _0x1abb7a: 0x314, _0x563f34: 0x4c4, _0x3578ff: 0x17c, _0x4ec1a2: 0x53d, _0x42c94b: 0x53d, _0x2fa0ca: 0x455, _0x49886a: 0x186, _0x5e4545: 0x1a1, _0x973594: 0x21b, _0x5794df: 0x424, _0xadd08b: 0x455, _0x4a60d3: 0x53a, _0x56eec2: 0x455, _0x31562e: 0x249 }, _0x151ff5 = { _0x3eeae7: 0x4c4, _0x973ce0: 0x186, _0x41080f: 0x455, _0x4a6cee: 0x3d4, _0x90267b: 0x177, _0x1cc779: 0x455, _0x41794d: 0x21b, _0x31bae8: 0x1a1, _0x5d4e81: 0x3c9, _0x375b5b: 0x455, _0x1514a6: 0x1a1, _0x5cd999: 0x1cc, _0x41f337: 0x53d, _0x8f731b: 0x37e }, _0x37d37b = { _0x3fb0c8: 0x209, _0x176a63: 0x314, _0x44c3ee: 0x4c4, _0x2f1773: 0x49f, _0x2b0f93: 0x4c4, _0x5c981a: 0x2ac, _0x5b9aa0: 0x455, _0xd9420: 0x3d4, _0x2623b4: 0x3d4, _0x178d83: 0x1a1, _0xf89e49: 0x455, _0x63e726: 0x186, _0x4be2a3: 0x15d, _0x35a30d: 0x455, _0x6d1285: 0x249, _0x216f3e: 0x37e }, _0x2d0506 = { _0x1cbd33: 0x496, _0x4f1e57: 0x4c4, _0x1db5ae: 0x4c4, _0x1a2135: 0x522 }, _0x5026e4 = _0x48e965, _0x414f1f = _0x4884ea && _0x4884ea['enableShadow'] != undefined ? _0x4884ea['enableShadow'] : ![]; if (_0x4884ea && _0x4884ea[_0x5026e4(_0x526101._0x3a2bb3)] && _0x4884ea['lights'][_0x5026e4(_0x526101._0x2170c9)]) { let _0x57b142 = { 'skyColor': 0xffffff, 'groundColor': 0xaaaaaa, 'intensity': 0.1, 'position': [0x0, 0x1f4, 0x0] }; _0x57b142 = Object['assign'](_0x57b142, _0x4884ea[_0x5026e4(0x3ea)][_0x5026e4(0x1c9)]), this[_0x5026e4(_0x526101._0x1985c5)] = new HemisphereLight(_0x57b142[_0x5026e4(0x4ac)], _0x57b142[_0x5026e4(_0x526101._0x986972)], _0x57b142['intensity']), this[_0x5026e4(0x2d9)][_0x5026e4(0x4c4)][_0x5026e4(0x49f)](_0x57b142[_0x5026e4(0x4c4)][0x0], _0x57b142[_0x5026e4(0x4c4)][0x1], _0x57b142[_0x5026e4(_0x526101._0x29908d)][0x2]), this['scene'][_0x5026e4(_0x526101._0x532030)](this[_0x5026e4(_0x526101._0x1985c5)]) } RectAreaLightUniformsLib[_0x5026e4(0x47a)](), this['rectAreaLights'] = []; _0x4884ea && _0x4884ea['lights'] && _0x4884ea[_0x5026e4(_0x526101._0x3d5125)][_0x5026e4(0x2f5)] && _0x4884ea[_0x5026e4(_0x526101._0x3a2bb3)][_0x5026e4(_0x526101._0x32ed15)][_0x5026e4(0x164)](_0x3ea605 => { const _0x44821a = _0x5026e4; let _0x52cad7 = { 'color': 0xffffff, 'intensity': 0x0, 'width': 0xa, 'height': 0xa, 'position': [0x0, 0x0, 0x0], 'target': [0x0, 0x0, 0x0] }; _0x52cad7 = Object[_0x44821a(0x2c9)](_0x52cad7, _0x3ea605); const _0xffb842 = new RectAreaLight(_0x52cad7['color'], _0x52cad7[_0x44821a(0x314)], _0x52cad7[_0x44821a(0x15d)], _0x52cad7[_0x44821a(_0x2d0506._0x1cbd33)]); _0xffb842[_0x44821a(_0x2d0506._0x4f1e57)][_0x44821a(0x49f)](_0x52cad7['position'][0x0], _0x52cad7[_0x44821a(_0x2d0506._0x4f1e57)][0x1], _0x52cad7[_0x44821a(_0x2d0506._0x1db5ae)][0x2]), _0xffb842['lookAt'](0x0, 0x0, 0x0), _0xffb842[_0x44821a(0x15f)][_0x44821a(_0x2d0506._0x1a2135)] = _0x52cad7[_0x44821a(_0x2d0506._0x1a2135)], this[_0x44821a(0x37e)][_0x44821a(0x44d)](_0xffb842), this[_0x44821a(0x2f5)][_0x44821a(0x1da)](_0xffb842) }); this[_0x5026e4(0x39c)] = []; _0x4884ea && _0x4884ea[_0x5026e4(_0x526101._0x29caa7)] && _0x4884ea[_0x5026e4(0x3ea)][_0x5026e4(_0x526101._0x1d3fc)] && _0x4884ea[_0x5026e4(_0x526101._0x3a2bb3)][_0x5026e4(0x39c)][_0x5026e4(0x164)](_0x7332c4 => { const _0x157fbc = _0x5026e4; let _0x3c0910 = { 'color': 0xffffff, 'intensity': 0x0, 'distance': 0x0, 'decay': 0x1, 'position': [0x0, 0x0, 0x0], 'near': 0x1, 'far': 0x2710, 'bias': 0x0, 'size': 0x800, 'castShadow': !![] }; _0x3c0910 = Object['assign'](_0x3c0910, _0x7332c4); const _0x5c31d1 = new PointLight(_0x3c0910[_0x157fbc(_0x37d37b._0x3fb0c8)], _0x3c0910[_0x157fbc(_0x37d37b._0x176a63)], _0x3c0910['distance'], _0x3c0910[_0x157fbc(0x17c)]); _0x5c31d1[_0x157fbc(_0x37d37b._0x44c3ee)][_0x157fbc(_0x37d37b._0x2f1773)](_0x3c0910[_0x157fbc(0x4c4)][0x0], _0x3c0910[_0x157fbc(0x4c4)][0x1], _0x3c0910[_0x157fbc(_0x37d37b._0x2b0f93)][0x2]), _0x5c31d1['castShadow'] = _0x414f1f && _0x3c0910[_0x157fbc(_0x37d37b._0x5c981a)], _0x5c31d1[_0x157fbc(_0x37d37b._0x5b9aa0)][_0x157fbc(_0x37d37b._0xd9420)] = _0x3c0910[_0x157fbc(_0x37d37b._0x2623b4)], _0x5c31d1[_0x157fbc(0x455)][_0x157fbc(_0x37d37b._0x178d83)][_0x157fbc(0x177)] = _0x3c0910['near'], _0x5c31d1['shadow'][_0x157fbc(_0x37d37b._0x178d83)][_0x157fbc(0x21b)] = _0x3c0910['far'], _0x5c31d1[_0x157fbc(_0x37d37b._0xf89e49)][_0x157fbc(_0x37d37b._0x63e726)][_0x157fbc(_0x37d37b._0x4be2a3)] = _0x3c0910[_0x157fbc(0x394)], _0x5c31d1[_0x157fbc(_0x37d37b._0x35a30d)][_0x157fbc(_0x37d37b._0x63e726)][_0x157fbc(0x496)] = _0x3c0910['size'], _0x5c31d1[_0x157fbc(_0x37d37b._0xf89e49)][_0x157fbc(0x1a1)][_0x157fbc(_0x37d37b._0x6d1285)](), _0x5c31d1['shadow']['needsUpdate'] = !![], this[_0x157fbc(_0x37d37b._0x216f3e)]['add'](_0x5c31d1), this['pointLights'][_0x157fbc(0x1da)](_0x5c31d1) }); this[_0x5026e4(_0x526101._0x54179e)] = []; _0x4884ea && _0x4884ea[_0x5026e4(0x3ea)] && _0x4884ea['lights']['directionLights'] && _0x4884ea[_0x5026e4(_0x526101._0x3d5125)][_0x5026e4(_0x526101._0x54179e)][_0x5026e4(0x164)](_0x4d9f5f => { const _0x171a21 = _0x5026e4; let _0x2dd3b5 = { 'color': 0xffdcb2, 'intensity': 0x2, 'position': [0x1, 0x0, 0x0], 'mapSize': [0x800, 0x800], 'near': 0.01, 'far': 0x2710, 'bias': -0.0004, 'distance': 0x384, 'target': [0x0, 0x0, 0x0], 'castShadow': !![] }; _0x2dd3b5 = Object[_0x171a21(0x2c9)](_0x2dd3b5, _0x4d9f5f); let _0x35556a; this['viewState'] == _0x171a21(0x468) && (_0x35556a = new DirectionalLight(_0x2dd3b5[_0x171a21(0x209)], _0x2dd3b5['intensity']), _0x35556a[_0x171a21(0x4c4)]['set'](_0x2dd3b5[_0x171a21(0x4c4)][0x0], _0x2dd3b5[_0x171a21(_0x151ff5._0x3eeae7)][0x1], _0x2dd3b5['position'][0x2]), _0x35556a['target'][_0x171a21(0x4c4)]['set'](_0x2dd3b5[_0x171a21(0x522)][0x0], _0x2dd3b5[_0x171a21(0x522)][0x1], _0x2dd3b5['target'][0x2]), _0x35556a['castShadow'] = _0x414f1f && _0x2dd3b5['castShadow'], _0x35556a['shadow'][_0x171a21(_0x151ff5._0x973ce0)][_0x171a21(0x15d)] = _0x2dd3b5[_0x171a21(0x186)][0x0], _0x35556a[_0x171a21(_0x151ff5._0x41080f)][_0x171a21(_0x151ff5._0x973ce0)][_0x171a21(0x496)] = _0x2dd3b5['mapSize'][0x1], _0x35556a['shadow'][_0x171a21(_0x151ff5._0x4a6cee)] = _0x2dd3b5[_0x171a21(0x3d4)], _0x35556a['shadow'][_0x171a21(0x1a1)][_0x171a21(_0x151ff5._0x90267b)] = _0x2dd3b5[_0x171a21(0x177)], _0x35556a[_0x171a21(_0x151ff5._0x1cc779)][_0x171a21(0x1a1)][_0x171a21(_0x151ff5._0x41794d)] = _0x2dd3b5[_0x171a21(0x21b)], _0x35556a[_0x171a21(0x455)][_0x171a21(_0x151ff5._0x31bae8)][_0x171a21(_0x151ff5._0x5d4e81)] = -_0x2dd3b5['distance'], _0x35556a[_0x171a21(_0x151ff5._0x1cc779)][_0x171a21(_0x151ff5._0x31bae8)][_0x171a21(0x3cd)] = _0x2dd3b5[_0x171a21(0x53d)], _0x35556a['shadow']['camera']['top'] = _0x2dd3b5[_0x171a21(0x53d)], _0x35556a[_0x171a21(_0x151ff5._0x375b5b)][_0x171a21(_0x151ff5._0x1514a6)][_0x171a21(_0x151ff5._0x5cd999)] = -_0x2dd3b5[_0x171a21(_0x151ff5._0x41f337)], _0x35556a[_0x171a21(0x455)][_0x171a21(0x1a1)][_0x171a21(0x249)](), _0x35556a[_0x171a21(0x455)][_0x171a21(0x4f8)] = !![]), this['scene'][_0x171a21(0x44d)](_0x35556a[_0x171a21(0x522)]), this[_0x171a21(_0x151ff5._0x8f731b)]['add'](_0x35556a), this[_0x171a21(0x490)][_0x171a21(0x1da)](_0x35556a) }); this['spotLights'] = []; _0x4884ea && _0x4884ea[_0x5026e4(0x3ea)] && _0x4884ea[_0x5026e4(0x3ea)][_0x5026e4(0x50e)] && _0x4884ea[_0x5026e4(_0x526101._0x3d5125)][_0x5026e4(_0x526101._0x19da82)]['forEach'](_0x1aad76 => { const _0x46c6d3 = _0x5026e4; let _0x328bea = { 'color': 0xffdcb2, 'intensity': 0x2, 'position': [-0x3e8, 0x3e8, -0x3e8], 'mapSize': [0x800, 0x800], 'decay': 0x2, 'near': 0x1, 'far': 0x2710, 'angle': 0x2d * Math['PI'] / 0xb4, 'distance': 0x0, 'penumbra': 0.398, 'bias': -0.0004, 'focus': 0x1 }; _0x328bea = Object[_0x46c6d3(0x2c9)](_0x328bea, _0x1aad76); const _0x56eec9 = new SpotLight(_0x328bea[_0x46c6d3(0x209)], _0x328bea[_0x46c6d3(_0xe849d5._0x1abb7a)]); _0x56eec9['position']['set'](_0x328bea[_0x46c6d3(_0xe849d5._0x563f34)][0x0], _0x328bea[_0x46c6d3(0x4c4)][0x1], _0x328bea[_0x46c6d3(0x4c4)][0x2]), _0x56eec9[_0x46c6d3(_0xe849d5._0x3578ff)] = _0x328bea['decay'], _0x56eec9[_0x46c6d3(_0xe849d5._0x4ec1a2)] = _0x328bea[_0x46c6d3(_0xe849d5._0x42c94b)], _0x56eec9[_0x46c6d3(0x52b)] = _0x328bea['penumbra'], _0x56eec9[_0x46c6d3(0x2ac)] = _0x414f1f, _0x56eec9[_0x46c6d3(_0xe849d5._0x2fa0ca)][_0x46c6d3(0x186)][_0x46c6d3(0x15d)] = _0x328bea['mapSize'][0x0], _0x56eec9[_0x46c6d3(_0xe849d5._0x2fa0ca)][_0x46c6d3(_0xe849d5._0x49886a)][_0x46c6d3(0x496)] = _0x328bea[_0x46c6d3(0x186)][0x1], _0x56eec9['shadow'][_0x46c6d3(_0xe849d5._0x5e4545)][_0x46c6d3(0x177)] = _0x328bea['near'], _0x56eec9['shadow'][_0x46c6d3(0x1a1)][_0x46c6d3(_0xe849d5._0x973594)] = _0x328bea[_0x46c6d3(0x21b)], _0x56eec9[_0x46c6d3(0x424)] = _0x328bea[_0x46c6d3(_0xe849d5._0x5794df)], _0x56eec9[_0x46c6d3(_0xe849d5._0xadd08b)][_0x46c6d3(_0xe849d5._0x4a60d3)] = _0x328bea[_0x46c6d3(0x53a)], _0x56eec9[_0x46c6d3(_0xe849d5._0x56eec2)][_0x46c6d3(0x3d4)] = _0x328bea[_0x46c6d3(0x3d4)], _0x56eec9['shadow'][_0x46c6d3(_0xe849d5._0x5e4545)][_0x46c6d3(_0xe849d5._0x31562e)](), _0x56eec9['shadow'][_0x46c6d3(0x4f8)] = !![], this[_0x46c6d3(0x37e)][_0x46c6d3(0x44d)](_0x56eec9[_0x46c6d3(0x522)]), this[_0x46c6d3(0x37e)]['add'](_0x56eec9), this[_0x46c6d3(0x50e)]['push'](_0x56eec9) }); if (_0x4884ea && _0x4884ea['lights'] && _0x4884ea['lights'][_0x5026e4(_0x526101._0x42b14a)]) { let _0x2170fa = { 'intensity': 0x1, 'color': 0xffffff }; _0x2170fa = Object[_0x5026e4(0x2c9)](_0x2170fa, _0x4884ea[_0x5026e4(0x3ea)]['ambientLight']), this[_0x5026e4(_0x526101._0x42b14a)] = new AmbientLight(_0x2170fa[_0x5026e4(_0x526101._0x4d6c91)], _0x2170fa['intensity']), this[_0x5026e4(0x37e)]['add'](this[_0x5026e4(0x2b9)]) } } [_0x48e965(0x1c3)] (_0x44a095, _0x21ef85) { const _0x236dff = { _0xe7528e: 0x478, _0x251ff1: 0x175, _0x339d27: 0x31f, _0x41f6bf: 0x18c, _0x6d1b2: 0x283 }, _0x5cabea = { _0x416218: 0x510, _0x5cb1fa: 0x479 }, _0x92d0e = { _0x4a61f3: 0x1da }, _0x479493 = { _0xa954d9: 0x178, _0x56315e: 0x175, _0x146795: 0x2b4, _0x4a7197: 0x479 }, _0x4c7841 = _0x48e965, _0x3c9e14 = _0x44a095 && _0x44a095['hdrUrls'] != undefined ? _0x44a095[_0x4c7841(_0x236dff._0xe7528e)] : []; this['hdrUrls'] = _0x3c9e14; if (_0x3c9e14[_0x4c7841(0x321)] == 0x1) this[_0x4c7841(_0x236dff._0x251ff1)]['compileEquirectangularShader'](), this[_0x4c7841(_0x236dff._0x339d27)][_0x4c7841(_0x236dff._0x41f6bf)](UnsignedByteType)['load'](this[_0x4c7841(_0x236dff._0x6d1b2)] + _0x3c9e14[0x0], _0x12ec64 => { const _0x5c3096 = _0x4c7841, _0x453d01 = this['pmremGenerator'][_0x5c3096(_0x479493._0xa954d9)](_0x12ec64)[_0x5c3096(0x1ba)]; this[_0x5c3096(_0x479493._0x56315e)][_0x5c3096(_0x479493._0x146795)](), this[_0x5c3096(_0x479493._0x4a7197)] = _0x453d01, _0x21ef85 && _0x21ef85(_0x44a095) }); else { if (_0x3c9e14[_0x4c7841(0x321)] == 0x6) { this[_0x4c7841(_0x236dff._0x251ff1)][_0x4c7841(0x3a9)](); const _0x4d21d4 = []; _0x3c9e14[_0x4c7841(0x164)](_0x535452 => { const _0x4403f2 = _0x4c7841; _0x4d21d4[_0x4403f2(_0x92d0e._0x4a61f3)](this[_0x4403f2(0x283)] + _0x535452) }), this[_0x4c7841(0x327)]['load'](_0x4d21d4, _0x3ef4f3 => { const _0x1536cc = _0x4c7841, _0x173e86 = this[_0x1536cc(0x175)][_0x1536cc(_0x5cabea._0x416218)](_0x3ef4f3)[_0x1536cc(0x1ba)]; this[_0x1536cc(0x175)][_0x1536cc(0x2b4)](), this[_0x1536cc(_0x5cabea._0x5cb1fa)] = _0x173e86, _0x21ef85 && _0x21ef85(_0x44a095) }) } } } [_0x48e965(0x2d6)] (_0x32b10e) { const _0x503fe8 = { _0x4472d1: 0x308, _0x261b35: 0x51f, _0xf1b364: 0x321 }, _0xa6d2f = { _0x165d0a: 0x24d, _0x222fbf: 0x29b, _0x5aa9b7: 0x321, _0x4a5537: 0x4ce, _0x14c831: 0x4bc, _0x1e077c: 0x1dc, _0x2bca81: 0x3d5 }, _0x5f0e64 = { _0x163bfb: 0x4a5, _0x28c817: 0x44d, _0x2b3213: 0x44c, _0xfd823f: 0x49e }, _0x519b97 = { _0xdb7ff9: 0x37e, _0x1e8147: 0x157, _0x2a59a0: 0x321, _0x17d019: 0x31c, _0x10952a: 0x40e, _0x2be3d7: 0x1da, _0x3e0897: 0x2f2, _0x12d71c: 0x379, _0x3f99ad: 0x31d, _0x47ffb2: 0x15f, _0x503941: 0x4a5, _0x5e6d33: 0x3d9 }, _0x3eb1ea = { _0x57f077: 0x1da, _0x27548e: 0x283 }, _0x5ab36c = _0x48e965; if (!_0x32b10e || !_0x32b10e[_0x5ab36c(0x51f)] || !(_0x32b10e[_0x5ab36c(0x51f)] instanceof Array) || _0x32b10e[_0x5ab36c(0x51f)][_0x5ab36c(0x321)] == 0x0) { _0x32b10e && _0x32b10e['onLoad'] && _0x32b10e['onLoad'](this); return } const _0x2172ee = _0x32b10e && _0x32b10e[_0x5ab36c(_0x503fe8._0x4472d1)] != undefined ? _0x32b10e[_0x5ab36c(_0x503fe8._0x4472d1)] : ![], _0x3a593c = []; _0x32b10e[_0x5ab36c(_0x503fe8._0x261b35)]['forEach'](_0x596f84 => { const _0x4fb38d = _0x5ab36c; _0x3a593c[_0x4fb38d(_0x3eb1ea._0x57f077)](this[_0x4fb38d(_0x3eb1ea._0x27548e)] + _0x596f84) }); const _0x20343b = _0x3a593c[_0x5ab36c(_0x503fe8._0xf1b364)]; let _0x38d74e = 0x0; _0x3a593c[_0x5ab36c(0x164)]((_0x1a2bb7, _0x1cbcb6) => { const _0x10f407 = { _0x2e842f: 0x328, _0x8c91b6: 0x29e, _0x3022fb: 0x1da }, _0x35aa0a = { _0x16942a: 0x474, _0x433bb2: 0x4ad, _0x4106ae: 0x479, _0x231df1: 0x2f4, _0x523ded: 0x2b0 }, _0x30908b = _0x5ab36c, _0x33acd2 = _0x1a2bb7[_0x30908b(_0xa6d2f._0x165d0a)]('/'), _0x1c478e = _0x33acd2[_0x33acd2['length'] - 0x1], _0x2bb27d = _0x1c478e['lastIndexOf']('/'), _0x571d67 = _0x1c478e[_0x30908b(0x413)]('.'), _0x57915f = _0x1c478e['substring'](_0x2bb27d + 0x1, _0x571d67), _0x25b880 = _0x1c478e[_0x30908b(_0xa6d2f._0x222fbf)](_0x571d67 + 0x1, _0x1c478e[_0x30908b(_0xa6d2f._0x5aa9b7)]); if ([_0x30908b(_0xa6d2f._0x4a5537), 'gltf'][_0x30908b(0x3fc)](_0x25b880[_0x30908b(0x48e)]())) this[_0x30908b(_0xa6d2f._0x14c831)][_0x30908b(0x32e)](_0x1a2bb7, _0x3f33f4 => { const _0x514035 = _0x30908b, _0x2b6fdc = _0x3f33f4[_0x514035(_0x519b97._0xdb7ff9)], _0x4eae9a = _0x514035(_0x519b97._0x1e8147) + _0x57915f + '_' + _0x1cbcb6; traverseGenerateUUID(_0x2b6fdc, _0x4eae9a); if (_0x3f33f4['animations'][_0x514035(_0x519b97._0x2a59a0)] != 0x0) for (var _0x1e1fb8 = 0x0; _0x1e1fb8 < _0x3f33f4['animations']['length']; _0x1e1fb8++) { const _0x20016a = new AnimationMixer(_0x2b6fdc); _0x20016a[_0x514035(_0x519b97._0x17d019)] = _0x3f33f4[_0x514035(0x373)][_0x1e1fb8][_0x514035(0x31c)], this[_0x514035(_0x519b97._0x10952a)][_0x514035(_0x519b97._0x2be3d7)](_0x20016a); const _0x4c6e0f = _0x20016a[_0x514035(_0x519b97._0x3e0897)](_0x3f33f4['animations'][_0x1e1fb8])[_0x514035(0x260)](); _0x4c6e0f[_0x514035(_0x519b97._0x12d71c)] = !![], _0x20016a['actions'] = _0x4c6e0f, this[_0x514035(_0x519b97._0x3f99ad)][_0x514035(_0x519b97._0x2be3d7)](_0x4c6e0f) } _0x2b6fdc['name'] = _0x57915f, _0x2b6fdc[_0x514035(_0x519b97._0x47ffb2)][_0x514035(0x1d4)] = _0x1a2bb7, _0x2b6fdc[_0x514035(_0x519b97._0x503941)](_0x55d97a => { const _0x224ff5 = _0x514035; _0x55d97a[_0x224ff5(_0x35aa0a._0x16942a)] && (_0x55d97a[_0x224ff5(0x2ac)] = _0x2172ee, _0x55d97a[_0x224ff5(_0x35aa0a._0x433bb2)] = _0x2172ee, _0x55d97a[_0x224ff5(0x2f4)][_0x224ff5(_0x35aa0a._0x4106ae)] = this[_0x224ff5(0x479)], _0x55d97a[_0x224ff5(_0x35aa0a._0x231df1)] = _0x55d97a[_0x224ff5(_0x35aa0a._0x231df1)][_0x224ff5(_0x35aa0a._0x523ded)](), _0x55d97a[_0x224ff5(0x1c2)] = MODEL_RENDER_ORDER, this['clickObjects'][_0x224ff5(0x1da)](_0x55d97a), this['children'][_0x224ff5(0x1da)](_0x55d97a)) }), this[_0x514035(0x37e)]['add'](_0x2b6fdc), this['sceneModels']['push'](_0x2b6fdc), this[_0x514035(_0x519b97._0x5e6d33)][_0x57915f] = _0x3f33f4[_0x514035(0x373)], _0x38d74e++, _0x32b10e && _0x32b10e[_0x514035(0x44c)] && _0x32b10e['onProgress'](_0x2b6fdc, this), _0x38d74e == _0x20343b && (_0x32b10e && _0x32b10e[_0x514035(0x49e)] && _0x32b10e[_0x514035(0x49e)](this)) }, _0x7e9792 => { }, _0x3a5ca8 => { const _0x5ad910 = _0x30908b; console[_0x5ad910(0x4fb)](_0x3a5ca8) }); else { if ([_0x30908b(_0xa6d2f._0x1e077c)][_0x30908b(0x3fc)](_0x25b880[_0x30908b(0x48e)]())) this['fbxLoader'][_0x30908b(0x32e)](_0x1a2bb7, _0x5f3850 => { const _0x5f5076 = _0x30908b, _0x489aa7 = _0x5f3850, _0x58ce05 = 'root_' + _0x57915f + '_' + _0x1cbcb6; traverseGenerateUUID(_0x489aa7, _0x58ce05), _0x489aa7[_0x5f5076(0x31c)] = _0x57915f, _0x489aa7[_0x5f5076(_0x5f0e64._0x163bfb)](_0x1aebf2 => { const _0x1ee7d3 = _0x5f5076; _0x1aebf2[_0x1ee7d3(0x474)] && (_0x1aebf2['castShadow'] = _0x2172ee, _0x1aebf2['receiveShadow'] = _0x2172ee, _0x1aebf2[_0x1ee7d3(0x1c2)] = MODEL_RENDER_ORDER, this[_0x1ee7d3(_0x10f407._0x2e842f)]['push'](_0x1aebf2), this[_0x1ee7d3(_0x10f407._0x8c91b6)][_0x1ee7d3(_0x10f407._0x3022fb)](_0x1aebf2)) }), this[_0x5f5076(0x37e)][_0x5f5076(_0x5f0e64._0x28c817)](_0x489aa7), this[_0x5f5076(0x17a)][_0x5f5076(0x1da)](_0x489aa7), _0x38d74e++, _0x32b10e && _0x32b10e[_0x5f5076(0x44c)] && _0x32b10e[_0x5f5076(_0x5f0e64._0x2b3213)](_0x489aa7, this), _0x38d74e == _0x20343b && (_0x32b10e && _0x32b10e['onLoad'] && _0x32b10e[_0x5f5076(_0x5f0e64._0xfd823f)](this)) }); else throw new Error(_0x25b880 + _0x30908b(_0xa6d2f._0x2bca81)) } }) } ['initPasses'] (_0x486bfb) { const _0x2065be = { _0x182d5: 0x536, _0x15fd26: 0x37e, _0x4b22a2: 0x2e6, _0x3692bb: 0x2c9, _0x4b73b9: 0x1c5, _0x392a1b: 0x362, _0x1afca1: 0x469, _0xa1ab5f: 0x549, _0xfbf89a: 0x248, _0x2b2b03: 0x203, _0x35cc72: 0x3e9, _0x336932: 0x3fd, _0x46e3c2: 0x2c9, _0x18c28c: 0x2e5, _0x4fa423: 0x433, _0x1ecd7f: 0x549, _0x2b64f3: 0x1f0, _0x22c7ef: 0x237, _0x1b87e7: 0x2c9, _0x5ea92a: 0x341, _0x298102: 0x37e, _0x206bda: 0x3ec, _0x10fa6f: 0x3ec, _0x21828d: 0x284, _0x38d063: 0x284, _0x5d9ca2: 0x2b1, _0x5ca87e: 0x549, _0x3532e5: 0x24c, _0x43ab9c: 0x482, _0x2aafbe: 0x191, _0x4b30ab: 0x41a, _0x1ee726: 0x203, _0x33b75e: 0x226, _0x4305e8: 0x26b, _0x1a5137: 0x2c9, _0x16c195: 0x2b2, _0xf0b088: 0x3ed, _0x2c2002: 0x3f0, _0x113211: 0x2a5, _0x22775f: 0x23f, _0x14d191: 0x1fb, _0x428568: 0x3e0, _0x536aa1: 0x285, _0x17ee25: 0x158, _0x2f0d5a: 0x49f, _0x5f2ebb: 0x347, _0x412882: 0x158, _0x52cb10: 0x34a, _0x22b404: 0x302, _0x2fdc5f: 0x312, _0x210c03: 0x37e, _0xd3c68b: 0x312, _0x2d1e0d: 0x472 }, _0x4c2b2e = _0x48e965, _0x26dcb9 = { 'format': RGBEFormat, 'magFilter': LinearFilter, 'minFilter': LinearFilter }; let _0x9fa99 = this['orbitCamera']; this['viewState'] == 'firstPerson' && (_0x9fa99 = this[_0x4c2b2e(_0x2065be._0x182d5)]); this[_0x4c2b2e(0x47f)] = new RenderPass(this[_0x4c2b2e(_0x2065be._0x15fd26)], _0x9fa99); const _0x27df60 = this['renderer'][_0x4c2b2e(_0x2065be._0x4b22a2)](new Vector2()); let _0x4a562b = { 'supersampling': ![] }; Object[_0x4c2b2e(_0x2065be._0x3692bb)](_0x4a562b, _0x486bfb && _0x486bfb[_0x4c2b2e(_0x2065be._0x4b73b9)]); const _0x95c78d = _0x4a562b[_0x4c2b2e(_0x2065be._0x392a1b)] ? _0x27df60['width'] * 0x2 : _0x27df60['width'], _0x21838b = _0x4a562b['supersampling'] ? _0x27df60['height'] * 0x2 : _0x27df60['height']; this['supersampling'] = _0x4a562b[_0x4c2b2e(0x362)], this[_0x4c2b2e(_0x2065be._0x1afca1)] = new WebGLMultisampleRenderTarget(_0x95c78d, _0x21838b, _0x26dcb9), this[_0x4c2b2e(_0x2065be._0xa1ab5f)] = new EffectComposer(this[_0x4c2b2e(_0x2065be._0xfbf89a)], this['msaaTarget']), this[_0x4c2b2e(0x549)][_0x4c2b2e(_0x2065be._0x2b2b03)](this['renderPass']), this[_0x4c2b2e(_0x2065be._0x35cc72)] = new EffectComposer(this[_0x4c2b2e(0x248)], this[_0x4c2b2e(0x469)]), this['bloomComposer'][_0x4c2b2e(_0x2065be._0x336932)] = ![], this[_0x4c2b2e(0x3e9)]['addPass'](this['renderPass']); const _0x4daf5c = { 'hue': 0x0, 'saturation': 0x1, 'vibrance': 0x0, 'brightness': 0x0, 'contrast': 0x1 }; Object[_0x4c2b2e(_0x2065be._0x46e3c2)](_0x4daf5c, _0x486bfb?.[_0x4c2b2e(_0x2065be._0x18c28c)]), this['filterPass'] = new FilterPass(_0x4daf5c); const _0x5ea5c7 = _0x486bfb?.[_0x4c2b2e(_0x2065be._0x4fa423)] !== undefined ? _0x486bfb?.['filterEnabled'] : ![]; this['filterPass']['enabled'] = _0x5ea5c7, this[_0x4c2b2e(_0x2065be._0x1ecd7f)][_0x4c2b2e(0x203)](this[_0x4c2b2e(0x19a)]); const _0x254b39 = _0x486bfb && _0x486bfb[_0x4c2b2e(0x237)] != undefined && _0x486bfb[_0x4c2b2e(0x237)][_0x4c2b2e(_0x2065be._0x2b64f3)] === 'color' ? new Color(_0x486bfb[_0x4c2b2e(_0x2065be._0x22c7ef)][_0x4c2b2e(0x27b)]) : new Color(); let _0xf7c41b = { 'level': 0x1, 'unbiased': !![] }; Object[_0x4c2b2e(_0x2065be._0x1b87e7)](_0xf7c41b, _0x486bfb && _0x486bfb[_0x4c2b2e(_0x2065be._0x5ea92a)]), this['ssaaPass'] = new SSAARenderPass(this[_0x4c2b2e(_0x2065be._0x298102)], _0x9fa99, _0x254b39, 0x0), this[_0x4c2b2e(_0x2065be._0x206bda)]['sampleLevel'] = _0xf7c41b['level'], this[_0x4c2b2e(_0x2065be._0x10fa6f)]['unbiased'] = _0xf7c41b[_0x4c2b2e(0x222)], this[_0x4c2b2e(0x549)][_0x4c2b2e(0x203)](this[_0x4c2b2e(0x3ec)]); const _0x51d5c1 = _0x486bfb && _0x486bfb[_0x4c2b2e(_0x2065be._0x21828d)] != undefined ? _0x486bfb[_0x4c2b2e(_0x2065be._0x38d063)] : ![]; this[_0x4c2b2e(0x3ec)][_0x4c2b2e(_0x2065be._0x5d9ca2)] = _0x51d5c1; let _0x2fed13 = { 'renderer': this[_0x4c2b2e(_0x2065be._0xfbf89a)], 'scene': this[_0x4c2b2e(0x37e)], 'camera': _0x9fa99, 'width': this['containerWidth'], 'height': this[_0x4c2b2e(0x191)], 'selects': [], 'groundReflector': null, 'encoding': LinearEncoding, 'maxDistance': 0xc8 }; _0x2fed13 = Object[_0x4c2b2e(0x2c9)](_0x2fed13, _0x486bfb && _0x486bfb[_0x4c2b2e(0x380)]), this[_0x4c2b2e(0x427)] = new SSRPass(_0x2fed13), this['ssrPass']['maxDistance'] = 0xc8; const _0x2de7ee = _0x486bfb && _0x486bfb[_0x4c2b2e(0x48f)] != undefined ? _0x486bfb[_0x4c2b2e(0x48f)] : ![]; this['ssrPass'][_0x4c2b2e(0x2b1)] = _0x2de7ee, this[_0x4c2b2e(0x549)][_0x4c2b2e(0x203)](this[_0x4c2b2e(0x427)]); let _0x5dcfae = { 'factor': 2.2 }; _0x5dcfae = Object['assign'](_0x5dcfae, _0x486bfb && _0x486bfb['gamma']), this[_0x4c2b2e(0x467)] = new ShaderPass(new ShaderMaterial({ 'uniforms': { 'tDiffuse': { 'value': null }, 'factor': { 'value': _0x5dcfae[_0x4c2b2e(0x250)] } }, 'vertexShader': gammaVertexShader, 'fragmentShader': gammaFragmentShader })); const _0xf5d413 = _0x486bfb && _0x486bfb[_0x4c2b2e(0x385)] != undefined ? _0x486bfb[_0x4c2b2e(0x385)] : !![]; this[_0x4c2b2e(_0x2065be._0x5ca87e)]['addPass'](this[_0x4c2b2e(0x467)]), this['gammaPass'][_0x4c2b2e(0x2b1)] = _0xf5d413; let _0x6e1d33 = { 'bloomStrength': 1.5, 'bloomRadius': 0x0, 'threshold': 0.85 }; _0x6e1d33 = Object[_0x4c2b2e(_0x2065be._0x46e3c2)](_0x6e1d33, _0x486bfb && _0x486bfb[_0x4c2b2e(_0x2065be._0x3532e5)]), this['bloomPass'] = new UnrealBloomPass(new Vector2(this[_0x4c2b2e(_0x2065be._0x43ab9c)], this[_0x4c2b2e(_0x2065be._0x2aafbe)]), _0x6e1d33[_0x4c2b2e(0x335)], _0x6e1d33[_0x4c2b2e(_0x2065be._0x4b30ab)], _0x6e1d33[_0x4c2b2e(0x407)]); const _0x3d4807 = _0x486bfb && _0x486bfb[_0x4c2b2e(0x2af)] != undefined ? _0x486bfb[_0x4c2b2e(0x2af)] : ![]; this['bloomPass']['enabled'] = _0x3d4807, this[_0x4c2b2e(_0x2065be._0x35cc72)][_0x4c2b2e(_0x2065be._0x1ee726)](this[_0x4c2b2e(0x271)]), this['finalbloomPass'] = new ShaderPass(new ShaderMaterial({ 'uniforms': { 'baseTexture': { 'value': null }, 'bloomTexture': { 'value': this[_0x4c2b2e(0x3e9)][_0x4c2b2e(0x1d2)][_0x4c2b2e(0x1ba)] } }, 'vertexShader': bloomVertexShader, 'fragmentShader': bloomFragShader }), _0x4c2b2e(_0x2065be._0x33b75e)), this[_0x4c2b2e(_0x2065be._0x4305e8)]['needsSwap'] = !![], this[_0x4c2b2e(0x549)]['addPass'](this['finalbloomPass']); let _0x5e0fd3 = { 'focus': 0x64, 'aperture': 0.00001, 'maxblur': 0.01, 'width': this['containerWidth'], 'height': this[_0x4c2b2e(0x191)] }; _0x5e0fd3 = Object[_0x4c2b2e(_0x2065be._0x1a5137)](_0x5e0fd3, _0x486bfb && _0x486bfb['dof']), this['bokehPass'] = new BokehPass(this[_0x4c2b2e(0x37e)], _0x9fa99, _0x5e0fd3), this['sceneComposer']['addPass'](this[_0x4c2b2e(_0x2065be._0x16c195)]); const _0x2340ac = _0x486bfb && _0x486bfb['dofEnabled'] != undefined ? _0x486bfb[_0x4c2b2e(_0x2065be._0xf0b088)] : ![]; this[_0x4c2b2e(_0x2065be._0x16c195)]['enabled'] = _0x2340ac; let _0xf94cd4 = { 'edgeStrength': 0x3, 'edgeGlow': 0x0, 'edgeThickness': 0x1, 'pulsePeriod': 0x0, 'visibleEdgeColor': _0x4c2b2e(0x27e), 'hiddenEdgeColor': _0x4c2b2e(_0x2065be._0x2c2002), 'msaa': ![], 'downSampleRatio': 0x2 }; _0xf94cd4 = Object[_0x4c2b2e(0x2c9)](_0xf94cd4, _0x486bfb && _0x486bfb[_0x4c2b2e(_0x2065be._0x113211)]), this['outlinePass'] = new OutlinePass(new Vector2(this['containerWidth'], this[_0x4c2b2e(0x191)]), this[_0x4c2b2e(0x37e)], _0x9fa99, this[_0x4c2b2e(0x4a7)], _0xf94cd4[_0x4c2b2e(0x1c5)]), this[_0x4c2b2e(0x158)][_0x4c2b2e(0x23f)] = _0xf94cd4[_0x4c2b2e(_0x2065be._0x22775f)], this[_0x4c2b2e(0x158)]['edgeGlow'] = _0xf94cd4[_0x4c2b2e(0x4f2)], this[_0x4c2b2e(0x158)][_0x4c2b2e(_0x2065be._0x14d191)] = _0xf94cd4[_0x4c2b2e(_0x2065be._0x14d191)], this[_0x4c2b2e(0x158)][_0x4c2b2e(_0x2065be._0x428568)] = _0xf94cd4['pulsePeriod'], this[_0x4c2b2e(0x158)][_0x4c2b2e(0x285)][_0x4c2b2e(0x49f)](_0xf94cd4[_0x4c2b2e(_0x2065be._0x536aa1)]), this[_0x4c2b2e(_0x2065be._0x17ee25)][_0x4c2b2e(0x347)][_0x4c2b2e(_0x2065be._0x2f0d5a)](_0xf94cd4[_0x4c2b2e(_0x2065be._0x5f2ebb)]), this[_0x4c2b2e(_0x2065be._0x412882)]['downSampleRatio'] = _0xf94cd4[_0x4c2b2e(0x3f4)], this['sceneComposer']['addPass'](this['outlinePass']); const _0x93d4fe = _0x486bfb && _0x486bfb['outlineEnabled'] != undefined ? _0x486bfb['outlineEnabled'] : ![]; this[_0x4c2b2e(_0x2065be._0x412882)][_0x4c2b2e(0x2b1)] = _0x93d4fe; const _0x30b6f0 = _0x486bfb && _0x486bfb[_0x4c2b2e(0x34a)] != undefined ? _0x486bfb[_0x4c2b2e(_0x2065be._0x52cb10)] : ![]; _0x30b6f0 && (this[_0x4c2b2e(0x302)] = new SSRSkyBox(null, _0x9fa99, this[_0x4c2b2e(0x248)]), this[_0x4c2b2e(_0x2065be._0x5ca87e)][_0x4c2b2e(0x203)](this[_0x4c2b2e(_0x2065be._0x22b404)]), this[_0x4c2b2e(_0x2065be._0x2fdc5f)] = new DoubleDepthBufferPass(this[_0x4c2b2e(_0x2065be._0x210c03)][_0x4c2b2e(0x2b0)](!![]), _0x9fa99, this[_0x4c2b2e(0x248)]), this[_0x4c2b2e(0x549)]['addPass'](this[_0x4c2b2e(_0x2065be._0xd3c68b)]), this[_0x4c2b2e(_0x2065be._0x2d1e0d)] = new SSRTPass(this['scene']['clone'](!![]), this['ddpPass'], _0x9fa99, this[_0x4c2b2e(0x248)]), this[_0x4c2b2e(_0x2065be._0x5ca87e)]['addPass'](this[_0x4c2b2e(_0x2065be._0x2d1e0d)])) } [_0x48e965(0x18a)] (_0x3d1c06, _0x57d87b) { const _0x2e772e = { _0x54f649: 0x4b6, _0x3f6f60: 0x2be, _0x107bf5: 0x237, _0x156451: 0x237, _0x536bd2: 0x4b6, _0x54902d: 0x4b6, _0x14b6e0: 0x3bf, _0x388cd7: 0x223, _0x2e74c5: 0x223, _0x130e46: 0x321, _0x558255: 0x45f, _0x399113: 0x49b, _0x2dda6f: 0x32e }, _0x5cb2af = { _0x1e776f: 0x49f, _0xed1107: 0x1c2, _0x1845e9: 0x4cf, _0x10bd86: 0x2f4, _0x50bd3c: 0x27b, _0x368638: 0x4cf }, _0x3de9ca = { _0x5fd32e: 0x1f0, _0xff1717: 0x4cf, _0x3a81bc: 0x4cf, _0x2f3e6b: 0x2f4, _0x4710d9: 0x44d }, _0x1e6a4f = { _0x41492e: 0x2fb, _0x49a797: 0x283 }, _0x261a7b = _0x48e965; if (!(_0x3d1c06 instanceof Array)) return; const _0x1ec40c = this[_0x261a7b(0x20f)], _0x14f5ae = _0x1ec40c && _0x1ec40c[_0x261a7b(0x237)] && _0x1ec40c[_0x261a7b(0x237)][_0x261a7b(0x4b6)] && _0x1ec40c[_0x261a7b(0x237)][_0x261a7b(_0x2e772e._0x54f649)][_0x261a7b(_0x2e772e._0x3f6f60)] ? _0x1ec40c[_0x261a7b(_0x2e772e._0x107bf5)][_0x261a7b(0x4b6)][_0x261a7b(0x2be)] : 0x1, _0x279a24 = _0x1ec40c && _0x1ec40c[_0x261a7b(_0x2e772e._0x156451)] && _0x1ec40c[_0x261a7b(0x237)][_0x261a7b(_0x2e772e._0x536bd2)] && _0x1ec40c['background'][_0x261a7b(_0x2e772e._0x54902d)][_0x261a7b(_0x2e772e._0x14b6e0)] ? _0x1ec40c['background']['options'][_0x261a7b(0x3bf)] : [0x0, 0x0, 0x0], _0x429eca = _0x1ec40c && _0x1ec40c[_0x261a7b(0x237)] && _0x1ec40c['background']['options'] && _0x1ec40c[_0x261a7b(0x237)][_0x261a7b(0x4b6)][_0x261a7b(_0x2e772e._0x388cd7)] ? _0x1ec40c[_0x261a7b(_0x2e772e._0x156451)][_0x261a7b(0x4b6)][_0x261a7b(_0x2e772e._0x2e74c5)] : ![], _0x4683b7 = 0xc350; this['skyRadius'] = _0x4683b7; if (_0x3d1c06[_0x261a7b(_0x2e772e._0x130e46)] == 0x6) { const _0x28150c = [], _0x89918c = []; _0x3d1c06[_0x261a7b(0x164)](_0x5477b0 => { const _0x37ddf0 = _0x261a7b; _0x28150c[_0x37ddf0(0x1da)](loadTex(this[_0x37ddf0(_0x1e6a4f._0x41492e)], this[_0x37ddf0(_0x1e6a4f._0x49a797)] + _0x5477b0)) }), Promise[_0x261a7b(_0x2e772e._0x558255)](_0x28150c)[_0x261a7b(_0x2e772e._0x399113)](_0x419ee3 => { const _0x27df5f = { _0x58612a: 0x1da }, _0x24321a = _0x261a7b; _0x419ee3[_0x24321a(0x164)](_0x547559 => { const _0x57bb0b = _0x24321a, _0x3a9a9e = new MeshBasicMaterial({ 'map': _0x547559, 'side': 0x2, 'transparent': !![], 'opacity': 0x1, 'fog': _0x429eca }); _0x89918c[_0x57bb0b(_0x27df5f._0x58612a)](_0x3a9a9e) }); const _0x194303 = new BoxGeometry(_0x4683b7, _0x4683b7, _0x4683b7), _0x148193 = new Mesh(_0x194303, _0x89918c); _0x148193[_0x24321a(0x2be)][_0x24321a(0x49f)](_0x14f5ae, _0x14f5ae, _0x14f5ae), _0x148193['rotation'][_0x24321a(0x49f)](_0x279a24[0x0], _0x279a24[0x1], _0x279a24[0x2]), _0x148193[_0x24321a(0x1c2)] = SKY_RENDER_ORDER, _0x148193[_0x24321a(_0x3de9ca._0x5fd32e)] = 'SkyBox', this[_0x24321a(_0x3de9ca._0xff1717)] ? (this[_0x24321a(_0x3de9ca._0x3a81bc)]['geometry'] = _0x194303, this[_0x24321a(_0x3de9ca._0xff1717)][_0x24321a(_0x3de9ca._0x2f3e6b)] = _0x89918c) : (this[_0x24321a(0x37e)][_0x24321a(_0x3de9ca._0x4710d9)](_0x148193), this['sky'] = _0x148193), this[_0x24321a(0x4cf)]['userData'][_0x24321a(0x27b)] = _0x3d1c06, _0x57d87b && _0x57d87b(this[_0x24321a(0x4cf)]) }) } else _0x3d1c06[_0x261a7b(0x321)] == 0x1 && this[_0x261a7b(0x2fb)][_0x261a7b(_0x2e772e._0x2dda6f)](this[_0x261a7b(0x283)] + _0x3d1c06[0x0], _0x4e5249 => { const _0x4e3d91 = _0x261a7b, _0x17a7a8 = new MeshBasicMaterial({ 'map': _0x4e5249, 'side': BackSide, 'transparent': !![], 'opacity': 0x1, 'fog': _0x429eca }), _0x126902 = new SphereGeometry(_0x4683b7, 0x3c, 0x3c), _0x73ca96 = new Mesh(_0x126902, _0x17a7a8); _0x73ca96[_0x4e3d91(0x2be)][_0x4e3d91(_0x5cb2af._0x1e776f)](_0x14f5ae, _0x14f5ae, _0x14f5ae), _0x73ca96['rotation'][_0x4e3d91(0x49f)](_0x279a24[0x0], _0x279a24[0x1], _0x279a24[0x2]), _0x73ca96[_0x4e3d91(_0x5cb2af._0xed1107)] = SKY_RENDER_ORDER, _0x73ca96[_0x4e3d91(0x1f0)] = _0x4e3d91(0x27a), this[_0x4e3d91(_0x5cb2af._0x1845e9)] ? (this[_0x4e3d91(_0x5cb2af._0x1845e9)]['geometry'] = _0x126902, this[_0x4e3d91(_0x5cb2af._0x1845e9)][_0x4e3d91(_0x5cb2af._0x10bd86)] = _0x17a7a8) : (this['scene']['add'](_0x73ca96), this[_0x4e3d91(0x4cf)] = _0x73ca96), this[_0x4e3d91(0x4cf)][_0x4e3d91(0x15f)][_0x4e3d91(_0x5cb2af._0x50bd3c)] = _0x3d1c06, _0x57d87b && _0x57d87b(this[_0x4e3d91(_0x5cb2af._0x368638)]) }) } [_0x48e965(0x18d)] (_0x5f41c1, _0x3ab8df) { const _0x5188c5 = { _0x371e37: 0x175, _0x1e74c1: 0x3d6, _0x25a2ba: 0x31f, _0x1ffcc2: 0x175, _0x2ba1cb: 0x3a9, _0xc421e3: 0x327 }, _0x36aba4 = { _0x4e4e72: 0x175, _0x2ed75f: 0x510, _0x51e747: 0x2b4, _0x6a0237: 0x37e }, _0x381c0f = { _0x123a8a: 0x2f4 }, _0x568ace = { _0x2357c9: 0x178, _0xa06339: 0x175 }, _0x204824 = _0x48e965; if (!(_0x5f41c1 instanceof Array)) return; if (_0x5f41c1[_0x204824(0x321)] == 0x1) this[_0x204824(_0x5188c5._0x371e37)][_0x204824(_0x5188c5._0x1e74c1)](), this[_0x204824(_0x5188c5._0x25a2ba)][_0x204824(0x18c)](UnsignedByteType)['load'](this['publicPath'] + _0x5f41c1[0x0], _0x58d539 => { const _0x174c4e = _0x204824, _0x5af501 = this[_0x174c4e(0x175)][_0x174c4e(_0x568ace._0x2357c9)](_0x58d539)[_0x174c4e(0x1ba)]; this[_0x174c4e(_0x568ace._0xa06339)][_0x174c4e(0x2b4)](), this[_0x174c4e(0x479)] = _0x5af501, this[_0x174c4e(0x37e)][_0x174c4e(0x4a5)](_0x1fdf59 => { const _0xcdca95 = _0x174c4e; _0x1fdf59[_0xcdca95(0x474)] && (_0x1fdf59[_0xcdca95(0x2f4)][_0xcdca95(0x479)] = _0x5af501) }), _0x3ab8df && _0x3ab8df(this[_0x174c4e(0x479)]) }); else { if (_0x5f41c1[_0x204824(0x321)] == 0x6) { this[_0x204824(_0x5188c5._0x1ffcc2)][_0x204824(_0x5188c5._0x2ba1cb)](); const _0x1ba061 = []; _0x1ba061[_0x204824(0x164)](_0x4e090b => { const _0x24078a = _0x204824; _0x1ba061['push'](this[_0x24078a(0x283)] + _0x4e090b) }), this[_0x204824(_0x5188c5._0xc421e3)][_0x204824(0x32e)](_0x1ba061, _0x4c45ae => { const _0x233d8d = _0x204824, _0x260dbd = this[_0x233d8d(_0x36aba4._0x4e4e72)][_0x233d8d(_0x36aba4._0x2ed75f)](_0x4c45ae)[_0x233d8d(0x1ba)]; this['pmremGenerator'][_0x233d8d(_0x36aba4._0x51e747)](), this[_0x233d8d(0x479)] = _0x260dbd, this[_0x233d8d(_0x36aba4._0x6a0237)][_0x233d8d(0x4a5)](_0x486ce7 => { const _0x52f20e = _0x233d8d; _0x486ce7['isMesh'] && (_0x486ce7[_0x52f20e(_0x381c0f._0x123a8a)][_0x52f20e(0x479)] = _0x260dbd) }), _0x3ab8df && _0x3ab8df(this['envMap']) }) } } } ['attach'] (_0x42cad1) { const _0x33c5a3 = _0x48e965; this[_0x33c5a3(0x37e)][_0x33c5a3(0x44d)](_0x42cad1) } [_0x48e965(0x4af)] (_0x5a3129) { const _0x4a8067 = { _0x4d6258: 0x37e }, _0x75b1d7 = _0x48e965; this[_0x75b1d7(_0x4a8067._0x4d6258)][_0x75b1d7(0x4af)](_0x5a3129); const _0x23a514 = this['children'][_0x75b1d7(0x413)](_0x5a3129); this[_0x75b1d7(0x29e)]['splice'](_0x23a514, 0x1) } [_0x48e965(0x15a)] (_0x17f3a4) { const _0x50ab60 = { _0x1251ce: 0x29e, _0x5e2b9e: 0x29e }, _0x5b46f6 = _0x48e965; for (const _0x32c7ce in this[_0x5b46f6(_0x50ab60._0x1251ce)]) { if (this[_0x5b46f6(_0x50ab60._0x5e2b9e)][_0x32c7ce]['name'] == _0x17f3a4) return this[_0x5b46f6(0x29e)][_0x32c7ce] } } [_0x48e965(0x29a)] (_0x567668) { const _0x24f134 = _0x48e965, _0x170c4c = []; for (const _0x3832ba in this[_0x24f134(0x29e)]) { this[_0x24f134(0x29e)][_0x3832ba][_0x24f134(0x31c)] == _0x567668 && _0x170c4c['push'](this['children'][_0x3832ba]) } return _0x170c4c } [_0x48e965(0x4dc)] (_0x565b51) { const _0xc0f91f = { _0x49c234: 0x29e }, _0x5abc34 = _0x48e965; for (const _0x506581 in this[_0x5abc34(_0xc0f91f._0x49c234)]) { if (this[_0x5abc34(0x29e)][_0x506581][_0x5abc34(0x39d)] == _0x565b51) return this[_0x5abc34(0x29e)][_0x506581] } } [_0x48e965(0x2d5)] (_0x1b2321) { const _0x3757fc = { _0x51b563: 0x29e }, _0xce756e = _0x48e965, _0x9188d = []; for (const _0x46dced in this[_0xce756e(_0x3757fc._0x51b563)]) { this['children'][_0x46dced][_0xce756e(0x1f0)] == _0x1b2321 && _0x9188d[_0xce756e(0x1da)](this[_0xce756e(0x29e)][_0x46dced]) } return _0x9188d } [_0x48e965(0x151)] (_0x273420) { const _0x3e936f = { _0x2a465a: 0x2bd, _0x418f51: 0x4c4, _0x46a1b2: 0x34c, _0x480bd8: 0x44f, _0x1e3231: 0x4dd, _0x583aea: 0x4c4, _0x21da12: 0x4dd, _0x5050dc: 0x371, _0x5ee2c0: 0x522, _0x1e42ff: 0x1ef, _0x47d90c: 0x3f5 }, _0x5ced9c = _0x48e965; if (this[_0x5ced9c(_0x3e936f._0x2a465a)] != _0x5ced9c(0x468)) return; const { target: _0xb0c0e0, callback: _0x5a0097, polarAngle: _0x321c96, azimuthalAngle: _0x8f11af, distance: _0x476494 } = _0x273420, _0xc17037 = new Vector3(); if (_0xb0c0e0 instanceof Vector3) _0xc17037[_0x5ced9c(0x371)](_0xb0c0e0); else _0xb0c0e0 instanceof Array && _0xc17037[_0x5ced9c(0x49f)](_0xb0c0e0[0x0], _0xb0c0e0[0x1], _0xb0c0e0[0x2]); const _0x537d53 = new Vector3()['subVectors'](this[_0x5ced9c(0x4dd)][_0x5ced9c(_0x3e936f._0x418f51)], this[_0x5ced9c(_0x3e936f._0x46a1b2)][_0x5ced9c(0x522)]), _0x4c68a9 = new Spherical()['setFromVector3'](_0x537d53); if (_0x321c96 !== undefined) _0x4c68a9['phi'] = _0x321c96; if (_0x8f11af !== undefined) _0x4c68a9[_0x5ced9c(_0x3e936f._0x480bd8)] = _0x8f11af; if (_0x476494 !== undefined) _0x4c68a9['radius'] = _0x476494; _0x537d53[_0x5ced9c(0x3f6)](_0x4c68a9); const _0x2e471f = new Vector3(); _0x2e471f[_0x5ced9c(0x371)](_0xc17037)['add'](_0x537d53), _0x2e471f['distanceTo'](this[_0x5ced9c(_0x3e936f._0x1e3231)][_0x5ced9c(_0x3e936f._0x583aea)]) < 0.0001 ? (this[_0x5ced9c(_0x3e936f._0x21da12)][_0x5ced9c(0x4c4)][_0x5ced9c(_0x3e936f._0x5050dc)](_0x2e471f), this['orbitControls'][_0x5ced9c(0x522)][_0x5ced9c(0x371)](_0xc17037), _0x5a0097 && _0x5a0097()) : (new Tween(this['orbitControls'][_0x5ced9c(_0x3e936f._0x5ee2c0)])['to'](_0xc17037, 0x320)[_0x5ced9c(0x1ef)](), new Tween(this[_0x5ced9c(0x4dd)][_0x5ced9c(_0x3e936f._0x418f51)])['to'](_0x2e471f, 0x320)[_0x5ced9c(_0x3e936f._0x1e42ff)]()[_0x5ced9c(_0x3e936f._0x47d90c)](() => { _0x5a0097 && _0x5a0097() })) } [_0x48e965(0x50c)] (_0x4d4839) { const _0x52d5ba = _0x48e965; _0x4d4839['layers'][_0x52d5ba(0x375)](0x2) } [_0x48e965(0x34b)] (_0x5d2169) { const _0x412423 = { _0x25c188: 0x4e1 }, _0x38622a = _0x48e965; _0x5d2169[_0x38622a(_0x412423._0x25c188)]['disable'](0x2) } ['addBloom'] (_0x52c1c2) { const _0xe34c07 = _0x48e965; _0x52c1c2[_0xe34c07(0x4e1)]['enable'](0x1) } [_0x48e965(0x2db)] (_0x340236) { const _0x1d6190 = { _0x132641: 0x4e1 }, _0x11c26a = _0x48e965; _0x340236[_0x11c26a(_0x1d6190._0x132641)][_0x11c26a(0x239)](0x1) } [_0x48e965(0x537)] ({ fileList: _0x3345fa, onLoad: _0x12b15a }) { const _0x29d316 = { _0x579561: 0x175, _0x5d8a57: 0x320, _0x1c96f4: 0x3a9, _0x450143: 0x1da }, _0x15b220 = { _0x3b2e2f: 0x4f8 }, _0x441882 = { _0x29f571: 0x45e, _0xe95f23: 0x48d, _0x342c7f: 0x15d, _0x299fd8: 0x1a0, _0x25a250: 0x4b8, _0x464dfd: 0x501, _0x414326: 0x501, _0x2f59da: 0x524, _0xa2a20f: 0x524, _0x471441: 0x3b4, _0x1af99f: 0x1f0, _0x3894f3: 0x3f7, _0x1b3ede: 0x3c5, _0x5ed3aa: 0x501, _0x493af1: 0x3c3, _0x2f9373: 0x175, _0x139044: 0x479, _0x23d041: 0x29e, _0x2fa238: 0x164 }, _0x5aba53 = _0x48e965, _0x3e811e = _0x3345fa['length']; if (_0x3e811e == 0x0) return; if (_0x3e811e == 0x1) { this[_0x5aba53(_0x29d316._0x579561)][_0x5aba53(0x3d6)](); const _0x10f633 = new FileReader(); _0x10f633['readAsArrayBuffer'](_0x3345fa[0x0]), _0x10f633[_0x5aba53(_0x29d316._0x5d8a57)] = _0x260b90 => { const _0x3ec4ae = _0x5aba53, _0x48be3f = _0x260b90['target']?.['result'], _0x1165ee = new DataTexture(null, 0x1, 0x1, undefined, undefined, undefined, undefined, undefined, NearestFilter, NearestFilter, undefined, undefined), _0x558b85 = this[_0x3ec4ae(0x31f)][_0x3ec4ae(0x18c)](UnsignedByteType)[_0x3ec4ae(_0x441882._0x29f571)](_0x48be3f); if (!_0x558b85) return; if (_0x558b85[_0x3ec4ae(_0x441882._0xe95f23)] !== undefined) _0x1165ee[_0x3ec4ae(_0x441882._0xe95f23)] = _0x558b85[_0x3ec4ae(0x48d)]; else _0x558b85[_0x3ec4ae(0x51b)] !== undefined && (_0x1165ee[_0x3ec4ae(0x48d)]['width'] = _0x558b85[_0x3ec4ae(_0x441882._0x342c7f)], _0x1165ee['image']['height'] = _0x558b85['height'], _0x1165ee[_0x3ec4ae(_0x441882._0xe95f23)][_0x3ec4ae(0x51b)] = _0x558b85[_0x3ec4ae(0x51b)]); _0x1165ee[_0x3ec4ae(_0x441882._0x299fd8)] = _0x558b85[_0x3ec4ae(0x1a0)] !== undefined ? _0x558b85[_0x3ec4ae(_0x441882._0x299fd8)] : ClampToEdgeWrapping, _0x1165ee[_0x3ec4ae(_0x441882._0x25a250)] = _0x558b85[_0x3ec4ae(0x4b8)] !== undefined ? _0x558b85['wrapT'] : ClampToEdgeWrapping, _0x1165ee[_0x3ec4ae(0x185)] = _0x558b85['magFilter'] !== undefined ? _0x558b85[_0x3ec4ae(0x185)] : LinearFilter, _0x1165ee[_0x3ec4ae(_0x441882._0x464dfd)] = _0x558b85[_0x3ec4ae(_0x441882._0x414326)] !== undefined ? _0x558b85[_0x3ec4ae(0x501)] : LinearFilter, _0x1165ee[_0x3ec4ae(_0x441882._0x2f59da)] = _0x558b85[_0x3ec4ae(0x524)] !== undefined ? _0x558b85[_0x3ec4ae(_0x441882._0xa2a20f)] : 0x1; _0x558b85['encoding'] !== undefined && (_0x1165ee['encoding'] = _0x558b85['encoding']); _0x558b85['flipY'] !== undefined && (_0x1165ee[_0x3ec4ae(0x179)] = _0x558b85[_0x3ec4ae(0x179)]); _0x558b85['format'] !== undefined && (_0x1165ee[_0x3ec4ae(0x3b4)] = _0x558b85[_0x3ec4ae(_0x441882._0x471441)]); _0x558b85[_0x3ec4ae(_0x441882._0x1af99f)] !== undefined && (_0x1165ee[_0x3ec4ae(_0x441882._0x1af99f)] = _0x558b85[_0x3ec4ae(_0x441882._0x1af99f)]); _0x558b85[_0x3ec4ae(0x3f7)] !== undefined && (_0x1165ee[_0x3ec4ae(_0x441882._0x3894f3)] = _0x558b85[_0x3ec4ae(0x3f7)], _0x1165ee[_0x3ec4ae(_0x441882._0x414326)] = LinearMipmapLinearFilter); _0x558b85[_0x3ec4ae(_0x441882._0x1b3ede)] === 0x1 && (_0x1165ee[_0x3ec4ae(_0x441882._0x5ed3aa)] = LinearFilter); _0x558b85[_0x3ec4ae(0x3c3)] !== undefined && (_0x1165ee[_0x3ec4ae(_0x441882._0x493af1)] = _0x558b85[_0x3ec4ae(_0x441882._0x493af1)]); _0x1165ee['needsUpdate'] = !![]; const _0x2734d9 = this[_0x3ec4ae(_0x441882._0x2f9373)][_0x3ec4ae(0x178)](_0x1165ee)['texture']; this['pmremGenerator']['dispose'](), this[_0x3ec4ae(_0x441882._0x139044)] = _0x2734d9, this[_0x3ec4ae(_0x441882._0x23d041)][_0x3ec4ae(_0x441882._0x2fa238)](_0x651dc => { const _0x223a98 = _0x3ec4ae; _0x651dc['material'][_0x223a98(0x479)] = _0x2734d9 }), _0x12b15a && _0x12b15a(_0x2734d9) } } else { if (_0x3e811e == 0x6) { this[_0x5aba53(0x175)][_0x5aba53(_0x29d316._0x1c96f4)](); const _0x419587 = new CubeTexture(), _0x21df64 = []; for (const _0x28e220 in _0x3345fa) { const _0x2538e7 = _0x3345fa[_0x28e220]; if (_0x2538e7 instanceof File) { const _0x4c04d9 = new FileReader(); _0x21df64[_0x5aba53(_0x29d316._0x450143)](parseImageFile(_0x4c04d9, _0x2538e7)) } } Promise[_0x5aba53(0x45f)](_0x21df64)[_0x5aba53(0x49b)](_0x5621f6 => { const _0x10aad9 = _0x5aba53; _0x419587[_0x10aad9(_0x15b220._0x3b2e2f)] = !![], _0x419587[_0x10aad9(0x2ed)] = _0x5621f6; const _0x2e4c0f = this['pmremGenerator'][_0x10aad9(0x510)](_0x419587)['texture']; this[_0x10aad9(0x175)][_0x10aad9(0x2b4)](), this['envMap'] = _0x2e4c0f, this['children'][_0x10aad9(0x164)](_0x5a43ba => { _0x5a43ba['material']['envMap'] = _0x2e4c0f }), _0x12b15a && _0x12b15a(_0x2e4c0f) }) } } } [_0x48e965(0x326)] ({ fileList: _0x23f36a, onLoad: _0x4f0d00 }) { const _0x182d8f = { _0xa5001c: 0x20f, _0x5d0347: 0x2be, _0x2d3007: 0x237, _0x28b8ba: 0x2be, _0xe3ae62: 0x237, _0x5c7ebd: 0x3bf, _0x41293a: 0x3bf, _0x3b94dc: 0x223, _0x3bdd2c: 0x45f, _0x22cdef: 0x49b }, _0x3537a7 = { _0x169ecd: 0x48d, _0x258c26: 0x4cf, _0x1d7f0b: 0x4f8, _0x597e32: 0x1ac, _0x8e8b6d: 0x3bf, _0x4f3b9a: 0x1c2, _0x154a6b: 0x37e, _0x2220cf: 0x44d }, _0x301515 = { _0x110491: 0x4cf, _0x2efeb3: 0x2f4, _0x35e79d: 0x49f, _0x179f50: 0x49f, _0x32cbd1: 0x37e, _0x2a6fe0: 0x44d }, _0x38ef57 = _0x48e965, _0x1495a0 = _0x23f36a[_0x38ef57(0x321)]; if (_0x1495a0 == 0x0) return; const _0x25dd1c = this[_0x38ef57(_0x182d8f._0xa5001c)], _0x19290d = _0x25dd1c && _0x25dd1c['background'] && _0x25dd1c[_0x38ef57(0x237)][_0x38ef57(0x4b6)] && _0x25dd1c[_0x38ef57(0x237)]['options'][_0x38ef57(_0x182d8f._0x5d0347)] ? _0x25dd1c[_0x38ef57(_0x182d8f._0x2d3007)]['options'][_0x38ef57(_0x182d8f._0x28b8ba)] : 0x1, _0x1c9b8c = _0x25dd1c && _0x25dd1c[_0x38ef57(0x237)] && _0x25dd1c[_0x38ef57(_0x182d8f._0xe3ae62)]['options'] && _0x25dd1c[_0x38ef57(0x237)][_0x38ef57(0x4b6)][_0x38ef57(_0x182d8f._0x5c7ebd)] ? _0x25dd1c['background'][_0x38ef57(0x4b6)][_0x38ef57(_0x182d8f._0x41293a)] : [0x0, 0x0, 0x0], _0x4a8c62 = _0x25dd1c && _0x25dd1c[_0x38ef57(0x237)] && _0x25dd1c[_0x38ef57(0x237)]['options'] && _0x25dd1c[_0x38ef57(_0x182d8f._0xe3ae62)]['options'][_0x38ef57(_0x182d8f._0x3b94dc)] ? _0x25dd1c[_0x38ef57(_0x182d8f._0x2d3007)]['options'][_0x38ef57(0x223)] : ![], _0x47bf2b = this['skyRadius']; if (_0x1495a0 == 0x6) { const _0x36d1d9 = [], _0x1d4bf7 = []; for (const _0xd3d77f in _0x23f36a) { const _0x5bb0ca = _0x23f36a[_0xd3d77f]; if (_0x5bb0ca instanceof File) { const _0x31260b = new FileReader(); _0x36d1d9['push'](parseImageFile(_0x31260b, _0x5bb0ca)) } } Promise[_0x38ef57(_0x182d8f._0x3bdd2c)](_0x36d1d9)[_0x38ef57(0x49b)](_0x1fe35e => { const _0x3c275f = { _0x568adb: 0x4f8, _0x200f09: 0x1da }, _0x46d187 = _0x38ef57; _0x1fe35e[_0x46d187(0x164)](_0x4a1d33 => { const _0x23d6b5 = _0x46d187, _0x1b2ea1 = new Texture(); _0x1b2ea1[_0x23d6b5(_0x3c275f._0x568adb)] = !![], _0x1b2ea1[_0x23d6b5(0x48d)] = _0x4a1d33; const _0x315ea2 = new MeshBasicMaterial({ 'map': _0x1b2ea1, 'side': BackSide, 'transparent': !![], 'opacity': 0x1, 'fog': _0x4a8c62 }); _0x1d4bf7[_0x23d6b5(_0x3c275f._0x200f09)](_0x315ea2) }); if (this[_0x46d187(0x4cf)]) this[_0x46d187(_0x301515._0x110491)][_0x46d187(_0x301515._0x2efeb3)][_0x46d187(0x4f8)] = !![], this['sky']['material'] = _0x1d4bf7; else { const _0x6bc28b = new BoxGeometry(_0x47bf2b, _0x47bf2b, _0x47bf2b), _0x1a7055 = new Mesh(_0x6bc28b, _0x1d4bf7); _0x1a7055[_0x46d187(0x2be)][_0x46d187(_0x301515._0x35e79d)](_0x19290d, _0x19290d, _0x19290d), _0x1a7055[_0x46d187(0x3bf)][_0x46d187(_0x301515._0x179f50)](_0x1c9b8c[0x0], _0x1c9b8c[0x1], _0x1c9b8c[0x2]), _0x1a7055[_0x46d187(0x1c2)] = SKY_RENDER_ORDER, _0x1a7055['type'] = _0x46d187(0x27a), this[_0x46d187(_0x301515._0x32cbd1)][_0x46d187(_0x301515._0x2a6fe0)](_0x1a7055), this[_0x46d187(_0x301515._0x110491)] = _0x1a7055 } }) } else { if (_0x1495a0 == 0x1) { const _0x1f6768 = new FileReader(); parseImageFile(_0x1f6768, _0x23f36a[0x0])[_0x38ef57(_0x182d8f._0x22cdef)](_0x33116b => { const _0x14f653 = _0x38ef57, _0x7c5708 = _0x33116b, _0x2f72c5 = new Texture(); _0x2f72c5[_0x14f653(_0x3537a7._0x169ecd)] = _0x7c5708, _0x2f72c5[_0x14f653(0x4f8)] = !![]; if (this[_0x14f653(_0x3537a7._0x258c26)]) this['sky'][_0x14f653(0x2f4)][_0x14f653(_0x3537a7._0x1d7f0b)] = !![], this[_0x14f653(_0x3537a7._0x258c26)][_0x14f653(0x2f4)][_0x14f653(_0x3537a7._0x597e32)] = _0x2f72c5; else { const _0x51e1a3 = new SphereGeometry(_0x47bf2b, 0x3c, 0x3c), _0x1b2051 = new MeshBasicMaterial({ 'map': _0x2f72c5, 'side': BackSide, 'transparent': !![], 'opacity': 0x1, 'fog': _0x4a8c62 }), _0x1ce6e0 = new Mesh(_0x51e1a3, _0x1b2051); _0x1ce6e0['scale'][_0x14f653(0x49f)](_0x19290d, _0x19290d, _0x19290d), _0x1ce6e0[_0x14f653(_0x3537a7._0x8e8b6d)]['set'](_0x1c9b8c[0x0], _0x1c9b8c[0x1], _0x1c9b8c[0x2]), _0x1ce6e0[_0x14f653(_0x3537a7._0x4f3b9a)] = SKY_RENDER_ORDER, _0x1ce6e0['type'] = 'SkyBox', this[_0x14f653(_0x3537a7._0x154a6b)][_0x14f653(_0x3537a7._0x2220cf)](_0x1ce6e0), this[_0x14f653(0x4cf)] = _0x1ce6e0 } }) } } } [_0x48e965(0x508)] ({ fileList: _0x3ceda0, onProgress: _0x4087ab, onLoad: _0x4f22c1 }) { const _0x5f45b4 = { _0x55187c: 0x321, _0x179f5d: 0x20f, _0x292efe: 0x308 }, _0x12e6a8 = { _0x864ecf: 0x522 }, _0x22e1d3 = _0x48e965, _0x23603f = _0x3ceda0[_0x22e1d3(_0x5f45b4._0x55187c)]; if (_0x23603f == 0x0) return; let _0x510bbd = 0x0, _0x38e16b = new Vector3(), _0x40edc7 = new Vector3(); const _0x2932ed = this[_0x22e1d3(0x20f)] && this['attrs'][_0x22e1d3(0x308)] != undefined ? this[_0x22e1d3(_0x5f45b4._0x179f5d)][_0x22e1d3(_0x5f45b4._0x292efe)] : ![]; for (const _0x5b110b in _0x3ceda0) { const _0x4af504 = _0x3ceda0[_0x5b110b]; if (_0x4af504 instanceof File) { const _0x1d992e = new FileReader(); _0x1d992e[_0x22e1d3(0x4a1)](_0x4af504), _0x1d992e['onload'] = _0x39ab34 => { const _0x3eaab0 = { _0x582a41: 0x31c, _0x5155d3: 0x24d, _0x51a6ac: 0x37e, _0x1b0689: 0x157, _0x50ddf5: 0x15f, _0x38847b: 0x4a5, _0x41b7c7: 0x44d, _0x16de85: 0x17a, _0x8cc019: 0x1da, _0x249e5c: 0x37b, _0x448fed: 0x4c4, _0x960745: 0x49f, _0x310793: 0x4c0, _0x5576d7: 0x34c }, _0x3e072b = { _0x32464d: 0x2ac, _0x4cb779: 0x4ad, _0x710826: 0x479, _0x39b8ba: 0x2f4, _0xa23ecb: 0x1c2, _0x1d2a98: 0x2b0, _0x5bc3f7: 0x303, _0x2e040b: 0x317, _0x2d0d97: 0x337 }, _0x3471e6 = _0x22e1d3, _0x59b93f = _0x39ab34[_0x3471e6(_0x12e6a8._0x864ecf)]?.[_0x3471e6(0x35b)]; _0x59b93f && this[_0x3471e6(0x4bc)][_0x3471e6(0x45e)](_0x59b93f, '', _0x4cc594 => { const _0x13eb78 = _0x3471e6; this[_0x13eb78(0x340)]['push'](_0x4cc594); const _0x5ea05f = _0x4af504[_0x13eb78(_0x3eaab0._0x582a41)][_0x13eb78(_0x3eaab0._0x5155d3)]('.'), _0x571d2f = _0x5ea05f[0x0], _0x5b5f3d = _0x4cc594[_0x13eb78(_0x3eaab0._0x51a6ac)], _0x575465 = _0x13eb78(_0x3eaab0._0x1b0689) + _0x571d2f + '_' + _0x5b110b; traverseGenerateUUID(_0x5b5f3d, _0x575465), _0x5b5f3d[_0x13eb78(0x31c)] = _0x571d2f, _0x5b5f3d[_0x13eb78(_0x3eaab0._0x50ddf5)]['fileName'] = _0x4af504[_0x13eb78(0x31c)], _0x5b5f3d[_0x13eb78(_0x3eaab0._0x38847b)](_0x3ed782 => { const _0x506f66 = _0x13eb78; if (_0x3ed782[_0x506f66(0x474)]) { _0x3ed782[_0x506f66(_0x3e072b._0x32464d)] = _0x2932ed, _0x3ed782[_0x506f66(_0x3e072b._0x4cb779)] = _0x2932ed, _0x3ed782[_0x506f66(0x2f4)][_0x506f66(_0x3e072b._0x710826)] = this[_0x506f66(_0x3e072b._0x710826)], _0x3ed782[_0x506f66(_0x3e072b._0x39b8ba)] = _0x3ed782[_0x506f66(0x2f4)][_0x506f66(0x2b0)](), _0x3ed782[_0x506f66(_0x3e072b._0xa23ecb)] = MODEL_RENDER_ORDER, _0x3ed782[_0x506f66(_0x3e072b._0x39b8ba)]['envMap'] = this[_0x506f66(0x479)]; const _0x40d81d = new Vector3(); _0x3ed782['geometry'][_0x506f66(0x1cb)][_0x506f66(0x426)](_0x40d81d); const _0x314d06 = _0x40d81d[_0x506f66(_0x3e072b._0x1d2a98)](); recursiveCalParentsMat(_0x3ed782, _0x314d06, new Matrix4()); const _0x3f4a7e = _0x3ed782['geometry'][_0x506f66(0x1cb)][_0x506f66(0x305)]['clone'](); recursiveCalParentsMat(_0x3ed782, _0x3f4a7e, new Matrix4()); const _0x3fd902 = _0x3ed782[_0x506f66(_0x3e072b._0x5bc3f7)][_0x506f66(0x1cb)]['min']['clone'](); recursiveCalParentsMat(_0x3ed782, _0x3fd902, new Matrix4()); const _0x4dbde6 = new Vector3()['subVectors'](_0x314d06, _0x3f4a7e), _0x31bcbd = new Vector3()[_0x506f66(_0x3e072b._0x2e040b)](_0x314d06, _0x3fd902); if (_0x4dbde6[_0x506f66(_0x3e072b._0x2d0d97)]() > _0x38e16b['lengthSq']()) _0x38e16b[_0x506f66(0x371)](_0x4dbde6); if (_0x31bcbd['lengthSq']() > _0x40edc7[_0x506f66(0x337)]()) _0x40edc7['copy'](_0x31bcbd) } }), this[_0x13eb78(_0x3eaab0._0x51a6ac)][_0x13eb78(_0x3eaab0._0x41b7c7)](_0x5b5f3d), this[_0x13eb78(_0x3eaab0._0x16de85)][_0x13eb78(_0x3eaab0._0x8cc019)](_0x5b5f3d), _0x510bbd++, _0x4087ab && _0x4087ab(_0x5b5f3d, this); if (_0x510bbd == _0x23603f) { let _0x1b9ac7 = _0x38e16b['x'] - _0x40edc7['x'], _0x4ae14c = _0x38e16b['z'] - _0x40edc7['z'], _0x329146 = _0x38e16b['y'] - _0x40edc7['y'], _0x3ef4ac = _0x40edc7['x'] + _0x1b9ac7 / 0x2, _0x37ea04 = _0x40edc7['y'] + _0x329146 / 0x2, _0xd900d7 = _0x40edc7['z'] + _0x4ae14c / 0x2, _0x248f84 = Math['sqrt'](Math[_0x13eb78(_0x3eaab0._0x249e5c)](Math[_0x13eb78(0x1e0)](Math[_0x13eb78(_0x3eaab0._0x249e5c)](_0x1b9ac7, 0x2) + Math['pow'](_0x4ae14c, 0x2)), 0x2) + Math['pow'](_0x329146, 0x2)); this['orbitControls']['object'][_0x13eb78(_0x3eaab0._0x448fed)][_0x13eb78(_0x3eaab0._0x960745)](_0x38e16b['x'] + _0x248f84 / 0x2, _0x248f84 * 0x2 / Math[_0x13eb78(_0x3eaab0._0x310793)](Math['PI'] / 0xb4 * 0x2d) + Math['abs'](_0x38e16b['y']), _0x38e16b['z'] + _0x248f84 / 0x2), this['orbitControls']['target'][_0x13eb78(0x49f)](_0x3ef4ac, _0x37ea04, _0xd900d7), this[_0x13eb78(_0x3eaab0._0x5576d7)]['update'](), _0x4f22c1 && _0x4f22c1() } }) } } } } ['exportScenes'] (_0x3f8ac5) { const _0x5b3f3d = { _0x1a1364: 0x2c9, _0x5a2dc0: 0x4dd, _0x2b6dd0: 0x4ab, _0x51060b: 0x4c4, _0x2b98c9: 0x34c, _0x598a9b: 0x34c, _0x598c49: 0x17a, _0x154964: 0x164, _0xb8e21c: 0x2cd, _0x52187e: 0x343, _0xf3cd8a: 0x519, _0x3b7a07: 0x2ce, _0x1170ab: 0x253, _0x50a43c: 0x193, _0x490408: 0x343, _0x102e54: 0x4fe }, _0x3f8f23 = { _0xaa3a67: 0x1da }, _0x157e78 = _0x48e965, _0xbd28aa = this[_0x157e78(0x20f)]; let _0x4eb0dd = Object[_0x157e78(_0x5b3f3d._0x1a1364)]({}, _0xbd28aa); _0x4eb0dd[_0x157e78(0x4ab)][_0x157e78(_0x5b3f3d._0x5a2dc0)] = Object['assign'](_0x4eb0dd[_0x157e78(_0x5b3f3d._0x2b6dd0)][_0x157e78(0x4dd)], { 'position': [this['orbitCamera'][_0x157e78(0x4c4)]['x'], this[_0x157e78(0x4dd)][_0x157e78(_0x5b3f3d._0x51060b)]['y'], this[_0x157e78(0x4dd)][_0x157e78(_0x5b3f3d._0x51060b)]['z']] }), _0x4eb0dd[_0x157e78(0x4e0)]['orbitControls'] = Object[_0x157e78(0x2c9)](_0x4eb0dd[_0x157e78(0x4e0)][_0x157e78(_0x5b3f3d._0x2b98c9)], { 'target': [this[_0x157e78(_0x5b3f3d._0x598a9b)][_0x157e78(0x522)]['x'], this[_0x157e78(0x34c)]['target']['y'], this['orbitControls']['target']['z']] }); const _0x2681b4 = []; this[_0x157e78(_0x5b3f3d._0x598c49)][_0x157e78(_0x5b3f3d._0x154964)](_0x3d208e => { const _0x3daabd = _0x157e78; _0x2681b4[_0x3daabd(_0x3f8f23._0xaa3a67)]('/' + _0x3d208e['userData'][_0x3daabd(0x25d)]) }), _0x4eb0dd = Object[_0x157e78(0x2c9)](_0x4eb0dd, { 'modelUrls': _0x2681b4 }); if (!_0x3f8ac5) _0x3f8ac5 = _0x157e78(0x17f); typeof _0x4eb0dd === _0x157e78(0x25e) && (_0x4eb0dd = JSON[_0x157e78(_0x5b3f3d._0xb8e21c)](_0x4eb0dd, undefined, 0x4)); const _0x1761ae = new Blob([_0x4eb0dd], { 'type': _0x157e78(_0x5b3f3d._0x52187e) }), _0x1ddbcb = document[_0x157e78(0x4fd)](_0x157e78(0x22c)), _0x46641a = document[_0x157e78(_0x5b3f3d._0xf3cd8a)]('a'); _0x46641a['download'] = _0x3f8ac5, _0x46641a[_0x157e78(_0x5b3f3d._0x3b7a07)] = window[_0x157e78(_0x5b3f3d._0x1170ab)]['createObjectURL'](_0x1761ae), _0x46641a['dataset'][_0x157e78(_0x5b3f3d._0x50a43c)] = [_0x157e78(_0x5b3f3d._0x490408), _0x46641a[_0x157e78(_0x5b3f3d._0x102e54)], _0x46641a[_0x157e78(0x2ce)]][_0x157e78(0x41f)](':'), _0x1ddbcb['initMouseEvent']('click', !![], ![], window, 0x0, 0x0, 0x0, 0x0, 0x0, ![], ![], ![], ![], 0x0, null), _0x46641a['dispatchEvent'](_0x1ddbcb) } [_0x48e965(0x548)] ({ data: _0x1170d2, onProgress: _0xc163be, onLoad: _0x29d054 }) { const _0x496abd = { _0x4a960c: 0x4cc, _0x42230b: 0x323, _0x42e2e0: 0x4ab, _0x41d8f8: 0x51f, _0x7ee58f: 0x2f0 }, _0x4c6df1 = _0x48e965; this['updateScenes'](_0x1170d2), this[_0x4c6df1(_0x496abd._0x4a960c)](_0x1170d2[_0x4c6df1(0x3ea)]), this[_0x4c6df1(_0x496abd._0x42230b)](_0x1170d2[_0x4c6df1(_0x496abd._0x42e2e0)]), this[_0x4c6df1(0x20a)](_0x1170d2), this[_0x4c6df1(0x3a4)]({ 'modelUrls': _0x1170d2[_0x4c6df1(0x51f)] ? _0x1170d2[_0x4c6df1(_0x496abd._0x41d8f8)] : [], 'onProgress': _0xc163be, 'onLoad': _0x29d054, 'nodes': _0x1170d2[_0x4c6df1(_0x496abd._0x7ee58f)] }) } ['loadModelByUrls'] ({ nodes: _0x21fa2a, modelUrls: _0x509bcc, onProgress: _0x41b930, onLoad: _0x2c5de9 }) { const _0x2749f8 = { _0x32b212: 0x20f, _0x5038b7: 0x308, _0x3bf4b6: 0x164 }, _0xd6fe5e = { _0x4dc48d: 0x29b, _0x2bc1e9: 0x321, _0x76173a: 0x4ce, _0x553852: 0x48e }, _0x3681b3 = { _0x41d895: 0x157, _0x4233f2: 0x31c, _0x42add2: 0x44d, _0x1ccff5: 0x17a }, _0x37404f = _0x48e965; if (!_0x509bcc || !(_0x509bcc instanceof Array) || _0x509bcc['length'] == 0x0) { _0x2c5de9 && _0x2c5de9(this); return } const _0x5a45a4 = this[_0x37404f(_0x2749f8._0x32b212)]?.[_0x37404f(_0x2749f8._0x5038b7)], _0x19250c = []; _0x509bcc[_0x37404f(0x164)](_0x353437 => { const _0x4d8160 = _0x37404f; _0x19250c[_0x4d8160(0x1da)](this['publicPath'] + _0x353437) }); const _0x3a7416 = _0x19250c[_0x37404f(0x321)]; let _0x76139 = 0x0; _0x19250c[_0x37404f(_0x2749f8._0x3bf4b6)]((_0x2db354, _0x4b0ae0) => { const _0x35ee63 = { _0x16685d: 0x39d, _0x20e0a6: 0x1f0, _0x21254e: 0x399, _0x54d683: 0x399, _0x460cd0: 0x4c4, _0x2bdefb: 0x49f, _0x3b045f: 0x2be, _0x4f4ce7: 0x399, _0x1b5d95: 0x4c4, _0xfb1404: 0x49f, _0x4793c8: 0x2ac, _0x4da329: 0x438, _0x375e35: 0x2f4, _0x2bca6e: 0x209, _0x254abd: 0x49f, _0x309b44: 0x532, _0x548302: 0x236, _0xb81b5: 0x4ae, _0x283e5a: 0x2f4, _0x174c96: 0x3cb, _0x33c701: 0x429, _0x67f7f9: 0x474, _0x338e23: 0x29e, _0x10d806: 0x1da }, _0xfcca25 = { _0x4e52ed: 0x40f, _0x1c5c41: 0x321, _0x1c157c: 0x460, _0x4e7785: 0x31c, _0x4e99b5: 0x31c, _0x566d16: 0x37e, _0x19b8f2: 0x373, _0x1b714c: 0x31c, _0x5d14e8: 0x40e, _0x2e0796: 0x1da, _0x1a04ae: 0x260, _0x32bf21: 0x379, _0x249a03: 0x1da }, _0x29b2a6 = _0x37404f, _0x2c0573 = _0x2db354['split']('/'), _0x25ad24 = _0x2c0573[_0x2c0573[_0x29b2a6(0x321)] - 0x1], _0x172151 = _0x25ad24['lastIndexOf']('/'), _0x57535b = _0x25ad24[_0x29b2a6(0x413)]('.'), _0x552ea4 = _0x25ad24[_0x29b2a6(_0xd6fe5e._0x4dc48d)](_0x172151 + 0x1, _0x57535b), _0x403480 = _0x25ad24['substring'](_0x57535b + 0x1, _0x25ad24[_0x29b2a6(_0xd6fe5e._0x2bc1e9)]); if ([_0x29b2a6(_0xd6fe5e._0x76173a), 'gltf']['includes'](_0x403480[_0x29b2a6(_0xd6fe5e._0x553852)]())) this['gltfLoader'][_0x29b2a6(0x32e)](_0x2db354, _0x47ff95 => { const _0x5c95d5 = { _0x433117: 0x1f0, _0x763782: 0x1d8, _0x3f7a91: 0x4c4, _0xafe825: 0x49f, _0x53762d: 0x2be, _0x551d7b: 0x1f0, _0x159344: 0x399, _0x25c25e: 0x4b6, _0x286048: 0x49f, _0x7d7a37: 0x438, _0x39bb1a: 0x2f4, _0x9a9847: 0x209, _0x48ba3c: 0x49f, _0x5c5a1f: 0x2f4, _0x55aafe: 0x511, _0x34cd7e: 0x2f4, _0x23ea3c: 0x263, _0x9f64ce: 0x2f4, _0x58dc39: 0x2f4, _0x3b300b: 0x451, _0x482ab5: 0x479, _0x112824: 0x1c2, _0xa59e02: 0x328, _0x1c8ab9: 0x1da }, _0x1e80f3 = _0x29b2a6, _0xfee1f9 = _0x47ff95[_0x1e80f3(0x47e)][_0x1e80f3(_0xfcca25._0x4e52ed)][_0x1e80f3(0x254)], _0x4d786d = {}; for (let _0x41c868 = 0x0; _0x41c868 < _0xfee1f9[_0x1e80f3(_0xfcca25._0x1c5c41)]; _0x41c868++) { if (!_0xfee1f9[_0x41c868][_0x1e80f3(0x31c)]) throw new Error(_0x1e80f3(_0xfcca25._0x1c157c)); !_0x4d786d[_0xfee1f9[_0x41c868][_0x1e80f3(_0xfcca25._0x4e7785)]] ? _0x4d786d[_0xfee1f9[_0x41c868][_0x1e80f3(0x31c)]] = 0x1 : _0x4d786d[_0xfee1f9[_0x41c868]['name']]++; if (_0x4d786d[_0xfee1f9[_0x41c868][_0x1e80f3(_0xfcca25._0x4e99b5)]] > 0x1) throw new Error(_0x1e80f3(0x2f6)) } const _0x5cc451 = _0x47ff95[_0x1e80f3(_0xfcca25._0x566d16)]; if (_0x47ff95[_0x1e80f3(_0xfcca25._0x19b8f2)]['length'] != 0x0) for (var _0x420855 = 0x0; _0x420855 < _0x47ff95[_0x1e80f3(_0xfcca25._0x19b8f2)][_0x1e80f3(0x321)]; _0x420855++) { const _0x3c4883 = new AnimationMixer(_0x5cc451); _0x3c4883['name'] = _0x47ff95[_0x1e80f3(0x373)][_0x420855][_0x1e80f3(_0xfcca25._0x1b714c)], this[_0x1e80f3(_0xfcca25._0x5d14e8)][_0x1e80f3(_0xfcca25._0x2e0796)](_0x3c4883); const _0x514b5d = _0x3c4883[_0x1e80f3(0x2f2)](_0x47ff95['animations'][_0x420855])[_0x1e80f3(_0xfcca25._0x1a04ae)](); _0x514b5d[_0x1e80f3(_0xfcca25._0x32bf21)] = !![], _0x3c4883['actions'] = _0x514b5d, this[_0x1e80f3(0x31d)][_0x1e80f3(_0xfcca25._0x2e0796)](_0x514b5d) } const _0x2291d2 = _0x1e80f3(0x157) + _0x552ea4 + '_' + _0x4b0ae0; traverseGenerateUUID(_0x5cc451, _0x2291d2), _0x5cc451[_0x1e80f3(0x31c)] = _0x552ea4, _0x5cc451[_0x1e80f3(0x15f)][_0x1e80f3(0x1d4)] = _0x2db354, _0x5cc451['traverse'](_0x39967a => { const _0x38f3a7 = _0x1e80f3, _0x4a682b = []; traverseSelectNodeByUUID(_0x21fa2a[_0x2291d2], _0x39967a[_0x38f3a7(0x39d)], _0x4a682b); if (_0x4a682b[_0x38f3a7(0x321)] > 0x0) { const _0x4c3768 = _0x4a682b[0x0]; if (_0x4c3768[_0x38f3a7(0x1f0)] == 'Group' || _0x4c3768[_0x38f3a7(_0x5c95d5._0x433117)] == _0x38f3a7(_0x5c95d5._0x763782)) { _0x39967a['visible'] = _0x4c3768['visible']; const { position: _0x517954, scale: _0x864bf4, rotation: _0x2ec03e } = _0x4c3768[_0x38f3a7(0x4b6)]; _0x39967a[_0x38f3a7(_0x5c95d5._0x3f7a91)][_0x38f3a7(0x49f)](_0x517954[0x0], _0x517954[0x1], _0x517954[0x2]), _0x39967a[_0x38f3a7(0x3bf)][_0x38f3a7(_0x5c95d5._0xafe825)](degToRad(_0x2ec03e[0x0]), degToRad(_0x2ec03e[0x1]), degToRad(_0x2ec03e[0x2])), _0x39967a[_0x38f3a7(_0x5c95d5._0x53762d)][_0x38f3a7(0x49f)](_0x864bf4[0x0], _0x864bf4[0x1], _0x864bf4[0x2]) } else { if (_0x4c3768[_0x38f3a7(_0x5c95d5._0x551d7b)] == _0x38f3a7(0x4f1)) { _0x39967a[_0x38f3a7(_0x5c95d5._0x159344)] = _0x4c3768[_0x38f3a7(0x399)]; const { position: _0x353836, scale: _0x2022b7, rotation: _0x2385d5, castShadow: _0x57ff7e, receiveShadow: _0x15c2de } = _0x4c3768[_0x38f3a7(_0x5c95d5._0x25c25e)]; _0x39967a[_0x38f3a7(_0x5c95d5._0x3f7a91)][_0x38f3a7(0x49f)](_0x353836[0x0], _0x353836[0x1], _0x353836[0x2]), _0x39967a[_0x38f3a7(0x3bf)][_0x38f3a7(_0x5c95d5._0x286048)](degToRad(_0x2385d5[0x0]), degToRad(_0x2385d5[0x1]), degToRad(_0x2385d5[0x2])), _0x39967a[_0x38f3a7(0x2be)][_0x38f3a7(0x49f)](_0x2022b7[0x0], _0x2022b7[0x1], _0x2022b7[0x2]), _0x39967a[_0x38f3a7(0x2ac)] = _0x5a45a4 ? _0x5a45a4 : _0x57ff7e, _0x39967a['receiveShadow'] = _0x5a45a4 ? _0x5a45a4 : _0x15c2de; if (_0x4c3768[_0x38f3a7(_0x5c95d5._0x7d7a37)]) { const { color: _0x3c50a9, depthTest: _0x4a0ccd, depthWrite: _0x35f81a, opacity: _0x596ecf, transparent: _0x18fb00, wireframe: _0x55c3d8, type: _0x276194 } = _0x4c3768[_0x38f3a7(0x438)]; _0x39967a[_0x38f3a7(_0x5c95d5._0x39bb1a)][_0x38f3a7(_0x5c95d5._0x9a9847)][_0x38f3a7(_0x5c95d5._0x48ba3c)](_0x3c50a9), _0x39967a[_0x38f3a7(_0x5c95d5._0x5c5a1f)][_0x38f3a7(0x532)] = _0x4a0ccd, _0x39967a[_0x38f3a7(0x2f4)][_0x38f3a7(_0x5c95d5._0x55aafe)] = _0x35f81a, _0x39967a[_0x38f3a7(_0x5c95d5._0x39bb1a)][_0x38f3a7(0x236)] = _0x596ecf, _0x39967a[_0x38f3a7(_0x5c95d5._0x34cd7e)][_0x38f3a7(_0x5c95d5._0x23ea3c)] = _0x18fb00, _0x39967a[_0x38f3a7(_0x5c95d5._0x9f64ce)][_0x38f3a7(0x4ae)] = _0x55c3d8; if (_0x276194 == 'MeshStandardMaterial' && _0x4c3768['matOptions']['extends']) { const { roughness: _0x72cf40, metalness: _0x129fb4, envMapIntensity: _0x29bca4, lightMapIntensity: _0x2290e1, emissive: _0x1c1db0, emissiveIntensity: _0xe12f9a } = _0x4c3768['matOptions']['extends']; _0x39967a[_0x38f3a7(_0x5c95d5._0x58dc39)][_0x38f3a7(0x206)] = _0x72cf40, _0x39967a[_0x38f3a7(0x2f4)][_0x38f3a7(0x338)] = _0x129fb4, _0x39967a['material']['envMapIntensity'] = _0x29bca4, _0x39967a[_0x38f3a7(_0x5c95d5._0x5c5a1f)]['lightMapIntensity'] = _0x2290e1, _0x39967a[_0x38f3a7(_0x5c95d5._0x5c5a1f)][_0x38f3a7(_0x5c95d5._0x3b300b)] = _0xe12f9a, _0x39967a[_0x38f3a7(0x2f4)]['emissive'][_0x38f3a7(0x49f)](_0x1c1db0) } } } } } _0x39967a['isMesh'] && (_0x39967a['material'][_0x38f3a7(0x479)] = this[_0x38f3a7(_0x5c95d5._0x482ab5)], _0x39967a['material'] = _0x39967a['material'][_0x38f3a7(0x2b0)](), _0x39967a[_0x38f3a7(_0x5c95d5._0x112824)] = MODEL_RENDER_ORDER, this[_0x38f3a7(_0x5c95d5._0xa59e02)][_0x38f3a7(_0x5c95d5._0x1c8ab9)](_0x39967a), this[_0x38f3a7(0x29e)][_0x38f3a7(0x1da)](_0x39967a)) }), this[_0x1e80f3(0x37e)][_0x1e80f3(0x44d)](_0x5cc451), this['sceneModels'][_0x1e80f3(_0xfcca25._0x249a03)](_0x5cc451), this[_0x1e80f3(0x3d9)][_0x552ea4] = _0x47ff95[_0x1e80f3(_0xfcca25._0x19b8f2)], _0x76139++, _0x41b930 && _0x41b930(_0x5cc451, this); if (_0x76139 == _0x3a7416) _0x2c5de9 && _0x2c5de9(this) }, _0x5d927b => { }, _0x5187cc => { console['error'](_0x5187cc) }); else { if ([_0x29b2a6(0x1dc)]['includes'](_0x403480['toLowerCase']())) this[_0x29b2a6(0x30c)][_0x29b2a6(0x32e)](_0x2db354, _0x37f585 => { const _0x218cfb = _0x29b2a6, _0x5cb340 = _0x37f585, _0x150e20 = _0x218cfb(_0x3681b3._0x41d895) + _0x552ea4 + '_' + _0x4b0ae0; traverseGenerateUUID(_0x5cb340, _0x150e20), _0x5cb340[_0x218cfb(_0x3681b3._0x4233f2)] = _0x552ea4, _0x5cb340[_0x218cfb(0x4a5)](_0x56a552 => { const _0x3b72d4 = _0x218cfb, _0x3eab9b = []; traverseSelectNodeByUUID(_0x21fa2a[_0x150e20], _0x56a552[_0x3b72d4(_0x35ee63._0x16685d)], _0x3eab9b); if (_0x3eab9b['length'] > 0x0) { const _0x1347a8 = _0x3eab9b[0x0]; if (_0x1347a8['type'] == 'Group' || _0x1347a8[_0x3b72d4(_0x35ee63._0x20e0a6)] == 'Object3D') { _0x56a552[_0x3b72d4(_0x35ee63._0x21254e)] = _0x1347a8[_0x3b72d4(_0x35ee63._0x54d683)]; const { position: _0x1a2105, scale: _0x4e7b26, rotation: _0x23d45c } = _0x1347a8[_0x3b72d4(0x4b6)]; _0x56a552[_0x3b72d4(_0x35ee63._0x460cd0)][_0x3b72d4(_0x35ee63._0x2bdefb)](_0x1a2105[0x0], _0x1a2105[0x1], _0x1a2105[0x2]), _0x56a552[_0x3b72d4(0x3bf)]['set'](degToRad(_0x23d45c[0x0]), degToRad(_0x23d45c[0x1]), degToRad(_0x23d45c[0x2])), _0x56a552[_0x3b72d4(_0x35ee63._0x3b045f)]['set'](_0x4e7b26[0x0], _0x4e7b26[0x1], _0x4e7b26[0x2]) } else { if (_0x1347a8[_0x3b72d4(0x1f0)] == _0x3b72d4(0x4f1)) { _0x56a552[_0x3b72d4(_0x35ee63._0x4f4ce7)] = _0x1347a8['visible']; const { position: _0x3e4688, scale: _0x2fed24, rotation: _0x27aef1, castShadow: _0x427bfa, receiveShadow: _0x69ace3 } = _0x1347a8[_0x3b72d4(0x4b6)]; _0x56a552[_0x3b72d4(_0x35ee63._0x1b5d95)][_0x3b72d4(_0x35ee63._0x2bdefb)](_0x3e4688[0x0], _0x3e4688[0x1], _0x3e4688[0x2]), _0x56a552[_0x3b72d4(0x3bf)][_0x3b72d4(0x49f)](degToRad(_0x27aef1[0x0]), degToRad(_0x27aef1[0x1]), degToRad(_0x27aef1[0x2])), _0x56a552[_0x3b72d4(0x2be)][_0x3b72d4(_0x35ee63._0xfb1404)](_0x2fed24[0x0], _0x2fed24[0x1], _0x2fed24[0x2]), _0x56a552[_0x3b72d4(_0x35ee63._0x4793c8)] = _0x5a45a4 ? _0x5a45a4 : _0x427bfa, _0x56a552[_0x3b72d4(0x4ad)] = _0x5a45a4 ? _0x5a45a4 : _0x69ace3; if (_0x1347a8['matOptions']) { const { color: _0x471195, depthTest: _0x3df1c9, depthWrite: _0x2cf34e, opacity: _0x294a6d, transparent: _0x3c3721, wireframe: _0x17260f, type: _0x4e4718 } = _0x1347a8[_0x3b72d4(_0x35ee63._0x4da329)]; _0x56a552[_0x3b72d4(_0x35ee63._0x375e35)][_0x3b72d4(_0x35ee63._0x2bca6e)][_0x3b72d4(_0x35ee63._0x254abd)](_0x471195), _0x56a552[_0x3b72d4(0x2f4)][_0x3b72d4(_0x35ee63._0x309b44)] = _0x3df1c9, _0x56a552['material'][_0x3b72d4(0x511)] = _0x2cf34e, _0x56a552[_0x3b72d4(_0x35ee63._0x375e35)][_0x3b72d4(_0x35ee63._0x548302)] = _0x294a6d, _0x56a552['material'][_0x3b72d4(0x263)] = _0x3c3721, _0x56a552['material'][_0x3b72d4(_0x35ee63._0xb81b5)] = _0x17260f; if (_0x1347a8[_0x3b72d4(0x438)]['extends']) { const { roughness: _0x19511a, metalness: _0x2d75a9, envMapIntensity: _0x3e5b7f, lightMapIntensity: _0xed0271, emissive: _0x1fa630, emissiveIntensity: _0x4e1541 } = _0x1347a8[_0x3b72d4(_0x35ee63._0x4da329)]['extends']; _0x56a552[_0x3b72d4(_0x35ee63._0x283e5a)]['roughness'] = _0x19511a, _0x56a552[_0x3b72d4(0x2f4)]['metalness'] = _0x2d75a9, _0x56a552['material'][_0x3b72d4(_0x35ee63._0x174c96)] = _0x3e5b7f, _0x56a552['material']['lightMapIntensity'] = _0xed0271, _0x56a552[_0x3b72d4(_0x35ee63._0x283e5a)][_0x3b72d4(0x451)] = _0x4e1541, _0x56a552[_0x3b72d4(_0x35ee63._0x283e5a)][_0x3b72d4(_0x35ee63._0x33c701)]['set'](_0x1fa630) } } } } } _0x56a552[_0x3b72d4(_0x35ee63._0x67f7f9)] && (_0x56a552[_0x3b72d4(0x1c2)] = MODEL_RENDER_ORDER, this[_0x3b72d4(0x328)]['push'](_0x56a552), this[_0x3b72d4(_0x35ee63._0x338e23)][_0x3b72d4(_0x35ee63._0x10d806)](_0x56a552)) }), this[_0x218cfb(0x37e)][_0x218cfb(_0x3681b3._0x42add2)](_0x5cb340), this[_0x218cfb(_0x3681b3._0x1ccff5)][_0x218cfb(0x1da)](_0x5cb340), _0x76139++, _0x41b930 && _0x41b930(_0x5cb340, this); if (_0x76139 == _0x3a7416) _0x2c5de9 && _0x2c5de9(this) }); else throw new Error(_0x403480 + '\x20is\x20not\x20supported.') } }) } [_0x48e965(0x323)] (_0x5c8fb9) { const _0x1dda19 = { _0x4fdb14: 0x4dd, _0x9c569f: 0x4dd, _0x107c7e: 0x34c, _0x513e21: 0x34c, _0x18c87b: 0x4dd, _0x23f19b: 0x150, _0x4041dc: 0x34c, _0x4c9af2: 0x150, _0x525182: 0x448, _0x3f76fb: 0x34c, _0x2f2efe: 0x448, _0x34d279: 0x4c4 }, _0x5b2fbb = _0x48e965; if (!_0x5c8fb9) return; if (_0x5c8fb9[_0x5b2fbb(_0x1dda19._0x4fdb14)]) { if (_0x5c8fb9[_0x5b2fbb(0x4dd)][_0x5b2fbb(0x177)] !== undefined) this[_0x5b2fbb(0x4dd)][_0x5b2fbb(0x177)] = 0.1; if (_0x5c8fb9[_0x5b2fbb(0x4dd)][_0x5b2fbb(0x21b)] !== undefined) this[_0x5b2fbb(0x4dd)]['far'] = _0x5c8fb9['orbitCamera']['far']; if (_0x5c8fb9[_0x5b2fbb(0x4dd)][_0x5b2fbb(0x458)] !== undefined) this[_0x5b2fbb(0x4dd)]['fov'] = _0x5c8fb9[_0x5b2fbb(_0x1dda19._0x4fdb14)][_0x5b2fbb(0x458)]; if (_0x5c8fb9[_0x5b2fbb(_0x1dda19._0x9c569f)]['aspect'] !== undefined) this[_0x5b2fbb(_0x1dda19._0x9c569f)]['aspect'] = _0x5c8fb9[_0x5b2fbb(0x4dd)][_0x5b2fbb(0x1b7)]; if (_0x5c8fb9[_0x5b2fbb(0x4dd)][_0x5b2fbb(0x442)] !== undefined) this[_0x5b2fbb(_0x1dda19._0x107c7e)]['maxDistance'] = _0x5c8fb9[_0x5b2fbb(_0x1dda19._0x4fdb14)]['maxDistance']; if (_0x5c8fb9[_0x5b2fbb(0x4dd)][_0x5b2fbb(0x40c)] !== undefined) this[_0x5b2fbb(_0x1dda19._0x513e21)]['minDistance'] = _0x5c8fb9[_0x5b2fbb(_0x1dda19._0x18c87b)]['minDistance']; if (_0x5c8fb9['orbitCamera'][_0x5b2fbb(_0x1dda19._0x23f19b)] !== undefined) this[_0x5b2fbb(_0x1dda19._0x4041dc)][_0x5b2fbb(0x150)] = _0x5c8fb9['orbitCamera'][_0x5b2fbb(_0x1dda19._0x4c9af2)]; if (_0x5c8fb9[_0x5b2fbb(0x4dd)][_0x5b2fbb(_0x1dda19._0x525182)] !== undefined) this[_0x5b2fbb(_0x1dda19._0x3f76fb)][_0x5b2fbb(_0x1dda19._0x2f2efe)] = _0x5c8fb9[_0x5b2fbb(_0x1dda19._0x9c569f)][_0x5b2fbb(0x448)]; if (_0x5c8fb9[_0x5b2fbb(0x4dd)]['position'] !== undefined) this[_0x5b2fbb(0x4dd)]['position']['set'](_0x5c8fb9['orbitCamera'][_0x5b2fbb(0x4c4)][0x0], _0x5c8fb9[_0x5b2fbb(_0x1dda19._0x9c569f)][_0x5b2fbb(0x4c4)][0x1], _0x5c8fb9[_0x5b2fbb(0x4dd)][_0x5b2fbb(_0x1dda19._0x34d279)][0x2]) } if (!_0x5c8fb9['firstPersonCamera']) return } [_0x48e965(0x4cc)] (_0x2397d3) { const _0x52937b = { _0x26b2f4: 0x1c9, _0x123148: 0x2d9, _0x2c8bdb: 0x4ac, _0x1e145b: 0x2b8, _0x485128: 0x49f, _0x1675ae: 0x4c4, _0x2e582d: 0x4c4, _0x4949f1: 0x2b9, _0x3b4d78: 0x314 }, _0x385efd = _0x48e965; if (!_0x2397d3) return; if (_0x2397d3[_0x385efd(_0x52937b._0x26b2f4)]) { let _0x2ce4f8 = { 'skyColor': 0xffffff, 'groundColor': 0xaaaaaa, 'intensity': 0.1, 'position': [0x0, 0x1f4, 0x0] }; _0x2ce4f8 = Object[_0x385efd(0x2c9)](_0x2ce4f8, _0x2397d3[_0x385efd(0x1c9)]), !this[_0x385efd(0x2d9)] ? (this[_0x385efd(_0x52937b._0x123148)] = new HemisphereLight(_0x2ce4f8[_0x385efd(_0x52937b._0x2c8bdb)], _0x2ce4f8[_0x385efd(_0x52937b._0x1e145b)], _0x2ce4f8['intensity']), this[_0x385efd(0x2d9)][_0x385efd(0x4c4)][_0x385efd(_0x52937b._0x485128)](_0x2ce4f8['position'][0x0], _0x2ce4f8[_0x385efd(0x4c4)][0x1], _0x2ce4f8[_0x385efd(0x4c4)][0x2]), this[_0x385efd(0x37e)][_0x385efd(0x44d)](this[_0x385efd(0x2d9)])) : (this['hemiLight']['color'][_0x385efd(_0x52937b._0x485128)](_0x2ce4f8['skyColor']), this['hemiLight']['groundColor'][_0x385efd(0x49f)](_0x2ce4f8['groundColor']), this[_0x385efd(0x2d9)]['intensity'] = _0x2ce4f8[_0x385efd(0x314)], this[_0x385efd(0x2d9)][_0x385efd(0x4c4)][_0x385efd(_0x52937b._0x485128)](_0x2ce4f8[_0x385efd(_0x52937b._0x1675ae)][0x0], _0x2ce4f8[_0x385efd(_0x52937b._0x1675ae)][0x1], _0x2ce4f8[_0x385efd(_0x52937b._0x2e582d)][0x2])) } if (_0x2397d3[_0x385efd(0x2b9)]) { let _0x5492bc = { 'intensity': 0x1, 'color': 0xffffff }; _0x5492bc = Object[_0x385efd(0x2c9)](_0x5492bc, _0x2397d3['ambientLight']), !this[_0x385efd(0x2b9)] ? (this[_0x385efd(_0x52937b._0x4949f1)] = new AmbientLight(_0x5492bc['color'], _0x5492bc['intensity']), this[_0x385efd(0x37e)]['add'](this[_0x385efd(_0x52937b._0x4949f1)])) : (this[_0x385efd(0x2b9)][_0x385efd(0x209)][_0x385efd(0x49f)](_0x5492bc[_0x385efd(0x209)]), this['ambientLight'][_0x385efd(0x314)] = _0x5492bc[_0x385efd(_0x52937b._0x3b4d78)]) } } ['updatePasses'] (_0x581ac1) { const _0x10e5ea = { _0x40eda1: 0x24c, _0x32f5b8: 0x38d, _0x9bd3c4: 0x53c, _0x242ba8: 0x208, _0x5f0787: 0x52d }, _0x52239c = _0x48e965; if (!_0x581ac1) return; if (_0x581ac1[_0x52239c(_0x10e5ea._0x40eda1)]) this[_0x52239c(_0x10e5ea._0x32f5b8)](_0x581ac1[_0x52239c(0x24c)]); if (_0x581ac1[_0x52239c(0x2a5)]) this[_0x52239c(_0x10e5ea._0x9bd3c4)](_0x581ac1[_0x52239c(0x2a5)]); if (_0x581ac1['msaa']) this['updateMSAAPass'](_0x581ac1['msaa']); if (_0x581ac1[_0x52239c(0x4d2)]) this[_0x52239c(_0x10e5ea._0x242ba8)](_0x581ac1[_0x52239c(0x4d2)]); if (_0x581ac1['dof']) this[_0x52239c(0x1a2)](_0x581ac1[_0x52239c(_0x10e5ea._0x5f0787)]) } ['updateBloomPass'] (_0x3e1270) { const _0x35dd18 = { _0xd7fb12: 0x2b1, _0x447a85: 0x26b, _0x318024: 0x2f4, _0x594caf: 0x234, _0x51973e: 0x1d2, _0x10c8d9: 0x1ba, _0x3bb57d: 0x271, _0x4881a4: 0x41a, _0x188557: 0x407, _0x4ffe55: 0x407 }, _0x8cfa40 = _0x48e965; if (!_0x3e1270) return; this[_0x8cfa40(0x271)][_0x8cfa40(_0x35dd18._0xd7fb12)] = _0x3e1270[_0x8cfa40(0x2b1)], this[_0x8cfa40(_0x35dd18._0x447a85)][_0x8cfa40(_0x35dd18._0x318024)][_0x8cfa40(_0x35dd18._0x594caf)]['bloomTexture']['value'] = _0x3e1270[_0x8cfa40(_0x35dd18._0xd7fb12)] ? this['bloomComposer'][_0x8cfa40(_0x35dd18._0x51973e)][_0x8cfa40(_0x35dd18._0x10c8d9)] : null; if (_0x3e1270[_0x8cfa40(0x335)] !== undefined) this[_0x8cfa40(_0x35dd18._0x3bb57d)]['strength'] = _0x3e1270['bloomStrength']; if (_0x3e1270[_0x8cfa40(0x41a)] !== undefined) this[_0x8cfa40(0x271)][_0x8cfa40(0x3da)] = _0x3e1270[_0x8cfa40(_0x35dd18._0x4881a4)]; if (_0x3e1270[_0x8cfa40(_0x35dd18._0x188557)] !== undefined) this[_0x8cfa40(0x271)][_0x8cfa40(_0x35dd18._0x4ffe55)] = _0x3e1270['threshold'] } [_0x48e965(0x53c)] (_0x4bdf4a) { const _0x1b2e90 = { _0x12f4c4: 0x158, _0x57bf8b: 0x4f2, _0xfcbeb8: 0x4f2, _0x1aa9c7: 0x1fb, _0xf8f318: 0x1fb, _0x2b8ec0: 0x3e0, _0x382ef8: 0x158, _0x205fd2: 0x49f }, _0x34de83 = _0x48e965; if (!_0x4bdf4a) return; this[_0x34de83(_0x1b2e90._0x12f4c4)][_0x34de83(0x2b1)] = _0x4bdf4a[_0x34de83(0x2b1)]; if (_0x4bdf4a['edgeStrength'] !== undefined) this[_0x34de83(_0x1b2e90._0x12f4c4)][_0x34de83(0x23f)] = _0x4bdf4a[_0x34de83(0x23f)]; if (_0x4bdf4a[_0x34de83(_0x1b2e90._0x57bf8b)] !== undefined) this['outlinePass']['edgeGlow'] = _0x4bdf4a[_0x34de83(_0x1b2e90._0xfcbeb8)]; if (_0x4bdf4a[_0x34de83(_0x1b2e90._0x1aa9c7)] !== undefined) this[_0x34de83(0x158)][_0x34de83(_0x1b2e90._0xf8f318)] = _0x4bdf4a[_0x34de83(_0x1b2e90._0x1aa9c7)]; if (_0x4bdf4a[_0x34de83(_0x1b2e90._0x2b8ec0)] !== undefined) this['outlinePass'][_0x34de83(_0x1b2e90._0x2b8ec0)] = _0x4bdf4a['pulsePeriod']; if (_0x4bdf4a['visibleEdgeColor'] !== undefined) this[_0x34de83(_0x1b2e90._0x382ef8)][_0x34de83(0x285)]['set'](_0x4bdf4a[_0x34de83(0x285)]); if (_0x4bdf4a['hiddenEdgeColor'] !== undefined) this['outlinePass']['hiddenEdgeColor'][_0x34de83(_0x1b2e90._0x205fd2)](_0x4bdf4a['hiddenEdgeColor']) } ['updateMSAAPass'] (_0x41f8b0) { const _0x2bc298 = { _0x16cf42: 0x362, _0x45bf4b: 0x482, _0x35aee2: 0x2f8, _0xbe082: 0x549, _0x58b205: 0x2f8 }, _0x5459a2 = _0x48e965; if (!_0x41f8b0) return; if (_0x41f8b0[_0x5459a2(_0x2bc298._0x16cf42)] !== undefined) { const _0x3ffe8b = this[_0x5459a2(_0x2bc298._0x45bf4b)] * 0x2, _0x12b6a1 = this[_0x5459a2(0x191)] * 0x2; this['msaaTarget'][_0x5459a2(_0x2bc298._0x35aee2)](_0x3ffe8b, _0x12b6a1), this[_0x5459a2(_0x2bc298._0xbe082)][_0x5459a2(0x2f8)](_0x3ffe8b, _0x12b6a1), this[_0x5459a2(0x3e9)]['setSize'](_0x3ffe8b, _0x12b6a1), this[_0x5459a2(0x271)][_0x5459a2(_0x2bc298._0x35aee2)](_0x3ffe8b, _0x12b6a1), this['finalbloomPass'][_0x5459a2(0x2f8)](_0x3ffe8b, _0x12b6a1), this[_0x5459a2(0x427)][_0x5459a2(_0x2bc298._0x58b205)](_0x3ffe8b, _0x12b6a1) } } [_0x48e965(0x208)] (_0xb63e99) { const _0x4d4f91 = { _0x52fe2f: 0x2b1, _0x4febc9: 0x467, _0x1aab85: 0x2f4 }, _0x3cb799 = _0x48e965; if (!_0xb63e99) return; this[_0x3cb799(0x467)][_0x3cb799(_0x4d4f91._0x52fe2f)] = _0xb63e99[_0x3cb799(0x2b1)], _0xb63e99['factor'] !== undefined && (this[_0x3cb799(_0x4d4f91._0x4febc9)][_0x3cb799(_0x4d4f91._0x1aab85)][_0x3cb799(0x234)]['factor'][_0x3cb799(0x27b)] = _0xb63e99[_0x3cb799(0x250)], this[_0x3cb799(_0x4d4f91._0x4febc9)]['material'][_0x3cb799(0x4f8)] = !![]) } [_0x48e965(0x1a2)] (_0x57ef57) { const _0x2fa257 = { _0x1bfff6: 0x2b1, _0x3dc366: 0x2b1, _0xaa500d: 0x3ff, _0x19b486: 0x234, _0x209027: 0x27b }, _0x3fb03f = _0x48e965; if (!_0x57ef57) return; this['bokehPass'][_0x3fb03f(_0x2fa257._0x1bfff6)] = _0x57ef57[_0x3fb03f(_0x2fa257._0x3dc366)]; if (_0x57ef57[_0x3fb03f(0x3ff)] !== undefined) this['bokehPass'][_0x3fb03f(0x234)][_0x3fb03f(_0x2fa257._0xaa500d)][_0x3fb03f(0x27b)] = _0x57ef57[_0x3fb03f(_0x2fa257._0xaa500d)]; if (_0x57ef57['maxblur'] !== undefined) this['bokehPass'][_0x3fb03f(_0x2fa257._0x19b486)][_0x3fb03f(0x2e8)][_0x3fb03f(0x27b)] = _0x57ef57[_0x3fb03f(0x2e8)]; if (_0x57ef57[_0x3fb03f(0x53a)] !== undefined) this[_0x3fb03f(0x2b2)][_0x3fb03f(0x234)]['focus'][_0x3fb03f(_0x2fa257._0x209027)] = _0x57ef57[_0x3fb03f(0x53a)] } [_0x48e965(0x45a)] (_0x1d47f8) { const _0x347119 = { _0x17eb14: 0x237, _0x359b31: 0x478 }, _0x5aed08 = _0x48e965; if (!_0x1d47f8) return; if (_0x1d47f8[_0x5aed08(0x237)]) this['updateBackground'](_0x1d47f8[_0x5aed08(_0x347119._0x17eb14)]); if (_0x1d47f8['hdrUrls']) this['updateHDR'](_0x1d47f8[_0x5aed08(_0x347119._0x359b31)]) } [_0x48e965(0x485)] (_0x3a7f43) { const _0x2ad0ff = { _0x10f69e: 0x209, _0x34c1aa: 0x4cf, _0x4dca76: 0x37e, _0x43c010: 0x237, _0x3f60e4: 0x459, _0x41740d: 0x27b, _0x508b91: 0x3ec, _0x174c6c: 0x1f0, _0x4f4096: 0x1ba, _0x29391b: 0x399, _0x182d69: 0x2fb, _0x576cfa: 0x32e, _0x391f05: 0x37e, _0x5cf3dc: 0x4b6, _0x2837d8: 0x223, _0xebe6ea: 0x4fa, _0x5d4797: 0x164, _0x269036: 0x49b, _0x235f85: 0x321, _0x588f76: 0x2fb }, _0x4a6ee1 = { _0xb2d311: 0x3bf, _0x5e0018: 0x4cf, _0x27aa91: 0x15f, _0x36f1d5: 0x27b }, _0x360837 = { _0x3bfc60: 0x164, _0x59eec4: 0x2be, _0x1a7c0c: 0x49f, _0xeffb07: 0x49f, _0x295a9c: 0x4cf, _0x4be349: 0x2f4, _0x15eeea: 0x27b, _0x3f9699: 0x399 }, _0x5dd6cf = { _0x213b82: 0x2fb }, _0x4a30d8 = { _0x2b81e1: 0x4b6 }, _0x1a609d = _0x48e965; if (!_0x3a7f43) return; this['bgType'] = _0x3a7f43[_0x1a609d(0x1f0)]; if (_0x3a7f43[_0x1a609d(0x1f0)] == _0x1a609d(_0x2ad0ff._0x10f69e)) { if (this[_0x1a609d(_0x2ad0ff._0x34c1aa)]) this['sky']['visible'] = ![]; if (this[_0x1a609d(_0x2ad0ff._0x4dca76)][_0x1a609d(0x237)]) this[_0x1a609d(0x37e)][_0x1a609d(_0x2ad0ff._0x43c010)] = null; this[_0x1a609d(_0x2ad0ff._0x3f60e4)] = _0x3a7f43[_0x1a609d(_0x2ad0ff._0x41740d)], this[_0x1a609d(0x248)][_0x1a609d(0x505)](_0x3a7f43[_0x1a609d(_0x2ad0ff._0x41740d)]), this[_0x1a609d(_0x2ad0ff._0x508b91)][_0x1a609d(0x31a)] = _0x3a7f43[_0x1a609d(_0x2ad0ff._0x41740d)] } else { if (_0x3a7f43[_0x1a609d(_0x2ad0ff._0x174c6c)] == _0x1a609d(_0x2ad0ff._0x4f4096)) { if (this[_0x1a609d(0x4cf)]) this[_0x1a609d(_0x2ad0ff._0x34c1aa)][_0x1a609d(_0x2ad0ff._0x29391b)] = ![]; this[_0x1a609d(_0x2ad0ff._0x182d69)][_0x1a609d(_0x2ad0ff._0x576cfa)](this[_0x1a609d(0x283)] + _0x3a7f43[_0x1a609d(_0x2ad0ff._0x41740d)], _0x316c61 => { const _0x1dc933 = _0x1a609d; this[_0x1dc933(0x37e)]['background'] = _0x316c61; if (_0x3a7f43['options']) for (const _0x25e4a9 in _0x3a7f43['options']) { const _0x477162 = _0x3a7f43[_0x1dc933(_0x4a30d8._0x2b81e1)][_0x25e4a9]; this['scene'][_0x1dc933(0x237)][_0x25e4a9] = _0x477162 } }) } else { if (_0x3a7f43[_0x1a609d(0x1f0)] == _0x1a609d(0x41c)) { if (this[_0x1a609d(0x37e)]['background']) this[_0x1a609d(_0x2ad0ff._0x391f05)][_0x1a609d(0x237)] = null; if (!(_0x3a7f43[_0x1a609d(0x27b)] instanceof Array)) return; const _0x2818c4 = _0x3a7f43['value'], _0xf5e083 = _0x3a7f43[_0x1a609d(0x4b6)]['scale'] ? _0x3a7f43[_0x1a609d(0x4b6)]['scale'] : 0x1, _0x4f93db = _0x3a7f43['options'][_0x1a609d(0x3bf)] ? _0x3a7f43[_0x1a609d(0x4b6)]['rotation'] : [0x0, 0x0, 0x0], _0x24816e = _0x3a7f43[_0x1a609d(_0x2ad0ff._0x5cf3dc)]['position'] ? _0x3a7f43[_0x1a609d(0x4b6)]['position'] : [0x0, 0x0, 0x0], _0x419f3b = _0x3a7f43[_0x1a609d(_0x2ad0ff._0x2837d8)] !== undefined ? _0x3a7f43['fog'] : ![], _0x148988 = 0xc350; this[_0x1a609d(_0x2ad0ff._0xebe6ea)] = _0x148988; if (_0x2818c4[_0x1a609d(0x321)] == 0x6) { const _0x1e1b7c = [], _0x3ca264 = []; _0x2818c4[_0x1a609d(_0x2ad0ff._0x5d4797)](_0x53d32b => { const _0xb55dde = _0x1a609d; _0x1e1b7c[_0xb55dde(0x1da)](loadTex(this[_0xb55dde(_0x5dd6cf._0x213b82)], this['publicPath'] + _0x53d32b)) }), Promise['all'](_0x1e1b7c)[_0x1a609d(_0x2ad0ff._0x269036)](_0x393d11 => { const _0x110f5b = { _0x264fc0: 0x1da }, _0x27b60b = _0x1a609d; _0x393d11[_0x27b60b(_0x360837._0x3bfc60)](_0x291870 => { const _0x26e727 = _0x27b60b, _0x226a56 = new MeshBasicMaterial({ 'map': _0x291870, 'side': 0x2, 'transparent': !![], 'opacity': 0x1, 'fog': _0x419f3b }); _0x3ca264[_0x26e727(_0x110f5b._0x264fc0)](_0x226a56) }); const _0xcc8a5f = new BoxGeometry(_0x148988, _0x148988, _0x148988), _0xe5fe6d = new Mesh(_0xcc8a5f, _0x3ca264); _0xe5fe6d[_0x27b60b(_0x360837._0x59eec4)][_0x27b60b(_0x360837._0x1a7c0c)](_0xf5e083, _0xf5e083, _0xf5e083), _0xe5fe6d['rotation'][_0x27b60b(_0x360837._0xeffb07)](degToRad(_0x4f93db[0x0]), degToRad(_0x4f93db[0x1]), degToRad(_0x4f93db[0x2])), _0xe5fe6d[_0x27b60b(0x4c4)][_0x27b60b(0x49f)](_0x24816e[0x0], _0x24816e[0x1], _0x24816e[0x2]), _0xe5fe6d[_0x27b60b(0x1c2)] = SKY_RENDER_ORDER, _0xe5fe6d['type'] = _0x27b60b(0x27a), this['sky'] ? (this[_0x27b60b(0x4cf)][_0x27b60b(0x303)] = _0xcc8a5f, this[_0x27b60b(_0x360837._0x295a9c)][_0x27b60b(_0x360837._0x4be349)] = _0x3ca264) : (this[_0x27b60b(0x37e)]['add'](_0xe5fe6d), this['sky'] = _0xe5fe6d), this['sky'][_0x27b60b(0x15f)][_0x27b60b(_0x360837._0x15eeea)] = _0x2818c4, this['sky'][_0x27b60b(_0x360837._0x3f9699)] = !![] }) } else _0x2818c4[_0x1a609d(_0x2ad0ff._0x235f85)] == 0x1 && this[_0x1a609d(_0x2ad0ff._0x588f76)][_0x1a609d(0x32e)](this[_0x1a609d(0x283)] + _0x2818c4[0x0], _0x4f53d1 => { const _0x3e6255 = _0x1a609d, _0x27da57 = new MeshBasicMaterial({ 'map': _0x4f53d1, 'side': BackSide, 'transparent': !![], 'opacity': 0x1, 'fog': _0x419f3b }), _0x19334a = new SphereGeometry(_0x148988, 0x3c, 0x3c), _0x246374 = new Mesh(_0x19334a, _0x27da57); _0x246374['scale'][_0x3e6255(0x49f)](_0xf5e083, _0xf5e083, _0xf5e083), _0x246374[_0x3e6255(_0x4a6ee1._0xb2d311)]['set'](_0x4f93db[0x0] * Math['PI'] / 0xb4, _0x4f93db[0x1] * Math['PI'] / 0xb4, _0x4f93db[0x2] * Math['PI'] / 0xb4), _0x246374[_0x3e6255(0x4c4)]['set'](_0x24816e[0x0], _0x24816e[0x1], _0x24816e[0x2]), _0x246374[_0x3e6255(0x1c2)] = SKY_RENDER_ORDER, _0x246374['type'] = _0x3e6255(0x27a), this['sky'] ? (this[_0x3e6255(_0x4a6ee1._0x5e0018)]['geometry'] = _0x19334a, this['sky']['material'] = _0x27da57) : (this[_0x3e6255(0x37e)]['add'](_0x246374), this[_0x3e6255(0x4cf)] = _0x246374), this[_0x3e6255(0x4cf)][_0x3e6255(_0x4a6ee1._0x27aa91)][_0x3e6255(_0x4a6ee1._0x36f1d5)] = _0x2818c4, this[_0x3e6255(0x4cf)][_0x3e6255(0x399)] = !![] }) } } } } ['updateHDR'] (_0x2bea7e) { if (!_0x2bea7e) return; this['setHDR'](_0x2bea7e) } } class EventsController { [_0x48e965(0x2b3)]; constructor() { const _0x4e289a = { _0x33e9fa: 0x2b3 }, _0x2548e3 = _0x48e965; this[_0x2548e3(_0x4e289a._0x33e9fa)] = {} } ['on'] (_0x5ae9dd, _0x1c1cc3) { const _0x4ae922 = { _0x325bb5: 0x334, _0x2c2595: 0x2b3, _0x42293d: 0x1da }, _0x28d19e = _0x48e965; typeof this['handlers'][_0x5ae9dd] == _0x28d19e(_0x4ae922._0x325bb5) && (this[_0x28d19e(0x2b3)][_0x5ae9dd] = []), this[_0x28d19e(_0x4ae922._0x2c2595)][_0x5ae9dd][_0x28d19e(_0x4ae922._0x42293d)](_0x1c1cc3) } [_0x48e965(0x439)] (_0x105a46) { const _0x4784a7 = { _0x23e087: 0x2b3, _0x3402da: 0x1f0 }, _0x4c0cac = _0x48e965; !_0x105a46[_0x4c0cac(0x522)] && (_0x105a46[_0x4c0cac(0x522)] = this); if (this[_0x4c0cac(0x2b3)][_0x105a46[_0x4c0cac(0x1f0)]] instanceof Array) { const _0x3c2878 = this[_0x4c0cac(_0x4784a7._0x23e087)][_0x105a46[_0x4c0cac(_0x4784a7._0x3402da)]]; for (let _0x5b7293 = 0x0; _0x5b7293 < _0x3c2878['length']; _0x5b7293++) { _0x3c2878[_0x5b7293] != undefined && _0x3c2878[_0x5b7293](_0x105a46) } } } [_0x48e965(0x4c8)] (_0x479221, _0x38239f) { const _0x27cc83 = { _0x6b3392: 0x2b3, _0xe2a1f9: 0x413 }, _0x184319 = _0x48e965; if (this[_0x184319(_0x27cc83._0x6b3392)] === undefined) return; const _0x53d53a = this['handlers'], _0xab8d39 = _0x53d53a[_0x479221]; if (_0xab8d39 !== undefined) { const _0x447d2a = _0xab8d39[_0x184319(_0x27cc83._0xe2a1f9)](_0x38239f); _0x447d2a !== -0x1 && _0xab8d39[_0x184319(0x1f2)](_0x447d2a, 0x1) } } } var EventsBus = new EventsController(); class Events { [_0x48e965(0x1e9)];[_0x48e965(0x19d)];[_0x48e965(0x4e5)];[_0x48e965(0x539)];[_0x48e965(0x187)];['dragenter'];[_0x48e965(0x531)];[_0x48e965(0x4ef)];['isDrag'];[_0x48e965(0x2c1)];['hoverTimer'];[_0x48e965(0x2b1)];[_0x48e965(0x4d7)]; constructor(_0x5c5ba5, _0x109c25) { const _0x204cfb = { _0x3f0bbb: 0x1e9, _0x328339: 0x2b1, _0x4167c6: 0x4d7, _0x1c56fb: 0x350 }, _0x97c49c = _0x48e965; this[_0x97c49c(_0x204cfb._0x3f0bbb)] = _0x5c5ba5, this['events'] = EventsBus, this[_0x97c49c(_0x204cfb._0x328339)] = { 'dbclick': !![], 'click': !![], 'hover': !![] }, this[_0x97c49c(_0x204cfb._0x4167c6)] = _0x109c25 ? _0x109c25 : this[_0x97c49c(_0x204cfb._0x3f0bbb)][_0x97c49c(0x248)][_0x97c49c(_0x204cfb._0x1c56fb)], this['initEvents']() } set ['onclick'] (_0x160b52) { const _0x3a0367 = { _0xfd548f: 0x19d, _0x51fe46: 0x231, _0x64cf84: 0x4e5 }, _0x27e33f = _0x48e965; _0x160b52 != undefined ? (this[_0x27e33f(0x4e5)] = _0x160b52, this[_0x27e33f(_0x3a0367._0xfd548f)]['on'](_0x27e33f(_0x3a0367._0x51fe46), this[_0x27e33f(0x4e5)])) : (this[_0x27e33f(0x19d)]['off'](_0x27e33f(_0x3a0367._0x51fe46), this['click']), this[_0x27e33f(_0x3a0367._0x64cf84)] = null) } get [_0x48e965(0x46e)] () { const _0x1a9fae = { _0x1f82f2: 0x4e5 }, _0x54113d = _0x48e965; return this[_0x54113d(_0x1a9fae._0x1f82f2)] } set [_0x48e965(0x47b)] (_0x52dd83) { const _0x82deea = { _0x2fc9aa: 0x539, _0x587304: 0x227, _0x1052c8: 0x539 }, _0x5b7e75 = _0x48e965; _0x52dd83 != undefined ? (this[_0x5b7e75(0x539)] = _0x52dd83, this[_0x5b7e75(0x19d)]['on']('bolDbClick', this[_0x5b7e75(_0x82deea._0x2fc9aa)])) : (this['events'][_0x5b7e75(0x4c8)](_0x5b7e75(_0x82deea._0x587304), this[_0x5b7e75(0x539)]), this[_0x5b7e75(_0x82deea._0x1052c8)] = null) } get [_0x48e965(0x47b)] () { return this['dbclick'] } set [_0x48e965(0x3b0)] (_0x3720a4) { const _0xb6dc3e = { _0x249fcd: 0x187, _0x516844: 0x19d, _0x544268: 0x542, _0x4f6257: 0x187 }, _0x50bff6 = _0x48e965; _0x3720a4 != undefined ? (this[_0x50bff6(_0xb6dc3e._0x249fcd)] = _0x3720a4, this[_0x50bff6(_0xb6dc3e._0x516844)]['on'](_0x50bff6(_0xb6dc3e._0x544268), this[_0x50bff6(_0xb6dc3e._0x249fcd)])) : (this[_0x50bff6(0x19d)][_0x50bff6(0x4c8)](_0x50bff6(0x542), this[_0x50bff6(_0xb6dc3e._0x4f6257)]), this['hover'] = null) } get ['onhover'] () { const _0x51e397 = { _0x21ea1b: 0x187 }, _0x409d69 = _0x48e965; return this[_0x409d69(_0x51e397._0x21ea1b)] } set [_0x48e965(0x2cc)] (_0x2ca270) { const _0x4e3d66 = { _0x58d478: 0x167, _0x2b55a0: 0x19d, _0x3f0c72: 0x4c8, _0x5d1af4: 0x167 }, _0xb44c84 = _0x48e965; _0x2ca270 != undefined ? (this[_0xb44c84(0x167)] = _0x2ca270, this[_0xb44c84(0x19d)]['on'](_0xb44c84(0x3c0), this[_0xb44c84(_0x4e3d66._0x58d478)])) : (this[_0xb44c84(_0x4e3d66._0x2b55a0)][_0xb44c84(_0x4e3d66._0x3f0c72)](_0xb44c84(0x3c0), this[_0xb44c84(_0x4e3d66._0x5d1af4)]), this['dragenter'] = null) } get [_0x48e965(0x2cc)] () { const _0x552bb3 = _0x48e965; return this[_0x552bb3(0x167)] } set [_0x48e965(0x471)] (_0x3e0fa9) { const _0x221570 = { _0x513e9f: 0x4c8 }, _0x2f0979 = _0x48e965; _0x3e0fa9 != undefined ? (this['dragend'] = _0x3e0fa9, this[_0x2f0979(0x19d)]['on']('bolDragEnd', this['dragend'])) : (this['events'][_0x2f0979(_0x221570._0x513e9f)](_0x2f0979(0x3d0), this[_0x2f0979(0x531)]), this['dragend'] = null) } get ['ondragend'] () { const _0x576b4a = { _0x5ce520: 0x531 }, _0x318be1 = _0x48e965; return this[_0x318be1(_0x576b4a._0x5ce520)] } [_0x48e965(0x4b0)] () { const _0x24be73 = { _0x3cf3e1: 0x1e9, _0x591baf: 0x248, _0xd80c52: 0x333, _0x1b5e12: 0x2df }, _0x2e0310 = { _0x4665f7: 0x294, _0x4c3297: 0x4f7, _0x4d5eb4: 0x1e9, _0x29d3bd: 0x2bd, _0x4e198f: 0x1fe, _0x454634: 0x19d, _0x474ac6: 0x536, _0x58f400: 0x1e9, _0xf831db: 0x328 }, _0x1eed8b = { _0x501927: 0x294, _0x44bcfa: 0x4d7, _0x4b8b0f: 0x4d7, _0x197461: 0x1e9, _0x227867: 0x3c0, _0x4603ce: 0x536, _0x4f4526: 0x328, _0x2f3393: 0x46b, _0x1566aa: 0x1fe, _0x2610c5: 0x19d, _0x3b2e67: 0x439 }, _0x372e05 = { _0x13773b: 0x2b1, _0x5adb82: 0x187, _0x53002d: 0x273, _0x398b15: 0x4d7, _0x43b375: 0x152, _0x1bef78: 0x4d7, _0x46e804: 0x1a8, _0x4854d8: 0x306, _0x30e88e: 0x4f7, _0x509f4e: 0x468, _0x253b74: 0x4dd, _0x5f2b82: 0x46b, _0x3398e5: 0x2e3, _0x520ddc: 0x19d, _0x3b9edb: 0x439, _0x46903a: 0x1e9, _0x31a53b: 0x1e9, _0x5a6c5c: 0x328, _0x28e14c: 0x2e3, _0x529665: 0x4cd, _0x1691be: 0x542 }, _0x17ecce = { _0x2af887: 0x4ef, _0x349a9c: 0x294, _0xcbe4c8: 0x4d7, _0x169c42: 0x152, _0x22e092: 0x306, _0x422b01: 0x468, _0x42d64a: 0x1e9, _0x247244: 0x439, _0x143508: 0x19d, _0x5e2053: 0x227 }, _0x5ba4cf = { _0x5daf6f: 0x294, _0x5d56d6: 0x4ef, _0x38c90b: 0x2c1 }, _0x4909ff = _0x48e965, _0x2e7a38 = this[_0x4909ff(_0x24be73._0x3cf3e1)][_0x4909ff(_0x24be73._0x591baf)][_0x4909ff(0x350)], _0x44556b = new Raycaster(), _0xbb052f = new Vector2(), _0x53ef01 = this; _0x2e7a38[_0x4909ff(_0x24be73._0xd80c52)] = _0x574513 => { const _0x1ad075 = _0x4909ff; _0x53ef01[_0x1ad075(0x2c1)] = setTimeout(() => { const _0x546cdd = _0x1ad075; _0x53ef01[_0x546cdd(0x2e3)] = !![] }, 0xc8) }, _0x2e7a38[_0x4909ff(_0x24be73._0x1b5e12)] = _0x26ec8e => { const _0x9c437c = { _0x1e0565: 0x1e9, _0x53a94b: 0x2bd, _0x5e7f11: 0x468, _0x2dcfde: 0x4f7, _0x20b589: 0x1e9, _0x1413e8: 0x328, _0x1f4019: 0x46b, _0x347498: 0x439 }, _0x2074a9 = _0x4909ff, _0x309074 = this['realCt'][_0x2074a9(_0x5ba4cf._0x5daf6f)], _0x359435 = this['realCt'][_0x2074a9(0x152)], { width: _0x149230, height: _0x25ce38, top: _0x786b77, left: _0x13a252 } = this[_0x2074a9(0x4d7)][_0x2074a9(0x1a8)](); !_0x53ef01['isDrag'] && (clearTimeout(_0x53ef01[_0x2074a9(0x4ef)]), _0x53ef01[_0x2074a9(_0x5ba4cf._0x5d56d6)] = setTimeout(() => { const _0x10449d = _0x2074a9; if (_0x53ef01[_0x10449d(_0x9c437c._0x1e0565)][_0x10449d(_0x9c437c._0x53a94b)] == _0x10449d(_0x9c437c._0x5e7f11)) { _0xbb052f['x'] = (_0x26ec8e['clientX'] - _0x13a252 + _0x309074) / _0x149230 * 0x2 - 0x1, _0xbb052f['y'] = -((_0x26ec8e[_0x10449d(_0x9c437c._0x2dcfde)] - _0x786b77 + _0x359435) / _0x25ce38) * 0x2 + 0x1; const _0x2058ce = _0x53ef01[_0x10449d(_0x9c437c._0x1e0565)]['orbitCamera'], _0x52d20a = _0x53ef01[_0x10449d(_0x9c437c._0x20b589)][_0x10449d(0x328)]; _0x44556b['setFromCamera'](_0xbb052f, _0x2058ce); const _0x5966f8 = _0x44556b[_0x10449d(0x1fe)](_0x52d20a); _0x53ef01[_0x10449d(0x19d)]['emit']({ 'type': 'bolClick', 'objects': _0x5966f8, 'event': _0x26ec8e }) } else { _0xbb052f['x'] = (_0x26ec8e[_0x10449d(0x306)] - _0x13a252 + _0x309074) / _0x149230 * 0x2 - 0x1, _0xbb052f['y'] = -((_0x26ec8e['clientY'] - _0x786b77 + _0x359435) / _0x25ce38) * 0x2 + 0x1; const _0x46c713 = _0x53ef01['container']['firstPersonCamera'], _0x3ae7cd = _0x53ef01[_0x10449d(_0x9c437c._0x20b589)][_0x10449d(_0x9c437c._0x1413e8)]; _0x44556b[_0x10449d(_0x9c437c._0x1f4019)](_0xbb052f, _0x46c713); const _0x38e78c = _0x44556b[_0x10449d(0x1fe)](_0x3ae7cd); _0x53ef01['events'][_0x10449d(_0x9c437c._0x347498)]({ 'type': 'bolClick', 'objects': _0x38e78c, 'event': _0x26ec8e }) } }, 0xc8)), clearTimeout(_0x53ef01[_0x2074a9(_0x5ba4cf._0x38c90b)]), _0x53ef01['isDrag'] = ![] }, _0x2e7a38['ondblclick'] = _0x3295a3 => { const _0x3603d2 = _0x4909ff; clearTimeout(_0x53ef01[_0x3603d2(_0x17ecce._0x2af887)]); const _0x2b1929 = this[_0x3603d2(0x4d7)][_0x3603d2(_0x17ecce._0x349a9c)], _0x27cbec = this[_0x3603d2(_0x17ecce._0xcbe4c8)][_0x3603d2(_0x17ecce._0x169c42)], { width: _0x231935, height: _0x63289f, top: _0x158f71, left: _0x5204f6 } = this['realCt'][_0x3603d2(0x1a8)](); _0xbb052f['x'] = (_0x3295a3[_0x3603d2(_0x17ecce._0x22e092)] - _0x5204f6 + _0x2b1929) / _0x231935 * 0x2 - 0x1, _0xbb052f['y'] = -((_0x3295a3['clientY'] - _0x158f71 + _0x27cbec) / _0x63289f) * 0x2 + 0x1; if (_0x53ef01['container']['viewState'] == _0x3603d2(_0x17ecce._0x422b01)) { const _0x18edf0 = _0x53ef01[_0x3603d2(0x1e9)][_0x3603d2(0x4dd)], _0x50e1da = _0x53ef01[_0x3603d2(_0x17ecce._0x42d64a)][_0x3603d2(0x328)]; _0x44556b[_0x3603d2(0x46b)](_0xbb052f, _0x18edf0); const _0x318765 = _0x44556b[_0x3603d2(0x1fe)](_0x50e1da); _0x53ef01['events'][_0x3603d2(_0x17ecce._0x247244)]({ 'type': _0x3603d2(0x227), 'objects': _0x318765, 'event': _0x3295a3 }) } else { const _0x3de973 = _0x53ef01[_0x3603d2(_0x17ecce._0x42d64a)]['firstPersonCamera'], _0x953cdb = _0x53ef01['container'][_0x3603d2(0x328)]; _0x44556b[_0x3603d2(0x46b)](_0xbb052f, _0x3de973); const _0x194380 = _0x44556b[_0x3603d2(0x1fe)](_0x953cdb); _0x53ef01[_0x3603d2(_0x17ecce._0x143508)][_0x3603d2(0x439)]({ 'type': _0x3603d2(_0x17ecce._0x5e2053), 'objects': _0x194380, 'event': _0x3295a3 }) } }, _0x2e7a38['onmousemove'] = _0x5b90c0 => { const _0x416098 = _0x4909ff; if (this[_0x416098(0x4a0)] || !this[_0x416098(_0x372e05._0x13773b)][_0x416098(_0x372e05._0x5adb82)]) return; this[_0x416098(0x4a0)] = setTimeout(() => { const _0xde70b2 = _0x416098; this[_0xde70b2(0x4a0)] = null }, 0x1e); if (document[_0x416098(_0x372e05._0x53002d)]) document['body'][_0x416098(0x165)][_0x416098(0x1dd)] = _0x416098(0x370); const _0x2f5bce = this[_0x416098(0x4d7)]['offsetLeft'], _0x3e4c14 = this[_0x416098(_0x372e05._0x398b15)][_0x416098(_0x372e05._0x43b375)], { width: _0x4a44dd, height: _0xfc3bde, top: _0x585c86, left: _0x3cadaf } = this[_0x416098(_0x372e05._0x1bef78)][_0x416098(_0x372e05._0x46e804)](); _0xbb052f['x'] = (_0x5b90c0[_0x416098(_0x372e05._0x4854d8)] - _0x3cadaf + _0x2f5bce) / _0x4a44dd * 0x2 - 0x1, _0xbb052f['y'] = -((_0x5b90c0[_0x416098(_0x372e05._0x30e88e)] - _0x585c86 + _0x3e4c14) / _0xfc3bde) * 0x2 + 0x1; let _0x58d04d; if (_0x53ef01['container'][_0x416098(0x2bd)] == _0x416098(_0x372e05._0x509f4e)) { _0x58d04d = _0x53ef01[_0x416098(0x1e9)][_0x416098(_0x372e05._0x253b74)]; const _0x41a6c4 = _0x53ef01[_0x416098(0x1e9)][_0x416098(0x328)]; _0x44556b[_0x416098(_0x372e05._0x5f2b82)](_0xbb052f, _0x58d04d); const _0x175ac6 = _0x44556b['intersectObjects'](_0x41a6c4); _0x53ef01[_0x416098(_0x372e05._0x3398e5)] ? _0x53ef01[_0x416098(_0x372e05._0x520ddc)][_0x416098(_0x372e05._0x3b9edb)]({ 'type': _0x416098(0x4cd), 'event': _0x5b90c0 }) : _0x53ef01[_0x416098(_0x372e05._0x520ddc)]['emit']({ 'type': _0x416098(0x542), 'objects': _0x175ac6, 'event': _0x5b90c0 }) } else { _0x58d04d = _0x53ef01[_0x416098(_0x372e05._0x46903a)]['firstPersonCamera']; const _0x3f5dbe = _0x53ef01[_0x416098(_0x372e05._0x31a53b)][_0x416098(_0x372e05._0x5a6c5c)]; _0x44556b[_0x416098(0x46b)](_0xbb052f, _0x58d04d); const _0xa20759 = _0x44556b[_0x416098(0x1fe)](_0x3f5dbe); _0x53ef01[_0x416098(_0x372e05._0x28e14c)] ? _0x53ef01[_0x416098(_0x372e05._0x520ddc)]['emit']({ 'type': _0x416098(_0x372e05._0x529665), 'event': _0x5b90c0 }) : _0x53ef01['events']['emit']({ 'type': _0x416098(_0x372e05._0x1691be), 'objects': _0xa20759, 'event': _0x5b90c0 }) } }, _0x2e7a38[_0x4909ff(0x2cc)] = _0x169092 => { const _0x484f09 = _0x4909ff, _0x341e5b = this[_0x484f09(0x4d7)][_0x484f09(_0x1eed8b._0x501927)], _0x3c4aa7 = this[_0x484f09(_0x1eed8b._0x44bcfa)][_0x484f09(0x152)], { width: _0x49c6bf, height: _0xc0c972, top: _0x2d5ff1, left: _0x235ae0 } = this[_0x484f09(_0x1eed8b._0x4b8b0f)]['getBoundingClientRect'](); _0xbb052f['x'] = (_0x169092[_0x484f09(0x306)] - _0x235ae0 + _0x341e5b) / _0x49c6bf * 0x2 - 0x1, _0xbb052f['y'] = -((_0x169092[_0x484f09(0x4f7)] - _0x2d5ff1 + _0x3c4aa7) / _0xc0c972) * 0x2 + 0x1; let _0x2854e1; if (_0x53ef01[_0x484f09(0x1e9)][_0x484f09(0x2bd)] == _0x484f09(0x468)) { _0x2854e1 = _0x53ef01['container'][_0x484f09(0x4dd)]; const _0x28c9c5 = _0x53ef01[_0x484f09(_0x1eed8b._0x197461)][_0x484f09(0x328)]; _0x44556b[_0x484f09(0x46b)](_0xbb052f, _0x2854e1); const _0x11569f = _0x44556b['intersectObjects'](_0x28c9c5); _0x53ef01['events']['emit']({ 'type': _0x484f09(_0x1eed8b._0x227867), 'objects': _0x11569f, 'event': _0x169092 }) } else { _0x2854e1 = _0x53ef01[_0x484f09(0x1e9)][_0x484f09(_0x1eed8b._0x4603ce)]; const _0x35e118 = _0x53ef01[_0x484f09(_0x1eed8b._0x197461)][_0x484f09(_0x1eed8b._0x4f4526)]; _0x44556b[_0x484f09(_0x1eed8b._0x2f3393)](_0xbb052f, _0x2854e1); const _0x231a19 = _0x44556b[_0x484f09(_0x1eed8b._0x1566aa)](_0x35e118); _0x53ef01[_0x484f09(_0x1eed8b._0x2610c5)][_0x484f09(_0x1eed8b._0x3b2e67)]({ 'type': _0x484f09(0x3c0), 'objects': _0x231a19, 'event': _0x169092 }) } }, _0x2e7a38['ondragend'] = _0x1c5f0e => { const _0x5d527d = _0x4909ff, _0x1e1c4f = this[_0x5d527d(0x4d7)][_0x5d527d(_0x2e0310._0x4665f7)], _0xfdf3e7 = this[_0x5d527d(0x4d7)][_0x5d527d(0x152)], { width: _0x2dc819, height: _0x8612db, top: _0x5226d5, left: _0x22613f } = this['realCt'][_0x5d527d(0x1a8)](); _0xbb052f['x'] = (_0x1c5f0e[_0x5d527d(0x306)] - _0x22613f + _0x1e1c4f) / _0x2dc819 * 0x2 - 0x1, _0xbb052f['y'] = -((_0x1c5f0e[_0x5d527d(_0x2e0310._0x4c3297)] - _0x5226d5 + _0xfdf3e7) / _0x8612db) * 0x2 + 0x1; let _0x5e3071; if (_0x53ef01[_0x5d527d(_0x2e0310._0x4d5eb4)][_0x5d527d(_0x2e0310._0x29d3bd)] == 'orbit') { _0x5e3071 = _0x53ef01['container'][_0x5d527d(0x4dd)]; const _0xb36344 = _0x53ef01[_0x5d527d(0x1e9)][_0x5d527d(0x328)]; _0x44556b[_0x5d527d(0x46b)](_0xbb052f, _0x5e3071); const _0x3acb3d = _0x44556b[_0x5d527d(_0x2e0310._0x4e198f)](_0xb36344); _0x53ef01[_0x5d527d(_0x2e0310._0x454634)][_0x5d527d(0x439)]({ 'type': 'bolDragEnd', 'objects': _0x3acb3d, 'event': _0x1c5f0e }) } else { _0x5e3071 = _0x53ef01[_0x5d527d(_0x2e0310._0x4d5eb4)][_0x5d527d(_0x2e0310._0x474ac6)]; const _0x3070b0 = _0x53ef01[_0x5d527d(_0x2e0310._0x58f400)][_0x5d527d(_0x2e0310._0xf831db)]; _0x44556b[_0x5d527d(0x46b)](_0xbb052f, _0x5e3071); const _0x2a5dd8 = _0x44556b[_0x5d527d(0x1fe)](_0x3070b0); _0x53ef01['events'][_0x5d527d(0x439)]({ 'type': 'bolDragEnd', 'objects': _0x2a5dd8, 'event': _0x1c5f0e }) } } } } class Text extends Sprite { ['bg']; constructor(_0x3924e2) { const _0x4d9b72 = { _0x2bb0ab: 0x3c9, _0x1117ef: 0x339, _0x2a73f1: 0x4de, _0x40d22c: 0x2f4, _0x2b323d: 0x4c4, _0x6d14c6: 0x2be, _0x1c8965: 0x1c2, _0x58e3d1: 0x237, _0x52ee2e: 0x32e, _0x535eb4: 0x252 }, _0x372712 = { _0x70fcc8: 0x38a, _0x55d5cf: 0x19b, _0x3d3dc7: 0x2a1, _0x417518: 0x2a1 }, _0x2afee7 = _0x48e965; super(); let _0x1b0ed9 = { 'position': [0x0, 0x0, 0x0], 'value': '', 'scale': 0x14, 'color': '#ffffff', 'width': 0x12c, 'lineHeight': 0x14, 'lineSpacing': 0x0, 'topSpacing': 0x0, 'background': '', 'textAlign': _0x2afee7(_0x4d9b72._0x2bb0ab), 'backgroundColor': _0x2afee7(0x2fd), 'sizeAttenuation': !![], 'publicPath': '', 'bgScale': [0x1, 0x1], 'bgOffset': [0x0, 0x0] }; _0x1b0ed9 = Object['assign'](_0x1b0ed9, _0x3924e2); let _0x16bb2f = typeof _0x1b0ed9['value'] == _0x2afee7(0x2ec) ? fillText : fillText2; const { textCanvas: _0x4ae63a, xScale: _0x416bb7, yScale: _0xba57be } = _0x16bb2f({ 'text': _0x1b0ed9['value'], 'fgColor': _0x1b0ed9[_0x2afee7(0x209)], 'width': _0x1b0ed9[_0x2afee7(0x15d)], 'lineHeight': _0x1b0ed9[_0x2afee7(_0x4d9b72._0x1117ef)], 'lineSpacing': _0x1b0ed9[_0x2afee7(0x409)], 'topSpacing': _0x1b0ed9[_0x2afee7(_0x4d9b72._0x2a73f1)], 'textAlign': _0x1b0ed9[_0x2afee7(0x298)] }), _0x31c3e3 = new CanvasTexture(_0x4ae63a), _0x3ad4be = new SpriteMaterial({ 'map': _0x31c3e3, 'transparent': !![], 'sizeAttenuation': _0x1b0ed9['sizeAttenuation'], 'fog': ![] }); this[_0x2afee7(_0x4d9b72._0x40d22c)] = _0x3ad4be, this[_0x2afee7(0x4c4)][_0x2afee7(0x49f)](_0x1b0ed9['position'][0x0], _0x1b0ed9[_0x2afee7(_0x4d9b72._0x2b323d)][0x1], _0x1b0ed9['position'][0x2]), this[_0x2afee7(_0x4d9b72._0x6d14c6)]['set'](_0x1b0ed9[_0x2afee7(0x2be)] * _0x416bb7, _0x1b0ed9['scale'] * _0xba57be, 0x1), this[_0x2afee7(_0x4d9b72._0x1c8965)] = TEXT_RENDER_ORDER + 0x1, _0x1b0ed9[_0x2afee7(_0x4d9b72._0x58e3d1)] != '' && new TextureLoader()[_0x2afee7(_0x4d9b72._0x52ee2e)](_0x1b0ed9[_0x2afee7(0x283)] + _0x1b0ed9[_0x2afee7(_0x4d9b72._0x58e3d1)], _0x1339d6 => { const _0x399307 = _0x2afee7; _0x1339d6[_0x399307(_0x372712._0x70fcc8)] = new Vector2(_0x1b0ed9[_0x399307(0x3f1)][0x0], _0x1b0ed9[_0x399307(0x3f1)][0x1]); const _0x52c60a = new SpriteMaterial({ 'map': _0x1339d6, 'transparent': !![], 'color': _0x1b0ed9[_0x399307(_0x372712._0x55d5cf)], 'sizeAttenuation': _0x1b0ed9['sizeAttenuation'], 'fog': ![] }), _0x55b7f9 = new Sprite(_0x52c60a); _0x55b7f9['renderOrder'] = TEXT_RENDER_ORDER, _0x55b7f9[_0x399307(0x2be)]['set'](_0x1b0ed9[_0x399307(_0x372712._0x3d3dc7)][0x0], _0x1b0ed9[_0x399307(_0x372712._0x417518)][0x1], 0x1), this[_0x399307(0x44d)](_0x55b7f9) }), this[_0x2afee7(0x1f0)] = _0x2afee7(_0x4d9b72._0x535eb4) } } function fillText (_0x313bd4) { const _0xbd5bb3 = { _0xfd65b7: 0x4ba, _0x1240bf: 0x3a2, _0x427604: 0x3a2, _0x3db302: 0x282, _0x404ae4: 0x1cd, _0x31e974: 0x1b4, _0x11b667: 0x324, _0x25e620: 0x3bc, _0x27bbd7: 0x3bc, _0x700c4f: 0x409, _0x316e0b: 0x15d, _0x40cd82: 0x519, _0x1e3273: 0x44a, _0x4fcdff: 0x30b, _0x566962: 0x494, _0x2330eb: 0x15d, _0x3b24c9: 0x496, _0x968265: 0x165, _0x443834: 0x3c9, _0x50e951: 0x488, _0x2f5c41: 0x2eb, _0x3e2535: 0x321, _0xeaa59b: 0x432, _0x4640b8: 0x3a3, _0x2de441: 0x32d, _0x246972: 0x53b, _0x4b5398: 0x3c9, _0x17015f: 0x321, _0x428fb9: 0x15d, _0x35594a: 0x321, _0x881807: 0x15d }, _0x398fc6 = _0x48e965; let _0x4ee8db = _0x313bd4 && _0x313bd4[_0x398fc6(0x28e)] !== undefined ? _0x313bd4['text'] : '', _0x5a1c02 = _0x313bd4 && _0x313bd4[_0x398fc6(_0xbd5bb3._0xfd65b7)] !== undefined ? _0x313bd4[_0x398fc6(0x4ba)] : 0xf, _0x2d91f8 = _0x313bd4 && _0x313bd4[_0x398fc6(_0xbd5bb3._0x1240bf)] !== undefined ? _0x313bd4[_0x398fc6(_0xbd5bb3._0x427604)] : 0x32, _0x259116 = _0x313bd4 && _0x313bd4[_0x398fc6(0x282)] !== undefined ? _0x313bd4[_0x398fc6(_0xbd5bb3._0x3db302)] : 0x14, _0x3becd7 = _0x313bd4 && _0x313bd4[_0x398fc6(0x1cd)] !== undefined ? _0x313bd4[_0x398fc6(_0xbd5bb3._0x404ae4)] : _0x398fc6(_0xbd5bb3._0x31e974), _0x49d94b = _0x313bd4 && _0x313bd4[_0x398fc6(_0xbd5bb3._0x11b667)] !== undefined ? _0x313bd4[_0x398fc6(0x324)] : _0x398fc6(0x3c7); _0x313bd4 && _0x313bd4[_0x398fc6(0x1af)] !== undefined ? _0x313bd4['letterSpacing'] : 0x0; let _0x23a8a1 = _0x313bd4 && _0x313bd4[_0x398fc6(0x493)] !== undefined ? _0x313bd4['bold'] : ![], _0x4d4ec5 = _0x313bd4 && _0x313bd4[_0x398fc6(_0xbd5bb3._0x25e620)] !== undefined ? _0x313bd4[_0x398fc6(_0xbd5bb3._0x27bbd7)] : ![], _0x2449d0 = _0x313bd4 && _0x313bd4[_0x398fc6(0x298)] !== undefined ? _0x313bd4[_0x398fc6(0x298)] : _0x398fc6(0x3c9), _0x22b4b2 = _0x313bd4 && _0x313bd4[_0x398fc6(0x339)] !== undefined ? _0x313bd4[_0x398fc6(0x339)] : 0x14, _0xf462f0 = _0x313bd4 && _0x313bd4['lineSpacing'] !== undefined ? _0x313bd4[_0x398fc6(_0xbd5bb3._0x700c4f)] : 0x0, _0x4b3156 = _0x313bd4 && _0x313bd4[_0x398fc6(0x4de)] !== undefined ? _0x313bd4[_0x398fc6(0x4de)] : 0x5, _0x366088 = _0x313bd4 && _0x313bd4[_0x398fc6(_0xbd5bb3._0x316e0b)] !== undefined ? _0x313bd4[_0x398fc6(0x15d)] : 0xc8; _0x23a8a1 = _0x23a8a1 ? _0x398fc6(0x32c) : '', _0x4d4ec5 = _0x4d4ec5 ? _0x398fc6(0x35d) : ''; let _0x2392a4 = document[_0x398fc6(_0xbd5bb3._0x40cd82)](_0x398fc6(0x264)), _0x1220a5 = _0x2392a4[_0x398fc6(_0xbd5bb3._0x1e3273)]('2d'); _0x1220a5[_0x398fc6(0x51a)] = _0x4d4ec5 + _0x23a8a1 + _0x2d91f8 + _0x398fc6(0x256) + _0x49d94b; const _0xd03cce = _0x1220a5[_0x398fc6(_0xbd5bb3._0x4fcdff)](_0x4ee8db)['width'], _0x4e11cd = Math[_0x398fc6(_0xbd5bb3._0x566962)](_0xd03cce / _0x366088); let _0x26b017 = _0x5a1c02 / _0x2d91f8, _0x34e3c4 = Math[_0x398fc6(0x494)](_0x259116 / _0x26b017), _0x38ee1d = _0x366088, _0x1e7265 = _0x38ee1d * _0x26b017, _0x4683bd = _0x1e7265 + (_0x259116 - _0x5a1c02); _0x2392a4[_0x398fc6(_0xbd5bb3._0x2330eb)] = _0x366088, _0x2392a4[_0x398fc6(_0xbd5bb3._0x3b24c9)] = _0x34e3c4 * _0x4e11cd, _0x2392a4[_0x398fc6(_0xbd5bb3._0x968265)][_0x398fc6(0x15d)] = _0x366088 + 'px', _0x2392a4[_0x398fc6(0x165)][_0x398fc6(0x496)] = _0x34e3c4 * _0x4e11cd + 'px', _0x259116 *= _0x4e11cd, _0x1220a5[_0x398fc6(0x298)] = _0x398fc6(_0xbd5bb3._0x443834), _0x1220a5[_0x398fc6(_0xbd5bb3._0x50e951)] = _0x398fc6(_0xbd5bb3._0x2f5c41), _0x1220a5[_0x398fc6(0x475)] = _0x3becd7, _0x1220a5['font'] = _0x4d4ec5 + _0x23a8a1 + _0x22b4b2 + _0x398fc6(0x256) + _0x49d94b; let _0x5b5a0c = 0x0, _0x299108 = _0x4b3156; for (let _0x5b4bbb = 0x0; _0x5b4bbb < _0x4ee8db[_0x398fc6(_0xbd5bb3._0x3e2535)]; _0x5b4bbb++) { const _0x5945cb = _0x4ee8db[_0x398fc6(_0xbd5bb3._0xeaa59b)](_0x5b4bbb, _0x5b4bbb + 0x1)[_0x398fc6(_0xbd5bb3._0x4640b8)](); _0x1220a5[_0x398fc6(_0xbd5bb3._0x2de441)](), _0x1220a5[_0x398fc6(_0xbd5bb3._0x246972)](_0x5b5a0c, _0x299108), _0x1220a5[_0x398fc6(0x395)](_0x5945cb, 0x0, 0x0), _0x1220a5[_0x398fc6(0x521)](), _0x5b5a0c += _0x1220a5[_0x398fc6(0x30b)](_0x5945cb)[_0x398fc6(_0xbd5bb3._0x2330eb)]; if (_0x5b5a0c + _0x1220a5['measureText'](_0x5945cb)[_0x398fc6(_0xbd5bb3._0x316e0b)] > _0x366088) { if (_0x2449d0 == _0x398fc6(_0xbd5bb3._0x4b5398)) _0x5b5a0c = 0x0; else { if (_0x2449d0 == 'center') { const _0x295960 = _0x4ee8db['slice'](_0x5b4bbb + 0x1, _0x4ee8db[_0x398fc6(_0xbd5bb3._0x17015f)])['toString'](), _0x3b2f4b = _0x1220a5[_0x398fc6(0x30b)](_0x295960)[_0x398fc6(_0xbd5bb3._0x428fb9)]; _0x3b2f4b < _0x366088 ? _0x5b5a0c = (_0x366088 - _0x3b2f4b) / 0x2 : _0x5b5a0c = 0x0 } else { if (_0x2449d0 == _0x398fc6(0x3cd)) { const _0x50cf77 = _0x4ee8db[_0x398fc6(0x432)](_0x5b4bbb + 0x1, _0x4ee8db[_0x398fc6(_0xbd5bb3._0x35594a)])[_0x398fc6(0x3a3)](), _0x766662 = _0x1220a5[_0x398fc6(0x30b)](_0x50cf77)[_0x398fc6(_0xbd5bb3._0x881807)]; _0x766662 < _0x366088 ? _0x5b5a0c = _0x366088 - _0x766662 : _0x5b5a0c = 0x0 } } } _0x299108 += _0x22b4b2 + _0xf462f0 } } return { 'text': _0x4ee8db, 'hWorldText': _0x5a1c02, 'hPxText': _0x2d91f8, 'hWorldAll': _0x259116, 'wWorldAll': _0x4683bd, 'fgColor': _0x3becd7, 'fontFamily': _0x49d94b, 'textCanvas': _0x2392a4, 'xScale': _0x366088, 'yScale': _0x34e3c4 * _0x4e11cd } } function fillText2 (_0x222483) { const _0x1f27c2 = { _0x5afcef: 0x28e, _0x3d0345: 0x4ba, _0x3187e0: 0x282, _0x4fd1df: 0x1cd, _0x1dac1d: 0x1cd, _0x3b9317: 0x1af, _0x59fb90: 0x493, _0x3b7aee: 0x3bc, _0x1a7a8f: 0x298, _0x418039: 0x3c9, _0x2220c0: 0x339, _0x46769f: 0x409, _0xd080eb: 0x15d, _0x316498: 0x32c, _0x476f6a: 0x35d, _0x4b0668: 0x519, _0x3eb4eb: 0x321, _0x27edaf: 0x165, _0x4aa939: 0x496, _0x2b4763: 0x2eb, _0x454757: 0x3cd, _0x46ab57: 0x432, _0x2e03f8: 0x3a3, _0x3666c2: 0x395, _0x1cb3da: 0x521, _0x4f8d81: 0x30b }, _0x23777d = _0x48e965; let _0x18d154 = _0x222483 && _0x222483[_0x23777d(_0x1f27c2._0x5afcef)] !== undefined ? _0x222483['text'] : [], _0x1d5fe6 = _0x222483 && _0x222483[_0x23777d(_0x1f27c2._0x3d0345)] !== undefined ? _0x222483['hWorldText'] : 0xf, _0x42d051 = _0x222483 && _0x222483[_0x23777d(0x3a2)] !== undefined ? _0x222483[_0x23777d(0x3a2)] : 0x32, _0x4d12c3 = _0x222483 && _0x222483[_0x23777d(_0x1f27c2._0x3187e0)] !== undefined ? _0x222483[_0x23777d(_0x1f27c2._0x3187e0)] : 0x14, _0x1e8910 = _0x222483 && _0x222483[_0x23777d(_0x1f27c2._0x4fd1df)] !== undefined ? _0x222483[_0x23777d(_0x1f27c2._0x1dac1d)] : _0x23777d(0x1b4), _0x670851 = _0x222483 && _0x222483['fontFamily'] !== undefined ? _0x222483[_0x23777d(0x324)] : _0x23777d(0x3c7); _0x222483 && _0x222483['letterSpacing'] !== undefined ? _0x222483[_0x23777d(_0x1f27c2._0x3b9317)] : 0x0; let _0x114857 = _0x222483 && _0x222483['bold'] !== undefined ? _0x222483[_0x23777d(_0x1f27c2._0x59fb90)] : ![], _0x19c3a7 = _0x222483 && _0x222483[_0x23777d(_0x1f27c2._0x3b7aee)] !== undefined ? _0x222483[_0x23777d(_0x1f27c2._0x3b7aee)] : ![], _0x30f619 = _0x222483 && _0x222483[_0x23777d(_0x1f27c2._0x1a7a8f)] !== undefined ? _0x222483[_0x23777d(_0x1f27c2._0x1a7a8f)] : _0x23777d(_0x1f27c2._0x418039), _0x518331 = _0x222483 && _0x222483[_0x23777d(_0x1f27c2._0x2220c0)] !== undefined ? _0x222483['lineHeight'] : 0x14, _0x48ed3c = _0x222483 && _0x222483[_0x23777d(_0x1f27c2._0x46769f)] !== undefined ? _0x222483[_0x23777d(0x409)] : 0x0, _0x522a48 = _0x222483 && _0x222483['topSpacing'] !== undefined ? _0x222483['topSpacing'] : 0x5, _0x1bc3aa = _0x222483 && _0x222483[_0x23777d(0x15d)] !== undefined ? _0x222483[_0x23777d(_0x1f27c2._0xd080eb)] : 0xc8; _0x114857 = _0x114857 ? _0x23777d(_0x1f27c2._0x316498) : '', _0x19c3a7 = _0x19c3a7 ? _0x23777d(_0x1f27c2._0x476f6a) : ''; let _0x44f58f = document[_0x23777d(_0x1f27c2._0x4b0668)](_0x23777d(0x264)), _0x5a0611 = _0x44f58f['getContext']('2d'); _0x5a0611[_0x23777d(0x51a)] = _0x19c3a7 + _0x114857 + _0x42d051 + _0x23777d(0x256) + _0x670851; const _0xf363ef = _0x18d154[_0x23777d(_0x1f27c2._0x3eb4eb)]; let _0x2e1d0b = _0x1d5fe6 / _0x42d051, _0x12bd7f = Math[_0x23777d(0x494)](_0x4d12c3 / _0x2e1d0b), _0x4a9c22 = _0x1bc3aa, _0x2b6443 = _0x4a9c22 * _0x2e1d0b, _0x69bc93 = _0x2b6443 + (_0x4d12c3 - _0x1d5fe6); _0x44f58f[_0x23777d(_0x1f27c2._0xd080eb)] = _0x1bc3aa, _0x44f58f['height'] = _0x12bd7f * _0xf363ef, _0x44f58f[_0x23777d(_0x1f27c2._0x27edaf)][_0x23777d(0x15d)] = _0x1bc3aa + 'px', _0x44f58f['style'][_0x23777d(_0x1f27c2._0x4aa939)] = _0x12bd7f * _0xf363ef + 'px', _0x4d12c3 *= _0xf363ef, _0x5a0611[_0x23777d(0x488)] = _0x23777d(_0x1f27c2._0x2b4763), _0x5a0611['fillStyle'] = _0x1e8910, _0x5a0611[_0x23777d(0x51a)] = _0x19c3a7 + _0x114857 + _0x518331 + _0x23777d(0x256) + _0x670851; let _0x160090 = 0x0, _0x4afbd2 = _0x522a48; for (let _0x56a4d = 0x0; _0x56a4d < _0x18d154[_0x23777d(_0x1f27c2._0x3eb4eb)]; _0x56a4d++) { const _0x48961f = _0x18d154[_0x56a4d], _0x2b1934 = _0x5a0611['measureText'](_0x48961f)[_0x23777d(0x15d)]; if (_0x30f619 == _0x23777d(_0x1f27c2._0x418039)) _0x160090 = 0x0; else { if (_0x30f619 == 'center') _0x160090 = (_0x1bc3aa - _0x2b1934) / 0x2; else _0x30f619 == _0x23777d(_0x1f27c2._0x454757) && (_0x160090 = _0x1bc3aa - _0x2b1934) } for (let _0x13c426 = 0x0; _0x13c426 < _0x48961f[_0x23777d(0x321)]; _0x13c426++) { const _0x3733b1 = _0x48961f[_0x23777d(_0x1f27c2._0x46ab57)](_0x13c426, _0x13c426 + 0x1)[_0x23777d(_0x1f27c2._0x2e03f8)](); _0x5a0611['save'](), _0x5a0611['translate'](_0x160090, _0x4afbd2), _0x5a0611[_0x23777d(_0x1f27c2._0x3666c2)](_0x3733b1, 0x0, 0x0), _0x5a0611[_0x23777d(_0x1f27c2._0x1cb3da)](), _0x160090 += _0x5a0611[_0x23777d(_0x1f27c2._0x4f8d81)](_0x3733b1)[_0x23777d(0x15d)] } _0x4afbd2 += _0x518331 + _0x48ed3c } return { 'text': _0x18d154, 'hWorldText': _0x1d5fe6, 'hPxText': _0x42d051, 'hWorldAll': _0x4d12c3, 'wWorldAll': _0x69bc93, 'fgColor': _0x1e8910, 'fontFamily': _0x670851, 'textCanvas': _0x44f58f, 'xScale': _0x1bc3aa, 'yScale': _0x12bd7f * _0xf363ef } } const texLoader = new TextureLoader(); class Icon extends Sprite { constructor(_0x5ad111) { const _0x1f0c1e = { _0xbf4cdd: 0x30a, _0x418261: 0x1c2 }, _0x107de3 = { _0x42a100: 0x408, _0x384375: 0x209, _0x4d58eb: 0x48d, _0x4a1f75: 0x15d, _0x5c1371: 0x2be, _0x2e58c5: 0x4c4, _0xc09a9a: 0x4c4 }, _0x5db97d = _0x48e965; super(); const _0x3d0ab3 = _0x5ad111['url']; let _0x419af9 = { 'position': [0x0, 0x0, 0x0], 'scale': [0x1, 0x1], 'sizeAttenuation': !![], 'publicPath': '', 'cb': _0x1f441e => { } }; _0x419af9 = Object[_0x5db97d(0x2c9)](_0x419af9, _0x5ad111), texLoader['load'](_0x419af9['publicPath'] + _0x3d0ab3, _0x2b00ef => { const _0x57d334 = _0x5db97d; _0x2b00ef['encoding'] = sRGBEncoding; const _0x4beaf2 = new SpriteMaterial({ 'map': _0x2b00ef, 'transparent': !![], 'sizeAttenuation': _0x419af9[_0x57d334(_0x107de3._0x42a100)], 'fog': ![] }); if (_0x5ad111[_0x57d334(_0x107de3._0x384375)] != undefined) _0x4beaf2['color'] = new Color(_0x5ad111['color']); this[_0x57d334(0x2f4)] = _0x4beaf2, this['scale'][_0x57d334(0x49f)](_0x419af9[_0x57d334(0x2be)][0x0] * (_0x2b00ef[_0x57d334(_0x107de3._0x4d58eb)][_0x57d334(_0x107de3._0x4a1f75)] / _0x2b00ef[_0x57d334(0x48d)][_0x57d334(0x496)]), _0x419af9[_0x57d334(_0x107de3._0x5c1371)][0x1], 0x1), this['position'][_0x57d334(0x49f)](_0x419af9[_0x57d334(_0x107de3._0x2e58c5)][0x0], _0x419af9[_0x57d334(_0x107de3._0xc09a9a)][0x1], _0x419af9[_0x57d334(0x4c4)][0x2]), _0x419af9['cb'] && _0x419af9['cb'](_0x2b00ef) }), this[_0x5db97d(0x1f0)] = _0x5db97d(_0x1f0c1e._0xbf4cdd), this[_0x5db97d(_0x1f0c1e._0x418261)] = ICON_RENDER_ORDER } } class CSS2DObject extends Object3D { constructor(_0x3cc69d) { const _0x17e0a3 = { _0x18a3b7: 0x421, _0x4e0fd5: 0x519, _0x290f32: 0x4be, _0x5677e6: 0x165, _0x2ec947: 0x300, _0x4126b3: 0x322 }, _0x455526 = { _0x44077c: 0x421, _0x344ade: 0x4a8 }, _0x29d427 = _0x48e965; super(), this[_0x29d427(_0x17e0a3._0x18a3b7)] = _0x3cc69d || document[_0x29d427(_0x17e0a3._0x4e0fd5)](_0x29d427(_0x17e0a3._0x290f32)), this['element'][_0x29d427(_0x17e0a3._0x5677e6)][_0x29d427(0x4c4)] = 'absolute', this['element'][_0x29d427(0x165)][_0x29d427(_0x17e0a3._0x2ec947)] = _0x29d427(0x504), this[_0x29d427(_0x17e0a3._0x18a3b7)][_0x29d427(_0x17e0a3._0x4126b3)](_0x29d427(0x1a5), ![]), this['addEventListener'](_0x29d427(0x477), function () { const _0x3094ea = _0x29d427; this[_0x3094ea(0x4a5)](function (_0xf313bb) { const _0x5847d0 = _0x3094ea; _0xf313bb[_0x5847d0(_0x455526._0x44077c)] instanceof Element && _0xf313bb[_0x5847d0(0x421)][_0x5847d0(_0x455526._0x344ade)] !== null && _0xf313bb[_0x5847d0(0x421)][_0x5847d0(0x4a8)]['removeChild'](_0xf313bb[_0x5847d0(_0x455526._0x44077c)]) }) }) } [_0x48e965(0x371)] (_0x210598, _0x4c9ad9) { const _0x2c6d54 = { _0x1c8884: 0x421 }, _0x5b852c = _0x48e965; return super['copy'](_0x210598, _0x4c9ad9), this[_0x5b852c(_0x2c6d54._0x1c8884)] = _0x210598[_0x5b852c(_0x2c6d54._0x1c8884)]['cloneNode'](!![]), this } } CSS2DObject[_0x48e965(0x4c2)][_0x48e965(0x369)] = !![], new Vector3(), new Matrix4(), new Matrix4(), new Vector3(), new Vector3(); class Popup extends CSS2DObject { [_0x48e965(0x1c1)]; constructor(_0x2e295c) { const _0x1a8b49 = { _0x394853: 0x399, _0x43a9df: 0x519, _0xcf34a0: 0x4be, _0x13dbb5: 0x1e1, _0xb808ba: 0x165, _0x27d032: 0x322, _0x1e92ee: 0x378, _0x5ed285: 0x546, _0x56504f: 0x4cb, _0x195ee6: 0x4f0, _0x434180: 0x4c4, _0xd8614f: 0x1c1, _0x465455: 0x1c1 }, _0x3dcf34 = _0x48e965; let _0x33e2c4 = { 'value': '', 'position': [0x0, 0x0, 0x0], 'className': '', 'style': '', 'closeVisible': _0x3dcf34(_0x1a8b49._0x394853), 'closeSize': 0x1, 'center': [-0.5, -0.5] }; _0x33e2c4 = Object['assign'](_0x33e2c4, _0x2e295c); const _0x2ba9a0 = document[_0x3dcf34(_0x1a8b49._0x43a9df)](_0x3dcf34(_0x1a8b49._0xcf34a0)); _0x2ba9a0['oncontextmenu'] = () => { return ![] }, _0x2ba9a0['innerHTML'] = _0x33e2c4[_0x3dcf34(0x27b)], _0x2ba9a0[_0x3dcf34(_0x1a8b49._0x13dbb5)] = _0x33e2c4['className'], _0x2ba9a0[_0x3dcf34(0x322)](_0x3dcf34(_0x1a8b49._0xb808ba), _0x33e2c4[_0x3dcf34(0x165)]); const _0x511556 = document['createElement'](_0x3dcf34(_0x1a8b49._0xcf34a0)); _0x511556[_0x3dcf34(_0x1a8b49._0x13dbb5)] = _0x3dcf34(0x3b8), document[_0x3dcf34(0x31b)][0x0][_0x3dcf34(0x213)](_0x3dcf34(0x4b7), 0x0), _0x511556[_0x3dcf34(_0x1a8b49._0x27d032)](_0x3dcf34(_0x1a8b49._0xb808ba), _0x3dcf34(0x53e) + _0x33e2c4[_0x3dcf34(_0x1a8b49._0x1e92ee)] + ')'), _0x511556[_0x3dcf34(_0x1a8b49._0xb808ba)][_0x3dcf34(_0x1a8b49._0x5ed285)] = _0x33e2c4[_0x3dcf34(_0x1a8b49._0x56504f)], _0x2ba9a0[_0x3dcf34(_0x1a8b49._0x195ee6)](_0x511556), super(_0x2ba9a0), this['position'][_0x3dcf34(0x49f)](_0x33e2c4[_0x3dcf34(_0x1a8b49._0x434180)][0x0], _0x33e2c4[_0x3dcf34(_0x1a8b49._0x434180)][0x1], _0x33e2c4[_0x3dcf34(_0x1a8b49._0x434180)][0x2]), this[_0x3dcf34(0x1c1)] = new Vector2(_0x33e2c4[_0x3dcf34(_0x1a8b49._0xd8614f)][0x0], _0x33e2c4[_0x3dcf34(_0x1a8b49._0x465455)][0x1]); const _0x2472af = this; _0x511556[_0x3dcf34(0x46e)] = () => { _0x2472af['visible'] = ![] } } } class Gif extends Sprite { constructor(_0x5ced26) { const _0xf386d5 = { _0x1c2871: 0x2c9, _0xa2477b: 0x16e, _0x204e85: 0x32e, _0x341986: 0x1d4 }, _0x350fa0 = { _0x5781dc: 0x2f4, _0x9b9fad: 0x49f, _0x4303e6: 0x1c2, _0x4925af: 0x1e9, _0x148f26: 0x1da }, _0x59dac3 = _0x48e965; super(); let _0x401a87 = { 'container': null, 'publicPath': '', 'url': '', 'scale': 0x1, 'position': [0x0, 0x0, 0x0] }; _0x401a87 = Object[_0x59dac3(_0xf386d5._0x1c2871)](_0x401a87, _0x5ced26), _0x401a87[_0x59dac3(0x1e9)] && _0x401a87[_0x59dac3(0x1e9)][_0x59dac3(_0xf386d5._0xa2477b)][_0x59dac3(_0xf386d5._0x204e85)](_0x401a87[_0x59dac3(0x283)] + _0x401a87[_0x59dac3(_0xf386d5._0x341986)], _0x3c743c => { const _0x558336 = _0x59dac3; this[_0x558336(_0x350fa0._0x5781dc)] = new SpriteMaterial({ 'map': _0x3c743c, 'transparent': !![], 'sizeAttenuation': ![], 'fog': ![] }), this['scale']['set'](_0x401a87['scale'] * _0x3c743c[_0x558336(0x48d)]['width'] / _0x3c743c[_0x558336(0x48d)]['height'], _0x401a87[_0x558336(0x2be)], 0x1), this[_0x558336(0x4c4)][_0x558336(_0x350fa0._0x9b9fad)](_0x401a87['position'][0x0], _0x401a87[_0x558336(0x4c4)][0x1], _0x401a87[_0x558336(0x4c4)][0x2]), this[_0x558336(_0x350fa0._0x4303e6)] = ICON_RENDER_ORDER, _0x401a87[_0x558336(_0x350fa0._0x4925af)]?.[_0x558336(0x3fe)][_0x558336(_0x350fa0._0x148f26)](_0x3c743c) }) } } class CSS3DObject extends Object3D { constructor(_0x295186) { const _0x1a6890 = { _0x1639f7: 0x421, _0x546d01: 0x4c4, _0x22774d: 0x1bb, _0x7c60b: 0x165, _0x59d6f: 0x322 }, _0x2980ca = _0x48e965; super(), this[_0x2980ca(_0x1a6890._0x1639f7)] = _0x295186 || document['createElement']('div'), this[_0x2980ca(0x421)]['style'][_0x2980ca(_0x1a6890._0x546d01)] = 'absolute', this[_0x2980ca(_0x1a6890._0x1639f7)][_0x2980ca(0x165)][_0x2980ca(_0x1a6890._0x22774d)] = 'auto', this[_0x2980ca(0x421)][_0x2980ca(_0x1a6890._0x7c60b)]['userSelect'] = _0x2980ca(0x504), this['element'][_0x2980ca(_0x1a6890._0x59d6f)](_0x2980ca(0x1a5), ![]), this['addEventListener']('removed', function () { const _0x20da4c = { _0x4224a2: 0x421, _0x2646ec: 0x506 }, _0xdfc19e = _0x2980ca; this[_0xdfc19e(0x4a5)](function (_0x4d8d95) { const _0x2bcc98 = _0xdfc19e; _0x4d8d95['element'] instanceof Element && _0x4d8d95['element']['parentNode'] !== null && _0x4d8d95[_0x2bcc98(_0x20da4c._0x4224a2)][_0x2bcc98(0x4a8)][_0x2bcc98(_0x20da4c._0x2646ec)](_0x4d8d95[_0x2bcc98(0x421)]) }) }) } [_0x48e965(0x371)] (_0x47cc05, _0x5cab77) { const _0x2c4471 = _0x48e965; return super['copy'](_0x47cc05, _0x5cab77), this[_0x2c4471(0x421)] = _0x47cc05['element']['cloneNode'](!![]), this } } CSS3DObject['prototype'][_0x48e965(0x315)] = !![]; class CSS3DSprite extends CSS3DObject { constructor(_0x179b04) { const _0x398702 = _0x48e965; super(_0x179b04), this[_0x398702(0x2e7)] = 0x0 } ['copy'] (_0x333ba2, _0x4e44da) { const _0x5edcde = { _0x56a8ee: 0x371, _0x4e79f2: 0x2e7 }, _0x507deb = _0x48e965; return super[_0x507deb(_0x5edcde._0x56a8ee)](_0x333ba2, _0x4e44da), this[_0x507deb(_0x5edcde._0x4e79f2)] = _0x333ba2['rotation2D'], this } } CSS3DSprite[_0x48e965(0x4c2)][_0x48e965(0x405)] = !![], new Matrix4(), new Matrix4(); class Popup3D extends CSS3DSprite { constructor(_0x2d9849) { const _0x63e178 = { _0xa40411: 0x399, _0x165f5f: 0x519, _0x54f9b6: 0x2a4, _0x5c3cb2: 0x27b, _0x3abea0: 0x4be, _0x1d8042: 0x1e1, _0x5dc862: 0x322, _0x599400: 0x161, _0x40c29f: 0x4c4, _0x19a132: 0x49f, _0x371823: 0x2be }, _0x19ea67 = { _0x406137: 0x399 }, _0x498fcf = _0x48e965; let _0x3b99b4 = { 'value': '', 'position': [0x0, 0x0, 0x0], 'className': '', 'closeVisible': _0x498fcf(_0x63e178._0xa40411), 'scale': [0x1, 0x1, 0x1] }; _0x3b99b4 = Object['assign'](_0x3b99b4, _0x2d9849); const _0x2411ad = document[_0x498fcf(_0x63e178._0x165f5f)]('div'); _0x2411ad[_0x498fcf(_0x63e178._0x54f9b6)] = _0x3b99b4[_0x498fcf(_0x63e178._0x5c3cb2)], _0x2411ad[_0x498fcf(0x1e1)] = _0x3b99b4[_0x498fcf(0x1e1)]; const _0x320a86 = document['createElement'](_0x498fcf(_0x63e178._0x3abea0)); _0x320a86[_0x498fcf(_0x63e178._0x1d8042)] = 'popup-close', _0x320a86[_0x498fcf(0x2a4)] = _0x498fcf(0x25f), _0x320a86[_0x498fcf(_0x63e178._0x5dc862)]('style', _0x498fcf(0x174)), _0x320a86[_0x498fcf(0x165)][_0x498fcf(0x546)] = _0x3b99b4[_0x498fcf(0x4cb)], _0x2411ad[_0x498fcf(0x4f0)](_0x320a86), _0x2411ad[_0x498fcf(0x4ff)](_0x498fcf(_0x63e178._0x599400), _0x13bc10 => { _0x13bc10['preventDefault']() }), super(_0x2411ad), this[_0x498fcf(_0x63e178._0x40c29f)][_0x498fcf(_0x63e178._0x19a132)](_0x3b99b4[_0x498fcf(0x4c4)][0x0], _0x3b99b4['position'][0x1], _0x3b99b4[_0x498fcf(0x4c4)][0x2]), this[_0x498fcf(0x2be)]['set'](_0x3b99b4[_0x498fcf(_0x63e178._0x371823)][0x0], _0x3b99b4[_0x498fcf(0x2be)][0x1], _0x3b99b4['scale'][0x2]); const _0x451148 = this; _0x320a86[_0x498fcf(0x46e)] = () => { const _0x15d61c = _0x498fcf; _0x451148[_0x15d61c(_0x19ea67._0x406137)] = ![] } } } const POI = { 'Text': Text, 'Icon': Icon, 'Popup': Popup, 'Gif': Gif, 'Popup3D': Popup3D }, _box$1 = new Box3(), _vector = new Vector3(); class LineSegmentsGeometry extends InstancedBufferGeometry { constructor() { const _0x4c824d = { _0x2c729c: 0x1f0, _0xcb903d: 0x322, _0x2948ca: 0x4c4, _0x14ddf1: 0x322 }, _0x160195 = _0x48e965; super(), this[_0x160195(_0x4c824d._0x2c729c)] = _0x160195(0x4d3); const _0x2faa69 = [-0x1, 0x2, 0x0, 0x1, 0x2, 0x0, -0x1, 0x1, 0x0, 0x1, 0x1, 0x0, -0x1, 0x0, 0x0, 0x1, 0x0, 0x0, -0x1, -0x1, 0x0, 0x1, -0x1, 0x0], _0x40000e = [-0x1, 0x2, 0x1, 0x2, -0x1, 0x1, 0x1, 0x1, -0x1, -0x1, 0x1, -0x1, -0x1, -0x2, 0x1, -0x2], _0x49e7e2 = [0x0, 0x2, 0x1, 0x2, 0x3, 0x1, 0x2, 0x4, 0x3, 0x4, 0x5, 0x3, 0x4, 0x6, 0x5, 0x6, 0x7, 0x5]; this['setIndex'](_0x49e7e2), this[_0x160195(_0x4c824d._0xcb903d)](_0x160195(_0x4c824d._0x2948ca), new Float32BufferAttribute(_0x2faa69, 0x3)), this[_0x160195(_0x4c824d._0x14ddf1)]('uv', new Float32BufferAttribute(_0x40000e, 0x2)) } [_0x48e965(0x24a)] (_0x3950f) { const _0x223ce7 = { _0x4d66ed: 0x176, _0x1d0d33: 0x3be, _0x5d8b39: 0x4f8 }, _0x4ab247 = _0x48e965, _0x346230 = this[_0x4ab247(_0x223ce7._0x4d66ed)][_0x4ab247(_0x223ce7._0x1d0d33)], _0x30b9f8 = this[_0x4ab247(_0x223ce7._0x4d66ed)][_0x4ab247(0x377)]; return _0x346230 !== undefined && (_0x346230[_0x4ab247(0x24a)](_0x3950f), _0x30b9f8[_0x4ab247(0x24a)](_0x3950f), _0x346230[_0x4ab247(_0x223ce7._0x5d8b39)] = !![]), this['boundingBox'] !== null && this[_0x4ab247(0x527)](), this[_0x4ab247(0x1c0)] !== null && this[_0x4ab247(0x41d)](), this } [_0x48e965(0x1ea)] (_0x5a7947) { const _0x1b5eb9 = { _0x5eecf4: 0x20e, _0x3037b5: 0x322, _0x86cd78: 0x377, _0x5d0caa: 0x41d }, _0x93e593 = _0x48e965; let _0x584131; if (_0x5a7947 instanceof Float32Array) _0x584131 = _0x5a7947; else Array[_0x93e593(_0x1b5eb9._0x5eecf4)](_0x5a7947) && (_0x584131 = new Float32Array(_0x5a7947)); const _0x21e4f4 = new InstancedInterleavedBuffer(_0x584131, 0x6, 0x1); return this[_0x93e593(_0x1b5eb9._0x3037b5)]('instanceStart', new InterleavedBufferAttribute(_0x21e4f4, 0x3, 0x0)), this['setAttribute'](_0x93e593(_0x1b5eb9._0x86cd78), new InterleavedBufferAttribute(_0x21e4f4, 0x3, 0x3)), this[_0x93e593(0x527)](), this[_0x93e593(_0x1b5eb9._0x5d0caa)](), this } [_0x48e965(0x2f1)] (_0x24cac9) { const _0x414ae1 = { _0x2932d0: 0x20e, _0x661978: 0x322, _0x399ad8: 0x3aa, _0x4e5e2a: 0x322 }, _0x3dceac = _0x48e965; let _0x229ea6; if (_0x24cac9 instanceof Float32Array) _0x229ea6 = _0x24cac9; else Array[_0x3dceac(_0x414ae1._0x2932d0)](_0x24cac9) && (_0x229ea6 = new Float32Array(_0x24cac9)); const _0x416df7 = new InstancedInterleavedBuffer(_0x229ea6, 0x6, 0x1); return this[_0x3dceac(_0x414ae1._0x661978)](_0x3dceac(_0x414ae1._0x399ad8), new InterleavedBufferAttribute(_0x416df7, 0x3, 0x0)), this[_0x3dceac(_0x414ae1._0x4e5e2a)](_0x3dceac(0x319), new InterleavedBufferAttribute(_0x416df7, 0x3, 0x3)), this } ['fromWireframeGeometry'] (_0x5295e2) { const _0x1ee674 = _0x48e965; return this[_0x1ee674(0x1ea)](_0x5295e2[_0x1ee674(0x176)][_0x1ee674(0x4c4)][_0x1ee674(0x30f)]), this } [_0x48e965(0x2a6)] (_0x268c50) { const _0xc6201b = { _0x48d83b: 0x4c4 }, _0x2967b3 = _0x48e965; return this[_0x2967b3(0x1ea)](_0x268c50[_0x2967b3(0x176)][_0x2967b3(_0xc6201b._0x48d83b)]['array']), this } [_0x48e965(0x204)] (_0x3c1c90) { const _0x2521a5 = { _0x475ba6: 0x1ee }, _0x471b30 = _0x48e965; return this[_0x471b30(_0x2521a5._0x475ba6)](new WireframeGeometry(_0x3c1c90[_0x471b30(0x303)])), this } [_0x48e965(0x462)] (_0x176a86) { const _0x446326 = { _0x3a980c: 0x361, _0x1fce9d: 0x4b1, _0x3ef196: 0x1ea, _0x210389: 0x176, _0x50ce4f: 0x4c4 }, _0x484dcc = _0x48e965, _0x18a32b = _0x176a86[_0x484dcc(0x303)]; if (_0x18a32b[_0x484dcc(_0x446326._0x3a980c)]) { console[_0x484dcc(0x4fb)](_0x484dcc(_0x446326._0x1fce9d)); return } else _0x18a32b[_0x484dcc(0x45d)] && this[_0x484dcc(_0x446326._0x3ef196)](_0x18a32b[_0x484dcc(_0x446326._0x210389)][_0x484dcc(_0x446326._0x50ce4f)][_0x484dcc(0x30f)]); return this } [_0x48e965(0x527)] () { const _0x2b8996 = { _0x51636c: 0x1cb, _0x439912: 0x430 }, _0x4eca89 = _0x48e965; this['boundingBox'] === null && (this[_0x4eca89(0x1cb)] = new Box3()); const _0x5e425d = this[_0x4eca89(0x176)][_0x4eca89(0x3be)], _0x11a2df = this[_0x4eca89(0x176)]['instanceEnd']; _0x5e425d !== undefined && _0x11a2df !== undefined && (this[_0x4eca89(_0x2b8996._0x51636c)][_0x4eca89(_0x2b8996._0x439912)](_0x5e425d), _box$1[_0x4eca89(0x430)](_0x11a2df), this[_0x4eca89(_0x2b8996._0x51636c)][_0x4eca89(0x480)](_box$1)) } [_0x48e965(0x41d)] () { const _0x573e3c = { _0x191a37: 0x1c0, _0x5c47dc: 0x1cb, _0x92465d: 0x527, _0x5a5e98: 0x176, _0x498cea: 0x3be, _0x3ee7a8: 0x3d1, _0x3540e9: 0x305, _0x187f2c: 0x3ba, _0x950cf8: 0x251 }, _0x2ac261 = _0x48e965; this[_0x2ac261(_0x573e3c._0x191a37)] === null && (this['boundingSphere'] = new Sphere()); this[_0x2ac261(_0x573e3c._0x5c47dc)] === null && this[_0x2ac261(_0x573e3c._0x92465d)](); const _0x77f8b0 = this[_0x2ac261(_0x573e3c._0x5a5e98)][_0x2ac261(_0x573e3c._0x498cea)], _0x4af900 = this['attributes'][_0x2ac261(0x377)]; if (_0x77f8b0 !== undefined && _0x4af900 !== undefined) { const _0x3cf3ef = this['boundingSphere'][_0x2ac261(0x1c1)]; this['boundingBox']['getCenter'](_0x3cf3ef); let _0x3fccc8 = 0x0; for (let _0x9113de = 0x0, _0x1a6b24 = _0x77f8b0[_0x2ac261(0x45b)]; _0x9113de < _0x1a6b24; _0x9113de++) { _vector[_0x2ac261(_0x573e3c._0x3ee7a8)](_0x77f8b0, _0x9113de), _0x3fccc8 = Math[_0x2ac261(_0x573e3c._0x3540e9)](_0x3fccc8, _0x3cf3ef[_0x2ac261(0x3ba)](_vector)), _vector[_0x2ac261(_0x573e3c._0x3ee7a8)](_0x4af900, _0x9113de), _0x3fccc8 = Math[_0x2ac261(0x305)](_0x3fccc8, _0x3cf3ef[_0x2ac261(_0x573e3c._0x187f2c)](_vector)) } this[_0x2ac261(_0x573e3c._0x191a37)][_0x2ac261(0x3da)] = Math['sqrt'](_0x3fccc8), isNaN(this[_0x2ac261(_0x573e3c._0x191a37)][_0x2ac261(0x3da)]) && console[_0x2ac261(0x4fb)](_0x2ac261(_0x573e3c._0x950cf8), this) } } [_0x48e965(0x16b)] () { } [_0x48e965(0x447)] (_0x12834a) { const _0x4a349e = { _0x349c87: 0x21c, _0x359d67: 0x414 }, _0x56dd22 = _0x48e965; return console[_0x56dd22(_0x4a349e._0x349c87)](_0x56dd22(_0x4a349e._0x359d67)), this[_0x56dd22(0x24a)](_0x12834a) } } LineSegmentsGeometry[_0x48e965(0x4c2)][_0x48e965(0x1bc)] = !![], UniformsLib$1['line'] = { 'linewidth': { 'value': 0x1 }, 'resolution': { 'value': new Vector2(0x1, 0x1) }, 'dashScale': { 'value': 0x1 }, 'dashSize': { 'value': 0x1 }, 'dashOffset': { 'value': 0x0 }, 'gapSize': { 'value': 0x1 }, 'opacity': { 'value': 0x1 } }, ShaderLib$1[_0x48e965(0x245)] = { 'uniforms': UniformsUtils$1['merge']([UniformsLib$1[_0x48e965(0x1be)], UniformsLib$1[_0x48e965(0x223)], UniformsLib$1[_0x48e965(0x245)]]), 'vertexShader': _0x48e965(0x269), 'fragmentShader': _0x48e965(0x404) }; function _0x3544 (_0x24f538, _0x27a455) { const _0x39b816 = _0x39b8(); return _0x3544 = function (_0x3544c5, _0x13c832) { _0x3544c5 = _0x3544c5 - 0x150; let _0x45ad3c = _0x39b816[_0x3544c5]; return _0x45ad3c }, _0x3544(_0x24f538, _0x27a455) } class LineMaterial extends ShaderMaterial { constructor(_0x17d8c0) { const _0x2f2927 = { _0x3351fc: 0x2b0, _0x7e2527: 0x245, _0x1b01ad: 0x245, _0x283fce: 0x3f8, _0x246b99: 0x20d }, _0x46e47a = { _0x3069d4: 0x4ca, _0x3fba69: 0x4f8, _0x4c9d30: 0x265, _0x26a975: 0x499, _0x49096c: 0x3d8 }, _0x4425a7 = { _0x6fa48d: 0x4ca, _0x14348d: 0x265 }, _0x1e3cb8 = { _0x130e8b: 0x234, _0xf27e38: 0x371 }, _0x475fa4 = { _0x260d90: 0x234, _0x4ea2d8: 0x219, _0x599348: 0x27b }, _0x4dd612 = { _0x476596: 0x27b }, _0x52ac86 = { _0x2eea1a: 0x234, _0x193a61: 0x236, _0x37feb7: 0x27b }, _0x4372f0 = { _0x30a68f: 0x1f9 }, _0x5c899b = { _0x2d6e07: 0x1c7, _0x54f6a8: 0x27b }, _0x340373 = { _0x46432c: 0x234, _0x4cd82f: 0x1c7, _0x188864: 0x27b }, _0x5c3c86 = { _0x4b2902: 0x277 }, _0x1a1d93 = { _0x3b6b78: 0x277 }, _0x5aa879 = { _0x24d532: 0x234, _0x45abeb: 0x2c8, _0x4af1e3: 0x27b }, _0x2d00ef = { _0x3a6fcf: 0x4d4, _0x34d01d: 0x4d4 }, _0xc5ffd9 = { _0x1d339a: 0x4d4 }, _0x2a254b = { _0x410631: 0x234 }, _0x267d78 = { _0x3bebba: 0x234, _0x427b70: 0x27b }, _0x90a47f = { _0x32545a: 0x3ab, _0x20399d: 0x27b }, _0x2e2e69 = _0x48e965; super({ 'type': 'LineMaterial', 'uniforms': UniformsUtils$1[_0x2e2e69(_0x2f2927._0x3351fc)](ShaderLib$1[_0x2e2e69(_0x2f2927._0x7e2527)][_0x2e2e69(0x234)]), 'vertexShader': ShaderLib$1[_0x2e2e69(_0x2f2927._0x1b01ad)][_0x2e2e69(0x42e)], 'fragmentShader': ShaderLib$1[_0x2e2e69(0x245)][_0x2e2e69(_0x2f2927._0x283fce)], 'clipping': !![] }), Object[_0x2e2e69(0x2a2)](this, { 'color': { 'enumerable': !![], 'get': function () { const _0x1f7d61 = _0x2e2e69; return this['uniforms'][_0x1f7d61(_0x90a47f._0x32545a)][_0x1f7d61(_0x90a47f._0x20399d)] }, 'set': function (_0x7e61c2) { const _0x4b0d12 = _0x2e2e69; this[_0x4b0d12(0x234)]['diffuse']['value'] = _0x7e61c2 } }, 'linewidth': { 'enumerable': !![], 'get': function () { const _0x502d2a = _0x2e2e69; return this[_0x502d2a(_0x267d78._0x3bebba)][_0x502d2a(0x4b2)][_0x502d2a(_0x267d78._0x427b70)] }, 'set': function (_0x13cb22) { const _0x5e1f79 = _0x2e2e69; this[_0x5e1f79(_0x2a254b._0x410631)]['linewidth'][_0x5e1f79(0x27b)] = _0x13cb22 } }, 'dashed': { 'enumerable': !![], 'get': function () { const _0x68598a = _0x2e2e69; return Boolean(_0x68598a(_0xc5ffd9._0x1d339a) in this[_0x68598a(0x265)]) }, 'set' (_0x3cd280) { const _0x3201a1 = _0x2e2e69; Boolean(_0x3cd280) !== Boolean(_0x3201a1(_0x2d00ef._0x3a6fcf) in this[_0x3201a1(0x265)]) && (this[_0x3201a1(0x4f8)] = !![]), _0x3cd280 === !![] ? this[_0x3201a1(0x265)][_0x3201a1(_0x2d00ef._0x34d01d)] = '' : delete this[_0x3201a1(0x265)][_0x3201a1(_0x2d00ef._0x34d01d)] } }, 'dashScale': { 'enumerable': !![], 'get': function () { const _0x31721a = _0x2e2e69; return this[_0x31721a(_0x5aa879._0x24d532)][_0x31721a(_0x5aa879._0x45abeb)][_0x31721a(_0x5aa879._0x4af1e3)] }, 'set': function (_0x55dcbd) { const _0x3a36b8 = _0x2e2e69; this[_0x3a36b8(0x234)]['dashScale']['value'] = _0x55dcbd } }, 'dashSize': { 'enumerable': !![], 'get': function () { const _0xa85527 = _0x2e2e69; return this[_0xa85527(0x234)][_0xa85527(_0x1a1d93._0x3b6b78)]['value'] }, 'set': function (_0x3f680e) { const _0x19c455 = _0x2e2e69; this[_0x19c455(0x234)][_0x19c455(_0x5c3c86._0x4b2902)]['value'] = _0x3f680e } }, 'dashOffset': { 'enumerable': !![], 'get': function () { const _0x1cdabe = _0x2e2e69; return this[_0x1cdabe(_0x340373._0x46432c)][_0x1cdabe(_0x340373._0x4cd82f)][_0x1cdabe(_0x340373._0x188864)] }, 'set': function (_0x18afb4) { const _0x55836f = _0x2e2e69; this['uniforms'][_0x55836f(_0x5c899b._0x2d6e07)][_0x55836f(_0x5c899b._0x54f6a8)] = _0x18afb4 } }, 'gapSize': { 'enumerable': !![], 'get': function () { const _0x230523 = _0x2e2e69; return this[_0x230523(0x234)][_0x230523(0x1f9)]['value'] }, 'set': function (_0x3d998d) { const _0x4d37e5 = _0x2e2e69; this[_0x4d37e5(0x234)][_0x4d37e5(_0x4372f0._0x30a68f)]['value'] = _0x3d998d } }, 'opacity': { 'enumerable': !![], 'get': function () { const _0x47afd9 = _0x2e2e69; return this[_0x47afd9(_0x52ac86._0x2eea1a)][_0x47afd9(_0x52ac86._0x193a61)][_0x47afd9(_0x52ac86._0x37feb7)] }, 'set': function (_0x164c67) { const _0x5ac254 = _0x2e2e69; this[_0x5ac254(0x234)][_0x5ac254(0x236)][_0x5ac254(_0x4dd612._0x476596)] = _0x164c67 } }, 'resolution': { 'enumerable': !![], 'get': function () { const _0x826215 = _0x2e2e69; return this[_0x826215(_0x475fa4._0x260d90)][_0x826215(_0x475fa4._0x4ea2d8)][_0x826215(_0x475fa4._0x599348)] }, 'set': function (_0xa97873) { const _0x2dcf19 = _0x2e2e69; this[_0x2dcf19(_0x1e3cb8._0x130e8b)]['resolution'][_0x2dcf19(0x27b)][_0x2dcf19(_0x1e3cb8._0xf27e38)](_0xa97873) } }, 'alphaToCoverage': { 'enumerable': !![], 'get': function () { const _0x574017 = _0x2e2e69; return Boolean(_0x574017(_0x4425a7._0x6fa48d) in this[_0x574017(_0x4425a7._0x14348d)]) }, 'set': function (_0x179f36) { const _0x8c320a = _0x2e2e69; Boolean(_0x179f36) !== Boolean(_0x8c320a(_0x46e47a._0x3069d4) in this['defines']) && (this[_0x8c320a(_0x46e47a._0x3fba69)] = !![]), _0x179f36 === !![] ? (this[_0x8c320a(_0x46e47a._0x4c9d30)][_0x8c320a(0x4ca)] = '', this[_0x8c320a(0x499)][_0x8c320a(0x3d8)] = !![]) : (delete this[_0x8c320a(0x265)][_0x8c320a(0x4ca)], this[_0x8c320a(_0x46e47a._0x26a975)][_0x8c320a(_0x46e47a._0x49096c)] = ![]) } } }), this[_0x2e2e69(_0x2f2927._0x246b99)](_0x17d8c0) } } LineMaterial['prototype'][_0x48e965(0x3ca)] = !![]; const _start = new Vector3(), _end = new Vector3(), _start4 = new Vector4(), _end4 = new Vector4(), _ssOrigin = new Vector4(), _ssOrigin3 = new Vector3(), _mvMatrix = new Matrix4(), _line = new Line3(), _closestPoint = new Vector3(), _box = new Box3(), _sphere = new Sphere(), _clipToWorldVector = new Vector4(); class LineSegments2 extends Mesh { constructor(_0x6f5dab = new LineSegmentsGeometry(), _0x468cac = new LineMaterial({ 'color': Math[_0x48e965(0x225)]() * 0xffffff })) { const _0x25f187 = { _0x12f590: 0x2c7 }, _0x174582 = _0x48e965; super(_0x6f5dab, _0x468cac), this[_0x174582(0x1f0)] = _0x174582(_0x25f187._0x12f590) } ['computeLineDistances'] () { const _0x2a366b = { _0x13e02b: 0x45b, _0x38e0e4: 0x45b, _0x1c8c86: 0x3d1, _0x4a5a5b: 0x3fa, _0x1479d8: 0x322, _0x1b046a: 0x198 }, _0x1c4a70 = _0x48e965, _0x190608 = this[_0x1c4a70(0x303)], _0x461994 = _0x190608[_0x1c4a70(0x176)][_0x1c4a70(0x3be)], _0x432f5a = _0x190608[_0x1c4a70(0x176)][_0x1c4a70(0x377)], _0x23f88d = new Float32Array(0x2 * _0x461994[_0x1c4a70(_0x2a366b._0x13e02b)]); for (let _0x50dbce = 0x0, _0x33f46c = 0x0, _0x33e561 = _0x461994[_0x1c4a70(_0x2a366b._0x38e0e4)]; _0x50dbce < _0x33e561; _0x50dbce++, _0x33f46c += 0x2) { _start[_0x1c4a70(_0x2a366b._0x1c8c86)](_0x461994, _0x50dbce), _end[_0x1c4a70(_0x2a366b._0x1c8c86)](_0x432f5a, _0x50dbce), _0x23f88d[_0x33f46c] = _0x33f46c === 0x0 ? 0x0 : _0x23f88d[_0x33f46c - 0x1], _0x23f88d[_0x33f46c + 0x1] = _0x23f88d[_0x33f46c] + _start[_0x1c4a70(_0x2a366b._0x4a5a5b)](_end) } const _0x2597f4 = new InstancedInterleavedBuffer(_0x23f88d, 0x2, 0x1); return _0x190608[_0x1c4a70(0x322)]('instanceDistanceStart', new InterleavedBufferAttribute(_0x2597f4, 0x1, 0x0)), _0x190608[_0x1c4a70(_0x2a366b._0x1479d8)](_0x1c4a70(_0x2a366b._0x1b046a), new InterleavedBufferAttribute(_0x2597f4, 0x1, 0x1)), this } ['raycast'] (_0x3fd62d, _0x5b9763) { const _0x2c7191 = { _0x110da9: 0x29d, _0x118cb7: 0x407, _0xa8eb64: 0x3bb, _0x484749: 0x332, _0x4fdc88: 0x2bb, _0x190f6f: 0x4b2, _0x3530c8: 0x176, _0xc8fda5: 0x377, _0x802184: 0x15d, _0x320afc: 0x24a, _0x2f7291: 0x305, _0x9981c9: 0x43d, _0x59ab96: 0x24a, _0xf3d44: 0x538, _0x37c035: 0x371, _0x15b89c: 0x1cb, _0x3b43d9: 0x305, _0x1b8d9b: 0x3d2, _0x3d6cb5: 0x332, _0x7bd4bc: 0x25b, _0x5815f2: 0x4f4, _0x1164b7: 0x20c, _0x5066c3: 0x45b, _0x22d5f4: 0x3d1, _0x22779d: 0x3d1, _0x32da33: 0x36e, _0x35e659: 0x24a, _0x52ce1d: 0x1ef, _0x3067e7: 0x4e9, _0x52d5a0: 0x351, _0x283667: 0x3fa, _0x2779ed: 0x4e9, _0x309674: 0x4e9 }, _0x39d096 = _0x48e965; _0x3fd62d['camera'] === null && console['error'](_0x39d096(_0x2c7191._0x110da9)); const _0x5dd4ba = _0x3fd62d[_0x39d096(0x3ad)][_0x39d096(0x360)] !== undefined ? _0x3fd62d['params']['Line2'][_0x39d096(_0x2c7191._0x118cb7)] || 0x0 : 0x0, _0x160a5c = _0x3fd62d[_0x39d096(_0x2c7191._0xa8eb64)], _0x4eecfa = _0x3fd62d[_0x39d096(0x1a1)], _0x56e683 = _0x4eecfa[_0x39d096(_0x2c7191._0x484749)], _0x589780 = this[_0x39d096(_0x2c7191._0x4fdc88)], _0x2f5e61 = this[_0x39d096(0x303)], _0x29e337 = this['material'], _0xd7f719 = _0x29e337['resolution'], _0x250c7c = _0x29e337[_0x39d096(_0x2c7191._0x190f6f)] + _0x5dd4ba, _0x413e24 = _0x2f5e61[_0x39d096(_0x2c7191._0x3530c8)][_0x39d096(0x3be)], _0x82d938 = _0x2f5e61[_0x39d096(_0x2c7191._0x3530c8)][_0x39d096(_0x2c7191._0xc8fda5)], _0x597b11 = -_0x4eecfa[_0x39d096(0x177)], _0x57c681 = 0x2 * Math[_0x39d096(0x305)](_0x250c7c / _0xd7f719[_0x39d096(_0x2c7191._0x802184)], _0x250c7c / _0xd7f719[_0x39d096(0x496)]); _0x2f5e61['boundingSphere'] === null && _0x2f5e61['computeBoundingSphere'](); _sphere[_0x39d096(0x371)](_0x2f5e61['boundingSphere'])[_0x39d096(_0x2c7191._0x320afc)](_0x589780); const _0x19ae6b = Math[_0x39d096(_0x2c7191._0x2f7291)](_0x4eecfa['near'], _sphere[_0x39d096(_0x2c7191._0x9981c9)](_0x160a5c[_0x39d096(0x3d2)])); _clipToWorldVector['set'](0x0, 0x0, -_0x19ae6b, 0x1)[_0x39d096(_0x2c7191._0x59ab96)](_0x4eecfa['projectionMatrix']), _clipToWorldVector[_0x39d096(0x20c)](0x1 / _clipToWorldVector['w']), _clipToWorldVector['applyMatrix4'](_0x4eecfa[_0x39d096(_0x2c7191._0xf3d44)]); const _0x5f4c40 = Math['abs'](_0x57c681 / _clipToWorldVector['w']) * 0.5; _sphere[_0x39d096(0x3da)] += _0x5f4c40; if (_0x3fd62d[_0x39d096(0x3bb)]['intersectsSphere'](_sphere) === ![]) return; _0x2f5e61['boundingBox'] === null && _0x2f5e61[_0x39d096(0x527)](); _box[_0x39d096(_0x2c7191._0x37c035)](_0x2f5e61[_0x39d096(_0x2c7191._0x15b89c)])[_0x39d096(0x24a)](_0x589780); const _0x1e130d = Math[_0x39d096(_0x2c7191._0x3b43d9)](_0x4eecfa[_0x39d096(0x177)], _box[_0x39d096(_0x2c7191._0x9981c9)](_0x160a5c[_0x39d096(_0x2c7191._0x1b8d9b)])); _clipToWorldVector[_0x39d096(0x49f)](0x0, 0x0, -_0x1e130d, 0x1)[_0x39d096(_0x2c7191._0x320afc)](_0x4eecfa[_0x39d096(_0x2c7191._0x3d6cb5)]), _clipToWorldVector['multiplyScalar'](0x1 / _clipToWorldVector['w']), _clipToWorldVector['applyMatrix4'](_0x4eecfa[_0x39d096(0x538)]); const _0x1efd16 = Math[_0x39d096(0x367)](_0x57c681 / _clipToWorldVector['w']) * 0.5; _box['max']['x'] += _0x1efd16, _box['max']['y'] += _0x1efd16, _box['max']['z'] += _0x1efd16, _box[_0x39d096(_0x2c7191._0x7bd4bc)]['x'] -= _0x1efd16, _box['min']['y'] -= _0x1efd16, _box[_0x39d096(0x25b)]['z'] -= _0x1efd16; if (_0x3fd62d[_0x39d096(0x3bb)][_0x39d096(0x431)](_box) === ![]) return; _0x160a5c['at'](0x1, _ssOrigin), _ssOrigin['w'] = 0x1, _ssOrigin[_0x39d096(0x24a)](_0x4eecfa[_0x39d096(_0x2c7191._0x5815f2)]), _ssOrigin[_0x39d096(0x24a)](_0x56e683), _ssOrigin[_0x39d096(_0x2c7191._0x1164b7)](0x1 / _ssOrigin['w']), _ssOrigin['x'] *= _0xd7f719['x'] / 0x2, _ssOrigin['y'] *= _0xd7f719['y'] / 0x2, _ssOrigin['z'] = 0x0, _ssOrigin3['copy'](_ssOrigin), _mvMatrix[_0x39d096(0x48b)](_0x4eecfa[_0x39d096(_0x2c7191._0x5815f2)], _0x589780); for (let _0x27b90a = 0x0, _0x4e2de5 = _0x413e24[_0x39d096(_0x2c7191._0x5066c3)]; _0x27b90a < _0x4e2de5; _0x27b90a++) { _start4[_0x39d096(_0x2c7191._0x22d5f4)](_0x413e24, _0x27b90a), _end4[_0x39d096(_0x2c7191._0x22779d)](_0x82d938, _0x27b90a), _start4['w'] = 0x1, _end4['w'] = 0x1, _start4[_0x39d096(0x24a)](_mvMatrix), _end4['applyMatrix4'](_mvMatrix); var _0x411f6e = _start4['z'] > _0x597b11 && _end4['z'] > _0x597b11; if (_0x411f6e) continue; if (_start4['z'] > _0x597b11) { const _0x3173d4 = _start4['z'] - _end4['z'], _0x540c3d = (_start4['z'] - _0x597b11) / _0x3173d4; _start4[_0x39d096(_0x2c7191._0x32da33)](_end4, _0x540c3d) } else { if (_end4['z'] > _0x597b11) { const _0x227778 = _end4['z'] - _start4['z'], _0x581974 = (_end4['z'] - _0x597b11) / _0x227778; _end4[_0x39d096(0x36e)](_start4, _0x581974) } } _start4[_0x39d096(_0x2c7191._0x35e659)](_0x56e683), _end4[_0x39d096(_0x2c7191._0x35e659)](_0x56e683), _start4[_0x39d096(0x20c)](0x1 / _start4['w']), _end4['multiplyScalar'](0x1 / _end4['w']), _start4['x'] *= _0xd7f719['x'] / 0x2, _start4['y'] *= _0xd7f719['y'] / 0x2, _end4['x'] *= _0xd7f719['x'] / 0x2, _end4['y'] *= _0xd7f719['y'] / 0x2, _line['start']['copy'](_start4), _line[_0x39d096(_0x2c7191._0x52ce1d)]['z'] = 0x0, _line[_0x39d096(0x4e9)]['copy'](_end4), _line[_0x39d096(_0x2c7191._0x3067e7)]['z'] = 0x0; const _0x110da1 = _line[_0x39d096(_0x2c7191._0x52d5a0)](_ssOrigin3, !![]); _line['at'](_0x110da1, _closestPoint); const _0x2d8f10 = MathUtils[_0x39d096(0x36e)](_start4['z'], _end4['z'], _0x110da1), _0x2312bc = _0x2d8f10 >= -0x1 && _0x2d8f10 <= 0x1, _0x2f87a6 = _ssOrigin3[_0x39d096(_0x2c7191._0x283667)](_closestPoint) < _0x250c7c * 0.5; if (_0x2312bc && _0x2f87a6) { _line['start'][_0x39d096(0x3d1)](_0x413e24, _0x27b90a), _line[_0x39d096(_0x2c7191._0x2779ed)][_0x39d096(0x3d1)](_0x82d938, _0x27b90a), _line[_0x39d096(0x1ef)][_0x39d096(0x24a)](_0x589780), _line[_0x39d096(_0x2c7191._0x309674)][_0x39d096(0x24a)](_0x589780); const _0x427f7b = new Vector3(), _0x62da6e = new Vector3(); _0x160a5c[_0x39d096(0x15b)](_line[_0x39d096(0x1ef)], _line[_0x39d096(0x4e9)], _0x62da6e, _0x427f7b), _0x5b9763[_0x39d096(0x1da)]({ 'point': _0x62da6e, 'pointOnLine': _0x427f7b, 'distance': _0x160a5c[_0x39d096(_0x2c7191._0x1b8d9b)][_0x39d096(0x3fa)](_0x62da6e), 'object': this, 'face': null, 'faceIndex': _0x27b90a, 'uv': null, 'uv2': null }) } } } } LineSegments2[_0x48e965(0x4c2)][_0x48e965(0x2c7)] = !![]; class LineGeometry extends LineSegmentsGeometry { constructor() { const _0x352411 = _0x48e965; super(), this[_0x352411(0x1f0)] = _0x352411(0x4c3) } ['setPositions'] (_0x1f9e4f) { const _0x597e81 = _0x48e965; var _0x299d0a = _0x1f9e4f['length'] - 0x3, _0x30456a = new Float32Array(0x2 * _0x299d0a); for (var _0x5143d7 = 0x0; _0x5143d7 < _0x299d0a; _0x5143d7 += 0x3) { _0x30456a[0x2 * _0x5143d7] = _0x1f9e4f[_0x5143d7], _0x30456a[0x2 * _0x5143d7 + 0x1] = _0x1f9e4f[_0x5143d7 + 0x1], _0x30456a[0x2 * _0x5143d7 + 0x2] = _0x1f9e4f[_0x5143d7 + 0x2], _0x30456a[0x2 * _0x5143d7 + 0x3] = _0x1f9e4f[_0x5143d7 + 0x3], _0x30456a[0x2 * _0x5143d7 + 0x4] = _0x1f9e4f[_0x5143d7 + 0x4], _0x30456a[0x2 * _0x5143d7 + 0x5] = _0x1f9e4f[_0x5143d7 + 0x5] } return super[_0x597e81(0x1ea)](_0x30456a), this } [_0x48e965(0x2f1)] (_0x119cab) { const _0x1f98d4 = { _0x29d830: 0x321, _0x3b0853: 0x2f1 }, _0x3b1a42 = _0x48e965; var _0x217634 = _0x119cab[_0x3b1a42(_0x1f98d4._0x29d830)] - 0x3, _0x498f33 = new Float32Array(0x2 * _0x217634); for (var _0x503e5e = 0x0; _0x503e5e < _0x217634; _0x503e5e += 0x3) { _0x498f33[0x2 * _0x503e5e] = _0x119cab[_0x503e5e], _0x498f33[0x2 * _0x503e5e + 0x1] = _0x119cab[_0x503e5e + 0x1], _0x498f33[0x2 * _0x503e5e + 0x2] = _0x119cab[_0x503e5e + 0x2], _0x498f33[0x2 * _0x503e5e + 0x3] = _0x119cab[_0x503e5e + 0x3], _0x498f33[0x2 * _0x503e5e + 0x4] = _0x119cab[_0x503e5e + 0x4], _0x498f33[0x2 * _0x503e5e + 0x5] = _0x119cab[_0x503e5e + 0x5] } return super[_0x3b1a42(_0x1f98d4._0x3b0853)](_0x498f33), this } [_0x48e965(0x3ee)] (_0x8196fe) { const _0x3465f0 = { _0x33810f: 0x1ea, _0x1b4f54: 0x176, _0x352ec2: 0x4c4 }, _0x34ee69 = _0x48e965; var _0x4f0275 = _0x8196fe['geometry']; if (_0x4f0275['isGeometry']) { console[_0x34ee69(0x4fb)](_0x34ee69(0x35c)); return } else _0x4f0275['isBufferGeometry'] && this[_0x34ee69(_0x3465f0._0x33810f)](_0x4f0275[_0x34ee69(_0x3465f0._0x1b4f54)][_0x34ee69(_0x3465f0._0x352ec2)]['array']); return this } } LineGeometry['prototype'][_0x48e965(0x1c6)] = !![]; class Line2 extends LineSegments2 { constructor(_0xaa298f = new LineGeometry(), _0xcb79e9 = new LineMaterial({ 'color': Math[_0x48e965(0x225)]() * 0xffffff })) { const _0x45bafe = { _0x166e99: 0x360 }, _0x3f1771 = _0x48e965; super(_0xaa298f, _0xcb79e9), this['type'] = _0x3f1771(_0x45bafe._0x166e99) } } Line2[_0x48e965(0x4c2)][_0x48e965(0x1cf)] = !![]; const vertexShader = _0x48e965(0x3e3), fragmentShader = _0x48e965(0x436); class BaseLineMaterial extends ShaderMaterial { [_0x48e965(0x3ca)] = !![]; constructor(_0x26d8c6) { const _0x166100 = { _0x2e236c: 0x234, _0x5d84aa: 0x277, _0x48fa62: 0x1c7, _0x435c71: 0x22e, _0x3067ae: 0x263 }, _0x552e4b = _0x48e965; super(), this[_0x552e4b(_0x166100._0x2e236c)] = mergeUniforms([UniformsLib[_0x552e4b(0x1be)], UniformsLib['fog'], cloneUniforms({ 'lineWidth': { 'value': _0x26d8c6?.[_0x552e4b(0x2dc)] }, 'resolution': { 'value': new Vector2(window[_0x552e4b(0x24b)], window[_0x552e4b(0x221)]) }, 'dashScale': { 'value': 0x1 }, 'dashSize': { 'value': _0x26d8c6?.[_0x552e4b(_0x166100._0x5d84aa)] }, 'dashOffset': { 'value': _0x26d8c6?.[_0x552e4b(_0x166100._0x48fa62)] }, 'gapSize': { 'value': _0x26d8c6?.[_0x552e4b(0x1f9)] }, 'opacity': { 'value': 0x1 }, 'attenuation': { 'value': _0x26d8c6?.[_0x552e4b(_0x166100._0x435c71)] } })]), this[_0x552e4b(_0x166100._0x3067ae)] = !![], this['color'] = new Color(_0x26d8c6?.[_0x552e4b(0x209)]), this[_0x552e4b(0x42e)] = vertexShader, this['fragmentShader'] = fragmentShader } get ['color'] () { const _0x4fcc41 = { _0x24a0c1: 0x3ab }, _0x2a99dd = _0x48e965; return this['uniforms'][_0x2a99dd(_0x4fcc41._0x24a0c1)][_0x2a99dd(0x27b)] } set [_0x48e965(0x209)] (_0x2e492a) { const _0x341b09 = { _0x5e536b: 0x234, _0x65cd28: 0x3ab }, _0xf910b9 = _0x48e965; this[_0xf910b9(_0x341b09._0x5e536b)][_0xf910b9(_0x341b09._0x65cd28)]['value'] = _0x2e492a } get [_0x48e965(0x2dc)] () { const _0x59feb8 = { _0x12aba2: 0x234 }, _0x281405 = _0x48e965; return this[_0x281405(_0x59feb8._0x12aba2)]['lineWidth']['value'] } set [_0x48e965(0x2dc)] (_0x39ae40) { const _0xdd947 = _0x48e965; this[_0xdd947(0x234)][_0xdd947(0x2dc)][_0xdd947(0x27b)] = _0x39ae40 } get [_0x48e965(0x3f2)] () { const _0x332a48 = { _0x5f967: 0x4d4, _0xbd146: 0x265 }, _0x3c3116 = _0x48e965; return Boolean(_0x3c3116(_0x332a48._0x5f967) in this[_0x3c3116(_0x332a48._0xbd146)]) } set ['dashed'] (_0x395c00) { const _0x3b5a09 = { _0x297215: 0x265, _0xe3faca: 0x265 }, _0x6a7f42 = _0x48e965; Boolean(_0x395c00) !== Boolean('USE_DASH' in this[_0x6a7f42(_0x3b5a09._0x297215)]) && (this[_0x6a7f42(0x4f8)] = !![]), _0x395c00 === !![] ? this[_0x6a7f42(0x265)][_0x6a7f42(0x4d4)] = '' : delete this[_0x6a7f42(_0x3b5a09._0xe3faca)][_0x6a7f42(0x4d4)] } get ['dashScale'] () { const _0x456880 = { _0x689ed: 0x2c8 }, _0x2c2d10 = _0x48e965; return this['uniforms'][_0x2c2d10(_0x456880._0x689ed)][_0x2c2d10(0x27b)] } set ['dashScale'] (_0x2b4555) { const _0x20c80a = { _0x331b6a: 0x2c8, _0x5d1cce: 0x27b }, _0x237091 = _0x48e965; this[_0x237091(0x234)][_0x237091(_0x20c80a._0x331b6a)][_0x237091(_0x20c80a._0x5d1cce)] = _0x2b4555 } get ['dashSize'] () { const _0x291ab3 = { _0x1fabca: 0x234, _0x435ccc: 0x27b }, _0x8a0b12 = _0x48e965; return this[_0x8a0b12(_0x291ab3._0x1fabca)]['dashSize'][_0x8a0b12(_0x291ab3._0x435ccc)] } set [_0x48e965(0x277)] (_0xbe3f0) { const _0x249555 = { _0x2f3423: 0x27b }, _0x52b5bf = _0x48e965; this[_0x52b5bf(0x234)][_0x52b5bf(0x277)][_0x52b5bf(_0x249555._0x2f3423)] = _0xbe3f0 } get [_0x48e965(0x1c7)] () { const _0x118ca4 = { _0x2175d6: 0x234, _0x29d5f4: 0x1c7 }, _0x543f01 = _0x48e965; return this[_0x543f01(_0x118ca4._0x2175d6)][_0x543f01(_0x118ca4._0x29d5f4)][_0x543f01(0x27b)] } set [_0x48e965(0x1c7)] (_0x48ab16) { const _0x267765 = { _0x592c85: 0x27b }, _0x20501e = _0x48e965; this[_0x20501e(0x234)][_0x20501e(0x1c7)][_0x20501e(_0x267765._0x592c85)] = _0x48ab16 } get [_0x48e965(0x1f9)] () { const _0x4f4d90 = _0x48e965; return this[_0x4f4d90(0x234)][_0x4f4d90(0x1f9)]['value'] } set [_0x48e965(0x1f9)] (_0x463220) { const _0x188087 = { _0x1a5058: 0x27b }, _0x4191f7 = _0x48e965; this['uniforms'][_0x4191f7(0x1f9)][_0x4191f7(_0x188087._0x1a5058)] = _0x463220 } get [_0x48e965(0x219)] () { const _0x1971f3 = _0x48e965; return this['uniforms'][_0x1971f3(0x219)][_0x1971f3(0x27b)] } set ['resolution'] (_0x273861) { const _0x14a775 = { _0x29cab3: 0x219, _0x303ae7: 0x27b }, _0x85b116 = _0x48e965; this[_0x85b116(0x234)][_0x85b116(_0x14a775._0x29cab3)][_0x85b116(_0x14a775._0x303ae7)]['copy'](_0x273861) } } class BaseLine extends Line2 { [_0x48e965(0x2f4)];[_0x48e965(0x384)]; constructor(_0xd23b7a) { const _0x53e051 = { _0x5447be: 0x303, _0xf2a57c: 0x384 }, _0x364de6 = _0x48e965; super(), this[_0x364de6(0x2f4)] = new BaseLineMaterial(_0xd23b7a), this[_0x364de6(_0x53e051._0x5447be)] = new LineGeometry(), this[_0x364de6(_0x53e051._0xf2a57c)] = 0x0 } ['setPositions'] (_0x5eb09d) { const _0x38a36e = { _0x150dca: 0x1ea, _0x1bb3b9: 0x200, _0x195895: 0x384, _0x414872: 0x321, _0x88e606: 0x277, _0x1f5a35: 0x1f9, _0x30da89: 0x384 }, _0x3d63e5 = _0x48e965; this['geometry'][_0x3d63e5(_0x38a36e._0x150dca)](_0x5eb09d), this[_0x3d63e5(_0x38a36e._0x1bb3b9)](), this[_0x3d63e5(_0x38a36e._0x195895)] = 0x0; for (let _0x4cb26f = 0x0; _0x4cb26f < _0x5eb09d[_0x3d63e5(_0x38a36e._0x414872)] - 0x3; _0x4cb26f += 0x3) { const _0x24206e = new Vector3(_0x5eb09d[_0x4cb26f], _0x5eb09d[_0x4cb26f + 0x1], _0x5eb09d[_0x4cb26f + 0x2]), _0x2090ee = new Vector3(_0x5eb09d[_0x4cb26f + 0x3], _0x5eb09d[_0x4cb26f + 0x1 + 0x3], _0x5eb09d[_0x4cb26f + 0x2 + 0x3]), _0x47e43b = _0x24206e[_0x3d63e5(0x3fa)](_0x2090ee); this['totalDistance'] += _0x47e43b } this['material'][_0x3d63e5(_0x38a36e._0x88e606)] = this[_0x3d63e5(0x384)] / 0x2, this['material'][_0x3d63e5(_0x38a36e._0x1f5a35)] = this[_0x3d63e5(_0x38a36e._0x30da89)] / 0x2 } ['setColors'] (_0x33aa38) { const _0x1015cd = _0x48e965; this['geometry'][_0x1015cd(0x517)](_0x33aa38) } } var earcut_1 = earcut, default_1 = earcut; function earcut (_0x38a46b, _0x235424, _0x16576d) { const _0x1e1931 = { _0x577d21: 0x321, _0x2883e6: 0x425 }, _0x4eca00 = _0x48e965; _0x16576d = _0x16576d || 0x2; var _0x11b80c = _0x235424 && _0x235424['length'], _0x165a9c = _0x11b80c ? _0x235424[0x0] * _0x16576d : _0x38a46b[_0x4eca00(_0x1e1931._0x577d21)], _0x465716 = linkedList(_0x38a46b, 0x0, _0x165a9c, _0x16576d, !![]), _0x59b980 = []; if (!_0x465716 || _0x465716[_0x4eca00(_0x1e1931._0x2883e6)] === _0x465716[_0x4eca00(0x1f4)]) return _0x59b980; var _0x59c9fa, _0x53ce0e, _0x3c2fe3, _0x481fa8, _0x43d235, _0x290bbc, _0x136724; if (_0x11b80c) _0x465716 = eliminateHoles(_0x38a46b, _0x235424, _0x465716, _0x16576d); if (_0x38a46b[_0x4eca00(0x321)] > 0x50 * _0x16576d) { _0x59c9fa = _0x3c2fe3 = _0x38a46b[0x0], _0x53ce0e = _0x481fa8 = _0x38a46b[0x1]; for (var _0x5449af = _0x16576d; _0x5449af < _0x165a9c; _0x5449af += _0x16576d) { _0x43d235 = _0x38a46b[_0x5449af], _0x290bbc = _0x38a46b[_0x5449af + 0x1]; if (_0x43d235 < _0x59c9fa) _0x59c9fa = _0x43d235; if (_0x290bbc < _0x53ce0e) _0x53ce0e = _0x290bbc; if (_0x43d235 > _0x3c2fe3) _0x3c2fe3 = _0x43d235; if (_0x290bbc > _0x481fa8) _0x481fa8 = _0x290bbc } _0x136724 = Math[_0x4eca00(0x305)](_0x3c2fe3 - _0x59c9fa, _0x481fa8 - _0x53ce0e), _0x136724 = _0x136724 !== 0x0 ? 0x7fff / _0x136724 : 0x0 } return earcutLinked(_0x465716, _0x59b980, _0x16576d, _0x59c9fa, _0x53ce0e, _0x136724, 0x0), _0x59b980 } function linkedList (_0x325458, _0x12724f, _0x5832f8, _0x5958c2, _0x4fbf50) { const _0x48b1c2 = _0x48e965; var _0x1d48ae, _0x4f10ae; if (_0x4fbf50 === signedArea(_0x325458, _0x12724f, _0x5832f8, _0x5958c2) > 0x0) { for (_0x1d48ae = _0x12724f; _0x1d48ae < _0x5832f8; _0x1d48ae += _0x5958c2)_0x4f10ae = insertNode(_0x1d48ae, _0x325458[_0x1d48ae], _0x325458[_0x1d48ae + 0x1], _0x4f10ae) } else { for (_0x1d48ae = _0x5832f8 - _0x5958c2; _0x1d48ae >= _0x12724f; _0x1d48ae -= _0x5958c2)_0x4f10ae = insertNode(_0x1d48ae, _0x325458[_0x1d48ae], _0x325458[_0x1d48ae + 0x1], _0x4f10ae) } return _0x4f10ae && equals(_0x4f10ae, _0x4f10ae[_0x48b1c2(0x425)]) && (removeNode(_0x4f10ae), _0x4f10ae = _0x4f10ae[_0x48b1c2(0x425)]), _0x4f10ae } function filterPoints (_0x18988c, _0x3cf81c) { const _0x5cb1d0 = { _0x3d1ea5: 0x1ca, _0x2edddc: 0x425 }, _0x5ae039 = _0x48e965; if (!_0x18988c) return _0x18988c; if (!_0x3cf81c) _0x3cf81c = _0x18988c; var _0x32b446 = _0x18988c, _0x49014a; do { _0x49014a = ![]; if (!_0x32b446[_0x5ae039(_0x5cb1d0._0x3d1ea5)] && (equals(_0x32b446, _0x32b446[_0x5ae039(_0x5cb1d0._0x2edddc)]) || area(_0x32b446['prev'], _0x32b446, _0x32b446[_0x5ae039(0x425)]) === 0x0)) { removeNode(_0x32b446), _0x32b446 = _0x3cf81c = _0x32b446['prev']; if (_0x32b446 === _0x32b446['next']) break; _0x49014a = !![] } else _0x32b446 = _0x32b446[_0x5ae039(0x425)] } while (_0x49014a || _0x32b446 !== _0x3cf81c); return _0x3cf81c } function earcutLinked (_0x8d08bd, _0x6af194, _0x1c135c, _0x55eae2, _0x2f9f3e, _0x2ae5c2, _0x4c6e63) { const _0x41516a = { _0x58a729: 0x1f4, _0x450bff: 0x425, _0x504c95: 0x1da }, _0x270a8e = _0x48e965; if (!_0x8d08bd) return; if (!_0x4c6e63 && _0x2ae5c2) indexCurve(_0x8d08bd, _0x55eae2, _0x2f9f3e, _0x2ae5c2); var _0x30bfc4 = _0x8d08bd, _0x383782, _0x5850b6; while (_0x8d08bd[_0x270a8e(_0x41516a._0x58a729)] !== _0x8d08bd[_0x270a8e(0x425)]) { _0x383782 = _0x8d08bd[_0x270a8e(0x1f4)], _0x5850b6 = _0x8d08bd[_0x270a8e(_0x41516a._0x450bff)]; if (_0x2ae5c2 ? isEarHashed(_0x8d08bd, _0x55eae2, _0x2f9f3e, _0x2ae5c2) : isEar(_0x8d08bd)) { _0x6af194[_0x270a8e(0x1da)](_0x383782['i'] / _0x1c135c | 0x0), _0x6af194[_0x270a8e(0x1da)](_0x8d08bd['i'] / _0x1c135c | 0x0), _0x6af194[_0x270a8e(_0x41516a._0x504c95)](_0x5850b6['i'] / _0x1c135c | 0x0), removeNode(_0x8d08bd), _0x8d08bd = _0x5850b6['next'], _0x30bfc4 = _0x5850b6['next']; continue } _0x8d08bd = _0x5850b6; if (_0x8d08bd === _0x30bfc4) { if (!_0x4c6e63) earcutLinked(filterPoints(_0x8d08bd), _0x6af194, _0x1c135c, _0x55eae2, _0x2f9f3e, _0x2ae5c2, 0x1); else { if (_0x4c6e63 === 0x1) _0x8d08bd = cureLocalIntersections(filterPoints(_0x8d08bd), _0x6af194, _0x1c135c), earcutLinked(_0x8d08bd, _0x6af194, _0x1c135c, _0x55eae2, _0x2f9f3e, _0x2ae5c2, 0x2); else _0x4c6e63 === 0x2 && splitEarcut(_0x8d08bd, _0x6af194, _0x1c135c, _0x55eae2, _0x2f9f3e, _0x2ae5c2) } break } } } function isEar (_0x576673) { const _0x89214d = { _0x271566: 0x425 }, _0x3a7789 = _0x48e965; var _0x37c744 = _0x576673[_0x3a7789(0x1f4)], _0x2433fd = _0x576673, _0x3da5e0 = _0x576673[_0x3a7789(0x425)]; if (area(_0x37c744, _0x2433fd, _0x3da5e0) >= 0x0) return ![]; var _0x2e7ab3 = _0x37c744['x'], _0x361b26 = _0x2433fd['x'], _0x3b0525 = _0x3da5e0['x'], _0x5e10af = _0x37c744['y'], _0x1a42fb = _0x2433fd['y'], _0x2231e0 = _0x3da5e0['y'], _0x615ed = _0x2e7ab3 < _0x361b26 ? _0x2e7ab3 < _0x3b0525 ? _0x2e7ab3 : _0x3b0525 : _0x361b26 < _0x3b0525 ? _0x361b26 : _0x3b0525, _0x36c3a4 = _0x5e10af < _0x1a42fb ? _0x5e10af < _0x2231e0 ? _0x5e10af : _0x2231e0 : _0x1a42fb < _0x2231e0 ? _0x1a42fb : _0x2231e0, _0x1bd816 = _0x2e7ab3 > _0x361b26 ? _0x2e7ab3 > _0x3b0525 ? _0x2e7ab3 : _0x3b0525 : _0x361b26 > _0x3b0525 ? _0x361b26 : _0x3b0525, _0x3fd29e = _0x5e10af > _0x1a42fb ? _0x5e10af > _0x2231e0 ? _0x5e10af : _0x2231e0 : _0x1a42fb > _0x2231e0 ? _0x1a42fb : _0x2231e0, _0x3766b2 = _0x3da5e0['next']; while (_0x3766b2 !== _0x37c744) { if (_0x3766b2['x'] >= _0x615ed && _0x3766b2['x'] <= _0x1bd816 && _0x3766b2['y'] >= _0x36c3a4 && _0x3766b2['y'] <= _0x3fd29e && pointInTriangle(_0x2e7ab3, _0x5e10af, _0x361b26, _0x1a42fb, _0x3b0525, _0x2231e0, _0x3766b2['x'], _0x3766b2['y']) && area(_0x3766b2[_0x3a7789(0x1f4)], _0x3766b2, _0x3766b2[_0x3a7789(_0x89214d._0x271566)]) >= 0x0) return ![]; _0x3766b2 = _0x3766b2[_0x3a7789(0x425)] } return !![] } function isEarHashed (_0x17838c, _0x49f26e, _0x1e6153, _0x33f60b) { const _0x163811 = { _0x42ad19: 0x1f4, _0x2605a9: 0x162, _0x4844e6: 0x425, _0x314186: 0x466 }, _0x594efe = _0x48e965; var _0x3ebb46 = _0x17838c[_0x594efe(0x1f4)], _0x55b6ce = _0x17838c, _0x38324c = _0x17838c['next']; if (area(_0x3ebb46, _0x55b6ce, _0x38324c) >= 0x0) return ![]; var _0x21324 = _0x3ebb46['x'], _0x424838 = _0x55b6ce['x'], _0x5128fb = _0x38324c['x'], _0x179618 = _0x3ebb46['y'], _0x2199df = _0x55b6ce['y'], _0xa18a07 = _0x38324c['y'], _0x10c4fd = _0x21324 < _0x424838 ? _0x21324 < _0x5128fb ? _0x21324 : _0x5128fb : _0x424838 < _0x5128fb ? _0x424838 : _0x5128fb, _0x5b4173 = _0x179618 < _0x2199df ? _0x179618 < _0xa18a07 ? _0x179618 : _0xa18a07 : _0x2199df < _0xa18a07 ? _0x2199df : _0xa18a07, _0x5d6dfe = _0x21324 > _0x424838 ? _0x21324 > _0x5128fb ? _0x21324 : _0x5128fb : _0x424838 > _0x5128fb ? _0x424838 : _0x5128fb, _0x57d3d1 = _0x179618 > _0x2199df ? _0x179618 > _0xa18a07 ? _0x179618 : _0xa18a07 : _0x2199df > _0xa18a07 ? _0x2199df : _0xa18a07, _0x3e8edc = zOrder(_0x10c4fd, _0x5b4173, _0x49f26e, _0x1e6153, _0x33f60b), _0x365f89 = zOrder(_0x5d6dfe, _0x57d3d1, _0x49f26e, _0x1e6153, _0x33f60b), _0x41dfe5 = _0x17838c[_0x594efe(0x466)], _0x42e296 = _0x17838c[_0x594efe(0x162)]; while (_0x41dfe5 && _0x41dfe5['z'] >= _0x3e8edc && _0x42e296 && _0x42e296['z'] <= _0x365f89) { if (_0x41dfe5['x'] >= _0x10c4fd && _0x41dfe5['x'] <= _0x5d6dfe && _0x41dfe5['y'] >= _0x5b4173 && _0x41dfe5['y'] <= _0x57d3d1 && _0x41dfe5 !== _0x3ebb46 && _0x41dfe5 !== _0x38324c && pointInTriangle(_0x21324, _0x179618, _0x424838, _0x2199df, _0x5128fb, _0xa18a07, _0x41dfe5['x'], _0x41dfe5['y']) && area(_0x41dfe5[_0x594efe(_0x163811._0x42ad19)], _0x41dfe5, _0x41dfe5['next']) >= 0x0) return ![]; _0x41dfe5 = _0x41dfe5['prevZ']; if (_0x42e296['x'] >= _0x10c4fd && _0x42e296['x'] <= _0x5d6dfe && _0x42e296['y'] >= _0x5b4173 && _0x42e296['y'] <= _0x57d3d1 && _0x42e296 !== _0x3ebb46 && _0x42e296 !== _0x38324c && pointInTriangle(_0x21324, _0x179618, _0x424838, _0x2199df, _0x5128fb, _0xa18a07, _0x42e296['x'], _0x42e296['y']) && area(_0x42e296[_0x594efe(_0x163811._0x42ad19)], _0x42e296, _0x42e296[_0x594efe(0x425)]) >= 0x0) return ![]; _0x42e296 = _0x42e296[_0x594efe(_0x163811._0x2605a9)] } while (_0x41dfe5 && _0x41dfe5['z'] >= _0x3e8edc) { if (_0x41dfe5['x'] >= _0x10c4fd && _0x41dfe5['x'] <= _0x5d6dfe && _0x41dfe5['y'] >= _0x5b4173 && _0x41dfe5['y'] <= _0x57d3d1 && _0x41dfe5 !== _0x3ebb46 && _0x41dfe5 !== _0x38324c && pointInTriangle(_0x21324, _0x179618, _0x424838, _0x2199df, _0x5128fb, _0xa18a07, _0x41dfe5['x'], _0x41dfe5['y']) && area(_0x41dfe5[_0x594efe(0x1f4)], _0x41dfe5, _0x41dfe5[_0x594efe(_0x163811._0x4844e6)]) >= 0x0) return ![]; _0x41dfe5 = _0x41dfe5[_0x594efe(_0x163811._0x314186)] } while (_0x42e296 && _0x42e296['z'] <= _0x365f89) { if (_0x42e296['x'] >= _0x10c4fd && _0x42e296['x'] <= _0x5d6dfe && _0x42e296['y'] >= _0x5b4173 && _0x42e296['y'] <= _0x57d3d1 && _0x42e296 !== _0x3ebb46 && _0x42e296 !== _0x38324c && pointInTriangle(_0x21324, _0x179618, _0x424838, _0x2199df, _0x5128fb, _0xa18a07, _0x42e296['x'], _0x42e296['y']) && area(_0x42e296['prev'], _0x42e296, _0x42e296['next']) >= 0x0) return ![]; _0x42e296 = _0x42e296[_0x594efe(0x162)] } return !![] } function cureLocalIntersections (_0x51beea, _0x1e70b0, _0x1acb3a) { const _0x232b28 = { _0x1448b5: 0x1da, _0x4a8591: 0x425 }, _0x50b1ad = _0x48e965; var _0x92d626 = _0x51beea; do { var _0x2d0139 = _0x92d626['prev'], _0x457147 = _0x92d626['next'][_0x50b1ad(0x425)]; !equals(_0x2d0139, _0x457147) && intersects(_0x2d0139, _0x92d626, _0x92d626[_0x50b1ad(0x425)], _0x457147) && locallyInside(_0x2d0139, _0x457147) && locallyInside(_0x457147, _0x2d0139) && (_0x1e70b0[_0x50b1ad(0x1da)](_0x2d0139['i'] / _0x1acb3a | 0x0), _0x1e70b0[_0x50b1ad(0x1da)](_0x92d626['i'] / _0x1acb3a | 0x0), _0x1e70b0[_0x50b1ad(_0x232b28._0x1448b5)](_0x457147['i'] / _0x1acb3a | 0x0), removeNode(_0x92d626), removeNode(_0x92d626[_0x50b1ad(_0x232b28._0x4a8591)]), _0x92d626 = _0x51beea = _0x457147), _0x92d626 = _0x92d626[_0x50b1ad(_0x232b28._0x4a8591)] } while (_0x92d626 !== _0x51beea); return filterPoints(_0x92d626) } function splitEarcut (_0x45bdc7, _0x2eb5d4, _0x32f734, _0x49411c, _0x269617, _0xf3913) { const _0x4c5163 = { _0x402e33: 0x425, _0x53903e: 0x425, _0x4a89cc: 0x425, _0x62bc: 0x425 }, _0x4dd2c0 = _0x48e965; var _0x36b668 = _0x45bdc7; do { var _0x2e6a33 = _0x36b668[_0x4dd2c0(_0x4c5163._0x402e33)][_0x4dd2c0(_0x4c5163._0x53903e)]; while (_0x2e6a33 !== _0x36b668[_0x4dd2c0(0x1f4)]) { if (_0x36b668['i'] !== _0x2e6a33['i'] && isValidDiagonal(_0x36b668, _0x2e6a33)) { var _0x33a76f = splitPolygon(_0x36b668, _0x2e6a33); _0x36b668 = filterPoints(_0x36b668, _0x36b668[_0x4dd2c0(_0x4c5163._0x4a89cc)]), _0x33a76f = filterPoints(_0x33a76f, _0x33a76f[_0x4dd2c0(_0x4c5163._0x62bc)]), earcutLinked(_0x36b668, _0x2eb5d4, _0x32f734, _0x49411c, _0x269617, _0xf3913, 0x0), earcutLinked(_0x33a76f, _0x2eb5d4, _0x32f734, _0x49411c, _0x269617, _0xf3913, 0x0); return } _0x2e6a33 = _0x2e6a33[_0x4dd2c0(_0x4c5163._0x53903e)] } _0x36b668 = _0x36b668[_0x4dd2c0(0x425)] } while (_0x36b668 !== _0x45bdc7) } function eliminateHoles (_0x1f6ca6, _0x5b5324, _0x46aa66, _0x43c88d) { const _0xbb1213 = { _0x4807f1: 0x321, _0x560775: 0x50f }, _0x3e5265 = _0x48e965; var _0xaf2e9e = [], _0x1d01c5, _0x4fbee9, _0x3871d4, _0x188bb3, _0x890a68; for (_0x1d01c5 = 0x0, _0x4fbee9 = _0x5b5324['length']; _0x1d01c5 < _0x4fbee9; _0x1d01c5++) { _0x3871d4 = _0x5b5324[_0x1d01c5] * _0x43c88d, _0x188bb3 = _0x1d01c5 < _0x4fbee9 - 0x1 ? _0x5b5324[_0x1d01c5 + 0x1] * _0x43c88d : _0x1f6ca6[_0x3e5265(_0xbb1213._0x4807f1)], _0x890a68 = linkedList(_0x1f6ca6, _0x3871d4, _0x188bb3, _0x43c88d, ![]); if (_0x890a68 === _0x890a68[_0x3e5265(0x425)]) _0x890a68['steiner'] = !![]; _0xaf2e9e[_0x3e5265(0x1da)](getLeftmost(_0x890a68)) } _0xaf2e9e[_0x3e5265(_0xbb1213._0x560775)](compareX); for (_0x1d01c5 = 0x0; _0x1d01c5 < _0xaf2e9e['length']; _0x1d01c5++) { _0x46aa66 = eliminateHole(_0xaf2e9e[_0x1d01c5], _0x46aa66) } return _0x46aa66 } function compareX (_0x3a292b, _0x30f7e7) { return _0x3a292b['x'] - _0x30f7e7['x'] } function eliminateHole (_0x55451f, _0x5c112b) { const _0x554d6c = { _0xfadb29: 0x425, _0x263f0b: 0x425 }, _0x45962c = _0x48e965; var _0x4363a9 = findHoleBridge(_0x55451f, _0x5c112b); if (!_0x4363a9) return _0x5c112b; var _0x56b81f = splitPolygon(_0x4363a9, _0x55451f); return filterPoints(_0x56b81f, _0x56b81f[_0x45962c(_0x554d6c._0xfadb29)]), filterPoints(_0x4363a9, _0x4363a9[_0x45962c(_0x554d6c._0x263f0b)]) } function _0x39b8 () { const _0x2397a3 = ['indexOf', 'THREE.LineSegmentsGeometry:\x20applyMatrix()\x20has\x20been\x20renamed\x20to\x20applyMatrix4().', 'tagNumber', 'deviation', 'flatten', 'mtlLoader', 'quaternion', 'bloomRadius', 'root', 'panorama', 'computeBoundingSphere', 'negate', 'join', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<common>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20float\x20vh;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(position,\x201.0);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vh\x20=\x20position.y;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20', 'element', 'selectedObjects', ';min-width:160px;width:auto;height:40px;outline:\x201px\x20ridge\x20rgb(255,\x20255,\x20255);border-radius:\x201px;\x27>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20<div\x20style=\x27display:flex;width:100%;;height:100%;text-align:center;color:', 'angle', 'next', 'getCenter', 'ssrPass', 'rotateZ', 'emissive', 'merge', 'onloadDeafault', 'textureWidth', 'animationLoc', 'vertexShader', 'setPosition', 'setFromBufferAttribute', 'intersectsBox', 'slice', 'filterEnabled', 'css2dRenderer', 'onBeforeRender', '\x0auniform\x20vec3\x20diffuse;\x0auniform\x20float\x20opacity;\x0a\x0auniform\x20float\x20dashSize;\x0auniform\x20float\x20dashOffset;\x0auniform\x20float\x20gapSize;\x0a\x0auniform\x20float\x20attenuation;\x0a\x0avarying\x20float\x20vLineDistance;\x0a\x0a#include\x20<common>\x0a#include\x20<color_pars_fragment>\x0a#include\x20<fog_pars_fragment>\x0a#include\x20<logdepthbuf_pars_fragment>\x0a#include\x20<clipping_planes_pars_fragment>\x0a\x0avarying\x20vec2\x20vUv;\x0a\x0avoid\x20main()\x20{\x0a\x0a\x20\x20\x20\x20#include\x20<clipping_planes_fragment>\x0a\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20if\x20(\x20vUv.y\x20<\x20-\x201.0\x20||\x20vUv.y\x20>\x201.0\x20)\x20discard;\x20//\x20discard\x20endcaps\x0a\x0a\x0a\x0a\x20\x20\x20\x20float\x20alpha\x20=\x201.0;\x0a\x0a\x20\x20\x20\x20#ifdef\x20ALPHA_TO_COVERAGE\x0a\x0a\x20\x20\x20\x20//\x20artifacts\x20appear\x20on\x20some\x20hardware\x20if\x20a\x20derivative\x20is\x20taken\x20within\x20a\x20conditional\x0a\x20\x20\x20\x20float\x20a\x20=\x20vUv.x;\x0a\x20\x20\x20\x20float\x20b\x20=\x20(\x20vUv.y\x20>\x200.0\x20)\x20?\x20vUv.y\x20-\x201.0\x20:\x20vUv.y\x20+\x201.0;\x0a\x20\x20\x20\x20float\x20len2\x20=\x20a\x20*\x20a\x20+\x20b\x20*\x20b;\x0a\x20\x20\x20\x20float\x20dlen\x20=\x20fwidth(\x20len2\x20);\x0a\x0a\x20\x20\x20\x20if\x20(\x20abs(\x20vUv.y\x20)\x20>\x201.0\x20)\x20{\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20alpha\x20=\x201.0\x20-\x20smoothstep(\x201.0\x20-\x20dlen,\x201.0\x20+\x20dlen,\x20len2\x20);\x0a\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20#else\x0a\x0a\x20\x20\x20\x20if\x20(\x20abs(\x20vUv.y\x20)\x20>\x201.0\x20)\x20{\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20a\x20=\x20vUv.x;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20b\x20=\x20(\x20vUv.y\x20>\x200.0\x20)\x20?\x20vUv.y\x20-\x201.0\x20:\x20vUv.y\x20+\x201.0;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20len2\x20=\x20a\x20*\x20a\x20+\x20b\x20*\x20b;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20if\x20(\x20len2\x20>\x201.0\x20)\x20discard;\x0a\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20#endif\x0a\x0a\x20\x20\x20\x20//\x20vec4\x20diffuseColor\x20=\x20vec4(\x20diffuse,\x20opacity\x20*\x20alpha\x20);\x0a\x0a\x20\x20\x20\x20#include\x20<logdepthbuf_fragment>\x0a\x20\x20\x20\x20#include\x20<color_fragment>\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20if(attenuation\x20==\x200.0){\x0a\x20\x20\x20\x20\x20\x20if\x20(\x20mod(\x20vLineDistance\x20+\x20dashOffset,\x20dashSize\x20+\x20gapSize\x20)\x20>\x20dashSize\x20)\x20discard;\x20//\x20todo\x20-\x20FIX\x0a\x20\x20\x20\x20\x20\x20vec4\x20diffuseColor\x20=\x20vec4(\x20diffuse,\x20\x20opacity\x20*\x20mod(\x20vLineDistance\x20+\x20dashOffset,\x20dashSize\x20+\x20gapSize\x20)\x20/\x20dashSize\x20);\x0a\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20diffuseColor;\x09\x0a\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(\x20diffuse,\x20opacity\x20*\x20alpha\x20);\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a\x20\x20\x20\x20#include\x20<encodings_fragment>\x0a\x20\x20\x20\x20#include\x20<fog_fragment>\x0a\x20\x20\x20\x20#include\x20<premultiplied_alpha_fragment>\x0a\x0a}', 'particlesWidth', 'matOptions', 'emit', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20color;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20opacity;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20height;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20varying\x20float\x20vh;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20oa\x20=\x20cos(.57\x20+\x20vh\x20/\x20height\x20+\x20.5)\x20/\x202.;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20gl_FragColor\x20=\x20vec4(color,\x20mix(.25,\x20opacity,\x20(height\x20-\x20vh)\x20/\x20height));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color,\x20\x20oa\x20);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20', 'loadGeometry', '\x0avarying\x20vec2\x20vUv;\x0auniform\x20vec3\x20color;\x0a\x0a#include\x20<logdepthbuf_pars_fragment>\x0a\x0avoid\x20main(){\x0a#include\x20<logdepthbuf_fragment>\x0a\x20\x20\x20\x20float\x20pct\x20=\x20distance(vUv,\x20vec2(.5));\x0a\x0a\x20\x20\x20\x20if(pct\x20<\x20.15){\x0a\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color,\x20.5);\x0a\x20\x20\x20\x20}else\x20if(pct>\x20.15\x20&&\x20pct\x20<\x20.1525){\x0a\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color,\x201.);\x0a\x20\x20\x20\x20}\x20else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20discard;\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a}\x0a', 'distanceToPoint', '].quaternion', 'viewport', 'names', 'cross', 'maxDistance', 'isScanningCirle', '\x0a\x09\x09\x09\x09uniform\x20sampler2D\x20mirrorSampler;\x0a\x09\x09\x09\x09uniform\x20float\x20alpha;\x0a\x09\x09\x09\x09uniform\x20float\x20time;\x0a\x09\x09\x09\x09uniform\x20float\x20size;\x0a\x09\x09\x09\x09uniform\x20float\x20distortionScale;\x0a\x09\x09\x09\x09uniform\x20sampler2D\x20normalSampler;\x0a\x09\x09\x09\x09uniform\x20vec3\x20sunColor;\x0a\x09\x09\x09\x09uniform\x20vec3\x20sunDirection;\x0a\x09\x09\x09\x09uniform\x20vec3\x20eye;\x0a\x09\x09\x09\x09uniform\x20vec3\x20waterColor;\x0a\x0a\x09\x09\x09\x09varying\x20vec4\x20mirrorCoord;\x0a\x09\x09\x09\x09varying\x20vec4\x20worldPosition;\x0a\x0a\x09\x09\x09\x09vec4\x20getNoise(\x20vec2\x20uv\x20)\x20{\x0a\x09\x09\x09\x09\x09vec2\x20uv0\x20=\x20(\x20uv\x20/\x20103.0\x20)\x20+\x20vec2(time\x20/\x2017.0,\x20time\x20/\x2029.0);\x0a\x09\x09\x09\x09\x09vec2\x20uv1\x20=\x20uv\x20/\x20107.0-vec2(\x20time\x20/\x20-19.0,\x20time\x20/\x2031.0\x20);\x0a\x09\x09\x09\x09\x09vec2\x20uv2\x20=\x20uv\x20/\x20vec2(\x208907.0,\x209803.0\x20)\x20+\x20vec2(\x20time\x20/\x20101.0,\x20time\x20/\x2097.0\x20);\x0a\x09\x09\x09\x09\x09vec2\x20uv3\x20=\x20uv\x20/\x20vec2(\x201091.0,\x201027.0\x20)\x20-\x20vec2(\x20time\x20/\x20109.0,\x20time\x20/\x20-113.0\x20);\x0a\x09\x09\x09\x09\x09vec4\x20noise\x20=\x20texture2D(\x20normalSampler,\x20uv0\x20)\x20+\x0a\x09\x09\x09\x09\x09\x09texture2D(\x20normalSampler,\x20uv1\x20)\x20+\x0a\x09\x09\x09\x09\x09\x09texture2D(\x20normalSampler,\x20uv2\x20)\x20+\x0a\x09\x09\x09\x09\x09\x09texture2D(\x20normalSampler,\x20uv3\x20);\x0a\x09\x09\x09\x09\x09return\x20noise\x20*\x200.5\x20-\x201.0;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09void\x20sunLight(\x20const\x20vec3\x20surfaceNormal,\x20const\x20vec3\x20eyeDirection,\x20float\x20shiny,\x20float\x20spec,\x20float\x20diffuse,\x20inout\x20vec3\x20diffuseColor,\x20inout\x20vec3\x20specularColor\x20)\x20{\x0a\x09\x09\x09\x09\x09vec3\x20reflection\x20=\x20normalize(\x20reflect(\x20-sunDirection,\x20surfaceNormal\x20)\x20);\x0a\x09\x09\x09\x09\x09float\x20direction\x20=\x20max(\x200.0,\x20dot(\x20eyeDirection,\x20reflection\x20)\x20);\x0a\x09\x09\x09\x09\x09specularColor\x20+=\x20pow(\x20direction,\x20shiny\x20)\x20*\x20sunColor\x20*\x20spec;\x0a\x09\x09\x09\x09\x09diffuseColor\x20+=\x20max(\x20dot(\x20sunDirection,\x20surfaceNormal\x20),\x200.0\x20)\x20*\x20sunColor\x20*\x20diffuse;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09#include\x20<common>\x0a\x09\x09\x09\x09#include\x20<packing>\x0a\x09\x09\x09\x09#include\x20<bsdfs>\x0a\x09\x09\x09\x09#include\x20<fog_pars_fragment>\x0a\x09\x09\x09\x09#include\x20<logdepthbuf_pars_fragment>\x0a\x09\x09\x09\x09#include\x20<lights_pars_begin>\x0a\x09\x09\x09\x09#include\x20<shadowmap_pars_fragment>\x0a\x09\x09\x09\x09#include\x20<shadowmask_pars_fragment>\x0a\x0a\x09\x09\x09\x09void\x20main()\x20{\x0a\x0a\x09\x09\x09\x09\x09#include\x20<logdepthbuf_fragment>\x0a\x09\x09\x09\x09\x09vec4\x20noise\x20=\x20getNoise(\x20worldPosition.xz\x20*\x20size\x20);\x0a\x09\x09\x09\x09\x09vec3\x20surfaceNormal\x20=\x20normalize(\x20noise.xzy\x20*\x20vec3(\x201.5,\x201.0,\x201.5\x20)\x20);\x0a\x0a\x09\x09\x09\x09\x09vec3\x20diffuseLight\x20=\x20vec3(0.0);\x0a\x09\x09\x09\x09\x09vec3\x20specularLight\x20=\x20vec3(0.0);\x0a\x0a\x09\x09\x09\x09\x09vec3\x20worldToEye\x20=\x20eye-worldPosition.xyz;\x0a\x09\x09\x09\x09\x09vec3\x20eyeDirection\x20=\x20normalize(\x20worldToEye\x20);\x0a\x09\x09\x09\x09\x09sunLight(\x20surfaceNormal,\x20eyeDirection,\x20100.0,\x202.0,\x200.5,\x20diffuseLight,\x20specularLight\x20);\x0a\x0a\x09\x09\x09\x09\x09float\x20distance\x20=\x20length(worldToEye);\x0a\x0a\x09\x09\x09\x09\x09vec2\x20distortion\x20=\x20surfaceNormal.xz\x20*\x20(\x200.001\x20+\x201.0\x20/\x20distance\x20)\x20*\x20distortionScale;\x0a\x09\x09\x09\x09\x09vec3\x20reflectionSample\x20=\x20vec3(\x20texture2D(\x20mirrorSampler,\x20mirrorCoord.xy\x20/\x20mirrorCoord.w\x20+\x20distortion\x20)\x20);\x0a\x0a\x09\x09\x09\x09\x09float\x20theta\x20=\x20max(\x20dot(\x20eyeDirection,\x20surfaceNormal\x20),\x200.0\x20);\x0a\x09\x09\x09\x09\x09float\x20rf0\x20=\x200.3;\x0a\x09\x09\x09\x09\x09float\x20reflectance\x20=\x20rf0\x20+\x20(\x201.0\x20-\x20rf0\x20)\x20*\x20pow(\x20(\x201.0\x20-\x20theta\x20),\x205.0\x20);\x0a\x09\x09\x09\x09\x09vec3\x20scatter\x20=\x20max(\x200.0,\x20dot(\x20surfaceNormal,\x20eyeDirection\x20)\x20)\x20*\x20waterColor;\x0a\x09\x09\x09\x09\x09vec3\x20albedo\x20=\x20mix(\x20(\x20sunColor\x20*\x20diffuseLight\x20*\x200.3\x20+\x20scatter\x20)\x20*\x20getShadowMask(),\x20(\x20vec3(\x200.1\x20)\x20+\x20reflectionSample\x20*\x200.9\x20+\x20reflectionSample\x20*\x20specularLight\x20),\x20reflectance);\x0a\x09\x09\x09\x09\x09vec3\x20outgoingLight\x20=\x20albedo;\x0a\x09\x09\x09\x09\x09gl_FragColor\x20=\x20vec4(\x20outgoingLight,\x20alpha\x20);\x0a\x0a\x09\x09\x09\x09\x09#include\x20<tonemapping_fragment>\x0a\x09\x09\x09\x09\x09#include\x20<fog_fragment>\x0a\x09\x09\x09\x09}', 'setTextOfPopup', 'bone', 'applyMatrix', 'minPolarAngle', 'copyPosition', 'getContext', 'isInformationPopup', 'onProgress', 'add', 'spreadEndRadius', 'theta', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<common>\x0a\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(position,\x201.0);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20', 'emissiveIntensity', 'scanRange', 'rotateSpeed', 'getHelperFromSkeleton', 'shadow', 'setFromRotationMatrix', 'setDrawRange', 'fov', 'bgColor', 'updateScenes', 'count', 'pos', 'isBufferGeometry', 'parse', 'all', 'model\x20name\x20should\x20be\x20defined.', '\x0avarying\x20vec2\x20vUv;\x0auniform\x20vec3\x20color;\x0auniform\x20float\x20uTime;\x0auniform\x20float\x20uClockwise;\x0auniform\x20float\x20ringWidth;\x0a\x0a#define\x20PI\x203.141592654\x0a#define\x20EPSILON\x201e-6\x0a\x0afloat\x20atan2(in\x20float\x20y,in\x20float\x20x){\x0a\x20\x20float\x20ax\x20=\x20abs(x);\x0a\x20\x20float\x20ay\x20=\x20abs(y);\x0a\x20\x20float\x20a\x20=\x20min(ax,\x20ay)\x20/\x20(max(ax,\x20ay)\x20+\x20EPSILON);\x0a\x20\x20float\x20s\x20=\x20a*a;\x0a\x20\x20float\x20r\x20=\x20((-.0464964749\x20*\x20s\x20+\x20.15931422)\x20*\x20s\x20-\x20.327622764)\x20*\x20s\x20*\x20a\x20+\x20a;\x0a\x20\x20if(ay\x20>\x20ax)\x20r\x20=\x20PI\x20/\x202.\x20-\x20r;\x0a\x20\x20if(x\x20<\x200.\x20)\x20r\x20=\x20PI\x20-\x20r;\x0a\x20\x20if(y\x20<\x200.\x20)\x20r\x20=\x202.\x20*\x20PI\x20-\x20r;\x0a\x20\x20return\x20r;\x0a}\x0a\x0a#include\x20<logdepthbuf_pars_fragment>\x0a\x0avoid\x20main(){\x0a#include\x20<logdepthbuf_fragment>\x0a\x20\x20\x20\x20float\x20pct\x20=\x20distance(vUv,\x20vec2(.5));\x0a\x0a\x20\x20\x20\x20if(pct\x20>\x20(.5\x20-\x20ringWidth)\x20&&\x20pct\x20<\x20.5){\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20dir\x20=\x20vUv\x20-\x20vec2(.5);\x0a\x20\x20\x20\x20\x20\x20\x20\x20dir\x20=\x20vec2(dir.x\x20*\x20cos(uTime)\x20-\x20dir.y\x20*\x20sin(uTime),\x20dir.x\x20*\x20sin(uTime)\x20+\x20dir.y\x20*\x20cos(uTime));\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20theta\x20=\x20atan2(dir.y\x20,dir.x);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(uClockwise\x20==\x201.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color\x20*\x20(2.4\x20+\x20sin(2.2\x20*\x20uTime)),\x20(2.\x20*\x20PI\x20-\x20theta)\x20/\x20(2.\x20*\x20PI));\x0a\x20\x20\x20\x20\x20\x20\x20\x20}else\x20if(uClockwise\x20==\x20-1.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color\x20*\x20(2.4\x20+\x20sin(2.2\x20*\x20uTime)),\x20theta\x20/\x20(2.\x20*\x20PI));\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20}\x20else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20discard;\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a}\x0a', 'fromLineSegments', 'changeDefaultPicture', 'baseTitle', 'pictureHeight', 'prevZ', 'gammaPass', 'orbit', 'msaaTarget', '\x0avarying\x20vec2\x20vUv;\x0auniform\x20vec3\x20color;\x0auniform\x20float\x20uTime;\x0auniform\x20float\x20opacity;\x0auniform\x20float\x20ringWidth;\x0a\x0a#include\x20<logdepthbuf_pars_fragment>\x0a\x0avoid\x20main(){\x0a#include\x20<logdepthbuf_fragment>\x0a\x0afloat\x20pct\x20=\x20distance(vUv,\x20vec2(.5));\x0a\x0aif(pct\x20>\x20uTime\x20&&\x20pct\x20<\x20(uTime\x20+\x20ringWidth)){\x0a\x20\x20gl_FragColor\x20=\x20vec4(color,\x20opacity);\x0a}\x20else{\x0a\x20\x20discard;\x0a}\x0a\x0a#include\x20<tonemapping_fragment>\x0a}\x0a', 'setFromCamera', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20size;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20attribute\x20float\x20scale;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20attribute\x20float\x20opacity;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20float\x20vOpacity;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<common>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20mvPosition\x20=\x20modelViewMatrix\x20*\x20vec4(\x20position,\x201.0\x20);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_PointSize\x20=\x20scale\x20*\x20size\x20*\x20(\x20300.0\x20/\x20-mvPosition.z\x20);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20mvPosition;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vOpacity\x20=\x20opacity;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20', 'thresholdBase', 'onclick', 'bottomRadius', 'outputEncoding', 'ondragend', 'ssrtPass', 'enableDamping', 'isMesh', 'fillStyle', 'decompose', 'removed', 'hdrUrls', 'envMap', 'init', 'ondbclick', 'startRisingAnimation2', '#ffffff', 'parser', 'renderPass', 'union', 'Background', 'containerWidth', '#00ffff', 'isCirclSpread', 'updateBackground', 'movementSpeed', 'triangles', 'textBaseline', 'canvasHeight', 'textPopup', 'multiplyMatrices', 'MSAAPass', 'image', 'toLowerCase', 'ssrEnabled', 'directionLights', 'templateModels', 'toArray', 'bold', 'ceil', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20precision\x20highp\x20float;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20v_position;\x0a\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20v_normal;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20color;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20emissive;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20opacity;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20threshold;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20vLightFront;\x0a\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20vIndirectFront;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20mixColor;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20minHeight;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20maxHeight;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20DOUBLE_SIDED\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20vLightBack;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20vIndirectBack;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<common>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<packing>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<color_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<uv_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<uv2_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<map_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<bsdfs>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<lights_pars_begin>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<fog_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<clipping_planes_pars_fragment>\x0a\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20baseHeight\x20=\x20v_position.y;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20if(baseHeight\x20<\x20minHeight){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x20\x20gl_FragColor\x20=\x20vec4(vec3(color\x20/\x202.),\x20opacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x20\x20return;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20}else\x20if(baseHeight\x20<\x20-80.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x20\x20gl_FragColor\x20=\x20vec4(vec3(0.,0.,1.),\x20opacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x20\x20return;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20}else\x20if(baseHeight\x20<\x20maxHeight){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x20\x20gl_FragColor\x20=\x20vec4(vec3(0.,1.,1.),\x20opacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x20\x20return;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20}\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20diffuseColor\x20=\x20vec4(\x20color,\x20opacity\x20);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20gl_FragColor\x20=\x20diffuseColor;\x20//\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<clipping_planes_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20ReflectedLight\x20reflectedLight\x20=\x20ReflectedLight(\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20)\x20);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20totalEmissiveRadiance\x20=\x20emissive;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<map_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<color_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<alphatest_fragment>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20DOUBLE_SIDED\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20reflectedLight.indirectDiffuse\x20+=\x20(\x20gl_FrontFacing\x20)\x20?\x20vIndirectFront\x20:\x20vIndirectBack;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#else\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20reflectedLight.indirectDiffuse\x20+=\x20vIndirectFront;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20reflectedLight.indirectDiffuse\x20*=\x20BRDF_Diffuse_Lambert(\x20diffuseColor.rgb\x20);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20DOUBLE_SIDED\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20reflectedLight.directDiffuse\x20=\x20(\x20gl_FrontFacing\x20)\x20?\x20vLightFront\x20:\x20vLightBack;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#else\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20reflectedLight.directDiffuse\x20=\x20vLightFront;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20reflectedLight.directDiffuse\x20*=\x20BRDF_Diffuse_Lambert(\x20diffuseColor.rgb\x20);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20modulation\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20outgoingLight\x20=\x20reflectedLight.directDiffuse\x20+\x20reflectedLight.indirectDiffuse;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(\x20outgoingLight,\x20diffuseColor.a\x20);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20interval\x20=\x20maxHeight\x20-\x20minHeight;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20offsetHeight\x20=\x20baseHeight\x20-\x20minHeight;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20dc\x20=\x20(offsetHeight\x20+\x20threshold)\x20/\x20interval;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor.rgb\x20+=\x20emissive\x20*\x20dc\x20/\x202.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor.rgb\x20+=\x20mixColor\x20*\x20(dc\x20/\x202.\x20+\x20.5);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x20\x20gl_FragColor.rgb\x20=\x20mix(mixColor\x20*\x20dc,\x20emissive\x20*\x20dc,\x20gl_FragColor.rgb);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<encodings_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<fog_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<premultiplied_alpha_fragment>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20', 'height', 'normalize', 'rgb(', 'extensions', 'side', 'then', 'logarithmicDepthBuffer', 'isPowerOfTwo', 'onLoad', 'set', 'hoverTimer', 'readAsArrayBuffer', 'triangleType', 'switchMode', '\x0avarying\x20vec2\x20vUv;\x0auniform\x20vec3\x20color;\x0auniform\x20vec3\x20edgeColor;\x0a\x0a#include\x20<logdepthbuf_pars_fragment>\x0a\x0avoid\x20main(){\x0a#include\x20<logdepthbuf_fragment>\x0a\x20\x20\x20\x20float\x20pct\x20=\x20distance(vUv,\x20vec2(.5));\x0a\x0a\x20\x20\x20\x20if(pct\x20>\x20.35\x20&&\x20pct\x20<\x20.495){\x0a\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color,\x20pct\x20/\x20.35\x20-\x201.);\x0a\x20\x20\x20\x20}else\x20if(pct\x20>\x20.495\x20&&\x20pct\x20<\x20.5){\x0a\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(edgeColor,\x201.);\x0a\x20\x20\x20\x20}\x20else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20discard;\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a}\x0a', 'traverse', 'startSpreadAnimation', 'outlineObjects', 'parentNode', 'mixColorBase', ';font-size:', 'cameras', 'skyColor', 'receiveShadow', 'wireframe', 'remove', 'initEvents', 'THREE.LineSegmentsGeometry\x20no\x20longer\x20supports\x20Geometry.\x20Use\x20THREE.BufferGeometry\x20instead.', 'linewidth', 'popupBaseScale', 'closePath', 'edgeColor', 'options', '.popup-close::before\x20{content:\x20\x22\x5c2716\x22;}', 'wrapT', 'popupBaseHeight', 'hWorldText', 'isWall', 'gltfLoader', 'drawLine', 'div', 'fontColor2', 'tan', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec2\x20uvu;\x0a\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(position,1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uvu\x20=\x20uv;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20', 'prototype', 'LineGeometry', 'position', 'textureHeight', 'isInformationTag', 'preload', 'off', '558TrwaWA', 'ALPHA_TO_COVERAGE', 'closeVisible', 'updateLights', 'bolDrag', 'glb', 'sky', 'contextBoxHeight', 'useFirstFramePosition', 'gamma', 'LineSegmentsGeometry', 'USE_DASH', 'emissiveStripe', 'fontSize', 'realCt', 'reflect', 'multiply', 'concat', 'fontColor3', 'findObjectById', 'orbitCamera', 'topSpacing', 'title', 'controls', 'layers', 'margin', 'dampingFactor', '', 'click', 'onerror', 'rotateY', 'title2', 'end', 'uTime', 'constant', '#0954ed', 'spreadReset', 'numbers', 'clickTimer', 'appendChild', 'Mesh', 'edgeGlow', 'defaultPictureStatus', 'matrixWorldInverse', 'bindMatrix', 'begin', 'clientY', 'needsUpdate', 'initPasses', 'skyRadius', 'error', 'endPoint', 'createEvent', 'download', 'addEventListener', 'lightWallOpts', 'minFilter', '</p>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20</div>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20</div>', 'time2', 'none', 'setClearColor', 'removeChild', 'smokeDir', 'loadModels', 'firstPersonControls', 'title3', 'objLoader', 'addBloomSpecial', 'mirrorSampler', 'spotLights', 'sort', 'fromCubemap', 'depthWrite', 'px\x20Microsoft\x20YaHei', 'setRenderTarget', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_fragment>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20color;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20height;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20uOpacity;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20float\x20vh;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_fragment>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20opc\x20=\x20(height\x20-\x20vh)\x20/\x20height;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color,\x20mix(.0,\x20uOpacity,\x20opc));\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20', 'popupType', 'toneMappingExposure', 'setFromPoints', 'setTitle1', 'createElement', 'font', 'data', 'squares', 'autoRotateSpeed', 'times', 'modelUrls', 'arc', 'restore', 'target', '\x0a\x09\x09\x09\x09uniform\x20mat4\x20textureMatrix;\x0a\x09\x09\x09\x09uniform\x20float\x20time;\x0a\x0a\x09\x09\x09\x09varying\x20vec4\x20mirrorCoord;\x0a\x09\x09\x09\x09varying\x20vec4\x20worldPosition;\x0a\x0a\x09\x09\x09\x09#include\x20<common>\x0a\x09\x09\x09\x09#include\x20<fog_pars_vertex>\x0a\x09\x09\x09\x09#include\x20<shadowmap_pars_vertex>\x0a\x09\x09\x09\x09#include\x20<logdepthbuf_pars_vertex>\x0a\x0a\x09\x09\x09\x09void\x20main()\x20{\x0a\x09\x09\x09\x09\x09mirrorCoord\x20=\x20modelMatrix\x20*\x20vec4(\x20position,\x201.0\x20);\x0a\x09\x09\x09\x09\x09worldPosition\x20=\x20mirrorCoord.xyzw;\x0a\x09\x09\x09\x09\x09mirrorCoord\x20=\x20textureMatrix\x20*\x20mirrorCoord;\x0a\x09\x09\x09\x09\x09vec4\x20mvPosition\x20=\x20\x20modelViewMatrix\x20*\x20vec4(\x20position,\x201.0\x20);\x0a\x09\x09\x09\x09\x09gl_Position\x20=\x20projectionMatrix\x20*\x20mvPosition;\x0a\x0a\x09\x09\x09\x09#include\x20<beginnormal_vertex>\x0a\x09\x09\x09\x09#include\x20<defaultnormal_vertex>\x0a\x09\x09\x09\x09#include\x20<logdepthbuf_vertex>\x0a\x09\x09\x09\x09#include\x20<fog_vertex>\x0a\x09\x09\x09\x09#include\x20<shadowmap_vertex>\x0a\x09\x09\x09}', 'anisotropy', 'smokeSimulation', 'updateMatrixWorld', 'computeBoundingBox', 'scales', 'directionTag', 'sunColor', 'penumbra', 'showPopup', 'dof', 'normalSampler', 'updatePath', 'canvasWidth', 'dragend', 'depthTest', 'setFromNormalAndCoplanarPoint', 'moveTo', 'clickAnimation', 'firstPersonCamera', 'loadHDR', 'projectionMatrixInverse', 'dbclick', 'focus', 'translate', 'updateOutlinePass', 'distance', 'color:white;height:\x2020px;\x20width:\x2020px;\x20position:\x20absolute;\x20right:\x200;\x20top:\x200;display:flex;align-items:center;justify-content:center;cursor:\x20pointer;transform:scale(', 'guideHeight', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20#define\x20PI\x203.14159265\x0a\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec2\x20uvu;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20uColor;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20uTime;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20startTime;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20vOpacity;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20uSpeed;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20uSge;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec2\x20spreadRange;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20noise(in\x20float\x20x){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20abs(fract(114514.155677\x20*\x20sin(x)));\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20difColor\x20=vec3(0.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20uopacity\x20=\x200.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20len1\x20=\x20\x20length(uvu\x20-\x20vec2(.5));\x20\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(startTime\x20<\x200.45){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(len1\x20>\x20startTime\x20-\x200.05\x20&&\x20len1\x20<\x20startTime\x20+\x200.05){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20difColor\x20=\x20uColor;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uopacity\x20=(1.-\x20smoothstep(startTime\x20-\x200.05,startTime\x20+\x200.04,len1));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(uopacity>0.97)difColor\x20+=\x20vec3(1.)*0.1;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(uopacity\x20<0.98)uopacity\x20*=1.-\x20startTime;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uopacity\x20=\x200.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20end\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(len1\x20>\x200.01\x20&&\x20spreadRange.x\x20>\x20len1){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(fract(uTime)-0.01\x20>=spreadRange.x\x20/\x203.){\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20width\x20=\x201.-fract(15.\x20*\x20(1.-\x20fract(-uTime\x20+\x20len1)));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20len2\x20=1.-smoothstep(0.1,.3,width\x20);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20difColor\x20+=\x20mix(vec3(0.),uColor\x20,len2);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uopacity\x20=len2;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(difColor,uopacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20', 'risingAnimation', 'bolHover', 'lookSpeed', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<common>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec2\x20vp;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(position,\x201.0);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vp\x20=\x20vec2(position.x,\x20position.z);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20', '', 'visibility', 'hidePopup', 'loadSceneByJSON', 'sceneComposer', 'maxPolarAngle', 'cameraFocus', 'offsetTop', 'particleSize', 'hdr', 'triangleSize', 'buffers', 'root_', 'outlinePass', 'defaultPicture', 'findObjectByName', 'distanceSqToSegment', 'textureMatrix', 'width', 'tDiffuse', 'userData', 'setText', 'contextmenu', 'nextZ', 'round', 'forEach', 'style', '\x20\x0avarying\x20vec2\x20vUv;\x0auniform\x20vec3\x20color;\x0auniform\x20float\x20uTime;\x0auniform\x20float\x20uClockwise;\x0a\x0a#define\x20PI\x203.141592654\x0a#define\x20EPSILON\x201e-6\x0a\x0afloat\x20atan2(in\x20float\x20y,in\x20float\x20x){\x0a\x20\x20float\x20ax\x20=\x20abs(x);\x0a\x20\x20float\x20ay\x20=\x20abs(y);\x0a\x20\x20float\x20a\x20=\x20min(ax,\x20ay)\x20/\x20(max(ax,\x20ay)\x20+\x20EPSILON);\x0a\x20\x20float\x20s\x20=\x20a*a;\x0a\x20\x20float\x20r\x20=\x20((-.0464964749\x20*\x20s\x20+\x20.15931422)\x20*\x20s\x20-\x20.327622764)\x20*\x20s\x20*\x20a\x20+\x20a;\x0a\x20\x20if(ay\x20>\x20ax)\x20r\x20=\x20PI\x20/\x202.\x20-\x20r;\x0a\x20\x20if(x\x20<\x200.\x20)\x20r\x20=\x20PI\x20-\x20r;\x0a\x20\x20if(y\x20<\x200.\x20)\x20r\x20=\x202.\x20*\x20PI\x20-\x20r;\x0a\x20\x20return\x20r;\x0a}\x0a#include\x20<logdepthbuf_pars_fragment>\x0a\x0avoid\x20main(){\x0a#include\x20<logdepthbuf_fragment>\x0a\x20\x20\x20\x20float\x20pct\x20=\x20distance(vUv,\x20vec2(.5));\x0a\x0a\x20\x20\x20\x20if(pct\x20<\x20.25){\x0a\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color\x20*\x20(2.4\x20+\x20sin(2.2\x20*\x20uTime)),\x201.);\x0a\x20\x20\x20\x20}else\x20if(pct\x20>\x20.25\x20&&\x20pct\x20<\x20.38){\x0a\x20\x20\x20\x20\x20\x20\x20\x20discard;\x0a\x20\x20\x20\x20}else\x20if(pct\x20>\x20.38\x20&&\x20pct\x20<\x20.4){\x0a\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color\x20*\x20(2.4\x20+\x20sin(2.2\x20*\x20uTime)),\x201.);\x0a\x20\x20\x20\x20}else\x20if(pct\x20<\x20.5){\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20dir\x20=\x20vUv\x20-\x20vec2(.5);\x0a\x20\x20\x20\x20\x20\x20\x20\x20dir\x20=\x20vec2(dir.x\x20*\x20cos(uTime)\x20-\x20dir.y\x20*\x20sin(uTime),\x20dir.x\x20*\x20sin(uTime)\x20+\x20dir.y\x20*\x20cos(uTime));\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20theta\x20=\x20atan2(dir.y\x20,dir.x);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(uClockwise\x20==\x201.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color\x20*\x20(2.4\x20+\x20sin(2.2\x20*\x20uTime)),\x20(2.\x20*\x20PI\x20-\x20theta)\x20/\x20(2.\x20*\x20PI));\x0a\x20\x20\x20\x20\x20\x20\x20\x20}else\x20if(uClockwise\x20==\x20-1.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color\x20*\x20(2.4\x20+\x20sin(2.2\x20*\x20uTime)),\x20theta\x20/\x20(2.\x20*\x20PI));\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20}\x20else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20discard;\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a\x20\x20\x20\x20\x0a}\x0a', 'dragenter', 'iconSpeed', 'ringWidth', '/js/gltfDraco/', 'toJSON', 'setColor', '].position', 'gifLoader', '\x0a\x20varying\x20vec2\x20vUv;\x0a\x20uniform\x20vec3\x20color;\x0a\x20uniform\x20float\x20uTime;\x0a\x20uniform\x20float\x20ringWidth;\x0a\x20uniform\x20float\x20rotateSpeed;\x0a\x20uniform\x20float\x20opacity;\x0a\x20\x0a\x20#define\x20PI\x203.141592654\x0a\x20#define\x20EPSILON\x201e-6\x0a\x20\x0a\x20float\x20atan2(in\x20float\x20y,in\x20float\x20x){\x0a\x20\x20\x20float\x20ax\x20=\x20abs(x);\x0a\x20\x20\x20float\x20ay\x20=\x20abs(y);\x0a\x20\x20\x20float\x20a\x20=\x20min(ax,\x20ay)\x20/\x20(max(ax,\x20ay)\x20+\x20EPSILON);\x0a\x20\x20\x20float\x20s\x20=\x20a*a;\x0a\x20\x20\x20float\x20r\x20=\x20((-.0464964749\x20*\x20s\x20+\x20.15931422)\x20*\x20s\x20-\x20.327622764)\x20*\x20s\x20*\x20a\x20+\x20a;\x0a\x20\x20\x20if(ay\x20>\x20ax)\x20r\x20=\x20PI\x20/\x202.\x20-\x20r;\x0a\x20\x20\x20if(x\x20<\x200.\x20)\x20r\x20=\x20PI\x20-\x20r;\x0a\x20\x20\x20if(y\x20<\x200.\x20)\x20r\x20=\x202.\x20*\x20PI\x20-\x20r;\x0a\x20\x20\x20return\x20r;\x0a\x20}\x0a\x20\x0a\x20#include\x20<logdepthbuf_pars_fragment>\x0a\x20\x0a\x20void\x20main(){\x0a\x20#include\x20<logdepthbuf_fragment>\x0a\x20\x20\x20\x20\x20float\x20pct\x20=\x20distance(vUv,\x20vec2(.5));\x0a\x20\x0a\x20\x20\x20\x20\x20if(pct\x20>\x20.5\x20-\x20ringWidth\x20&&\x20pct\x20<\x20.5){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20dir\x20=\x20vUv\x20-\x20vec2(.5);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20dir\x20=\x20vec2(dir.x\x20*\x20cos(uTime\x20*\x20rotateSpeed)\x20-\x20dir.y\x20*\x20sin(uTime\x20*\x20rotateSpeed),\x20dir.x\x20*\x20sin(uTime\x20*\x20rotateSpeed)\x20+\x20dir.y\x20*\x20cos(uTime\x20*\x20rotateSpeed));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20theta\x20=\x20atan2(dir.y\x20,dir.x);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20if(theta\x20>\x200.\x20&&\x20theta\x20<\x20PI\x20/\x203.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color\x20,\x20opacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20}else\x20if(theta\x20>\x202.\x20*\x20PI\x20/\x203.\x20&&\x20theta\x20<\x20PI){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color\x20,\x20opacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20}else\x20if(theta\x20>\x204.\x20*\x20PI\x20/\x203.\x20&&\x20theta\x20<\x205.\x20*\x20PI\x20/\x203.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color\x20,\x20opacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20discard;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20}\x20else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20discard;\x0a\x20\x20\x20\x20\x20}\x0a\x20\x0a\x20\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a\x20}\x0a\x20', 'clientWidth', 'zIndex', 'icon-sprite-title-3', 'hasWireframe', 'color:white;height:\x2020px;\x20width:\x2020px;\x20position:\x20absolute;\x20right:\x200;\x20top:\x200;display:flex;align-items:center;justify-content:center;cursor:\x20pointer;pointer-events:\x20visible;', 'pmremGenerator', 'attributes', 'near', 'fromEquirectangular', 'flipY', 'sceneModels', 'setHeight', 'decay', 'minHeightStripe', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20#define\x20EPSILON\x201e-6\x0a\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec2\x20uvu;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20uColor;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20startColor;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20startTime;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20uTime;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20vOpacity;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20uSpeed;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20uSge;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20isCirclSpread;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec2\x20scanningRange;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20noise(in\x20float\x20x){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20abs(fract(114514.155677\x20*\x20sin(x)));\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20PI\x20=\x203.14159265;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20drawCircle(float\x20index,\x20float\x20range)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20opacity\x20=\x201.0;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(index\x20>=\x201.0\x20-\x20range)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20opacity\x20=\x201.0\x20-\x20(index\x20-\x20(1.0\x20-\x20range))\x20/\x20range;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x20else\x20if(index\x20<=\x20range)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20opacity\x20=\x20index\x20/\x20range;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20opacity;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20distanceTo(vec2\x20src,\x20vec2\x20dst)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20dx\x20=\x20src.x\x20-\x20dst.x;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20dy\x20=\x20src.y\x20-\x20dst.y;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20dv\x20=\x20dx\x20*\x20dx\x20+\x20dy\x20*\x20dy;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20sqrt(dv);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20atan2(in\x20float\x20y,in\x20float\x20x){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20ax\x20=\x20abs(x);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20ay\x20=\x20abs(y);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20a\x20=\x20min(ax,\x20ay)\x20/\x20(max(ax,\x20ay)\x20+\x20EPSILON);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20s\x20=\x20a*a;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20r\x20=\x20((-.0464964749\x20*\x20s\x20+\x20.15931422)\x20*\x20s\x20-\x20.327622764)\x20*\x20s\x20*\x20a\x20+\x20a;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(ay\x20>\x20ax)\x20r\x20=\x20PI\x20/\x202.\x20-\x20r;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(x\x20<\x200.\x20)\x20r\x20=\x20PI\x20-\x20r;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(y\x20<\x200.\x20)\x20r\x20=\x202.\x20*\x20PI\x20-\x20r;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20r;\x0a\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20difColor\x20=vec3(0.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20uopacity\x20=\x201.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20len\x20=\x20\x20length(uvu\x20-\x20vec2(.5));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x20start\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(startTime\x20<\x200.45){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(len\x20>\x20startTime\x20-\x200.05\x20&&\x20len\x20<\x20startTime\x20+\x200.05){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20difColor\x20=\x20startColor;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uopacity\x20=(1.-\x20smoothstep(startTime\x20-\x200.05,startTime\x20+\x200.04,len));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(uopacity>0.97)difColor\x20+=\x20vec3(1.)*0.1;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(uopacity\x20<0.98)uopacity\x20*=1.-\x20startTime;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uopacity\x20=\x200.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20end\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(startTime>=0.45){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x202\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(isCirclSpread\x20>0.99){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(uTime\x20<=2.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20time1\x20=\x20uTime\x20/\x202.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(len\x20<\x200.15){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20difColor\x20=\x20startColor\x20+\x200.2*vec3(1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uopacity\x20*=\x20time1;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else\x20if(len\x20>=0.15\x20&&\x20len\x20<0.16){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20difColor\x20=\x20uColor\x20+\x200.1\x20*\x20vec3(1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uopacity\x20*=\x20time1;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uopacity\x20=\x200.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20difColor\x20=vec3(0.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(len\x20<\x200.15){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20difColor\x20=\x20startColor\x20+\x200.2*vec3(1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20iTime\x20=\x20-uTime\x20*\x20uSpeed;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20opacity\x20=\x200.0;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20len\x20=\x20distanceTo(vec2(0.5,\x200.5),\x20vec2(uvu.x,\x20uvu.y));\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20size\x20=\x201.0\x20/\x20uSge;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20range\x20=\x20vec2(0.35,\x200.75);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20index\x20=\x20mod(iTime\x20+\x20len,\x20size);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(index\x20<\x20size\x20&&\x20len\x20<=\x200.5)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20i\x20=\x20sin(index\x20/\x20size\x20*\x20PI);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(i\x20>=\x20range.x\x20&&\x20i\x20<=\x20range.y){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20t\x20=\x20(i\x20-\x20range.x)\x20/\x20(range.y\x20-\x20range.x);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20r\x20=\x200.1;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20opacity\x20=\x20drawCircle(t,\x20r);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20opacity\x20*=\x20\x201.0\x20-\x20len\x20/\x200.5;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20};\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(\x20vOpacity\x20*\x20opacity\x20<=\x200.0){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uopacity\x20=\x200.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20difColor\x20=\x20vec3(0.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20difColor\x20=\x20uColor\x20+\x200.1\x20*\x20vec3(1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uopacity\x20=\x20vOpacity\x20*\x20opacity;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20float\x20newTime\x20=(.5\x20-\x20fract(uTime)/2.)/2.+0.15;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20float\x20heightLine\x20=\x20sin\x20(50.\x20*\x20newTime\x20*\x20len);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20float\x20len2\x20=1.-\x20smoothstep(0.,0.5,heightLine\x20>=0.?heightLine:-heightLine);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20difColor\x20=\x20mix(vec3(0.),color\x20+\x200.1*vec3(1.),len2);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20uopacity\x20=len2;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20pct\x20=\x20distance(uvu,\x20vec2(.5));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(pct\x20>\x20scanningRange.x\x20&&\x20pct\x20<\x20scanningRange.y){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20dir\x20=\x20uvu\x20-\x20vec2(.5);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20dir\x20=\x20vec2(dir.x\x20*\x20cos(uTime)\x20-\x20dir.y\x20*\x20sin(uTime),\x20dir.x\x20*\x20sin(uTime)\x20+\x20dir.y\x20*\x20cos(uTime));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20theta\x20=\x20atan2(dir.y\x20,dir.x);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20difColor\x20=\x20uColor\x20*\x20(2.4\x20+\x20sin(2.2\x20*\x20uTime));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uopacity\x20=\x20theta\x20/\x20(2.\x20*\x20PI);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x20else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20difColor\x20=\x20vec3(0.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uopacity\x20=\x200.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(difColor,uopacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20', 'settings.json', 'rgba(', 'trim', 'Reflector', 'clipBias', 'resourcePictureStatus', 'magFilter', 'mapSize', 'hover', 'canvasSize', 'resourcePicture', 'setSkyBox', 'titleColor', 'setDataType', 'setHDR', 'drawPictureBackground', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<common>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(vec3(0.)\x20,\x200.0);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20', 'getNearestBone', 'containerHeight', 'bounceTag', 'downloadurl', '\x20\x0avarying\x20vec2\x20vUv;\x0auniform\x20vec3\x20color;\x0auniform\x20float\x20uTime;\x0auniform\x20float\x20uClockwise;\x0a\x0a#define\x20PI\x203.141592654\x0a#define\x20EPSILON\x201e-6\x0a\x0afloat\x20atan2(in\x20float\x20y,in\x20float\x20x){\x0a\x20\x20float\x20ax\x20=\x20abs(x);\x0a\x20\x20float\x20ay\x20=\x20abs(y);\x0a\x20\x20float\x20a\x20=\x20min(ax,\x20ay)\x20/\x20(max(ax,\x20ay)\x20+\x20EPSILON);\x0a\x20\x20float\x20s\x20=\x20a*a;\x0a\x20\x20float\x20r\x20=\x20((-.0464964749\x20*\x20s\x20+\x20.15931422)\x20*\x20s\x20-\x20.327622764)\x20*\x20s\x20*\x20a\x20+\x20a;\x0a\x20\x20if(ay\x20>\x20ax)\x20r\x20=\x20PI\x20/\x202.\x20-\x20r;\x0a\x20\x20if(x\x20<\x200.\x20)\x20r\x20=\x20PI\x20-\x20r;\x0a\x20\x20if(y\x20<\x200.\x20)\x20r\x20=\x202.\x20*\x20PI\x20-\x20r;\x0a\x20\x20return\x20r;\x0a}\x0a\x0a#include\x20<logdepthbuf_pars_fragment>\x0a\x0avoid\x20main(){\x0a#include\x20<logdepthbuf_fragment>\x0a\x20\x20\x20\x20float\x20pct\x20=\x20distance(vUv,\x20vec2(.5));\x0a\x0a\x20\x20\x20\x20if(pct\x20>\x20.495\x20&&\x20pct\x20<\x20.5){\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20dir\x20=\x20vUv\x20-\x20vec2(.5);\x0a\x20\x20\x20\x20\x20\x20\x20\x20dir\x20=\x20vec2(dir.x\x20*\x20cos(uTime)\x20-\x20dir.y\x20*\x20sin(uTime),\x20dir.x\x20*\x20sin(uTime)\x20+\x20dir.y\x20*\x20cos(uTime));\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20theta\x20=\x20atan2(dir.y\x20,dir.x);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(theta\x20>\x200.\x20&&\x20theta\x20<\x20(PI\x20/\x202.)\x20){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20discard;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x20else\x20if(theta\x20>\x20PI\x20&&\x20theta\x20<\x20(3.\x20*\x20PI\x20/\x202.)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20discard;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x20else{\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(uClockwise\x20==\x201.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color\x20,\x20mod(theta,\x20PI\x20/\x202.)\x20/\x20(\x20PI\x20/\x202.));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color\x20,\x20abs(mod(PI\x20/\x202.\x20-\x20theta,\x20PI\x20/\x202.))\x20/\x20(\x20PI\x20/\x202.));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20}\x20else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20discard;\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a}\x0a', 'lookAt', 'cubicGuide', 'renameBones', 'instanceDistanceEnd', 'startRotateAnimation13', 'filterPass', 'backgroundColor', 'TemplateParser', 'events', 'rotatingAnimation2', 'indicateRadius', 'wrapS', 'camera', 'updateDOFPass', 'emissiveBase', 'fontSize3', 'draggable', 'canvasContext', 'sunDirection', 'getBoundingClientRect', 'particlesColor', 'time1', 'spreadStartRadius', 'map', 'fontSize1', 'isBox', 'letterSpacing', 'log', 'popupAnimation', 'isWater', 'isSpreadRound', '#000000', 'preserveHipPosition', 'baseHeightValue', 'aspect', 'waterNormals', 'getDelta', 'texture', 'pointerEvents', 'isLineSegmentsGeometry', 'animate', 'common', 'devicePixelRatio', 'boundingSphere', 'center', 'renderOrder', 'initHDR', 'popupBaseSize', 'msaa', 'isLineGeometry', 'dashOffset', 'update', 'hemisphereLight', 'steiner', 'boundingBox', 'bottom', 'fgColor', 'changeTitle', 'isLine2', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20color;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20mixColor;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20mixColor2;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20threshold;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20height;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20type;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20opacity;\x0a\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20float\x20vh;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20LIGHTS\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20vLightFront;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20vIndirectFront;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20DOUBLE_SIDED\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20vLightBack;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20vIndirectBack;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<common>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<packing>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<color_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<uv_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<uv2_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<map_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<bsdfs>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<lights_pars_begin>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<fog_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<clipping_planes_pars_fragment>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#ifndef\x20LIGHTS\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<common>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20LIGHTS\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20diffuseColor\x20=\x20vec4(\x20color,\x20opacity\x20);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<clipping_planes_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20ReflectedLight\x20reflectedLight\x20=\x20ReflectedLight(\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20)\x20);\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<map_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<color_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<alphatest_fragment>\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20DOUBLE_SIDED\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20reflectedLight.indirectDiffuse\x20+=\x20(\x20gl_FrontFacing\x20)\x20?\x20vIndirectFront\x20:\x20vIndirectBack;\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20reflectedLight.indirectDiffuse\x20+=\x20vIndirectFront;\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20reflectedLight.indirectDiffuse\x20*=\x20BRDF_Diffuse_Lambert(\x20diffuseColor.rgb\x20);\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20DOUBLE_SIDED\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20reflectedLight.directDiffuse\x20=\x20(\x20gl_FrontFacing\x20)\x20?\x20vLightFront\x20:\x20vLightBack;\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20reflectedLight.directDiffuse\x20=\x20vLightFront;\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20reflectedLight.directDiffuse\x20*=\x20BRDF_Diffuse_Lambert(\x20diffuseColor.rgb\x20);\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20modulation\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20outgoingLight\x20=\x20reflectedLight.directDiffuse\x20+\x20reflectedLight.indirectDiffuse;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(\x20outgoingLight,\x20diffuseColor.a\x20);\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(type\x20==\x200.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor.rgb\x20+=\x20vec3(mix(\x20vec3(0.),\x20mixColor,\x20vec3((2.\x20*\x20(vh+\x20threshold)\x20/\x20height\x20+\x201.)\x20/\x204.)));\x20\x20//\x200\x20~\x200.5\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor.rgb\x20+=\x20vec3(mix(\x20vec3(0.),\x20mixColor2,\x20vec3((\x20(vh\x20+\x20threshold)\x20/\x20height\x20+\x20.5)\x20/\x202.\x20+\x20.5)));\x20//\x200.5\x20~\x201\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else\x20if(type\x20==\x201.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(gl_FragColor.rgb,\x20opacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<encodings_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<fog_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<premultiplied_alpha_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#ifndef\x20LIGHTS\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(type\x20==\x200.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color,\x20opacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor.rgb\x20+=\x20vec3(mix(\x20color,\x20mixColor,\x20vec3((2.\x20*\x20vh\x20/\x20height\x20+\x201.)\x20/\x202.)));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor.rgb\x20+=\x20vec3(mix(\x20color,\x20mixColor2,\x20vec3((vh\x20/\x20height\x20+\x20.5)\x20/\x202.\x20+\x20.5)));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else\x20if(type\x20==\x201.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color,\x20opacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20', 'dragging-changed', 'renderTarget2', 'identity', 'url', 'getHexString', 'dot', 'clear', 'Object3D', 'startRotateAnimation', 'push', 'canvasElement', 'fbx', 'cursor', 'loadMaterial', 'path', 'sqrt', 'className', '<div\x20style=\x27pointer-events:none;background-color:', 'gradient', '5762165UKweUv', 'topRadius', 'Bold\x20', 'isReflector', 'beginPath', 'container', 'setPositions', 'BloomPass', 'waterColor', '_size', 'fromWireframeGeometry', 'start', 'type', 'stopIconAnimation', 'splice', 'bounds', 'prev', 'renderCamera', 'title-update\x20needs\x20canvasElement', '', 'retarget', 'gapSize', 'bones', 'edgeThickness', 'clearRect', '_height', 'intersectObjects', 'uncacheAction', 'computeLineDistances', 'hideGuideCube', 'Camera', 'addPass', 'fromMesh', 'retargetClip', 'roughness', 'values', 'updateGammaPass', 'color', 'updatePasses', 'titleWidth', 'multiplyScalar', 'setValues', 'isArray', 'attrs', 'DOFPass', 'exec', 'startIndicateAnimation', 'insertRule', 'lineTo', 'distortionScale', 'rgb(100,100,100)', 'opacities', '#ff0000', 'resolution', 'vertices', 'far', 'warn', 'CineonToneMapping', 'cubes', 'findBoneTrackData', 'getSkeletonOffsets', 'innerHeight', 'unbiased', 'fog', 'setFromMatrixScale', 'random', 'baseTexture', 'bolDbClick', 'stats', 'spreadAnimation', 'extractRotation', 'drawText', 'MouseEvents', 'pyramidHeight', 'attenuation', 'keys', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20precision\x20highp\x20float;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20v_position;\x0a\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20v_normal;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20color;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20emissiveBase;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20emissiveStripe;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20opacity;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20thresholdBase;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20vLightFront;\x0a\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20vIndirectFront;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20mixColorBase;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20minHeightBase;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20maxHeightBase;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20minHeightStripe;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20maxHeightStripe;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20DOUBLE_SIDED\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20vLightBack;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20vIndirectBack;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<common>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<packing>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<color_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<uv_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<uv2_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<map_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<bsdfs>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<lights_pars_begin>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<fog_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<clipping_planes_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20baseHeight\x20=\x20v_position.y;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20if(baseHeight\x20<\x20minHeight){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x20\x20gl_FragColor\x20=\x20vec4(vec3(color\x20/\x202.),\x20opacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x20\x20return;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20}else\x20if(baseHeight\x20<\x20-80.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x20\x20gl_FragColor\x20=\x20vec4(vec3(0.,0.,1.),\x20opacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x20\x20return;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20}else\x20if(baseHeight\x20<\x20maxHeight){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x20\x20gl_FragColor\x20=\x20vec4(vec3(0.,1.,1.),\x20opacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x20\x20return;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20}\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20diffuseColor\x20=\x20vec4(\x20color,\x20opacity\x20);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20gl_FragColor\x20=\x20diffuseColor;\x20//\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<clipping_planes_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20ReflectedLight\x20reflectedLight\x20=\x20ReflectedLight(\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20)\x20);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20totalEmissiveRadiance\x20=\x20emissiveBase;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<map_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<color_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<alphatest_fragment>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20DOUBLE_SIDED\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20reflectedLight.indirectDiffuse\x20+=\x20(\x20gl_FrontFacing\x20)\x20?\x20vIndirectFront\x20:\x20vIndirectBack;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#else\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20reflectedLight.indirectDiffuse\x20+=\x20vIndirectFront;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20reflectedLight.indirectDiffuse\x20*=\x20BRDF_Diffuse_Lambert(\x20diffuseColor.rgb\x20);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20DOUBLE_SIDED\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20reflectedLight.directDiffuse\x20=\x20(\x20gl_FrontFacing\x20)\x20?\x20vLightFront\x20:\x20vLightBack;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#else\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20reflectedLight.directDiffuse\x20=\x20vLightFront;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20reflectedLight.directDiffuse\x20*=\x20BRDF_Diffuse_Lambert(\x20diffuseColor.rgb\x20);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20modulation\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20outgoingLight\x20=\x20reflectedLight.directDiffuse\x20+\x20reflectedLight.indirectDiffuse;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(\x20outgoingLight,\x20diffuseColor.a\x20);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20interval\x20=\x20maxHeightBase\x20-\x20minHeightBase;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20offsetHeight\x20=\x20baseHeight\x20-\x20minHeightBase;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20dc\x20=\x20(offsetHeight\x20+\x20thresholdBase)\x20/\x20interval;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor.rgb\x20+=\x20emissiveBase\x20*\x20dc\x20/\x202.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor.rgb\x20+=\x20mixColorBase\x20*\x20(dc\x20/\x202.\x20+\x20.5);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20centerY\x20=\x20(maxHeightStripe\x20-\x20minHeightStripe)\x20/\x202.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20ds\x20=\x20dot(v_normal,\x20vec3(0.,\x201.\x20,0.));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(baseHeight\x20>=\x20minHeightStripe\x20&&\x20baseHeight\x20<=\x20maxHeightStripe\x20&&\x20ds\x20<\x200.0001\x20&&\x20ds\x20>\x20-0.0001){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20rs\x20=\x20mod(abs(abs(centerY)\x20-\x20abs(baseHeight)),\x2010.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(rs\x20<=\x202.\x20&&\x20rs\x20>=\x20.2){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor.rgb\x20+=\x20emissiveStripe;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<encodings_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<fog_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<premultiplied_alpha_fragment>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20', 'bolClick', 'horseRaceAnimationSpeed', 'css3dRenderer', 'uniforms', 'particleNumber', 'opacity', 'background', 'sub', 'disable', '_width', 'fps', 'icon-sprite-title-1', 'spreadAnimation2', 'textType', 'edgeStrength', 'ACESFilmicToneMapping', '567510BpdFiS', 'onloadPicture', 'changeResourcePicture', 'shadowMap', 'line', 'icon', 'rotateX', 'renderer', 'updateProjectionMatrix', 'applyMatrix4', 'innerWidth', 'bloom', 'split', 'spreadStartHeight', 'dracoLoader', 'factor', 'THREE.LineSegmentsGeometry.computeBoundingSphere():\x20Computed\x20radius\x20is\x20NaN.\x20The\x20instanced\x20position\x20data\x20is\x20likely\x20to\x20have\x20NaN\x20values.', 'Text', 'URL', 'nodes', 'isPictureDropdownTag', 'px\x20', 'isTagBase', 'setTitle3', 'setCenter', 'extrude', 'min', 'Values\x20in\x20the\x202-0\x20', 'fileName', 'object', '&#10006', 'play', 'lifeCycle', 'changeMode', 'transparent', 'canvas', 'defines', '\x0a\x09\x09uniform\x20vec3\x20color;\x0a\x09\x09uniform\x20sampler2D\x20tDiffuse;\x0a\x09\x09varying\x20vec4\x20vUv;\x0a\x0a\x09\x09#include\x20<logdepthbuf_pars_fragment>\x0a\x0a\x09\x09float\x20blendOverlay(\x20float\x20base,\x20float\x20blend\x20)\x20{\x0a\x0a\x09\x09\x09return(\x20base\x20<\x200.5\x20?\x20(\x202.0\x20*\x20base\x20*\x20blend\x20)\x20:\x20(\x201.0\x20-\x202.0\x20*\x20(\x201.0\x20-\x20base\x20)\x20*\x20(\x201.0\x20-\x20blend\x20)\x20)\x20);\x0a\x0a\x09\x09}\x0a\x0a\x09\x09vec3\x20blendOverlay(\x20vec3\x20base,\x20vec3\x20blend\x20)\x20{\x0a\x0a\x09\x09\x09return\x20vec3(\x20blendOverlay(\x20base.r,\x20blend.r\x20),\x20blendOverlay(\x20base.g,\x20blend.g\x20),\x20blendOverlay(\x20base.b,\x20blend.b\x20)\x20);\x0a\x0a\x09\x09}\x0a\x0a\x09\x09void\x20main()\x20{\x0a\x0a\x09\x09\x09#include\x20<logdepthbuf_fragment>\x0a\x0a\x09\x09\x09vec4\x20base\x20=\x20texture2DProj(\x20tDiffuse,\x20vUv\x20);\x0a\x09\x09\x09gl_FragColor\x20=\x20vec4(\x20blendOverlay(\x20base.rgb,\x20color\x20),\x201.0\x20);\x0a\x0a\x09\x09}', 'opts', 'function\x20getNodeKeyByName()\x27s\x20key\x20\x27', '\x0a\x09\x09#include\x20<common>\x0a\x09\x09#include\x20<color_pars_vertex>\x0a\x09\x09#include\x20<fog_pars_vertex>\x0a\x09\x09#include\x20<logdepthbuf_pars_vertex>\x0a\x09\x09#include\x20<clipping_planes_pars_vertex>\x0a\x0a\x09\x09uniform\x20float\x20linewidth;\x0a\x09\x09uniform\x20vec2\x20resolution;\x0a\x0a\x09\x09attribute\x20vec3\x20instanceStart;\x0a\x09\x09attribute\x20vec3\x20instanceEnd;\x0a\x0a\x09\x09attribute\x20vec3\x20instanceColorStart;\x0a\x09\x09attribute\x20vec3\x20instanceColorEnd;\x0a\x0a\x09\x09varying\x20vec2\x20vUv;\x0a\x0a\x09\x09#ifdef\x20USE_DASH\x0a\x0a\x09\x09\x09uniform\x20float\x20dashScale;\x0a\x09\x09\x09attribute\x20float\x20instanceDistanceStart;\x0a\x09\x09\x09attribute\x20float\x20instanceDistanceEnd;\x0a\x09\x09\x09varying\x20float\x20vLineDistance;\x0a\x0a\x09\x09#endif\x0a\x0a\x09\x09void\x20trimSegment(\x20const\x20in\x20vec4\x20start,\x20inout\x20vec4\x20end\x20)\x20{\x0a\x0a\x09\x09\x09//\x20trim\x20end\x20segment\x20so\x20it\x20terminates\x20between\x20the\x20camera\x20plane\x20and\x20the\x20near\x20plane\x0a\x0a\x09\x09\x09//\x20conservative\x20estimate\x20of\x20the\x20near\x20plane\x0a\x09\x09\x09float\x20a\x20=\x20projectionMatrix[\x202\x20][\x202\x20];\x20//\x203nd\x20entry\x20in\x203th\x20column\x0a\x09\x09\x09float\x20b\x20=\x20projectionMatrix[\x203\x20][\x202\x20];\x20//\x203nd\x20entry\x20in\x204th\x20column\x0a\x09\x09\x09float\x20nearEstimate\x20=\x20-\x200.5\x20*\x20b\x20/\x20a;\x0a\x0a\x09\x09\x09float\x20alpha\x20=\x20(\x20nearEstimate\x20-\x20start.z\x20)\x20/\x20(\x20end.z\x20-\x20start.z\x20);\x0a\x0a\x09\x09\x09end.xyz\x20=\x20mix(\x20start.xyz,\x20end.xyz,\x20alpha\x20);\x0a\x0a\x09\x09}\x0a\x0a\x09\x09void\x20main()\x20{\x0a\x0a\x09\x09\x09#ifdef\x20USE_COLOR\x0a\x0a\x09\x09\x09\x09vColor.xyz\x20=\x20(\x20position.y\x20<\x200.5\x20)\x20?\x20instanceColorStart\x20:\x20instanceColorEnd;\x0a\x0a\x09\x09\x09#endif\x0a\x0a\x09\x09\x09#ifdef\x20USE_DASH\x0a\x0a\x09\x09\x09\x09vLineDistance\x20=\x20(\x20position.y\x20<\x200.5\x20)\x20?\x20dashScale\x20*\x20instanceDistanceStart\x20:\x20dashScale\x20*\x20instanceDistanceEnd;\x0a\x0a\x09\x09\x09#endif\x0a\x0a\x09\x09\x09float\x20aspect\x20=\x20resolution.x\x20/\x20resolution.y;\x0a\x0a\x09\x09\x09vUv\x20=\x20uv;\x0a\x0a\x09\x09\x09//\x20camera\x20space\x0a\x09\x09\x09vec4\x20start\x20=\x20modelViewMatrix\x20*\x20vec4(\x20instanceStart,\x201.0\x20);\x0a\x09\x09\x09vec4\x20end\x20=\x20modelViewMatrix\x20*\x20vec4(\x20instanceEnd,\x201.0\x20);\x0a\x0a\x09\x09\x09//\x20special\x20case\x20for\x20perspective\x20projection,\x20and\x20segments\x20that\x20terminate\x20either\x20in,\x20or\x20behind,\x20the\x20camera\x20plane\x0a\x09\x09\x09//\x20clearly\x20the\x20gpu\x20firmware\x20has\x20a\x20way\x20of\x20addressing\x20this\x20issue\x20when\x20projecting\x20into\x20ndc\x20space\x0a\x09\x09\x09//\x20but\x20we\x20need\x20to\x20perform\x20ndc-space\x20calculations\x20in\x20the\x20shader,\x20so\x20we\x20must\x20address\x20this\x20issue\x20directly\x0a\x09\x09\x09//\x20perhaps\x20there\x20is\x20a\x20more\x20elegant\x20solution\x20--\x20WestLangley\x0a\x0a\x09\x09\x09bool\x20perspective\x20=\x20(\x20projectionMatrix[\x202\x20][\x203\x20]\x20==\x20-\x201.0\x20);\x20//\x204th\x20entry\x20in\x20the\x203rd\x20column\x0a\x0a\x09\x09\x09if\x20(\x20perspective\x20)\x20{\x0a\x0a\x09\x09\x09\x09if\x20(\x20start.z\x20<\x200.0\x20&&\x20end.z\x20>=\x200.0\x20)\x20{\x0a\x0a\x09\x09\x09\x09\x09trimSegment(\x20start,\x20end\x20);\x0a\x0a\x09\x09\x09\x09}\x20else\x20if\x20(\x20end.z\x20<\x200.0\x20&&\x20start.z\x20>=\x200.0\x20)\x20{\x0a\x0a\x09\x09\x09\x09\x09trimSegment(\x20end,\x20start\x20);\x0a\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09//\x20clip\x20space\x0a\x09\x09\x09vec4\x20clipStart\x20=\x20projectionMatrix\x20*\x20start;\x0a\x09\x09\x09vec4\x20clipEnd\x20=\x20projectionMatrix\x20*\x20end;\x0a\x0a\x09\x09\x09//\x20ndc\x20space\x0a\x09\x09\x09vec2\x20ndcStart\x20=\x20clipStart.xy\x20/\x20clipStart.w;\x0a\x09\x09\x09vec2\x20ndcEnd\x20=\x20clipEnd.xy\x20/\x20clipEnd.w;\x0a\x0a\x09\x09\x09//\x20direction\x0a\x09\x09\x09vec2\x20dir\x20=\x20ndcEnd\x20-\x20ndcStart;\x0a\x0a\x09\x09\x09//\x20account\x20for\x20clip-space\x20aspect\x20ratio\x0a\x09\x09\x09dir.x\x20*=\x20aspect;\x0a\x09\x09\x09dir\x20=\x20normalize(\x20dir\x20);\x0a\x0a\x09\x09\x09//\x20perpendicular\x20to\x20dir\x0a\x09\x09\x09vec2\x20offset\x20=\x20vec2(\x20dir.y,\x20-\x20dir.x\x20);\x0a\x0a\x09\x09\x09//\x20undo\x20aspect\x20ratio\x20adjustment\x0a\x09\x09\x09dir.x\x20/=\x20aspect;\x0a\x09\x09\x09offset.x\x20/=\x20aspect;\x0a\x0a\x09\x09\x09//\x20sign\x20flip\x0a\x09\x09\x09if\x20(\x20position.x\x20<\x200.0\x20)\x20offset\x20*=\x20-\x201.0;\x0a\x0a\x09\x09\x09//\x20endcaps\x0a\x09\x09\x09if\x20(\x20position.y\x20<\x200.0\x20)\x20{\x0a\x0a\x09\x09\x09\x09offset\x20+=\x20-\x20dir;\x0a\x0a\x09\x09\x09}\x20else\x20if\x20(\x20position.y\x20>\x201.0\x20)\x20{\x0a\x0a\x09\x09\x09\x09offset\x20+=\x20dir;\x0a\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09//\x20adjust\x20for\x20linewidth\x0a\x09\x09\x09offset\x20*=\x20linewidth;\x0a\x0a\x09\x09\x09//\x20adjust\x20for\x20clip-space\x20to\x20screen-space\x20conversion\x20//\x20maybe\x20resolution\x20should\x20be\x20based\x20on\x20viewport\x20...\x0a\x09\x09\x09offset\x20/=\x20resolution.y;\x0a\x0a\x09\x09\x09//\x20select\x20end\x0a\x09\x09\x09vec4\x20clip\x20=\x20(\x20position.y\x20<\x200.5\x20)\x20?\x20clipStart\x20:\x20clipEnd;\x0a\x0a\x09\x09\x09//\x20back\x20to\x20clip\x20space\x0a\x09\x09\x09offset\x20*=\x20clip.w;\x0a\x0a\x09\x09\x09clip.xy\x20+=\x20offset;\x0a\x0a\x09\x09\x09gl_Position\x20=\x20clip;\x0a\x0a\x09\x09\x09vec4\x20mvPosition\x20=\x20(\x20position.y\x20<\x200.5\x20)\x20?\x20start\x20:\x20end;\x20//\x20this\x20is\x20an\x20approximation\x0a\x0a\x09\x09\x09#include\x20<logdepthbuf_vertex>\x0a\x09\x09\x09#include\x20<clipping_planes_vertex>\x0a\x09\x09\x09#include\x20<fog_vertex>\x0a\x0a\x09\x09}', '.bones[', 'finalbloomPass', 'toneMapping', 'spreadSpeed', 'sin', 'setMask', 'drawTitle', 'bloomPass', 'setFromMatrixPosition', 'body', 'circleRadius', 'invert', 'LinearToneMapping', 'dashSize', 'positionRange', 'strokeColor', 'SkyBox', 'value', 'drawPicture', 'points', '#98e10f', 'pyramidWidth', 'rgb(250,250,250)', 'alpha', 'hWorldAll', 'publicPath', 'ssaaEnabled', 'visibleEdgeColor', 'hip', 'preservePosition', 'relative', 'autoClear', 'startSpreadAnimation3', 'lon', 'default', 'stopAnimation', 'text', 'pose', 'PointLights', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20color;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20gradient;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20opacity;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20height;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20vertical;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20pos;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20gl_FragColor\x20=\x20vec4(\x20mix(color,\x20\x20vec3(0.)\x20,\x20vec3(\x20(height\x20-\x20vy)\x20/\x20height)\x20)\x20\x20,\x20opacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20gl_FragColor\x20=\x20vec4(\x20mix(\x20mix(color,\x20\x20vec3(0.)\x20,\x20vec3(\x20(height\x20-\x20vy)\x20/\x20height)\x20),\x20color\x20,\x20vec3(\x20(height\x20-\x20vy)\x20/\x20height)\x20)\x20\x20,\x20opacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(\x20mix(color,\x20\x20gradient\x20,\x20vec3(\x20(height\x20-\x20pos.y)\x20/\x20height)\x20)\x20\x20,\x20opacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor.rgb\x20+=\x20vec3(\x20mix(color,\x20\x20gradient\x20,\x20vec3(\x20abs(vertical\x20+\x20pos.x)\x20/\x20vertical)\x20)\x20);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20', 'encoding', 'ReflectorShader', 'offsetLeft', 'skeleton', 'defaultResource', 'getPoints', 'textAlign', 'autoRotate', 'findObjectsByName', 'substring', 'state', 'LineSegments2:\x20\x22Raycaster.camera\x22\x20needs\x20to\x20be\x20set\x20in\x20order\x20to\x20raycast\x20against\x20LineSegments2.', 'children', '1781520MjaOjP', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20LIGHTS\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20vLightFront;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20vIndirectFront;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20DOUBLE_SIDED\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20vLightBack;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20vIndirectBack;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<common>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<uv_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<uv2_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<bsdfs>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<lights_pars_begin>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<color_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<fog_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<clipping_planes_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#ifndef\x20LIGHTS\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<common>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20float\x20vh;\x0a\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20LIGHTS\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<uv_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<uv2_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<color_vertex>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<beginnormal_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<defaultnormal_vertex>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<begin_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<project_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<clipping_planes_vertex>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<worldpos_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<lights_lambert_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<fog_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#ifndef\x20LIGHTS\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(position,\x201.0);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vh\x20=\x20position.y;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20', 'bgScale', 'defineProperties', 't1Tag', 'innerHTML', 'outline', 'fromEdgesGeometry', 'getBones', 'setBgColor', 'transformControl', 'circleOpts', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<common>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(vec3(0.)\x20,\x201.0);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20', 'castShadow', 'isObject3D', 'depth', 'bloomEnabled', 'clone', 'enabled', 'bokehPass', 'handlers', 'dispose', 'cubeOpts', 'AmbientLight', 'clientHeight', 'groundColor', 'ambientLight', 'NoToneMapping', 'matrixWorld', 'fill', 'viewState', 'scale', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20color;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20height;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20type;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20varying\x20float\x20vh;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_fragment>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(type\x20==\x200.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color,\x20mix(.045,\x201.,\x20vh\x20/\x20height));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else\x20if(type\x20==\x201.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color,\x20mix(.045,\x201.,\x20(height\x20-\x20vh)\x20/\x20height));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20', 'minHeight', 'dragTimer', 'parent', 'resize', 'risingMaxHeight', 'setAnimationLoop', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec2\x20vUv;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<common>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(position,\x201.0);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vUv\x20=\x20uv;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20', 'LineSegments2', 'dashScale', 'assign', 'rotateAnimation8', 'changeText', 'ondragenter', 'stringify', 'href', 'changeColor', 'startRotateAnimation8', 'indicateAnimation', 'getRenderTarget', 'fontSize2', 'fillRect', 'findObjectsByType', 'initModels', 'bind', 'computedSpreadCircle', 'hemiLight', 'getBoneByName', 'removeBloom', 'lineWidth', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20color;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20gradient;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20opacity;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec2\x20vp;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec2\x20uCenter;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#define\x20EPSILON\x201e-4\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#define\x20NUM\x201200\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#define\x20WIDTH\x20200\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<clipping_planes_pars_fragment>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<clipping_planes_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20gl_FragColor\x20=\x20vec4(\x20mix(color,\x20\x20vec3(0.)\x20,\x20vec3(\x20(height\x20-\x20vy)\x20/\x20height)\x20)\x20\x20,\x20opacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20gl_FragColor\x20=\x20vec4(\x20mix(\x20mix(color,\x20\x20vec3(0.)\x20,\x20vec3(\x20(height\x20-\x20vy)\x20/\x20height)\x20),\x20color\x20,\x20vec3(\x20(height\x20-\x20vy)\x20/\x20height)\x20)\x20\x20,\x20opacity);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p\x20=\x20vp;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color,\x20opacity);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#pragma\x20unroll_loop_start\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20for\x20(\x20int\x20i\x20=\x200;\x20i\x20<\x20NUM;\x20i+=20\x20)\x20{\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(i\x20==\x200){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(int(abs(uCenter.x\x20-\x20p.x))\x20>=\x20WIDTH\x20/\x202\x20*\x20i\x20&&\x20int(abs(uCenter.x\x20-\x20p.x))\x20<=\x20WIDTH\x20/\x202\x20*\x20(i\x20+\x201)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(vec3(1.),\x201.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else\x20if(int(abs(uCenter.y\x20-\x20p.y))\x20>=\x20WIDTH\x20/\x202\x20*\x20i\x20&&\x20int(abs(uCenter.y\x20-\x20p.y))\x20<=\x20WIDTH\x20/\x202\x20*\x20(i\x20+\x201)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(vec3(1.),\x201.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(int(abs(uCenter.x\x20-\x20p.x))\x20>=\x20WIDTH\x20*\x20i\x20&&\x20int(abs(uCenter.x\x20-\x20p.x))\x20<=\x20WIDTH\x20*\x20(i\x20+\x201)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(vec3(1.),\x201.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else\x20if(int(abs(uCenter.y\x20-\x20p.y))\x20>=\x20WIDTH\x20*\x20i\x20&&\x20int(abs(uCenter.y\x20-\x20p.y))\x20<=\x20WIDTH\x20*\x20(i\x20+\x201)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(vec3(1.),\x201.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#pragma\x20unroll_loop_end\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_fragment>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20', 'sphereRadius', 'onmouseup', '\x27\x20is\x20not\x20valid.', 'initRender', 'rotateAnimation13', 'isDrag', 'pictureDrawMode', 'filter', 'getDrawingBufferSize', 'rotation2D', 'maxblur', '90QkSvwn', 'stop', 'top', 'string', 'images', 'title1', 'sizeRange', 'template', 'setColors', 'clipAction', 'fontColor', 'material', 'rectAreaLights', 'model\x20name\x20should\x20be\x20uniqued.', '\x0avarying\x20vec2\x20vUv;\x0auniform\x20vec3\x20color;\x0a\x0a\x0a#include\x20<logdepthbuf_pars_fragment>\x0a\x0avoid\x20main(){\x0a#include\x20<logdepthbuf_fragment>\x0a\x20\x20\x20\x20float\x20pct\x20=\x20distance(vUv,\x20vec2(.5));\x0a\x0a\x20\x20\x20\x20if(pct\x20>\x20.35\x20&&\x20pct\x20<\x20.355){\x0a\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color,\x201.);\x0a\x20\x20\x20\x20}else\x20if(pct\x20>\x20.355\x20&&\x20pct\x20<\x20.5){\x0a\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color,\x201.\x20-\x20pct\x20/\x20.5);\x0a\x20\x20\x20\x20}\x20else{\x0a\x20\x20\x20\x20\x20\x20discard;\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a}\x0a', 'setSize', 'setColorOfWall', 'startRotatingAnimation2', 'texLoader', '530WOWABG', '#00ff00', 'loadExtrudeGeometry', '673255xWSdel', 'userSelect', 'autoUpdate', 'ssrSkyBox', 'geometry', 'Wrong\x20path!', 'max', 'clientX', 'eye', 'enableShadow', '12318fjTXRx', 'Icon', 'measureText', 'fbxLoader', 'risingAnimationBounce', 'setPixelRatio', 'array', 'wallSize', 'initLights', 'ddpPass', 'isBone', 'intensity', 'isCSS3DObject', 'canvasAnimation', 'subVectors', 'circleEfficiencyOpts', 'instanceColorEnd', 'clearColor', 'styleSheets', 'name', 'mixerActions', 'setIndex', 'hdrLoader', 'onload', 'length', 'setAttribute', 'updateCameras', 'fontFamily', 'updateTime', 'loadSkyBox', 'cubeTexLoader', 'clickObjects', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_fragment>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20color;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20radius;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20opacity;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20float\x20vh;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color,\x20mix(.045,\x20opacity,\x20(vh\x20/\x20radius\x20+\x201.)\x20/\x202.\x20));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20', 'canvasTextAutoLine', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20color;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20sampler2D\x20map;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20useMap;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20float\x20vOpacity;\x0a\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<common>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_fragment>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20d\x20=\x20distance(gl_PointCoord,\x20vec2(.5));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(d\x20<\x20.5){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(useMap\x20==\x200.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(\x20color,\x20vOpacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv\x20=\x20(vec3(\x20gl_PointCoord.x,\x201.0\x20-\x20gl_PointCoord.y,\x201\x20)\x20).xy;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20mapTexel\x20=\x20texture2D(\x20map,\x20uv\x20);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(\x20color,\x20vOpacity\x20\x20*\x20mapTexel.a\x20);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20gl_FragColor.rgb\x20=\x20mix(vec3(0.),\x20mapTexel.rgb,\x20gl_FragColor.rgb);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20gl_FragColor.rgb\x20+=\x20mapTexel.rgb;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20discard;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20', 'bold\x20', 'save', 'load', '/demos', 'status', 'baseTag', 'projectionMatrix', 'onmousedown', 'undefined', 'bloomStrength', 'initControls', 'lengthSq', 'metalness', 'lineHeight', 'createLinearGradient', 'DirectionLights', 'isSkinnedMesh', 'animationTag', 'bgType', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<common>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20pos;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(position,\x201.0);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20pos\x20=\x20position;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20', 'loadedFileResults', 'ssaa', 'setDecoderPath', 'text/json', 'outlineEnabled', 'canvasObject', 'TransformControls', 'hiddenEdgeColor', 'loadingBar', 'setColorOfPopup', 'ssrtEnabled', 'removeBloomSpecial', 'orbitControls', 'sortObjects', 'startRisingAnimation', 'spritPopupAttrs', 'domElement', 'closestPointToPointParameter', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<common>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec2\x20vUv;\x0a\x20\x20\x20\x20\x20\x20\x20\x20void\x20main()\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(position,\x201.0);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vUv\x20=\x20uv;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20}', 'holes', 'clickCallback', 'isPicturePopup', 'JSONParser', 'isCirclEfficiency', 'particlesNumbers', 'parentElement', '\x20\x0avarying\x20vec2\x20vUv;\x0auniform\x20vec3\x20color;\x0auniform\x20float\x20uTime;\x0auniform\x20float\x20ringWidth;\x0a\x0a#define\x20PI\x203.141592654\x0a#define\x20EPSILON\x201e-6\x0a\x0afloat\x20atan2(in\x20float\x20y,in\x20float\x20x){\x0a\x20\x20float\x20ax\x20=\x20abs(x);\x0a\x20\x20float\x20ay\x20=\x20abs(y);\x0a\x20\x20float\x20a\x20=\x20min(ax,\x20ay)\x20/\x20(max(ax,\x20ay)\x20+\x20EPSILON);\x0a\x20\x20float\x20s\x20=\x20a*a;\x0a\x20\x20float\x20r\x20=\x20((-.0464964749\x20*\x20s\x20+\x20.15931422)\x20*\x20s\x20-\x20.327622764)\x20*\x20s\x20*\x20a\x20+\x20a;\x0a\x20\x20if(ay\x20>\x20ax)\x20r\x20=\x20PI\x20/\x202.\x20-\x20r;\x0a\x20\x20if(x\x20<\x200.\x20)\x20r\x20=\x20PI\x20-\x20r;\x0a\x20\x20if(y\x20<\x200.\x20)\x20r\x20=\x202.\x20*\x20PI\x20-\x20r;\x0a\x20\x20return\x20r;\x0a}\x0a\x0a#include\x20<logdepthbuf_pars_fragment>\x0a\x0avoid\x20main(){\x0a#include\x20<logdepthbuf_fragment>\x0a\x20\x20\x20\x20float\x20pct\x20=\x20distance(vUv,\x20vec2(.5));\x0a\x0a\x20\x20\x20\x20if(pct\x20>\x20uTime\x20&&\x20pct\x20<\x20(uTime\x20+\x20ringWidth)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20dir\x20=\x20vUv\x20-\x20vec2(.5);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20theta\x20=\x20atan2(dir.y\x20,dir.x);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(theta\x20>\x200.\x20&&\x20theta\x20<\x20(PI\x20/\x202.)\x20){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20discard;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x20else\x20if(theta\x20>\x20PI\x20&&\x20theta\x20<\x20(3.\x20*\x20PI\x20/\x202.)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20discard;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x20else{\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color\x20,\x20mod(theta,\x20PI\x20/\x202.)\x20/\x20(\x20PI\x20/\x202.));\x0a\x20\x20\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20}\x20else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20discard;\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a}\x0a', 'result', 'THREE.LineGeometry\x20no\x20longer\x20supports\x20Geometry.\x20Use\x20THREE.BufferGeometry\x20instead.', 'italic\x20', 'showTitle', 'mixColor', 'Line2', 'isGeometry', 'supersampling', '\x0avarying\x20vec2\x20vUv;\x0auniform\x20vec3\x20color;\x0auniform\x20float\x20uTime;\x0auniform\x20float\x20uClockwise;\x0auniform\x20float\x20ringWidth;\x0auniform\x20float\x20rotateSpeed;\x0a\x0a#define\x20PI\x203.141592654\x0a#define\x20EPSILON\x201e-6\x0a\x0afloat\x20atan2(in\x20float\x20y,in\x20float\x20x){\x0a\x20\x20float\x20ax\x20=\x20abs(x);\x0a\x20\x20float\x20ay\x20=\x20abs(y);\x0a\x20\x20float\x20a\x20=\x20min(ax,\x20ay)\x20/\x20(max(ax,\x20ay)\x20+\x20EPSILON);\x0a\x20\x20float\x20s\x20=\x20a*a;\x0a\x20\x20float\x20r\x20=\x20((-.0464964749\x20*\x20s\x20+\x20.15931422)\x20*\x20s\x20-\x20.327622764)\x20*\x20s\x20*\x20a\x20+\x20a;\x0a\x20\x20if(ay\x20>\x20ax)\x20r\x20=\x20PI\x20/\x202.\x20-\x20r;\x0a\x20\x20if(x\x20<\x200.\x20)\x20r\x20=\x20PI\x20-\x20r;\x0a\x20\x20if(y\x20<\x200.\x20)\x20r\x20=\x202.\x20*\x20PI\x20-\x20r;\x0a\x20\x20return\x20r;\x0a}\x0a\x0a#include\x20<logdepthbuf_pars_fragment>\x0a\x0avoid\x20main(){\x0a#include\x20<logdepthbuf_fragment>\x0a\x20\x20\x20\x20float\x20pct\x20=\x20distance(vUv,\x20vec2(.5));\x0a\x0a\x20\x20\x20\x20if(pct\x20>\x20uTime\x20&&\x20pct\x20<\x20uTime\x20+\x20ringWidth){\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20dir\x20=\x20vUv\x20-\x20vec2(.5);\x0a\x20\x20\x20\x20\x20\x20\x20\x20dir\x20=\x20vec2(dir.x\x20*\x20cos(uTime\x20*\x20rotateSpeed)\x20-\x20dir.y\x20*\x20sin(uTime\x20*\x20rotateSpeed),\x20dir.x\x20*\x20sin(uTime\x20*\x20rotateSpeed)\x20+\x20dir.y\x20*\x20cos(uTime\x20*\x20rotateSpeed));\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20theta\x20=\x20atan2(dir.y\x20,dir.x);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(uClockwise\x20==\x201.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color\x20,\x20(2.\x20*\x20PI\x20-\x20theta)\x20/\x20(2.\x20*\x20PI));\x0a\x20\x20\x20\x20\x20\x20\x20\x20}else\x20if(uClockwise\x20==\x20-1.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color\x20,\x20theta\x20/\x20(2.\x20*\x20PI));\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20}\x20else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20discard;\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a}\x0a', 'draw', 'startPoint', '\x0a\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20color;\x0a\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20emissive;\x0a\x20\x20\x20\x20\x20\x20uniform\x20float\x20opacity;\x0a\x20\x20\x20\x20\x20\x20uniform\x20float\x20uTime;\x0a\x20\x20\x20\x20\x20\x20varying\x20vec2\x20vUv;\x0a\x0a\x20\x20\x20\x20\x20\x20#include\x20<common>\x0a\x20\x20\x20\x20\x20\x20#include\x20<fog_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_fragment>\x0a\x20\x20\x20\x20\x20\x20#include\x20<clipping_planes_pars_fragment>\x0a\x0a\x20\x20\x20\x20\x20\x20void\x20main()\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<clipping_planes_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_fragment>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20pct\x20=\x20distance(vUv,\x20vec2(.5));\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(pct\x20<\x20.1){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(emissive,\x20opacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x20else\x20if(pct\x20>\x20(.15\x20+\x20uTime)\x20&&\x20pct\x20<\x20(.16\x20+\x20uTime)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(emissive,\x20opacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x20else\x20if(pct\x20>\x20.4\x20&&\x20pct\x20<\x20.5){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color,\x20mix(.05,\x20opacity,\x20pct\x20/\x20.5\x20-\x20.8));\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x20else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20discard;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<fog_fragment>\x0a\x0a\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20', 'abs', 'render', 'isCSS2DObject', 'boneInverses', 'strokeStyle', 'baseSize', 'firstPerson', 'lerp', 'highp', 'auto', 'copy', '#0000ff', 'animations', '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<common>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20precision\x20highp\x20float;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20v_position;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20v_normal;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20vLightFront;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20vIndirectFront;\x0a\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20DOUBLE_SIDED\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20vLightBack;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec3\x20vIndirectBack;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<uv_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<uv2_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<bsdfs>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<lights_pars_begin>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<color_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<fog_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<clipping_planes_pars_vertex>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<uv_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<uv2_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<color_vertex>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<beginnormal_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<defaultnormal_vertex>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<begin_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<project_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<clipping_planes_vertex>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<worldpos_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<lights_lambert_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<fog_vertex>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20v_position\x20=\x20position;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20v_normal\x20=\x20normal;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20', 'enable', 'sign', 'instanceEnd', 'closeSize', 'paused', 'stroke', 'pow', 'lat', 'loadExtrudeMaterial', 'scene', '\x0a\x09\x09uniform\x20vec3\x20color;\x0a\x09\x09uniform\x20sampler2D\x20tDiffuse;\x0a\x09\x09uniform\x20float\x20opacity;\x0a\x09\x09varying\x20vec4\x20vUv;\x0a\x0a\x09\x09#include\x20<logdepthbuf_pars_fragment>\x0a\x0a\x09\x09float\x20blendOverlay(\x20float\x20base,\x20float\x20blend\x20)\x20{\x0a\x0a\x09\x09\x09return(\x20base\x20<\x200.5\x20?\x20(\x202.0\x20*\x20base\x20*\x20blend\x20)\x20:\x20(\x201.0\x20-\x202.0\x20*\x20(\x201.0\x20-\x20base\x20)\x20*\x20(\x201.0\x20-\x20blend\x20)\x20)\x20);\x0a\x0a\x09\x09}\x0a\x0a\x09\x09vec3\x20blendOverlay(\x20vec3\x20base,\x20vec3\x20blend\x20)\x20{\x0a\x0a\x09\x09\x09return\x20vec3(\x20blendOverlay(\x20base.r,\x20blend.r\x20),\x20blendOverlay(\x20base.g,\x20blend.g\x20),\x20blendOverlay(\x20base.b,\x20blend.b\x20)\x20);\x0a\x0a\x09\x09}\x0a\x0a\x09\x09void\x20main()\x20{\x0a\x0a\x09\x09\x09#include\x20<logdepthbuf_fragment>\x0a\x0a\x09\x09\x09vec4\x20base\x20=\x20texture2DProj(\x20tDiffuse,\x20vUv\x20);\x0a\x09\x09\x09gl_FragColor\x20=\x20vec4(\x20blendOverlay(\x20base.rgb,\x20color\x20),\x20opacity);\x0a\x0a\x09\x09}', 'ssr', '_viewState', 'computedScanCircle', 'time', 'totalDistance', 'gammaEnabled', 'cos', 'quat', 'titleSize', 'animationIndex', 'offset', 'squareRadius', 'img', 'updateBloomPass', 'minHeightBase', '\x0avarying\x20vec2\x20vUv;\x0auniform\x20vec3\x20color;\x0auniform\x20float\x20uTime;\x0auniform\x20float\x20uClockwise;\x0a\x0a#define\x20PI\x203.141592654\x0a#define\x20EPSILON\x201e-6\x0a\x0afloat\x20atan2(in\x20float\x20y,in\x20float\x20x){\x0a\x20\x20float\x20ax\x20=\x20abs(x);\x0a\x20\x20float\x20ay\x20=\x20abs(y);\x0a\x20\x20float\x20a\x20=\x20min(ax,\x20ay)\x20/\x20(max(ax,\x20ay)\x20+\x20EPSILON);\x0a\x20\x20float\x20s\x20=\x20a*a;\x0a\x20\x20float\x20r\x20=\x20((-.0464964749\x20*\x20s\x20+\x20.15931422)\x20*\x20s\x20-\x20.327622764)\x20*\x20s\x20*\x20a\x20+\x20a;\x0a\x20\x20if(ay\x20>\x20ax)\x20r\x20=\x20PI\x20/\x202.\x20-\x20r;\x0a\x20\x20if(x\x20<\x200.\x20)\x20r\x20=\x20PI\x20-\x20r;\x0a\x20\x20if(y\x20<\x200.\x20)\x20r\x20=\x202.\x20*\x20PI\x20-\x20r;\x0a\x20\x20return\x20r;\x0a}\x0a\x0a#include\x20<logdepthbuf_pars_fragment>\x0a\x0avoid\x20main(){\x0a#include\x20<logdepthbuf_fragment>\x0a\x20\x20\x20\x20float\x20pct\x20=\x20distance(vUv,\x20vec2(.5));\x0a\x0a\x20\x20\x20\x20if(pct\x20<\x20.15){\x0a\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color\x20*\x20(2.4\x20+\x20sin(2.2\x20*\x20uTime)),\x201.);\x0a\x20\x20\x20\x20}else\x20if(pct>\x20.4\x20&&\x20pct\x20<\x20.5){\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20dir\x20=\x20vUv\x20-\x20vec2(.5);\x0a\x20\x20\x20\x20\x20\x20\x20\x20dir\x20=\x20vec2(dir.x\x20*\x20cos(uTime)\x20-\x20dir.y\x20*\x20sin(uTime),\x20dir.x\x20*\x20sin(uTime)\x20+\x20dir.y\x20*\x20cos(uTime));\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20theta\x20=\x20atan2(dir.y\x20,dir.x);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(uClockwise\x20==\x201.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color\x20*\x20(2.4\x20+\x20sin(2.2\x20*\x20uTime)),\x20(2.\x20*\x20PI\x20-\x20theta)\x20/\x20(2.\x20*\x20PI));\x0a\x20\x20\x20\x20\x20\x20\x20\x20}else\x20if(uClockwise\x20==\x20-1.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color\x20*\x20(2.4\x20+\x20sin(2.2\x20*\x20uTime)),\x20theta\x20/\x20(2.\x20*\x20PI));\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20}\x20else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20discard;\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a}\x0a', 'risingAnimation2', 'popupOpts', 'hidden', 'pyramidColor', 'size', 'fillText', 'rotatingAnimation', 'preserveMatrix', 'drawImage', 'visible', 'offsets', 'precision', 'pointLights', 'uuid', '/edit', 'horseRaceLampAnimation', 'GammaPass', 'templatePublic', 'hPxText', 'toString', 'loadModelByUrls', 'hideTitle', 'shader', 'initCameras', 'normal', 'compileCubemapShader', 'instanceColorStart', 'diffuse', 'useTargetMatrix', 'params', 'SpotLights', 'startRotatingAnimation', 'onhover', '125888KuvvGI', 'src', 'rotateAnimation', 'format', 'duration', 'risingSpeed', 'positions', 'popup-close', 'titleHeight', 'distanceToSquared', 'ray', 'italic', 'iconAnimation', 'instanceStart', 'rotation', 'bolDragEnter', '1974DQfoUb', 'RectAreaLights', 'generateMipmaps', 'elements', 'mipmapCount', 'htmlEle', 'sans-serif', '\x0avarying\x20vec2\x20vUv;\x0auniform\x20vec3\x20color;\x0auniform\x20float\x20uTime;\x0auniform\x20float\x20opacity;\x0a\x0a#include\x20<logdepthbuf_pars_fragment>\x0a\x0avoid\x20main(){\x0a#include\x20<logdepthbuf_fragment>\x0a\x0afloat\x20pct\x20=\x20distance(vUv,\x20vec2(.5));\x0a\x0aif(pct\x20>\x20.48\x20&&\x20pct\x20<\x20.5){\x0a\x20\x20gl_FragColor\x20=\x20vec4(color,\x20opacity);\x0a}\x20else{\x0a\x20\x20discard;\x0a}\x0a\x0a#include\x20<tonemapping_fragment>\x0a}\x0a', 'left', 'isLineMaterial', 'envMapIntensity', 'speed', 'right', 'spreadEndHeight', 'fontColor1', 'bolDragEnd', 'fromBufferAttribute', 'origin', 'test', 'bias', '\x20is\x20not\x20supported.', 'compileEquirectangularShader', 'lifecycle', 'derivatives', 'sceneAnimations', 'radius', 'startTime', 'wallHeight', 'hide', '\x0a\x20\x20\x20\x20\x20\x20uniform\x20vec2\x20center;\x0a\x20\x20\x20\x20\x20\x20varying\x20vec2\x20vUv;\x0a\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20#include\x20<common>\x0a\x20\x20\x20\x20\x20\x20#include\x20<fog_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20#include\x20<clipping_planes_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20void\x20main()\x20{\x0a\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20mvPosition\x20=\x20modelViewMatrix\x20*\x20vec4(\x200.0,\x200.0,\x200.0,\x201.0\x20);\x0a\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20scale;\x0a\x20\x20\x20\x20\x20\x20\x20\x20scale.x\x20=\x20length(\x20vec3(\x20modelMatrix[\x200\x20].x,\x20modelMatrix[\x200\x20].y,\x20modelMatrix[\x200\x20].z\x20)\x20);\x0a\x20\x20\x20\x20\x20\x20\x20\x20scale.y\x20=\x20length(\x20vec3(\x20modelMatrix[\x201\x20].x,\x20modelMatrix[\x201\x20].y,\x20modelMatrix[\x201\x20].z\x20)\x20);\x0a\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20alignedPosition\x20=\x20(\x20position.xy\x20-\x20(\x20center\x20-\x20vec2(\x200.5\x20)\x20)\x20)\x20*\x20scale;\x0a\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20mvPosition.xy\x20+=\x20alignedPosition;\x0a\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20mvPosition;\x0a\x20\x20\x20\x20\x20\x20\x20\x20vUv\x20=\x20uv;\x20\x0a\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<clipping_planes_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<fog_vertex>\x0a\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20}', 'resourcePath', 'pulsePeriod', 'baseImageTitle', 'antialias', '\x0a#include\x20<common>\x0a#include\x20<color_pars_vertex>\x0a#include\x20<fog_pars_vertex>\x0a#include\x20<logdepthbuf_pars_vertex>\x0a#include\x20<clipping_planes_pars_vertex>\x0a\x0auniform\x20float\x20lineWidth;\x0auniform\x20vec2\x20resolution;\x0a\x0aattribute\x20vec3\x20instanceStart;\x0aattribute\x20vec3\x20instanceEnd;\x0a\x0aattribute\x20vec3\x20instanceColorStart;\x0aattribute\x20vec3\x20instanceColorEnd;\x0a\x0avarying\x20vec2\x20vUv;\x0a\x0a\x0a\x20\x20\x20\x20uniform\x20float\x20dashScale;\x0a\x20\x20\x20\x20attribute\x20float\x20instanceDistanceStart;\x0a\x20\x20\x20\x20attribute\x20float\x20instanceDistanceEnd;\x0a\x20\x20\x20\x20varying\x20float\x20vLineDistance;\x0a\x0a\x0avoid\x20trimSegment(\x20const\x20in\x20vec4\x20start,\x20inout\x20vec4\x20end\x20)\x20{\x0a\x0a\x20\x20\x20\x20//\x20trim\x20end\x20segment\x20so\x20it\x20terminates\x20between\x20the\x20camera\x20plane\x20and\x20the\x20near\x20plane\x0a\x0a\x20\x20\x20\x20//\x20conservative\x20estimate\x20of\x20the\x20near\x20plane\x0a\x20\x20\x20\x20float\x20a\x20=\x20projectionMatrix[\x202\x20][\x202\x20];\x20//\x203nd\x20entry\x20in\x203th\x20column\x0a\x20\x20\x20\x20float\x20b\x20=\x20projectionMatrix[\x203\x20][\x202\x20];\x20//\x203nd\x20entry\x20in\x204th\x20column\x0a\x20\x20\x20\x20float\x20nearEstimate\x20=\x20-\x200.5\x20*\x20b\x20/\x20a;\x0a\x0a\x20\x20\x20\x20float\x20alpha\x20=\x20(\x20nearEstimate\x20-\x20start.z\x20)\x20/\x20(\x20end.z\x20-\x20start.z\x20);\x0a\x0a\x20\x20\x20\x20end.xyz\x20=\x20mix(\x20start.xyz,\x20end.xyz,\x20alpha\x20);\x0a\x0a}\x0a\x0avoid\x20main()\x20{\x0a\x0a\x20\x20\x20\x20#ifdef\x20USE_COLOR\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20vColor.xyz\x20=\x20(\x20position.y\x20<\x200.5\x20)\x20?\x20instanceColorStart\x20:\x20instanceColorEnd;\x0a\x0a\x20\x20\x20\x20#endif\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20vLineDistance\x20=\x20(\x20position.y\x20<\x200.5\x20)\x20?\x20dashScale\x20*\x20instanceDistanceStart\x20:\x20dashScale\x20*\x20instanceDistanceEnd;\x0a\x0a\x20\x20\x20\x20float\x20aspect\x20=\x20resolution.x\x20/\x20resolution.y;\x0a\x0a\x20\x20\x20\x20vUv\x20=\x20uv;\x0a\x0a\x20\x20\x20\x20//\x20camera\x20space\x0a\x20\x20\x20\x20vec4\x20start\x20=\x20modelViewMatrix\x20*\x20vec4(\x20instanceStart,\x201.0\x20);\x0a\x20\x20\x20\x20vec4\x20end\x20=\x20modelViewMatrix\x20*\x20vec4(\x20instanceEnd,\x201.0\x20);\x0a\x0a\x20\x20\x20\x20//\x20special\x20case\x20for\x20perspective\x20projection,\x20and\x20segments\x20that\x20terminate\x20either\x20in,\x20or\x20behind,\x20the\x20camera\x20plane\x0a\x20\x20\x20\x20//\x20clearly\x20the\x20gpu\x20firmware\x20has\x20a\x20way\x20of\x20addressing\x20this\x20issue\x20when\x20projecting\x20into\x20ndc\x20space\x0a\x20\x20\x20\x20//\x20but\x20we\x20need\x20to\x20perform\x20ndc-space\x20calculations\x20in\x20the\x20shader,\x20so\x20we\x20must\x20address\x20this\x20issue\x20directly\x0a\x20\x20\x20\x20//\x20perhaps\x20there\x20is\x20a\x20more\x20elegant\x20solution\x20--\x20WestLangley\x0a\x0a\x20\x20\x20\x20bool\x20perspective\x20=\x20(\x20projectionMatrix[\x202\x20][\x203\x20]\x20==\x20-\x201.0\x20);\x20//\x204th\x20entry\x20in\x20the\x203rd\x20column\x0a\x0a\x20\x20\x20\x20if\x20(\x20perspective\x20)\x20{\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20if\x20(\x20start.z\x20<\x200.0\x20&&\x20end.z\x20>=\x200.0\x20)\x20{\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20trimSegment(\x20start,\x20end\x20);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x20else\x20if\x20(\x20end.z\x20<\x200.0\x20&&\x20start.z\x20>=\x200.0\x20)\x20{\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20trimSegment(\x20end,\x20start\x20);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20//\x20clip\x20space\x0a\x20\x20\x20\x20vec4\x20clipStart\x20=\x20projectionMatrix\x20*\x20start;\x0a\x20\x20\x20\x20vec4\x20clipEnd\x20=\x20projectionMatrix\x20*\x20end;\x0a\x0a\x20\x20\x20\x20//\x20ndc\x20space\x0a\x20\x20\x20\x20vec2\x20ndcStart\x20=\x20clipStart.xy\x20/\x20clipStart.w;\x0a\x20\x20\x20\x20vec2\x20ndcEnd\x20=\x20clipEnd.xy\x20/\x20clipEnd.w;\x0a\x0a\x20\x20\x20\x20//\x20direction\x0a\x20\x20\x20\x20vec2\x20dir\x20=\x20ndcEnd\x20-\x20ndcStart;\x0a\x0a\x20\x20\x20\x20//\x20account\x20for\x20clip-space\x20aspect\x20ratio\x0a\x20\x20\x20\x20dir.x\x20*=\x20aspect;\x0a\x20\x20\x20\x20dir\x20=\x20normalize(\x20dir\x20);\x0a\x0a\x20\x20\x20\x20//\x20perpendicular\x20to\x20dir\x0a\x20\x20\x20\x20vec2\x20offset\x20=\x20vec2(\x20dir.y,\x20-\x20dir.x\x20);\x0a\x0a\x20\x20\x20\x20//\x20undo\x20aspect\x20ratio\x20adjustment\x0a\x20\x20\x20\x20dir.x\x20/=\x20aspect;\x0a\x20\x20\x20\x20offset.x\x20/=\x20aspect;\x0a\x0a\x20\x20\x20\x20//\x20sign\x20flip\x0a\x20\x20\x20\x20if\x20(\x20position.x\x20<\x200.0\x20)\x20offset\x20*=\x20-\x201.0;\x0a\x0a\x20\x20\x20\x20//\x20endcaps\x0a\x20\x20\x20\x20if\x20(\x20position.y\x20<\x200.0\x20)\x20{\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20offset\x20+=\x20-\x20dir;\x0a\x0a\x20\x20\x20\x20}\x20else\x20if\x20(\x20position.y\x20>\x201.0\x20)\x20{\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20offset\x20+=\x20dir;\x0a\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20//\x20adjust\x20for\x20lineWidth\x0a\x20\x20\x20\x20offset\x20*=\x20lineWidth;\x0a\x0a\x20\x20\x20\x20//\x20adjust\x20for\x20clip-space\x20to\x20screen-space\x20conversion\x20//\x20maybe\x20resolution\x20should\x20be\x20based\x20on\x20viewport\x20...\x0a\x20\x20\x20\x20offset\x20/=\x20resolution.y;\x0a\x0a\x20\x20\x20\x20//\x20select\x20end\x0a\x20\x20\x20\x20vec4\x20clip\x20=\x20(\x20position.y\x20<\x200.5\x20)\x20?\x20clipStart\x20:\x20clipEnd;\x0a\x0a\x20\x20\x20\x20//\x20back\x20to\x20clip\x20space\x0a\x20\x20\x20\x20offset\x20*=\x20clip.w;\x0a\x0a\x20\x20\x20\x20clip.xy\x20+=\x20offset;\x0a\x0a\x20\x20\x20\x20gl_Position\x20=\x20clip;\x0a\x0a\x20\x20\x20\x20vec4\x20mvPosition\x20=\x20(\x20position.y\x20<\x200.5\x20)\x20?\x20start\x20:\x20end;\x20//\x20this\x20is\x20an\x20approximation\x0a\x0a\x20\x20\x20\x20#include\x20<logdepthbuf_vertex>\x0a\x20\x20\x20\x20#include\x20<clipping_planes_vertex>\x0a\x20\x20\x20\x20#include\x20<fog_vertex>\x0a\x0a}', 'toneMappingType', 'absolute', 'initScene', 'closed', '_bgColor', 'bloomComposer', 'lights', 'matrix', 'ssaaPass', 'dofEnabled', 'fromLine', 'startSpreadAnimation2', '#190a05', 'bgOffset', 'dashed', 'clockwise', 'downSampleRatio', 'onComplete', 'setFromSpherical', 'mipmaps', 'fragmentShader', 'spreadAnimation3', 'distanceTo', 'setTitle', 'includes', 'renderToScreen', 'gifTextures', 'aperture', '', 'wallColor', '56895CTwMCM', 'initialize', '\x0a\x09\x09uniform\x20vec3\x20diffuse;\x0a\x09\x09uniform\x20float\x20opacity;\x0a\x0a\x09\x09#ifdef\x20USE_DASH\x0a\x0a\x09\x09\x09uniform\x20float\x20dashSize;\x0a\x09\x09\x09uniform\x20float\x20dashOffset;\x0a\x09\x09\x09uniform\x20float\x20gapSize;\x0a\x0a\x09\x09#endif\x0a\x0a\x09\x09varying\x20float\x20vLineDistance;\x0a\x0a\x09\x09#include\x20<common>\x0a\x09\x09#include\x20<color_pars_fragment>\x0a\x09\x09#include\x20<fog_pars_fragment>\x0a\x09\x09#include\x20<logdepthbuf_pars_fragment>\x0a\x09\x09#include\x20<clipping_planes_pars_fragment>\x0a\x0a\x09\x09varying\x20vec2\x20vUv;\x0a\x0a\x09\x09void\x20main()\x20{\x0a\x0a\x09\x09\x09#include\x20<clipping_planes_fragment>\x0a\x0a\x09\x09\x09#ifdef\x20USE_DASH\x0a\x0a\x09\x09\x09\x09if\x20(\x20vUv.y\x20<\x20-\x201.0\x20||\x20vUv.y\x20>\x201.0\x20)\x20discard;\x20//\x20discard\x20endcaps\x0a\x0a\x09\x09\x09\x09if\x20(\x20mod(\x20vLineDistance\x20+\x20dashOffset,\x20dashSize\x20+\x20gapSize\x20)\x20>\x20dashSize\x20)\x20discard;\x20//\x20todo\x20-\x20FIX\x0a\x0a\x09\x09\x09#endif\x0a\x0a\x09\x09\x09float\x20alpha\x20=\x201.0;\x0a\x0a\x09\x09\x09#ifdef\x20ALPHA_TO_COVERAGE\x0a\x0a\x09\x09\x09//\x20artifacts\x20appear\x20on\x20some\x20hardware\x20if\x20a\x20derivative\x20is\x20taken\x20within\x20a\x20conditional\x0a\x09\x09\x09float\x20a\x20=\x20vUv.x;\x0a\x09\x09\x09float\x20b\x20=\x20(\x20vUv.y\x20>\x200.0\x20)\x20?\x20vUv.y\x20-\x201.0\x20:\x20vUv.y\x20+\x201.0;\x0a\x09\x09\x09float\x20len2\x20=\x20a\x20*\x20a\x20+\x20b\x20*\x20b;\x0a\x09\x09\x09float\x20dlen\x20=\x20fwidth(\x20len2\x20);\x0a\x0a\x09\x09\x09if\x20(\x20abs(\x20vUv.y\x20)\x20>\x201.0\x20)\x20{\x0a\x0a\x09\x09\x09\x09alpha\x20=\x201.0\x20-\x20smoothstep(\x201.0\x20-\x20dlen,\x201.0\x20+\x20dlen,\x20len2\x20);\x0a\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09#else\x0a\x0a\x09\x09\x09if\x20(\x20abs(\x20vUv.y\x20)\x20>\x201.0\x20)\x20{\x0a\x0a\x09\x09\x09\x09float\x20a\x20=\x20vUv.x;\x0a\x09\x09\x09\x09float\x20b\x20=\x20(\x20vUv.y\x20>\x200.0\x20)\x20?\x20vUv.y\x20-\x201.0\x20:\x20vUv.y\x20+\x201.0;\x0a\x09\x09\x09\x09float\x20len2\x20=\x20a\x20*\x20a\x20+\x20b\x20*\x20b;\x0a\x0a\x09\x09\x09\x09if\x20(\x20len2\x20>\x201.0\x20)\x20discard;\x0a\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09#endif\x0a\x0a\x09\x09\x09vec4\x20diffuseColor\x20=\x20vec4(\x20diffuse,\x20opacity\x20*\x20alpha\x20);\x0a\x0a\x09\x09\x09#include\x20<logdepthbuf_fragment>\x0a\x09\x09\x09#include\x20<color_fragment>\x0a\x0a\x09\x09\x09gl_FragColor\x20=\x20diffuseColor;\x0a\x0a\x09\x09\x09#include\x20<tonemapping_fragment>\x0a\x09\x09\x09#include\x20<encodings_fragment>\x0a\x09\x09\x09#include\x20<fog_fragment>\x0a\x09\x09\x09#include\x20<premultiplied_alpha_fragment>\x0a\x0a\x09\x09}', 'isCSS3DSprite', 'setCallBack', 'threshold', 'sizeAttenuation', 'lineSpacing', 'isCompositeIcon', 'show', 'minDistance', '9999', 'mixers', 'json', 'anchor', 'maxHeight', '\x0a\x09\x09uniform\x20mat4\x20textureMatrix;\x0a\x09\x09varying\x20vec4\x20vUv;\x0a\x0a\x09\x09#include\x20<common>\x0a\x09\x09#include\x20<logdepthbuf_pars_vertex>\x0a\x0a\x09\x09void\x20main()\x20{\x0a\x0a\x09\x09\x09vUv\x20=\x20textureMatrix\x20*\x20vec4(\x20position,\x201.0\x20);\x0a\x0a\x09\x09\x09gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(\x20position,\x201.0\x20);\x0a\x0a\x09\x09\x09#include\x20<logdepthbuf_vertex>\x0a\x0a\x09\x09}']; _0x39b8 = function () { return _0x2397a3 }; return _0x39b8() } function findHoleBridge (_0x1772d4, _0x380f1a) { const _0x638861 = { _0x16b22f: 0x425 }, _0x484e14 = _0x48e965; var _0x3875cb = _0x380f1a, _0x365ac1 = _0x1772d4['x'], _0x36de00 = _0x1772d4['y'], _0x472c78 = -Infinity, _0x491dca; do { if (_0x36de00 <= _0x3875cb['y'] && _0x36de00 >= _0x3875cb[_0x484e14(_0x638861._0x16b22f)]['y'] && _0x3875cb[_0x484e14(_0x638861._0x16b22f)]['y'] !== _0x3875cb['y']) { var _0xbb2f12 = _0x3875cb['x'] + (_0x36de00 - _0x3875cb['y']) * (_0x3875cb[_0x484e14(_0x638861._0x16b22f)]['x'] - _0x3875cb['x']) / (_0x3875cb[_0x484e14(0x425)]['y'] - _0x3875cb['y']); if (_0xbb2f12 <= _0x365ac1 && _0xbb2f12 > _0x472c78) { _0x472c78 = _0xbb2f12, _0x491dca = _0x3875cb['x'] < _0x3875cb[_0x484e14(0x425)]['x'] ? _0x3875cb : _0x3875cb['next']; if (_0xbb2f12 === _0x365ac1) return _0x491dca } } _0x3875cb = _0x3875cb[_0x484e14(0x425)] } while (_0x3875cb !== _0x380f1a); if (!_0x491dca) return null; var _0x31c990 = _0x491dca, _0xdc22a9 = _0x491dca['x'], _0x4a0552 = _0x491dca['y'], _0x58601e = Infinity, _0x3778a3; _0x3875cb = _0x491dca; do { _0x365ac1 >= _0x3875cb['x'] && _0x3875cb['x'] >= _0xdc22a9 && _0x365ac1 !== _0x3875cb['x'] && pointInTriangle(_0x36de00 < _0x4a0552 ? _0x365ac1 : _0x472c78, _0x36de00, _0xdc22a9, _0x4a0552, _0x36de00 < _0x4a0552 ? _0x472c78 : _0x365ac1, _0x36de00, _0x3875cb['x'], _0x3875cb['y']) && (_0x3778a3 = Math['abs'](_0x36de00 - _0x3875cb['y']) / (_0x365ac1 - _0x3875cb['x']), locallyInside(_0x3875cb, _0x1772d4) && (_0x3778a3 < _0x58601e || _0x3778a3 === _0x58601e && (_0x3875cb['x'] > _0x491dca['x'] || _0x3875cb['x'] === _0x491dca['x'] && sectorContainsSector(_0x491dca, _0x3875cb))) && (_0x491dca = _0x3875cb, _0x58601e = _0x3778a3)), _0x3875cb = _0x3875cb['next'] } while (_0x3875cb !== _0x31c990); return _0x491dca } function sectorContainsSector (_0x2d9d3d, _0x32b3e5) { const _0x50cd13 = { _0x4a4c99: 0x1f4, _0x542636: 0x425 }, _0x4b55f0 = _0x48e965; return area(_0x2d9d3d[_0x4b55f0(_0x50cd13._0x4a4c99)], _0x2d9d3d, _0x32b3e5['prev']) < 0x0 && area(_0x32b3e5[_0x4b55f0(0x425)], _0x2d9d3d, _0x2d9d3d[_0x4b55f0(_0x50cd13._0x542636)]) < 0x0 } function indexCurve (_0x225caa, _0x538cd1, _0x26babc, _0x1408c8) { const _0x3c891b = { _0x411ad8: 0x1f4, _0x40b541: 0x162, _0x45ff18: 0x466 }, _0x44c5ea = _0x48e965; var _0xb5ccdb = _0x225caa; do { if (_0xb5ccdb['z'] === 0x0) _0xb5ccdb['z'] = zOrder(_0xb5ccdb['x'], _0xb5ccdb['y'], _0x538cd1, _0x26babc, _0x1408c8); _0xb5ccdb[_0x44c5ea(0x466)] = _0xb5ccdb[_0x44c5ea(_0x3c891b._0x411ad8)], _0xb5ccdb[_0x44c5ea(0x162)] = _0xb5ccdb[_0x44c5ea(0x425)], _0xb5ccdb = _0xb5ccdb[_0x44c5ea(0x425)] } while (_0xb5ccdb !== _0x225caa); _0xb5ccdb[_0x44c5ea(0x466)][_0x44c5ea(_0x3c891b._0x40b541)] = null, _0xb5ccdb[_0x44c5ea(_0x3c891b._0x45ff18)] = null, sortLinked(_0xb5ccdb) } function sortLinked (_0x52691f) { const _0x2b6d35 = { _0x1c4656: 0x162, _0x41467c: 0x466 }, _0x303a92 = _0x48e965; var _0x5c2f9a, _0x30473a, _0x18449d, _0x4d4f59, _0x40b033, _0x272378, _0x1d990d, _0x59b1e7, _0x581957 = 0x1; do { _0x30473a = _0x52691f, _0x52691f = null, _0x40b033 = null, _0x272378 = 0x0; while (_0x30473a) { _0x272378++, _0x18449d = _0x30473a, _0x1d990d = 0x0; for (_0x5c2f9a = 0x0; _0x5c2f9a < _0x581957; _0x5c2f9a++) { _0x1d990d++, _0x18449d = _0x18449d[_0x303a92(0x162)]; if (!_0x18449d) break } _0x59b1e7 = _0x581957; while (_0x1d990d > 0x0 || _0x59b1e7 > 0x0 && _0x18449d) { _0x1d990d !== 0x0 && (_0x59b1e7 === 0x0 || !_0x18449d || _0x30473a['z'] <= _0x18449d['z']) ? (_0x4d4f59 = _0x30473a, _0x30473a = _0x30473a[_0x303a92(0x162)], _0x1d990d--) : (_0x4d4f59 = _0x18449d, _0x18449d = _0x18449d[_0x303a92(0x162)], _0x59b1e7--); if (_0x40b033) _0x40b033[_0x303a92(_0x2b6d35._0x1c4656)] = _0x4d4f59; else _0x52691f = _0x4d4f59; _0x4d4f59[_0x303a92(_0x2b6d35._0x41467c)] = _0x40b033, _0x40b033 = _0x4d4f59 } _0x30473a = _0x18449d } _0x40b033['nextZ'] = null, _0x581957 *= 0x2 } while (_0x272378 > 0x1); return _0x52691f } function zOrder (_0x3922aa, _0x35743c, _0x540a59, _0xa99619, _0x52ec3e) { return _0x3922aa = (_0x3922aa - _0x540a59) * _0x52ec3e | 0x0, _0x35743c = (_0x35743c - _0xa99619) * _0x52ec3e | 0x0, _0x3922aa = (_0x3922aa | _0x3922aa << 0x8) & 0xff00ff, _0x3922aa = (_0x3922aa | _0x3922aa << 0x4) & 0xf0f0f0f, _0x3922aa = (_0x3922aa | _0x3922aa << 0x2) & 0x33333333, _0x3922aa = (_0x3922aa | _0x3922aa << 0x1) & 0x55555555, _0x35743c = (_0x35743c | _0x35743c << 0x8) & 0xff00ff, _0x35743c = (_0x35743c | _0x35743c << 0x4) & 0xf0f0f0f, _0x35743c = (_0x35743c | _0x35743c << 0x2) & 0x33333333, _0x35743c = (_0x35743c | _0x35743c << 0x1) & 0x55555555, _0x3922aa | _0x35743c << 0x1 } function getLeftmost (_0x4d3ab0) { const _0x5c5451 = _0x48e965; var _0x12a21b = _0x4d3ab0, _0x51a43a = _0x4d3ab0; do { if (_0x12a21b['x'] < _0x51a43a['x'] || _0x12a21b['x'] === _0x51a43a['x'] && _0x12a21b['y'] < _0x51a43a['y']) _0x51a43a = _0x12a21b; _0x12a21b = _0x12a21b[_0x5c5451(0x425)] } while (_0x12a21b !== _0x4d3ab0); return _0x51a43a } function pointInTriangle (_0x29cde4, _0x572ee0, _0x5bdff0, _0x35f59e, _0x1e5f90, _0x35cdf5, _0x65a70f, _0x552d77) { return (_0x1e5f90 - _0x65a70f) * (_0x572ee0 - _0x552d77) >= (_0x29cde4 - _0x65a70f) * (_0x35cdf5 - _0x552d77) && (_0x29cde4 - _0x65a70f) * (_0x35f59e - _0x552d77) >= (_0x5bdff0 - _0x65a70f) * (_0x572ee0 - _0x552d77) && (_0x5bdff0 - _0x65a70f) * (_0x35cdf5 - _0x552d77) >= (_0x1e5f90 - _0x65a70f) * (_0x35f59e - _0x552d77) } function isValidDiagonal (_0x215af9, _0x1503c3) { const _0x753427 = { _0x12d0e4: 0x1f4, _0x3c45eb: 0x1f4 }, _0x3af571 = _0x48e965; return _0x215af9[_0x3af571(0x425)]['i'] !== _0x1503c3['i'] && _0x215af9['prev']['i'] !== _0x1503c3['i'] && !intersectsPolygon(_0x215af9, _0x1503c3) && (locallyInside(_0x215af9, _0x1503c3) && locallyInside(_0x1503c3, _0x215af9) && middleInside(_0x215af9, _0x1503c3) && (area(_0x215af9['prev'], _0x215af9, _0x1503c3[_0x3af571(0x1f4)]) || area(_0x215af9, _0x1503c3[_0x3af571(_0x753427._0x12d0e4)], _0x1503c3)) || equals(_0x215af9, _0x1503c3) && area(_0x215af9[_0x3af571(_0x753427._0x3c45eb)], _0x215af9, _0x215af9['next']) > 0x0 && area(_0x1503c3['prev'], _0x1503c3, _0x1503c3['next']) > 0x0) } function area (_0x460cf2, _0x4fd372, _0xa43a16) { return (_0x4fd372['y'] - _0x460cf2['y']) * (_0xa43a16['x'] - _0x4fd372['x']) - (_0x4fd372['x'] - _0x460cf2['x']) * (_0xa43a16['y'] - _0x4fd372['y']) } function equals (_0x103e12, _0x5ab541) { return _0x103e12['x'] === _0x5ab541['x'] && _0x103e12['y'] === _0x5ab541['y'] } function intersects (_0x4e6754, _0x33e955, _0x2b0bb4, _0x3e2d61) { var _0x487d42 = sign(area(_0x4e6754, _0x33e955, _0x2b0bb4)), _0x4164cc = sign(area(_0x4e6754, _0x33e955, _0x3e2d61)), _0x5b5ef3 = sign(area(_0x2b0bb4, _0x3e2d61, _0x4e6754)), _0x15e086 = sign(area(_0x2b0bb4, _0x3e2d61, _0x33e955)); if (_0x487d42 !== _0x4164cc && _0x5b5ef3 !== _0x15e086) return !![]; if (_0x487d42 === 0x0 && onSegment(_0x4e6754, _0x2b0bb4, _0x33e955)) return !![]; if (_0x4164cc === 0x0 && onSegment(_0x4e6754, _0x3e2d61, _0x33e955)) return !![]; if (_0x5b5ef3 === 0x0 && onSegment(_0x2b0bb4, _0x4e6754, _0x3e2d61)) return !![]; if (_0x15e086 === 0x0 && onSegment(_0x2b0bb4, _0x33e955, _0x3e2d61)) return !![]; return ![] } function onSegment (_0x1505ed, _0x1f8e5a, _0x34b7ae) { const _0x28a793 = { _0x68efd3: 0x25b, _0x164cf0: 0x305 }, _0x44bfb8 = _0x48e965; return _0x1f8e5a['x'] <= Math['max'](_0x1505ed['x'], _0x34b7ae['x']) && _0x1f8e5a['x'] >= Math[_0x44bfb8(_0x28a793._0x68efd3)](_0x1505ed['x'], _0x34b7ae['x']) && _0x1f8e5a['y'] <= Math[_0x44bfb8(_0x28a793._0x164cf0)](_0x1505ed['y'], _0x34b7ae['y']) && _0x1f8e5a['y'] >= Math[_0x44bfb8(0x25b)](_0x1505ed['y'], _0x34b7ae['y']) } function sign (_0x56b087) { return _0x56b087 > 0x0 ? 0x1 : _0x56b087 < 0x0 ? -0x1 : 0x0 } function intersectsPolygon (_0x3f4182, _0x46edbe) { const _0xf61fad = { _0x513fdc: 0x425 }, _0x5a1bd0 = _0x48e965; var _0x12d966 = _0x3f4182; do { if (_0x12d966['i'] !== _0x3f4182['i'] && _0x12d966['next']['i'] !== _0x3f4182['i'] && _0x12d966['i'] !== _0x46edbe['i'] && _0x12d966[_0x5a1bd0(_0xf61fad._0x513fdc)]['i'] !== _0x46edbe['i'] && intersects(_0x12d966, _0x12d966[_0x5a1bd0(0x425)], _0x3f4182, _0x46edbe)) return !![]; _0x12d966 = _0x12d966[_0x5a1bd0(0x425)] } while (_0x12d966 !== _0x3f4182); return ![] } function locallyInside (_0x5d9528, _0x3b8d0a) { const _0x44f2b0 = { _0x20b971: 0x1f4, _0x1f51cd: 0x425 }, _0x431600 = _0x48e965; return area(_0x5d9528[_0x431600(_0x44f2b0._0x20b971)], _0x5d9528, _0x5d9528[_0x431600(0x425)]) < 0x0 ? area(_0x5d9528, _0x3b8d0a, _0x5d9528['next']) >= 0x0 && area(_0x5d9528, _0x5d9528['prev'], _0x3b8d0a) >= 0x0 : area(_0x5d9528, _0x3b8d0a, _0x5d9528[_0x431600(0x1f4)]) < 0x0 || area(_0x5d9528, _0x5d9528[_0x431600(_0x44f2b0._0x1f51cd)], _0x3b8d0a) < 0x0 } function middleInside (_0x34da55, _0xcb9a61) { const _0x5e0c2e = { _0x2f316f: 0x425, _0x3f063e: 0x425, _0x273dc5: 0x425 }, _0x11ef56 = _0x48e965; var _0x179992 = _0x34da55, _0x48992c = ![], _0x58a864 = (_0x34da55['x'] + _0xcb9a61['x']) / 0x2, _0x30bb46 = (_0x34da55['y'] + _0xcb9a61['y']) / 0x2; do { if (_0x179992['y'] > _0x30bb46 !== _0x179992[_0x11ef56(_0x5e0c2e._0x2f316f)]['y'] > _0x30bb46 && _0x179992['next']['y'] !== _0x179992['y'] && _0x58a864 < (_0x179992[_0x11ef56(_0x5e0c2e._0x3f063e)]['x'] - _0x179992['x']) * (_0x30bb46 - _0x179992['y']) / (_0x179992[_0x11ef56(_0x5e0c2e._0x273dc5)]['y'] - _0x179992['y']) + _0x179992['x']) _0x48992c = !_0x48992c; _0x179992 = _0x179992['next'] } while (_0x179992 !== _0x34da55); return _0x48992c } function splitPolygon (_0x284a2f, _0x5dc543) { const _0xcdd791 = { _0x3e88f7: 0x1f4, _0x4ec11f: 0x425, _0x5debdf: 0x1f4, _0x576f92: 0x425 }, _0x493cff = _0x48e965; var _0x4cebac = new Node(_0x284a2f['i'], _0x284a2f['x'], _0x284a2f['y']), _0x56c025 = new Node(_0x5dc543['i'], _0x5dc543['x'], _0x5dc543['y']), _0x4047dc = _0x284a2f['next'], _0x192906 = _0x5dc543[_0x493cff(_0xcdd791._0x3e88f7)]; return _0x284a2f[_0x493cff(_0xcdd791._0x4ec11f)] = _0x5dc543, _0x5dc543[_0x493cff(_0xcdd791._0x5debdf)] = _0x284a2f, _0x4cebac['next'] = _0x4047dc, _0x4047dc[_0x493cff(_0xcdd791._0x5debdf)] = _0x4cebac, _0x56c025['next'] = _0x4cebac, _0x4cebac[_0x493cff(0x1f4)] = _0x56c025, _0x192906[_0x493cff(_0xcdd791._0x576f92)] = _0x56c025, _0x56c025[_0x493cff(0x1f4)] = _0x192906, _0x56c025 } function insertNode (_0x452e56, _0x5c1f9f, _0x155636, _0x2a7d2c) { const _0x2f3f2e = { _0x1ba083: 0x425 }, _0x1702e7 = _0x48e965; var _0xb2803a = new Node(_0x452e56, _0x5c1f9f, _0x155636); return !_0x2a7d2c ? (_0xb2803a['prev'] = _0xb2803a, _0xb2803a[_0x1702e7(_0x2f3f2e._0x1ba083)] = _0xb2803a) : (_0xb2803a['next'] = _0x2a7d2c[_0x1702e7(0x425)], _0xb2803a['prev'] = _0x2a7d2c, _0x2a7d2c[_0x1702e7(0x425)][_0x1702e7(0x1f4)] = _0xb2803a, _0x2a7d2c[_0x1702e7(0x425)] = _0xb2803a), _0xb2803a } function removeNode (_0x2856bd) { const _0x11dd91 = { _0x39f96b: 0x1f4, _0x18404c: 0x425, _0x16e367: 0x425, _0x1a618d: 0x162, _0x58612e: 0x466 }, _0x418b36 = _0x48e965; _0x2856bd[_0x418b36(0x425)][_0x418b36(_0x11dd91._0x39f96b)] = _0x2856bd[_0x418b36(0x1f4)], _0x2856bd[_0x418b36(0x1f4)][_0x418b36(_0x11dd91._0x18404c)] = _0x2856bd[_0x418b36(_0x11dd91._0x16e367)]; if (_0x2856bd['prevZ']) _0x2856bd[_0x418b36(0x466)]['nextZ'] = _0x2856bd[_0x418b36(0x162)]; if (_0x2856bd['nextZ']) _0x2856bd[_0x418b36(_0x11dd91._0x1a618d)][_0x418b36(_0x11dd91._0x58612e)] = _0x2856bd[_0x418b36(0x466)] } function Node (_0x14642a, _0x3d7991, _0x5b99e0) { const _0x564353 = { _0x518777: 0x1f4 }, _0xdbda64 = _0x48e965; this['i'] = _0x14642a, this['x'] = _0x3d7991, this['y'] = _0x5b99e0, this[_0xdbda64(_0x564353._0x518777)] = null, this['next'] = null, this['z'] = 0x0, this[_0xdbda64(0x466)] = null, this[_0xdbda64(0x162)] = null, this[_0xdbda64(0x1ca)] = ![] } earcut[_0x48e965(0x416)] = function (_0x36d16e, _0x2c86c8, _0x4ad846, _0xdaf401) { const _0x1fd2b5 = { _0x3f4138: 0x321, _0x3e1777: 0x367 }, _0x121cd = _0x48e965; var _0x12faed = _0x2c86c8 && _0x2c86c8[_0x121cd(0x321)], _0x2ee98b = _0x12faed ? _0x2c86c8[0x0] * _0x4ad846 : _0x36d16e[_0x121cd(_0x1fd2b5._0x3f4138)], _0x2de037 = Math[_0x121cd(_0x1fd2b5._0x3e1777)](signedArea(_0x36d16e, 0x0, _0x2ee98b, _0x4ad846)); if (_0x12faed) for (var _0x343c0a = 0x0, _0x557532 = _0x2c86c8['length']; _0x343c0a < _0x557532; _0x343c0a++) { var _0x551596 = _0x2c86c8[_0x343c0a] * _0x4ad846, _0x13df46 = _0x343c0a < _0x557532 - 0x1 ? _0x2c86c8[_0x343c0a + 0x1] * _0x4ad846 : _0x36d16e[_0x121cd(_0x1fd2b5._0x3f4138)]; _0x2de037 -= Math[_0x121cd(0x367)](signedArea(_0x36d16e, _0x551596, _0x13df46, _0x4ad846)) } var _0x1216de = 0x0; for (_0x343c0a = 0x0; _0x343c0a < _0xdaf401['length']; _0x343c0a += 0x3) { var _0x5d5436 = _0xdaf401[_0x343c0a] * _0x4ad846, _0x469962 = _0xdaf401[_0x343c0a + 0x1] * _0x4ad846, _0x1bcfe7 = _0xdaf401[_0x343c0a + 0x2] * _0x4ad846; _0x1216de += Math['abs']((_0x36d16e[_0x5d5436] - _0x36d16e[_0x1bcfe7]) * (_0x36d16e[_0x469962 + 0x1] - _0x36d16e[_0x5d5436 + 0x1]) - (_0x36d16e[_0x5d5436] - _0x36d16e[_0x469962]) * (_0x36d16e[_0x1bcfe7 + 0x1] - _0x36d16e[_0x5d5436 + 0x1])) } return _0x2de037 === 0x0 && _0x1216de === 0x0 ? 0x0 : Math[_0x121cd(0x367)]((_0x1216de - _0x2de037) / _0x2de037) }; function signedArea (_0x1b0d03, _0x545a05, _0x3e5802, _0x8bf93c) { var _0x2c67bb = 0x0; for (var _0x4c1d0a = _0x545a05, _0x52c26d = _0x3e5802 - _0x8bf93c; _0x4c1d0a < _0x3e5802; _0x4c1d0a += _0x8bf93c) { _0x2c67bb += (_0x1b0d03[_0x52c26d] - _0x1b0d03[_0x4c1d0a]) * (_0x1b0d03[_0x4c1d0a + 0x1] + _0x1b0d03[_0x52c26d + 0x1]), _0x52c26d = _0x4c1d0a } return _0x2c67bb } earcut[_0x48e965(0x417)] = function (_0x401a3e) { const _0x4c6185 = { _0x34d1d8: 0x321, _0x12f587: 0x21a, _0x291bd7: 0x353 }, _0x29a64b = _0x48e965; var _0x4910aa = _0x401a3e[0x0][0x0][_0x29a64b(_0x4c6185._0x34d1d8)], _0x5e8d00 = { 'vertices': [], 'holes': [], 'dimensions': _0x4910aa }, _0x5a7457 = 0x0; for (var _0x2be771 = 0x0; _0x2be771 < _0x401a3e[_0x29a64b(0x321)]; _0x2be771++) { for (var _0x39b06b = 0x0; _0x39b06b < _0x401a3e[_0x2be771][_0x29a64b(0x321)]; _0x39b06b++) { for (var _0x51ff49 = 0x0; _0x51ff49 < _0x4910aa; _0x51ff49++)_0x5e8d00[_0x29a64b(_0x4c6185._0x12f587)]['push'](_0x401a3e[_0x2be771][_0x39b06b][_0x51ff49]) } _0x2be771 > 0x0 && (_0x5a7457 += _0x401a3e[_0x2be771 - 0x1]['length'], _0x5e8d00[_0x29a64b(_0x4c6185._0x291bd7)][_0x29a64b(0x1da)](_0x5a7457)) } return _0x5e8d00 }, earcut_1[_0x48e965(0x28c)] = default_1; class BaseExtrudeShape extends Mesh { [_0x48e965(0x267)];[_0x48e965(0x496)];['center'];[_0x48e965(0x25a)]; constructor(_0x38d0a3) { const _0x49e5aa = { _0x44b307: 0x218, _0x3a36b1: 0x483, _0x23c437: 0x267, _0x17cca3: 0x25a, _0x3ff770: 0x43b }, _0x47e2ec = _0x48e965; super(), this['opts'] = Object[_0x47e2ec(0x2c9)]({ 'height': 0xa, 'color': _0x47e2ec(_0x49e5aa._0x44b307), 'center': [0x0, 0x0], 'extrude': ![], 'gradient': _0x47e2ec(_0x49e5aa._0x3a36b1), 'vertical': 0x5dc0 }, _0x38d0a3), this[_0x47e2ec(0x496)] = this[_0x47e2ec(0x267)][_0x47e2ec(0x496)] !== undefined ? this[_0x47e2ec(0x267)][_0x47e2ec(0x496)] : 0xa, this[_0x47e2ec(0x1c1)] = this[_0x47e2ec(_0x49e5aa._0x23c437)][_0x47e2ec(0x1c1)] !== undefined ? this[_0x47e2ec(0x267)][_0x47e2ec(0x1c1)] : [0x0, 0x0], this[_0x47e2ec(_0x49e5aa._0x17cca3)] = this[_0x47e2ec(0x267)]['extrude'] !== undefined ? this[_0x47e2ec(0x267)][_0x47e2ec(0x25a)] : ![], this[_0x47e2ec(0x25a)] ? (this[_0x47e2ec(0x2fe)](this['opts'][_0x47e2ec(0x27d)]), this[_0x47e2ec(0x37d)](_0x38d0a3)) : (this[_0x47e2ec(_0x49e5aa._0x3ff770)](this[_0x47e2ec(0x267)][_0x47e2ec(0x27d)]), this[_0x47e2ec(0x1de)](_0x38d0a3)) } [_0x48e965(0x1de)] (_0xe0df34) { const _0x5d733f = { _0x26402e: 0x209, _0x3db20c: 0x496, _0x12e4c4: 0x303, _0x2507eb: 0x1c0, _0x311462: 0x1c1, _0x4b2be8: 0x303, _0x412e07: 0x544 }, _0x327b12 = _0x48e965; this[_0x327b12(0x2f4)] = new ShaderMaterial({ 'transparent': !![], 'side': 0x2, 'uniforms': { 'color': { 'value': new Color(_0xe0df34[_0x327b12(_0x5d733f._0x26402e)]) }, 'opacity': { 'value': 0x1 }, 'height': { 'value': this[_0x327b12(_0x5d733f._0x3db20c)] }, 'gradient': { 'value': new Color(_0xe0df34['gradient']) }, 'uCenter': { 'value': new Vector2(this[_0x327b12(_0x5d733f._0x12e4c4)][_0x327b12(_0x5d733f._0x2507eb)]?.[_0x327b12(_0x5d733f._0x311462)]['x'], this[_0x327b12(_0x5d733f._0x4b2be8)]['boundingSphere']?.[_0x327b12(0x1c1)]['z']) } }, 'vertexShader': _0x327b12(_0x5d733f._0x412e07), 'fragmentShader': _0x327b12(0x2dd) }) } ['loadExtrudeMaterial'] (_0x3a5f1d) { const _0x1fe7b1 = { _0x2dcaa5: 0x2f4, _0x34fda8: 0x209, _0x5bfd90: 0x496, _0xecb1df: 0x1e3, _0x1aee38: 0x291 }, _0x1392cc = _0x48e965; this[_0x1392cc(_0x1fe7b1._0x2dcaa5)] = new ShaderMaterial({ 'transparent': !![], 'side': 0x2, 'uniforms': { 'color': { 'value': new Color(_0x3a5f1d[_0x1392cc(_0x1fe7b1._0x34fda8)]) }, 'opacity': { 'value': 0x1 }, 'height': { 'value': this[_0x1392cc(_0x1fe7b1._0x5bfd90)] }, 'gradient': { 'value': new Color(_0x3a5f1d[_0x1392cc(_0x1fe7b1._0xecb1df)]) }, 'vertical': { 'value': this[_0x1392cc(0x267)]['vertical'] } }, 'vertexShader': _0x1392cc(0x33f), 'fragmentShader': _0x1392cc(_0x1fe7b1._0x1aee38) }) } [_0x48e965(0x2fe)] (_0x56f7b6) { const _0x367c50 = { _0x318913: 0x4da, _0x5cf278: 0x321, _0x6976fe: 0x321, _0x36e4ac: 0x1da, _0x5e3330: 0x1da, _0x48987b: 0x321, _0xf23451: 0x432, _0x21e3c6: 0x4da, _0x19ffbb: 0x2b0, _0xeda789: 0x303, _0x5bee9c: 0x322, _0x1a077b: 0x3a8 }, _0x16327a = _0x48e965; let _0x4f6eb3 = [], _0x50d50b = [], _0x52fe81 = []; const _0x548954 = lnglat2mercator(this[_0x16327a(0x1c1)]); for (let _0x544db7 = 0x0; _0x544db7 < _0x56f7b6['length']; _0x544db7++) { const _0x5d8af6 = lnglat2mercator(_0x56f7b6[_0x544db7]); _0x4f6eb3 = _0x4f6eb3['concat'](_0x5d8af6), _0x50d50b = _0x50d50b[_0x16327a(_0x367c50._0x318913)](_0x5d8af6[0x0] - _0x548954[0x0], 0x0, _0x5d8af6[0x1] - _0x548954[0x1]) } _0x52fe81 = earcut_1(_0x4f6eb3); const _0x46b4f2 = []; let _0x222a01 = []; for (let _0x4190a1 = 0x0; _0x4190a1 < _0x50d50b['length']; _0x4190a1 += 0x3) { _0x46b4f2[_0x16327a(0x1da)](_0x50d50b[_0x4190a1], _0x50d50b[_0x4190a1 + 0x1] + this['height'], _0x50d50b[_0x4190a1 + 0x2]) } _0x222a01 = _0x50d50b['slice']()['concat'](_0x46b4f2); const _0x38768f = []; let _0x3446ed = []; for (let _0x4317f6 = 0x0; _0x4317f6 < _0x52fe81[_0x16327a(0x321)]; _0x4317f6 += 0x3) { _0x38768f[_0x16327a(0x1da)](_0x52fe81[_0x4317f6] + _0x46b4f2[_0x16327a(0x321)] / 0x3, _0x52fe81[_0x4317f6 + 0x1] + _0x46b4f2['length'] / 0x3, _0x52fe81[_0x4317f6 + 0x2] + _0x46b4f2[_0x16327a(_0x367c50._0x5cf278)] / 0x3) } _0x3446ed = _0x52fe81[_0x16327a(_0x367c50._0x318913)](_0x38768f); let _0x49a773 = []; const _0x2e57aa = [], _0x5f2c0b = _0x50d50b['slice']()[_0x16327a(0x4da)](_0x46b4f2), _0x291e7e = _0x222a01[_0x16327a(0x321)] / 0x3; for (let _0x49f53b = 0x0; _0x49f53b < _0x50d50b[_0x16327a(_0x367c50._0x6976fe)] / 0x3; _0x49f53b++) { _0x49f53b == _0x50d50b['length'] / 0x3 - 0x1 ? (_0x2e57aa[_0x16327a(_0x367c50._0x36e4ac)](_0x49f53b + _0x291e7e, 0x0 + _0x291e7e, _0x49f53b + _0x50d50b['length'] / 0x3 + _0x291e7e), _0x2e57aa[_0x16327a(0x1da)](_0x49f53b + _0x50d50b['length'] / 0x3 + _0x291e7e, 0x0 + _0x291e7e, 0x0 + _0x50d50b[_0x16327a(0x321)] / 0x3 + _0x291e7e)) : (_0x2e57aa[_0x16327a(_0x367c50._0x5e3330)](_0x49f53b + _0x291e7e, _0x49f53b + 0x1 + _0x291e7e, _0x49f53b + _0x50d50b[_0x16327a(_0x367c50._0x6976fe)] / 0x3 + _0x291e7e), _0x2e57aa['push'](_0x49f53b + _0x50d50b[_0x16327a(0x321)] / 0x3 + _0x291e7e, _0x49f53b + 0x1 + _0x291e7e, _0x49f53b + 0x1 + _0x50d50b[_0x16327a(_0x367c50._0x48987b)] / 0x3 + _0x291e7e)) } _0x222a01 = _0x222a01[_0x16327a(_0x367c50._0xf23451)]()[_0x16327a(_0x367c50._0x21e3c6)](_0x5f2c0b), _0x3446ed = _0x3446ed[_0x16327a(0x432)]()[_0x16327a(0x4da)](_0x2e57aa); for (let _0x2437d6 = 0x0; _0x2437d6 < _0x3446ed[_0x16327a(0x321)]; _0x2437d6 += 0x3) { const _0x52ed32 = _0x3446ed[_0x2437d6], _0x1dfb89 = _0x3446ed[_0x2437d6 + 0x1], _0x4325c4 = _0x3446ed[_0x2437d6 + 0x2], _0x3f9dc7 = new Vector3(_0x222a01[_0x1dfb89 * 0x3] - _0x222a01[_0x52ed32 * 0x3], _0x222a01[_0x1dfb89 * 0x3 + 0x1] - _0x222a01[_0x52ed32 * 0x3 + 0x1], _0x222a01[_0x1dfb89 * 0x3 + 0x2] - _0x222a01[_0x52ed32 * 0x3 + 0x2])[_0x16327a(0x497)](), _0x33a917 = new Vector3(_0x222a01[_0x4325c4 * 0x3] - _0x222a01[_0x52ed32 * 0x3], _0x222a01[_0x4325c4 * 0x3 + 0x1] - _0x222a01[_0x52ed32 * 0x3 + 0x1], _0x222a01[_0x4325c4 * 0x3 + 0x2] - _0x222a01[_0x52ed32 * 0x3 + 0x2])[_0x16327a(0x497)](), _0x265347 = _0x3f9dc7[_0x16327a(_0x367c50._0x19ffbb)]()[_0x16327a(0x441)](_0x33a917)['normalize'](); _0x49a773['push'](_0x265347['x'], _0x265347['y'], _0x265347['z'], _0x265347['x'], _0x265347['y'], _0x265347['z'], _0x265347['x'], _0x265347['y'], _0x265347['z']) } this[_0x16327a(_0x367c50._0xeda789)][_0x16327a(0x31e)](_0x3446ed), this[_0x16327a(0x303)][_0x16327a(_0x367c50._0x5bee9c)](_0x16327a(0x4c4), new Float32BufferAttribute(_0x222a01, 0x3)), this['geometry']['setAttribute'](_0x16327a(_0x367c50._0x1a077b), new Float32BufferAttribute(_0x49a773, 0x3)); if (this['extrude']) { const _0x305c9e = new BaseLine({ 'lineWidth': 0x1, 'color': _0x16327a(0x47d) }); _0x305c9e[_0x16327a(0x1ea)](_0x46b4f2), this[_0x16327a(0x44d)](_0x305c9e) } } [_0x48e965(0x43b)] (_0x254744) { const _0x291c0c = { _0x224508: 0x1c1, _0x4d0896: 0x4da, _0x1956b7: 0x303, _0x2634b1: 0x322, _0x457196: 0x1ea, _0x41fc11: 0x44d }, _0x1cff82 = _0x48e965; let _0x17f79a = [], _0x4c7eb4 = [], _0x5d1357 = [], _0x4d9489 = []; const _0x2f2511 = lnglat2mercator(this[_0x1cff82(_0x291c0c._0x224508)]); for (let _0x262418 = 0x0; _0x262418 < _0x254744['length']; _0x262418++) { const _0x2cba8a = lnglat2mercator(_0x254744[_0x262418]); _0x17f79a = _0x17f79a[_0x1cff82(0x4da)](_0x2cba8a), _0x4c7eb4 = _0x4c7eb4[_0x1cff82(_0x291c0c._0x4d0896)](_0x2cba8a[0x0] - _0x2f2511[0x0], 0x0, _0x2cba8a[0x1] - _0x2f2511[0x1]), _0x5d1357 = _0x5d1357[_0x1cff82(0x4da)](0x0, 0x1, 0x0) } _0x4d9489 = earcut_1(_0x17f79a), this[_0x1cff82(_0x291c0c._0x1956b7)][_0x1cff82(0x31e)](_0x4d9489), this[_0x1cff82(0x303)]['setAttribute']('position', new Float32BufferAttribute(_0x4c7eb4, 0x3)), this[_0x1cff82(0x303)][_0x1cff82(_0x291c0c._0x2634b1)]('normal', new Float32BufferAttribute(_0x5d1357, 0x3)); const _0x379032 = new BaseLine({ 'lineWidth': 0x6, 'color': _0x1cff82(0x47d) }); _0x379032[_0x1cff82(_0x291c0c._0x457196)](_0x4c7eb4), this[_0x1cff82(_0x291c0c._0x41fc11)](_0x379032) } } class BaseCube extends Mesh { ['opts'];['width'];[_0x48e965(0x496)];[_0x48e965(0x2ae)]; constructor(_0x3ad6e9) { const _0x335e08 = { _0x23a8e5: 0x267, _0x5840e7: 0x2c9, _0x2b7fb8: 0x218, _0x1de160: 0x15d, _0x4304b4: 0x15d, _0x4c5272: 0x267, _0x278590: 0x2ae, _0x31712a: 0x496, _0x254c86: 0x4da, _0x48701f: 0x303, _0x13284d: 0x3a8, _0x5e8182: 0x209, _0x25750d: 0x267, _0x502180: 0x1d0, _0x3cdf75: 0x2f4, _0x21d6aa: 0x42a, _0x349dd3: 0x2f4, _0xf747c6: 0x2f4, _0x4a0efe: 0x3ea }, _0x4dcc39 = _0x48e965; super(), this[_0x4dcc39(_0x335e08._0x23a8e5)] = Object[_0x4dcc39(_0x335e08._0x5840e7)]({ 'width': 0.015, 'height': 0.5, 'depth': 0.015, 'color': _0x4dcc39(_0x335e08._0x2b7fb8), 'mixColor': '#0000ff', 'mixColor2': '#000000', 'type': 0x0, 'threshold': 0x5dc, 'lights': !![] }, _0x3ad6e9), this[_0x4dcc39(_0x335e08._0x1de160)] = this['opts'][_0x4dcc39(_0x335e08._0x4304b4)] !== undefined ? this['opts'][_0x4dcc39(_0x335e08._0x1de160)] : 0.015, this['height'] = this[_0x4dcc39(0x267)]['height'] !== undefined ? this[_0x4dcc39(_0x335e08._0x23a8e5)][_0x4dcc39(0x496)] : 0.5, this['depth'] = this[_0x4dcc39(_0x335e08._0x4c5272)][_0x4dcc39(0x2ae)] !== undefined ? this[_0x4dcc39(_0x335e08._0x4c5272)]['depth'] : 0.015; const _0x48569d = [-this[_0x4dcc39(_0x335e08._0x4304b4)] / 0x2, 0x0, this[_0x4dcc39(0x2ae)] / 0x2, this[_0x4dcc39(_0x335e08._0x1de160)] / 0x2, 0x0, this['depth'] / 0x2, this[_0x4dcc39(0x15d)] / 0x2, 0x0, -this['depth'] / 0x2, -this[_0x4dcc39(0x15d)] / 0x2, 0x0, -this[_0x4dcc39(0x2ae)] / 0x2], _0x3f8b47 = [-this['width'] / 0x2, this[_0x4dcc39(0x496)], this['depth'] / 0x2, this['width'] / 0x2, this['height'], this[_0x4dcc39(_0x335e08._0x278590)] / 0x2, this[_0x4dcc39(0x15d)] / 0x2, this[_0x4dcc39(_0x335e08._0x31712a)], -this[_0x4dcc39(0x2ae)] / 0x2, -this[_0x4dcc39(0x15d)] / 0x2, this[_0x4dcc39(0x496)], -this['depth'] / 0x2], _0x58cb85 = _0x48569d['concat'](_0x3f8b47), _0x4077c2 = [0x0, 0x1, 0x3, 0x3, 0x1, 0x2], _0x5c136c = [0x4, 0x5, 0x7, 0x7, 0x5, 0x6], _0x465d1d = [0x0, 0x1, 0x4, 0x4, 0x1, 0x5, 0x1, 0x2, 0x5, 0x5, 0x2, 0x6, 0x2, 0x3, 0x6, 0x6, 0x3, 0x7, 0x3, 0x0, 0x7, 0x7, 0x0, 0x4], _0x45eaeb = _0x4077c2[_0x4dcc39(_0x335e08._0x254c86)](_0x5c136c)['concat'](_0x465d1d), _0x4f8c0a = [0x0, -0x1, 0x0, 0x0, -0x1, 0x0, 0x0, -0x1, 0x0, 0x0, -0x1, 0x0], _0x6d9af8 = [0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0], _0x2f36bc = [0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, -0x1, 0x0, 0x0, -0x1, 0x0, 0x0, -0x1, 0x0, 0x0, -0x1, -0x1, 0x0, 0x0, -0x1, 0x0, 0x0, -0x1, 0x0, 0x0, -0x1, 0x0, 0x0], _0x23f264 = _0x4f8c0a[_0x4dcc39(0x4da)](_0x6d9af8)[_0x4dcc39(0x4da)](_0x2f36bc); this[_0x4dcc39(0x303)]['setIndex'](_0x45eaeb), this[_0x4dcc39(0x303)][_0x4dcc39(0x322)]('position', new Float32BufferAttribute(_0x58cb85, 0x3)), this[_0x4dcc39(_0x335e08._0x48701f)][_0x4dcc39(0x322)](_0x4dcc39(_0x335e08._0x13284d), new Float32BufferAttribute(_0x23f264, 0x3)), this['material'] = new ShaderMaterial({ 'transparent': !![], 'uniforms': { 'color': { 'value': new Color(this[_0x4dcc39(0x267)][_0x4dcc39(_0x335e08._0x5e8182)]) }, 'height': { 'value': this[_0x4dcc39(_0x335e08._0x25750d)]['height'] }, 'threshold': { 'value': this[_0x4dcc39(_0x335e08._0x25750d)][_0x4dcc39(0x407)] }, 'type': { 'value': this['opts']['type'] }, 'opacity': { 'value': 0x1 }, 'mixColor': { 'value': new Color(this[_0x4dcc39(0x267)][_0x4dcc39(0x35f)]) }, 'mixColor2': { 'value': new Color(this[_0x4dcc39(0x267)]['mixColor2']) } }, 'vertexShader': _0x4dcc39(0x2a0), 'fragmentShader': _0x4dcc39(_0x335e08._0x502180) }), this[_0x4dcc39(_0x335e08._0x3cdf75)]['uniforms'] = UniformsUtils[_0x4dcc39(_0x335e08._0x21d6aa)]([this[_0x4dcc39(_0x335e08._0x349dd3)]['uniforms'], UniformsLib[_0x4dcc39(0x3ea)]]); if (this[_0x4dcc39(0x267)][_0x4dcc39(0x3ea)]) this[_0x4dcc39(_0x335e08._0xf747c6)]['defines'] = { 'LIGHTS': '' }; this[_0x4dcc39(_0x335e08._0x349dd3)][_0x4dcc39(_0x335e08._0x4a0efe)] = this[_0x4dcc39(0x267)][_0x4dcc39(0x3ea)] } } const fragmentShaders = [_0x48e965(0x166), _0x48e965(0x461), _0x48e965(0x38f), _0x48e965(0x43c), _0x48e965(0x2f7), _0x48e965(0x4a4), '\x0avarying\x20vec2\x20vUv;\x0auniform\x20vec3\x20color;\x0auniform\x20float\x20uTime;\x0auniform\x20float\x20ringWidth;\x0a\x0a#include\x20<logdepthbuf_pars_fragment>\x0a\x0avoid\x20main(){\x0a#include\x20<logdepthbuf_fragment>\x0a\x20\x20float\x20pct\x20=\x20distance(vUv,\x20vec2(.5));\x0a\x0a\x20\x20if(pct\x20>=\x20uTime\x20&&\x20pct\x20<=\x20(uTime\x20+\x20ringWidth)){\x0a\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color,\x20pct\x20/\x20(uTime\x20+\x20ringWidth)\x20-\x20(uTime\x20/\x20(uTime\x20+\x20ringWidth)));\x0a\x20\x20}\x20else{\x0a\x20\x20\x20\x20discard;\x0a\x20\x20}\x0a\x0a\x20\x20#include\x20<tonemapping_fragment>\x0a}\x0a', '\x0avarying\x20vec2\x20vUv;\x0auniform\x20vec3\x20color;\x0a\x0a#include\x20<logdepthbuf_pars_fragment>\x0a\x0avoid\x20main(){\x0a#include\x20<logdepthbuf_fragment>\x0a\x20\x20float\x20pct\x20=\x20distance(vUv,\x20vec2(.5));\x0a\x0a\x20\x20if(pct\x20>\x20.4\x20&&\x20pct\x20<\x20.5){\x0a\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color,\x20pct\x20/\x20.5\x20-\x20.8);\x0a\x20\x20}\x20else{\x0a\x20\x20\x20\x20\x20\x20discard;\x0a\x20\x20}\x0a\x0a\x20\x20#include\x20<tonemapping_fragment>\x0a}\x0a', _0x48e965(0x194), _0x48e965(0x46a), _0x48e965(0x3c8), _0x48e965(0x35a), _0x48e965(0x363), _0x48e965(0x16f)]; class BaseCircle extends Mesh { ['opts'];[_0x48e965(0x389)];[_0x48e965(0x4ed)];[_0x48e965(0x1ab)];[_0x48e965(0x44e)];[_0x48e965(0x26d)];[_0x48e965(0x3ce)];[_0x48e965(0x24e)];[_0x48e965(0x169)];['clockwise'];[_0x48e965(0x453)];['bounceTag']; constructor(_0x483365) { const _0x5ee5fc = { _0x5ef3d4: 0x2c9, _0x4d30ff: 0x47d, _0x2e896b: 0x47d, _0x452878: 0x389, _0x35e33c: 0x4ed, _0x41eaf1: 0x267, _0x33bd4d: 0x169, _0x29da15: 0x1ab, _0x211065: 0x44e, _0x1d3dbe: 0x267, _0x564701: 0x44e, _0x27a6d5: 0x267, _0x3994c0: 0x3f3, _0x26ad24: 0x24e, _0x1c9665: 0x453, _0x3709cd: 0x3da, _0x16f4e4: 0x303, _0xbcf4a7: 0x267, _0x2e06de: 0x209, _0x23a9e3: 0x169, _0x59667b: 0x2c6, _0x307cad: 0x1f0 }, _0x18678b = _0x48e965; super(), this[_0x18678b(0x267)] = Object[_0x18678b(_0x5ee5fc._0x5ef3d4)]({ 'radius': 0x1, 'color': _0x18678b(_0x5ee5fc._0x4d30ff), 'edgeColor': _0x18678b(_0x5ee5fc._0x2e896b), 'type': 0x0, 'spreadReset': !![], 'spreadStartRadius': 0.02, 'spreadEndRadius': 0.4, 'spreadSpeed': 0x1, 'clockwise': -0x1, 'spreadEndHeight': 0x0, 'spreadStartHeight': 0.5, 'ringWidth': 0.1, 'rotateSpeed': 0xa }, _0x483365), this[_0x18678b(_0x5ee5fc._0x452878)] = -0x1, this[_0x18678b(0x192)] = 0x1, this[_0x18678b(0x4ed)] = this[_0x18678b(0x267)][_0x18678b(_0x5ee5fc._0x35e33c)] !== undefined ? this[_0x18678b(_0x5ee5fc._0x41eaf1)][_0x18678b(_0x5ee5fc._0x35e33c)] : !![], this[_0x18678b(_0x5ee5fc._0x33bd4d)] = this['opts']['ringWidth'] !== undefined ? this['opts']['ringWidth'] : 0.1, this[_0x18678b(0x1ab)] = this['opts']['spreadStartRadius'] !== undefined ? this[_0x18678b(0x267)][_0x18678b(_0x5ee5fc._0x29da15)] : 0.02, this[_0x18678b(0x44e)] = this['opts'][_0x18678b(_0x5ee5fc._0x211065)] !== undefined ? this[_0x18678b(_0x5ee5fc._0x1d3dbe)][_0x18678b(_0x5ee5fc._0x564701)] : 0.4, this['spreadSpeed'] = this[_0x18678b(_0x5ee5fc._0x41eaf1)][_0x18678b(0x26d)] !== undefined ? this['opts'][_0x18678b(0x26d)] : 0x1, this['clockwise'] = this[_0x18678b(_0x5ee5fc._0x27a6d5)][_0x18678b(_0x5ee5fc._0x3994c0)] !== undefined ? this['opts'][_0x18678b(0x3f3)] : -0x1, this[_0x18678b(0x3ce)] = this['opts'][_0x18678b(0x3ce)] !== undefined ? this[_0x18678b(0x267)]['spreadEndHeight'] : 0x0, this[_0x18678b(0x24e)] = this['opts'][_0x18678b(0x24e)] !== undefined ? this[_0x18678b(_0x5ee5fc._0x27a6d5)][_0x18678b(_0x5ee5fc._0x26ad24)] : 0.5, this[_0x18678b(0x453)] = this[_0x18678b(0x267)][_0x18678b(_0x5ee5fc._0x1c9665)] !== undefined ? this[_0x18678b(0x267)][_0x18678b(0x453)] : 0xa, this[_0x18678b(0x303)] = new PlaneGeometry(this[_0x18678b(0x267)][_0x18678b(0x3da)], this['opts'][_0x18678b(_0x5ee5fc._0x3709cd)], 0x1, 0x1), this[_0x18678b(_0x5ee5fc._0x16f4e4)]['rotateX'](Math['PI'] / 0x2), this[_0x18678b(0x2f4)] = new ShaderMaterial({ 'side': 0x2, 'transparent': !![], 'uniforms': { 'edgeColor': { 'value': new Color(this['opts'][_0x18678b(0x4b5)]) }, 'color': { 'value': new Color(this[_0x18678b(_0x5ee5fc._0xbcf4a7)][_0x18678b(_0x5ee5fc._0x2e06de)]) }, 'uTime': { 'value': 0x0 }, 'uClockwise': { 'value': this[_0x18678b(0x3f3)] }, 'opacity': { 'value': 0x1 }, 'ringWidth': { 'value': this[_0x18678b(_0x5ee5fc._0x23a9e3)] }, 'rotateSpeed': { 'value': this['rotateSpeed'] } }, 'vertexShader': _0x18678b(_0x5ee5fc._0x59667b), 'fragmentShader': fragmentShaders[this[_0x18678b(_0x5ee5fc._0xbcf4a7)][_0x18678b(_0x5ee5fc._0x307cad)]] }) } [_0x48e965(0x2ca)] () { const _0x2967dd = { _0x442fe4: 0x2d7, _0x165971: 0x4ea, _0x2367bf: 0x27b, _0x2d26da: 0x3f3, _0x48d3b2: 0x27b }, _0x5b04ac = _0x48e965; this[_0x5b04ac(0x389)] = requestAnimationFrame(this['rotateAnimation8'][_0x5b04ac(_0x2967dd._0x442fe4)](this)), this[_0x5b04ac(0x2f4)][_0x5b04ac(0x234)][_0x5b04ac(_0x2967dd._0x165971)][_0x5b04ac(_0x2967dd._0x2367bf)] -= 0.01 * this[_0x5b04ac(_0x2967dd._0x2d26da)], this['material'][_0x5b04ac(0x234)]['uTime'][_0x5b04ac(_0x2967dd._0x48d3b2)] %= Math['PI'] * 0x2 } [_0x48e965(0x2d0)] () { const _0x25a8cc = _0x48e965; if (this[_0x25a8cc(0x267)][_0x25a8cc(0x1f0)] == 0x8) this[_0x25a8cc(0x2ca)]() } [_0x48e965(0x3b3)] () { const _0x107a9c = { _0x1d82cf: 0x2f4 }, _0x363aa5 = _0x48e965; this[_0x363aa5(0x389)] = requestAnimationFrame(this['rotateAnimation'][_0x363aa5(0x2d7)](this)), this[_0x363aa5(_0x107a9c._0x1d82cf)][_0x363aa5(0x234)]['uTime'][_0x363aa5(0x27b)] -= 0.01 * this['clockwise'] } [_0x48e965(0x1d9)] () { const _0x3169db = { _0x3798d6: 0x1f0, _0x111946: 0x1f0, _0x524ad5: 0x267, _0x5c9b0d: 0x1f0 }, _0x1d0808 = _0x48e965; if (this[_0x1d0808(0x267)][_0x1d0808(_0x3169db._0x3798d6)] == 0x0 || this['opts'][_0x1d0808(_0x3169db._0x111946)] == 0x1 || this[_0x1d0808(_0x3169db._0x524ad5)][_0x1d0808(_0x3169db._0x5c9b0d)] == 0x2) this[_0x1d0808(0x3b3)]() } ['spreadAnimation'] () { const _0x58ce97 = { _0x1e7a44: 0x229, _0x3fd1f2: 0x234, _0x5191ca: 0x234, _0x486c44: 0x4ea, _0x2adbc5: 0x44e, _0x3d2bf1: 0x27b, _0x988206: 0x1ab }, _0x40e775 = _0x48e965; this[_0x40e775(0x389)] = requestAnimationFrame(this[_0x40e775(_0x58ce97._0x1e7a44)][_0x40e775(0x2d7)](this)), this['material'][_0x40e775(_0x58ce97._0x3fd1f2)]['uTime']['value'] += 0.001 * this[_0x40e775(0x26d)], this['material'][_0x40e775(_0x58ce97._0x5191ca)][_0x40e775(_0x58ce97._0x486c44)][_0x40e775(0x27b)] >= this[_0x40e775(_0x58ce97._0x2adbc5)] && (this['material'][_0x40e775(0x234)][_0x40e775(0x4ea)][_0x40e775(_0x58ce97._0x3d2bf1)] = this[_0x40e775(0x4ed)] ? 0x0 : this[_0x40e775(_0x58ce97._0x988206)]) } [_0x48e965(0x4a6)] () { const _0x54a6d1 = { _0x5df37c: 0x267, _0x3ff63e: 0x1f0, _0x235f8a: 0x1ab }, _0x9bcfe8 = _0x48e965; (this[_0x9bcfe8(_0x54a6d1._0x5df37c)][_0x9bcfe8(_0x54a6d1._0x3ff63e)] == 0x6 || this[_0x9bcfe8(_0x54a6d1._0x5df37c)][_0x9bcfe8(0x1f0)] == 0xb) && (this[_0x9bcfe8(0x2f4)][_0x9bcfe8(0x234)][_0x9bcfe8(0x4ea)][_0x9bcfe8(0x27b)] = this[_0x9bcfe8(_0x54a6d1._0x235f8a)], this[_0x9bcfe8(0x229)]()) } [_0x48e965(0x30d)] () { const _0xd3efcf = { _0x1eb76c: 0x30d, _0x20b40d: 0x192, _0x3e5036: 0x4c4, _0x1265e8: 0x3ce }, _0x2cb300 = _0x48e965; this[_0x2cb300(0x389)] = requestAnimationFrame(this[_0x2cb300(_0xd3efcf._0x1eb76c)]['bind'](this)), this[_0x2cb300(0x2f4)]['uniforms'][_0x2cb300(0x4ea)][_0x2cb300(0x27b)] += 0.001 * this[_0x2cb300(_0xd3efcf._0x20b40d)] * this[_0x2cb300(0x26d)], this[_0x2cb300(_0xd3efcf._0x3e5036)]['y'] += this[_0x2cb300(_0xd3efcf._0x20b40d)] * this[_0x2cb300(0x26d)] * 0.001, (this[_0x2cb300(0x4c4)]['y'] >= this[_0x2cb300(_0xd3efcf._0x1265e8)] || this['position']['y'] <= this[_0x2cb300(0x24e)]) && (this['bounceTag'] *= -0x1) } ['startRisingAnimationBounce'] () { const _0x30ebc8 = { _0x5e0e82: 0x234, _0x41b7e2: 0x4ea, _0x5c66dd: 0x4c4 }, _0x2a8e95 = _0x48e965; this['opts']['type'] == 0x9 && (this[_0x2a8e95(0x2f4)][_0x2a8e95(_0x30ebc8._0x5e0e82)][_0x2a8e95(_0x30ebc8._0x41b7e2)][_0x2a8e95(0x27b)] = this[_0x2a8e95(0x1ab)], this[_0x2a8e95(_0x30ebc8._0x5c66dd)]['y'] = this[_0x2a8e95(0x24e)], this[_0x2a8e95(0x30d)]()) } ['spreadAnimation2'] () { const _0x4c8e24 = { _0x7601b5: 0x23d, _0x4d3e11: 0x2d7, _0x19605c: 0x2f4, _0x259d2e: 0x4ea, _0x3a921a: 0x27b, _0x650897: 0x234, _0x11833e: 0x27b, _0x4d70c2: 0x24e, _0x14278d: 0x3ce, _0x50760a: 0x26d }, _0x319751 = _0x48e965; this[_0x319751(0x389)] = requestAnimationFrame(this[_0x319751(_0x4c8e24._0x7601b5)][_0x319751(_0x4c8e24._0x4d3e11)](this)), this[_0x319751(_0x4c8e24._0x19605c)][_0x319751(0x234)][_0x319751(_0x4c8e24._0x259d2e)][_0x319751(_0x4c8e24._0x3a921a)] += 0.001 * this[_0x319751(0x26d)], this['material'][_0x319751(_0x4c8e24._0x650897)]['opacity'][_0x319751(_0x4c8e24._0x11833e)] -= 0x1 / ((this[_0x319751(0x44e)] - this['spreadStartRadius']) / (0.001 * this[_0x319751(0x26d)])), this[_0x319751(0x4c4)]['y'] -= (this[_0x319751(_0x4c8e24._0x4d70c2)] - this[_0x319751(_0x4c8e24._0x14278d)]) / ((this[_0x319751(0x44e)] - this[_0x319751(0x1ab)]) / (0.001 * this[_0x319751(_0x4c8e24._0x50760a)])), this[_0x319751(0x2f4)][_0x319751(0x234)][_0x319751(_0x4c8e24._0x259d2e)][_0x319751(0x27b)] >= this['spreadEndRadius'] && (this[_0x319751(0x2f4)][_0x319751(_0x4c8e24._0x650897)]['uTime'][_0x319751(0x27b)] = 0x0, this[_0x319751(0x2f4)][_0x319751(_0x4c8e24._0x650897)][_0x319751(0x236)][_0x319751(0x27b)] = 0x1, this['position']['y'] = this[_0x319751(_0x4c8e24._0x4d70c2)]) } [_0x48e965(0x3ef)] () { const _0x1b00c2 = { _0x266413: 0x267, _0x42ae0e: 0x1f0, _0x3e5c02: 0x4c4, _0x8aabd9: 0x24e }, _0x376a01 = _0x48e965; this[_0x376a01(_0x1b00c2._0x266413)][_0x376a01(_0x1b00c2._0x42ae0e)] == 0x9 && (this[_0x376a01(0x2f4)]['uniforms']['uTime']['value'] = this[_0x376a01(0x1ab)], this[_0x376a01(_0x1b00c2._0x3e5c02)]['y'] = this[_0x376a01(_0x1b00c2._0x8aabd9)], this[_0x376a01(0x23d)]()) } [_0x48e965(0x3f9)] () { const _0x4f3c56 = { _0x2a74b5: 0x389, _0x267b94: 0x234, _0x473064: 0x1ab, _0x4d7f37: 0x26d, _0x3557fd: 0x4c4, _0x2297ff: 0x234, _0x1a307a: 0x4ea, _0x500507: 0x27b, _0x4c6757: 0x4ed }, _0x32762a = _0x48e965; this[_0x32762a(_0x4f3c56._0x2a74b5)] = requestAnimationFrame(this[_0x32762a(0x3f9)]['bind'](this)), this[_0x32762a(0x2f4)][_0x32762a(_0x4f3c56._0x267b94)]['uTime']['value'] += 0.001 * this[_0x32762a(0x26d)], this['material']['uniforms'][_0x32762a(0x236)]['value'] -= 0x1 / ((this[_0x32762a(0x44e)] - this[_0x32762a(_0x4f3c56._0x473064)]) / (0.001 * this[_0x32762a(_0x4f3c56._0x4d7f37)])), this[_0x32762a(_0x4f3c56._0x3557fd)]['y'] += 0.001 * this['spreadSpeed'], this[_0x32762a(0x2f4)][_0x32762a(0x234)]['uTime'][_0x32762a(0x27b)] >= this['spreadEndRadius'] && (this[_0x32762a(0x2f4)][_0x32762a(_0x4f3c56._0x2297ff)][_0x32762a(_0x4f3c56._0x1a307a)][_0x32762a(_0x4f3c56._0x500507)] = this[_0x32762a(_0x4f3c56._0x4c6757)] ? 0x0 : this[_0x32762a(0x1ab)], this[_0x32762a(0x2f4)][_0x32762a(_0x4f3c56._0x267b94)][_0x32762a(0x236)][_0x32762a(_0x4f3c56._0x500507)] = 0x1, this['position']['y'] = this['spreadReset'] ? 0x0 : this[_0x32762a(0x24e)]) } [_0x48e965(0x28a)] () { const _0x5b634f = { _0x486959: 0x2f4, _0x32396a: 0x234, _0x571103: 0x27b, _0x382b79: 0x1ab, _0x439abc: 0x24e, _0x1fb381: 0x3f9 }, _0xc125d1 = _0x48e965; this['opts'][_0xc125d1(0x1f0)] == 0xc && (this[_0xc125d1(_0x5b634f._0x486959)][_0xc125d1(_0x5b634f._0x32396a)][_0xc125d1(0x4ea)][_0xc125d1(_0x5b634f._0x571103)] = this[_0xc125d1(_0x5b634f._0x382b79)], this['position']['y'] = this[_0xc125d1(_0x5b634f._0x439abc)], this[_0xc125d1(_0x5b634f._0x1fb381)]()) } [_0x48e965(0x2e2)] () { const _0x57404d = { _0x4927b1: 0x27b }, _0x2d1c6c = _0x48e965; this[_0x2d1c6c(0x389)] = requestAnimationFrame(this[_0x2d1c6c(0x2e2)][_0x2d1c6c(0x2d7)](this)), this['material']['uniforms']['uTime'][_0x2d1c6c(_0x57404d._0x4927b1)] += 0.001 } [_0x48e965(0x199)] () { const _0x53b3de = _0x48e965; this[_0x53b3de(0x267)][_0x53b3de(0x1f0)] == 0xd && this[_0x53b3de(0x2e2)]() } ['stopAnimation'] () { const _0x32cd20 = _0x48e965; cancelAnimationFrame(this['animationIndex']), this[_0x32cd20(0x389)] = -0x1 } } const drawText$1 = [drawTextCanvas, drawTextCanvas2, drawTextCanvas3, drawTextCanvas4, drawTextCanvas5, drawTextCanvas6], updateText = [updateTextCanvas, updateTextCanvas2]; class BaseTitle extends Sprite { [_0x48e965(0x28e)];['opts'];[_0x48e965(0x3e8)];[_0x48e965(0x236)];[_0x48e965(0x2f3)];['strokeColor'];[_0x48e965(0x4d6)];['height'];[_0x48e965(0x23e)];[_0x48e965(0x1ed)];[_0x48e965(0x23a)];['_height'];[_0x48e965(0x1db)]; constructor(_0x51dd22) { const _0x23008a = { _0x58ca0f: 0x459, _0x5eca9a: 0x236, _0x1862ef: 0x2f3, _0x190877: 0x47d, _0xe81fff: 0x28e, _0x5b6bd0: 0x4d6, _0x34ac56: 0x2c9, _0x25e975: 0x2f3, _0xc0b1cf: 0x459, _0xd6f010: 0x496, _0x2d12e6: 0x188, _0x1cc221: 0x459, _0x10a055: 0x267, _0x1094b0: 0x292, _0xb541f4: 0x496, _0x11bc67: 0x2be, _0x12279e: 0x49f, _0x55e721: 0x489 }, _0x1ecdb6 = _0x48e965; super(), this['_bgColor'] = new Color(_0x51dd22?.['bgColor'] !== undefined ? _0x51dd22?.[_0x1ecdb6(_0x23008a._0x58ca0f)] : '#ff0000'), this['opacity'] = _0x51dd22?.[_0x1ecdb6(_0x23008a._0x5eca9a)] !== undefined ? _0x51dd22[_0x1ecdb6(_0x23008a._0x5eca9a)] : 0x1, this[_0x1ecdb6(0x2f3)] = _0x51dd22?.['fontColor'] !== undefined ? _0x51dd22?.[_0x1ecdb6(_0x23008a._0x1862ef)] : _0x1ecdb6(_0x23008a._0x190877), this['strokeColor'] = _0x51dd22?.['strokeColor'] !== undefined ? _0x51dd22?.[_0x1ecdb6(0x279)] : _0x1ecdb6(0x218), this[_0x1ecdb6(_0x23008a._0xe81fff)] = _0x51dd22?.['text'] !== undefined ? _0x51dd22?.[_0x1ecdb6(0x28e)] : '', this[_0x1ecdb6(_0x23008a._0x5b6bd0)] = _0x51dd22?.[_0x1ecdb6(0x4d6)] !== undefined ? _0x51dd22?.['fontSize'] : 0x40, this[_0x1ecdb6(0x496)] = _0x51dd22?.[_0x1ecdb6(0x496)] !== undefined ? _0x51dd22?.[_0x1ecdb6(0x496)] : 0x0, this[_0x1ecdb6(0x23e)] = _0x51dd22?.[_0x1ecdb6(0x1f0)] !== undefined ? _0x51dd22?.[_0x1ecdb6(0x1f0)] : 0x0, this[_0x1ecdb6(0x1ed)] = _0x51dd22?.[_0x1ecdb6(0x394)] !== undefined ? _0x51dd22?.[_0x1ecdb6(0x394)] : 0x1, this[_0x1ecdb6(0x267)] = Object[_0x1ecdb6(_0x23008a._0x34ac56)]({ 'text': this[_0x1ecdb6(0x28e)], 'fontColor': this[_0x1ecdb6(_0x23008a._0x25e975)], 'bgColor': this[_0x1ecdb6(_0x23008a._0xc0b1cf)], 'strokeColor': this[_0x1ecdb6(0x279)], 'fontSize': this[_0x1ecdb6(_0x23008a._0x5b6bd0)], 'height': this[_0x1ecdb6(_0x23008a._0xd6f010)], 'size': this[_0x1ecdb6(_0x23008a._0x2d12e6)], 'type': this[_0x1ecdb6(0x23e)] }, _0x51dd22); const { canvas: _0x23fded, width: _0x4b0295, height: _0x69a082 } = drawText$1[this['textType']]({ 'text': this['opts']['text'], 'fontColor': this[_0x1ecdb6(0x267)][_0x1ecdb6(0x2f3)], 'bgColor': this[_0x1ecdb6(0x267)][_0x1ecdb6(_0x23008a._0x1cc221)], 'strokeColor': this[_0x1ecdb6(_0x23008a._0x10a055)][_0x1ecdb6(0x279)], 'fontSize': this['opts'][_0x1ecdb6(_0x23008a._0x5b6bd0)] }); this[_0x1ecdb6(0x1db)] = _0x23fded; const _0x26db44 = new CanvasTexture(_0x23fded); _0x26db44[_0x1ecdb6(_0x23008a._0x1094b0)] = sRGBEncoding, this[_0x1ecdb6(0x2f4)] = new SpriteMaterial({ 'map': _0x26db44, 'transparent': !![], 'opacity': 0x1 }), this['canvasWidth'] = _0x4b0295, this[_0x1ecdb6(0x489)] = _0x69a082, this['center']['set'](0.5, 0x0), this['position']['set'](0x0, this[_0x1ecdb6(_0x23008a._0xb541f4)], 0x0), this[_0x1ecdb6(_0x23008a._0x11bc67)][_0x1ecdb6(_0x23008a._0x12279e)](this[_0x1ecdb6(0x188)] * this[_0x1ecdb6(0x530)] / this[_0x1ecdb6(_0x23008a._0x55e721)], this[_0x1ecdb6(_0x23008a._0x2d12e6)], 0x1) } get [_0x48e965(0x459)] () { const _0x2c506f = { _0x53ef4f: 0x3e8 }, _0x35a7fe = _0x48e965; return _0x35a7fe(0x180) + this['_bgColor']['r'] * 0xff + ',' + this[_0x35a7fe(_0x2c506f._0x53ef4f)]['g'] * 0xff + ',' + this[_0x35a7fe(_0x2c506f._0x53ef4f)]['b'] * 0xff + ',' + this['opacity'] + ')' } set [_0x48e965(0x459)] (_0x19495c) { const _0x11e5ea = { _0x51f007: 0x3e8 }, _0x5d3c4c = _0x48e965; this[_0x5d3c4c(_0x11e5ea._0x51f007)]['set'](_0x19495c) } get [_0x48e965(0x188)] () { const _0x20d470 = _0x48e965; return this[_0x20d470(0x1ed)] } set ['canvasSize'] (_0x2c8689) { const _0x552985 = _0x48e965; this[_0x552985(0x1ed)] = _0x2c8689 } get [_0x48e965(0x530)] () { const _0x167a33 = { _0x22e170: 0x23a }, _0x58ef55 = _0x48e965; return this[_0x58ef55(_0x167a33._0x22e170)] } set ['canvasWidth'] (_0x21f22a) { this['_width'] = _0x21f22a } get [_0x48e965(0x489)] () { return this['_height'] } set [_0x48e965(0x489)] (_0x1d1e98) { this['_height'] = _0x1d1e98 } ['update'] ({ type: _0x1253dc, text: _0x5cd14c, fontColor: _0x1ae59d, bgColor: _0xd6a4e1, strokeColor: _0x5a6ba9, fontSize: _0x583226, size: _0x2ead6d }) { const _0x4368da = { _0x5b04dd: 0x1f6, _0x52a2b5: 0x459, _0x5485a8: 0x279, _0x297c52: 0x23e, _0x3fdf2d: 0x188, _0x37d4ec: 0x188, _0x4cf3fd: 0x530, _0x12680a: 0x530, _0x28c6a8: 0x188, _0x416819: 0x2f4, _0x412e39: 0x1ac }, _0x76570a = _0x48e965; if (!this['canvasElement']) throw new Error(_0x76570a(_0x4368da._0x5b04dd)); if (_0xd6a4e1 !== undefined) this[_0x76570a(_0x4368da._0x52a2b5)] = _0xd6a4e1; this['fontColor'] = _0x1ae59d !== undefined ? _0x1ae59d : this[_0x76570a(0x2f3)], this[_0x76570a(_0x4368da._0x5485a8)] = _0x5a6ba9 !== undefined ? _0x5a6ba9 : this[_0x76570a(_0x4368da._0x5485a8)], this[_0x76570a(0x28e)] = _0x5cd14c !== undefined ? _0x5cd14c : this['text'], this[_0x76570a(0x4d6)] = _0x583226 !== undefined ? _0x583226 : this[_0x76570a(0x4d6)], this[_0x76570a(_0x4368da._0x297c52)] = _0x1253dc !== undefined ? _0x1253dc : this[_0x76570a(0x23e)], this[_0x76570a(_0x4368da._0x3fdf2d)] = _0x2ead6d !== undefined ? _0x2ead6d : this[_0x76570a(_0x4368da._0x37d4ec)]; const _0xfe3ce7 = Object[_0x76570a(0x2c9)]({ 'text': this[_0x76570a(0x28e)], 'fontColor': this[_0x76570a(0x2f3)], 'bgColor': this[_0x76570a(0x459)], 'strokeColor': this[_0x76570a(_0x4368da._0x5485a8)], 'fontSize': this[_0x76570a(0x4d6)], 'canvas': this[_0x76570a(0x1db)] }), { width: _0x3aa6a9, height: _0x4797dc } = updateText[this['textType']](_0xfe3ce7); this[_0x76570a(_0x4368da._0x4cf3fd)] = _0x3aa6a9, this['canvasHeight'] = _0x4797dc, this['scale'][_0x76570a(0x49f)](this[_0x76570a(_0x4368da._0x3fdf2d)] * this[_0x76570a(_0x4368da._0x12680a)] / this['canvasHeight'], this[_0x76570a(_0x4368da._0x28c6a8)], 0x1); if (this[_0x76570a(_0x4368da._0x416819)][_0x76570a(_0x4368da._0x412e39)]) this[_0x76570a(_0x4368da._0x416819)][_0x76570a(_0x4368da._0x412e39)][_0x76570a(0x4f8)] = !![]; this['material'][_0x76570a(0x4f8)] = !![] } } class BaseShapeVicGeometry extends BufferGeometry { constructor() { const _0x5e784d = { _0x44ddd9: 0x49f, _0x56447c: 0x441, _0x1c8fe8: 0x4c4, _0x2df535: 0x322, _0x224e20: 0x3a8 }, _0x807951 = _0x48e965; super(); const _0x32197c = [0x0, 0x0, 0x0, 0.25, 0.5, 0x0, 0x0, 0.3, 0.1, 0x0, 0x0, 0x0, 0x0, 0.3, 0.1, -0.25, 0.5, 0x0, 0x0, 0x0, 0x0, 0x0, 0.3, -0.1, 0.25, 0.5, 0x0, 0x0, 0x0, 0x0, -0.25, 0.5, 0x0, 0x0, 0.3, -0.1, 0.25, 0.5, 0x0, 0x0, 0.3, -0.1, 0x0, 0.3, 0.1, 0x0, 0.3, 0.1, 0x0, 0.3, -0.1, -0.25, 0.5, 0x0], _0x113fea = new Vector3(), _0x218fe7 = new Vector3(), _0x39b0d0 = []; for (let _0x3d9edf = 0x0; _0x3d9edf < _0x32197c[_0x807951(0x321)]; _0x3d9edf += 0x9) { _0x113fea[_0x807951(_0x5e784d._0x44ddd9)](_0x32197c[_0x3d9edf + 0x3] - _0x32197c[_0x3d9edf], _0x32197c[_0x3d9edf + 0x4] - _0x32197c[_0x3d9edf + 0x1], _0x32197c[_0x3d9edf + 0x5] - _0x32197c[_0x3d9edf + 0x2]), _0x218fe7[_0x807951(0x49f)](_0x32197c[_0x3d9edf + 0x6] - _0x32197c[_0x3d9edf], _0x32197c[_0x3d9edf + 0x7] - _0x32197c[_0x3d9edf + 0x1], _0x32197c[_0x3d9edf + 0x8] - _0x32197c[_0x3d9edf + 0x2]); const _0x5355d2 = _0x113fea[_0x807951(0x2b0)]()[_0x807951(_0x5e784d._0x56447c)](_0x218fe7)[_0x807951(0x497)](); _0x39b0d0[_0x807951(0x1da)](_0x5355d2['x'], _0x5355d2['y'], _0x5355d2['z'], _0x5355d2['x'], _0x5355d2['y'], _0x5355d2['z'], _0x5355d2['x'], _0x5355d2['y'], _0x5355d2['z']) } this[_0x807951(0x322)](_0x807951(_0x5e784d._0x1c8fe8), new BufferAttribute(new Float32Array(_0x32197c), 0x3)), this[_0x807951(_0x5e784d._0x2df535)](_0x807951(_0x5e784d._0x224e20), new BufferAttribute(new Float32Array(_0x39b0d0), 0x3)) } } class BaseShapeVic extends Mesh { [_0x48e965(0x267)];[_0x48e965(0x389)];['speed']; constructor(_0x138df8) { const _0x22a635 = { _0x277984: 0x267, _0xe672cf: 0x2c9, _0x2614d8: 0x218, _0x58db0d: 0x209, _0x269f62: 0x3cc, _0x40b93a: 0x3cc }, _0x566ce3 = _0x48e965; super(), this[_0x566ce3(_0x22a635._0x277984)] = Object[_0x566ce3(_0x22a635._0xe672cf)]({ 'color': _0x566ce3(_0x22a635._0x2614d8) }, _0x138df8), this[_0x566ce3(0x303)] = new BaseShapeVicGeometry(), this['material'] = new MeshStandardMaterial({ 'color': this[_0x566ce3(0x267)][_0x566ce3(_0x22a635._0x58db0d)], 'transparent': !![], 'side': 0x2 }), this['animationIndex'] = -0x1, this[_0x566ce3(_0x22a635._0x269f62)] = this[_0x566ce3(0x267)][_0x566ce3(_0x22a635._0x40b93a)] !== undefined ? this[_0x566ce3(0x267)][_0x566ce3(_0x22a635._0x269f62)] : 0x1 } ['animate'] () { const _0x4e53af = { _0x3a9538: 0x1bd, _0x339eed: 0x2d7, _0x2ff221: 0x3cc }, _0x49c0b4 = _0x48e965; this['animationIndex'] = requestAnimationFrame(this[_0x49c0b4(_0x4e53af._0x3a9538)][_0x49c0b4(_0x4e53af._0x339eed)](this)), this['rotation']['z'] += this[_0x49c0b4(_0x4e53af._0x2ff221)] * 0.1 / Math['PI'] } [_0x48e965(0x1ef)] () { this['animate']() } [_0x48e965(0x2ea)] () { const _0x2ff417 = { _0x1ff303: 0x389 }, _0x2ed66a = _0x48e965; cancelAnimationFrame(this[_0x2ed66a(0x389)]), this[_0x2ed66a(_0x2ff417._0x1ff303)] = -0x1 } } class BaseSpreadCircle extends Mesh { [_0x48e965(0x389)];['speed'];[_0x48e965(0x383)];[_0x48e965(0x267)]; constructor(_0x49048e) { const _0x5a09d5 = { _0x252d2f: 0x47d, _0x3e6b8e: 0x267, _0x5ef530: 0x3cc, _0x202056: 0x352, _0x2efea0: 0x2f4, _0x3904b9: 0x303, _0x477128: 0x247 }, _0x59ce3e = _0x48e965; super(); let _0x2aa41a = { 'radius': 0x1, 'color': _0x59ce3e(_0x5a09d5._0x252d2f), 'speed': 0x1, 'time': 0x0 }; _0x2aa41a = Object['assign'](_0x2aa41a, _0x49048e), this[_0x59ce3e(_0x5a09d5._0x3e6b8e)] = _0x49048e, this['speed'] = _0x2aa41a[_0x59ce3e(_0x5a09d5._0x5ef530)], this['time'] = _0x2aa41a['time']; const _0x1bad13 = new PlaneGeometry(_0x2aa41a[_0x59ce3e(0x3da)], _0x2aa41a[_0x59ce3e(0x3da)], 0x1, 0x1), _0x1eca41 = _0x59ce3e(_0x5a09d5._0x202056), _0x4c27c2 = '\x0a\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec2\x20vUv;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20color;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20opacity;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20uSpeed;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20uSge;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20time;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_fragment>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20PI\x20=\x203.14159265;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20drawCircle(float\x20index,\x20float\x20range)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20opaa\x20=\x201.0;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(index\x20>=\x201.0\x20-\x20range)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20opaa\x20=\x201.0\x20-\x20(index\x20-\x20(1.0\x20-\x20range))\x20/\x20range;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x20else\x20if(index\x20<=\x20range)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20opaa\x20=\x20index\x20/\x20range;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20opaa;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20distanceTo(vec2\x20src,\x20vec2\x20dst)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20dx\x20=\x20src.x\x20-\x20dst.x;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20dy\x20=\x20src.y\x20-\x20dst.y;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20dv\x20=\x20dx\x20*\x20dx\x20+\x20dy\x20*\x20dy;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20sqrt(dv);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20void\x20main()\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20iTime\x20=\x20-time\x20*\x20uSpeed;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20opa\x20=\x200.0;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20len\x20=\x20distanceTo(vec2(0.5,\x200.5),\x20vec2(vUv.x,\x20vUv.y));\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20size\x20=\x201.0\x20/\x20uSge;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20range\x20=\x20vec2(0.65,\x200.85);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20index\x20=\x20mod(iTime\x20+\x20len,\x20size);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(index\x20<\x20size\x20&&\x20len\x20<=\x200.5)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20i\x20=\x20sin(index\x20/\x20size\x20*\x20PI);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(i\x20>=\x20range.x\x20&&\x20i\x20<=\x20range.y){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20t\x20=\x20(i\x20-\x20range.x)\x20/\x20(range.y\x20-\x20range.x);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20r\x20=\x200.3;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20opa\x20=\x20drawCircle(t,\x20r);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20opa\x20*=\x20\x201.0\x20-\x20len\x20/\x200.5;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20};\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(\x20opacity\x20*\x20opa\x20<=\x200.0){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20discard;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color,\x20opacity\x20*\x20opa);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20}'; this[_0x59ce3e(_0x5a09d5._0x2efea0)] = new ShaderMaterial({ 'side': 0x2, 'transparent': !![], 'uniforms': { 'color': { 'value': new Color(_0x2aa41a['color']) }, 'opacity': { 'value': 0x1 }, 'uSpeed': { 'value': 0.25 }, 'uSge': { 'value': 0x3 }, 'uRadius': { 'value': _0x2aa41a['radius'] / 0x2 }, 'time': { 'value': _0x2aa41a[_0x59ce3e(0x383)] } }, 'vertexShader': _0x1eca41, 'fragmentShader': _0x4c27c2 }), this[_0x59ce3e(_0x5a09d5._0x3904b9)] = _0x1bad13, this['geometry'][_0x59ce3e(_0x5a09d5._0x477128)](Math['PI'] / 0x2) } [_0x48e965(0x1bd)] () { const _0x59d61a = { _0x27b276: 0x1bd, _0xee6642: 0x2d7, _0x431292: 0x2f4 }, _0x4d197c = _0x48e965; this['animationIndex'] = requestAnimationFrame(this[_0x4d197c(_0x59d61a._0x27b276)][_0x4d197c(_0x59d61a._0xee6642)](this)), this[_0x4d197c(_0x59d61a._0x431292)][_0x4d197c(0x234)]['time'][_0x4d197c(0x27b)] += this['speed'] * 0.01 } [_0x48e965(0x1ef)] () { const _0x21265b = { _0x1ebd0b: 0x1bd }, _0x139cb8 = _0x48e965; this[_0x139cb8(_0x21265b._0x1ebd0b)]() } [_0x48e965(0x2ea)] () { const _0x411f7b = { _0x417e6e: 0x389 }, _0x47c481 = _0x48e965; cancelAnimationFrame(this[_0x47c481(_0x411f7b._0x417e6e)]), this['animationIndex'] = null } } class BaseFlyLine extends BaseLine { [_0x48e965(0x1df)];[_0x48e965(0x496)]; constructor(_0x5415ed) { const _0xc5d4d1 = { _0x28bda0: 0x1df, _0x168daa: 0x365, _0x18fafe: 0x4fc, _0x153fcd: 0x365, _0x46747a: 0x3fa, _0x3b1d45: 0x371, _0x4e36a2: 0x20c, _0x54d542: 0x2b0, _0x49f3e0: 0x371, _0x3c382f: 0x1df, _0x169b92: 0x371, _0x1cb198: 0x1df, _0x250973: 0x2b0, _0x7b0cc3: 0x44d, _0x1a2254: 0x4df, _0x23a2c2: 0x47d, _0x3c7c96: 0x4df, _0x12ed76: 0x4c4, _0x47c34e: 0x371, _0x4f1477: 0x496 }, _0x30790b = { _0x2d0560: 0x1da }, _0x484728 = _0x48e965; super(_0x5415ed), this[_0x484728(0x496)] = _0x5415ed?.[_0x484728(0x496)] !== undefined ? _0x5415ed['height'] : 0x64, this[_0x484728(_0xc5d4d1._0x28bda0)] = new CubicBezierCurve3(new Vector3(), new Vector3(), new Vector3(), new Vector3()); if (_0x5415ed && _0x5415ed[_0x484728(_0xc5d4d1._0x168daa)] && _0x5415ed['endPoint']) { const _0x16142a = new Vector3(), _0x5d43de = new Vector3(), _0x53f77a = new Vector3()['subVectors'](_0x5415ed[_0x484728(_0xc5d4d1._0x18fafe)], _0x5415ed[_0x484728(_0xc5d4d1._0x153fcd)])[_0x484728(0x497)](), _0x52bedf = _0x5415ed[_0x484728(0x365)][_0x484728(_0xc5d4d1._0x46747a)](_0x5415ed['endPoint']), _0x407030 = _0x52bedf / 0x4, _0x463180 = 0x3 * _0x52bedf / 0x4; _0x16142a[_0x484728(_0xc5d4d1._0x3b1d45)](_0x5415ed[_0x484728(_0xc5d4d1._0x168daa)])[_0x484728(0x44d)](_0x53f77a[_0x484728(0x2b0)]()[_0x484728(_0xc5d4d1._0x4e36a2)](_0x407030)), _0x16142a['y'] = this[_0x484728(0x496)], _0x5d43de[_0x484728(0x371)](_0x5415ed[_0x484728(0x365)])[_0x484728(0x44d)](_0x53f77a[_0x484728(_0xc5d4d1._0x54d542)]()[_0x484728(_0xc5d4d1._0x4e36a2)](_0x463180)), _0x5d43de['y'] = this['height'], this[_0x484728(0x1df)]['v0'][_0x484728(_0xc5d4d1._0x49f3e0)](_0x5415ed[_0x484728(0x365)]), this[_0x484728(0x1df)]['v1'][_0x484728(0x371)](_0x16142a), this[_0x484728(_0xc5d4d1._0x3c382f)]['v2'][_0x484728(_0xc5d4d1._0x169b92)](_0x5d43de), this[_0x484728(0x1df)]['v3'][_0x484728(0x371)](_0x5415ed['endPoint']); const _0xd3d1bc = this[_0x484728(_0xc5d4d1._0x1cb198)]['getPoints'](0x1f4), _0x331c0f = []; _0xd3d1bc[_0x484728(0x164)](_0x5388ab => { const _0x4053ef = _0x484728; _0x331c0f[_0x4053ef(_0x30790b._0x2d0560)](_0x5388ab['x'], _0x5388ab['y'], _0x5388ab['z']) }), this[_0x484728(0x1ea)](_0x331c0f); const _0x34bb20 = _0x5415ed[_0x484728(_0xc5d4d1._0x153fcd)][_0x484728(_0xc5d4d1._0x250973)]()[_0x484728(_0xc5d4d1._0x7b0cc3)](_0x5415ed['endPoint'])[_0x484728(0x20c)](0.5); if (_0x5415ed[_0x484728(_0xc5d4d1._0x1a2254)] !== undefined) { const _0x59358 = new BaseTitle({ 'strokeColor': _0x484728(_0xc5d4d1._0x23a2c2), 'bgColor': _0x5415ed[_0x484728(0x209)], 'text': _0x5415ed[_0x484728(_0xc5d4d1._0x3c7c96)], 'type': 0x0, 'size': _0x5415ed['titleSize'] }); this['add'](_0x59358), _0x59358[_0x484728(_0xc5d4d1._0x12ed76)][_0x484728(_0xc5d4d1._0x47c34e)](_0x34bb20), _0x59358['position']['y'] = this[_0x484728(_0xc5d4d1._0x4f1477)] } } } [_0x48e965(0x52f)] ({ v0: _0x37c2e9, v1: _0x36731a, v2: _0x8c4f5c, v3: _0x434875 }) { const _0x463362 = { _0x13a577: 0x371, _0x2ddf53: 0x1df, _0xb1d751: 0x1df, _0x3ba7e9: 0x371 }, _0xe69ced = _0x48e965; if (_0x37c2e9 !== undefined) this['path']['v0'][_0xe69ced(_0x463362._0x13a577)](_0x37c2e9); if (_0x36731a !== undefined) this[_0xe69ced(_0x463362._0x2ddf53)]['v1'][_0xe69ced(0x371)](_0x36731a); if (_0x8c4f5c !== undefined) this[_0xe69ced(_0x463362._0xb1d751)]['v2'][_0xe69ced(0x371)](_0x8c4f5c); if (_0x434875 !== undefined) this['path']['v3'][_0xe69ced(_0x463362._0x3ba7e9)](_0x434875); const _0x20adfb = this['path'][_0xe69ced(0x297)](0x1f4), _0xc85c74 = []; _0x20adfb[_0xe69ced(0x164)](_0x18f230 => { const _0x3790bf = _0xe69ced; _0xc85c74[_0x3790bf(0x1da)](_0x18f230['x'], _0x18f230['y'], _0x18f230['z']) }), this['setPositions'](_0xc85c74) } } class BaseParticles extends Points { [_0x48e965(0x267)];['positions'];[_0x48e965(0x528)];['opacities'];['lifeCycle'];['animationTag'];[_0x48e965(0x389)];[_0x48e965(0x4ee)];[_0x48e965(0x394)];['width'];[_0x48e965(0x496)];[_0x48e965(0x2ae)];['updateTime'];[_0x48e965(0x507)]; constructor(_0x314393) { const _0xd0d9dd = { _0x210009: 0x267, _0xb1da3f: 0x218, _0x534061: 0x4ee, _0x549948: 0x267, _0x385a99: 0x394, _0x275668: 0x394, _0x504f9a: 0x15d, _0x394b9c: 0x267, _0x1941bc: 0x15d, _0x1b285c: 0x267, _0x13745d: 0x15d, _0x15557f: 0x496, _0x44307b: 0x267, _0x3cbfef: 0x496, _0x2b540f: 0x2ae, _0x1990c8: 0x267, _0x5404de: 0x507, _0x584420: 0x46c, _0x23f656: 0x32b, _0x28463a: 0x267, _0x4140f0: 0x209, _0x233157: 0x217, _0x313a98: 0x261, _0x59184a: 0x1da, _0x2542ce: 0x225, _0x3c1082: 0x496, _0x5d0080: 0x1da, _0xdca455: 0x225, _0x4f8576: 0x33d, _0x21e283: 0x1da, _0x415df3: 0x225, _0x223071: 0x225, _0x254b68: 0x303, _0x4b391f: 0x3b7, _0x59c7a0: 0x2be, _0x134596: 0x528, _0x1dc583: 0x322 }, _0x74894b = _0x48e965; super(), this[_0x74894b(_0xd0d9dd._0x210009)] = Object['assign']({ 'color': _0x74894b(_0xd0d9dd._0xb1da3f), 'size': 0.1, 'width': 0.1, 'height': 0.5, 'depth': 0.1, 'numbers': 0x14 }, _0x314393), this['animationIndex'] = -0x1, this[_0x74894b(_0xd0d9dd._0x534061)] = this['opts'][_0x74894b(_0xd0d9dd._0x534061)] !== undefined ? this[_0x74894b(_0xd0d9dd._0x549948)][_0x74894b(_0xd0d9dd._0x534061)] : 0x14, this[_0x74894b(_0xd0d9dd._0x385a99)] = this[_0x74894b(0x267)][_0x74894b(_0xd0d9dd._0x275668)] !== undefined ? this[_0x74894b(_0xd0d9dd._0x210009)]['size'] : 0.1, this[_0x74894b(_0xd0d9dd._0x504f9a)] = this[_0x74894b(_0xd0d9dd._0x394b9c)][_0x74894b(_0xd0d9dd._0x1941bc)] !== undefined ? this[_0x74894b(_0xd0d9dd._0x1b285c)][_0x74894b(_0xd0d9dd._0x13745d)] : 0.1, this[_0x74894b(_0xd0d9dd._0x15557f)] = this[_0x74894b(0x267)][_0x74894b(0x496)] !== undefined ? this[_0x74894b(_0xd0d9dd._0x44307b)][_0x74894b(_0xd0d9dd._0x3cbfef)] : 0.5, this[_0x74894b(_0xd0d9dd._0x2b540f)] = this[_0x74894b(_0xd0d9dd._0x1990c8)][_0x74894b(_0xd0d9dd._0x2b540f)] !== undefined ? this[_0x74894b(0x267)]['depth'] : 0.1, this[_0x74894b(_0xd0d9dd._0x5404de)] = new Vector3(0x0, 0x1, 0x0), this['material'] = new ShaderMaterial({ 'transparent': !![], 'vertexShader': _0x74894b(_0xd0d9dd._0x584420), 'fragmentShader': _0x74894b(_0xd0d9dd._0x23f656), 'uniforms': { 'size': { 'value': this[_0x74894b(0x267)][_0x74894b(_0xd0d9dd._0x385a99)] }, 'color': { 'value': new Color(this[_0x74894b(_0xd0d9dd._0x28463a)][_0x74894b(_0xd0d9dd._0x4140f0)]) }, 'map': { 'value': null }, 'useMap': { 'value': 0x0 } }, 'depthTest': !![], 'depthWrite': ![] }), this['positions'] = [], this['scales'] = [], this[_0x74894b(_0xd0d9dd._0x233157)] = [], this['animationTag'] = [], this[_0x74894b(_0xd0d9dd._0x313a98)] = []; for (let _0x254754 = 0x0; _0x254754 < this[_0x74894b(_0xd0d9dd._0x534061)]; _0x254754++) { this[_0x74894b(0x3b7)][_0x74894b(_0xd0d9dd._0x59184a)]((Math[_0x74894b(_0xd0d9dd._0x2542ce)]() * 0x2 - 0x1) * this[_0x74894b(0x15d)]), this['positions']['push'](Math[_0x74894b(_0xd0d9dd._0x2542ce)]() * this[_0x74894b(_0xd0d9dd._0x3c1082)]), this['positions'][_0x74894b(_0xd0d9dd._0x5d0080)]((Math['random']() * 0x2 - 0x1) * this['depth']), this[_0x74894b(0x528)][_0x74894b(0x1da)](Math[_0x74894b(_0xd0d9dd._0xdca455)]() * 0.2 + 0.2), this[_0x74894b(0x217)][_0x74894b(_0xd0d9dd._0x5d0080)](Math[_0x74894b(_0xd0d9dd._0x2542ce)]() + 0.1), this[_0x74894b(_0xd0d9dd._0x313a98)]['push'](Math['random']() * 0x4b0 + 0x64), this[_0x74894b(_0xd0d9dd._0x4f8576)][_0x74894b(_0xd0d9dd._0x21e283)](Math[_0x74894b(_0xd0d9dd._0xdca455)]() + 0.5, Math[_0x74894b(_0xd0d9dd._0x415df3)]() + 0.5, Math[_0x74894b(_0xd0d9dd._0x223071)]() + 0.5) } this[_0x74894b(_0xd0d9dd._0x254b68)][_0x74894b(0x322)](_0x74894b(0x4c4), new Float32BufferAttribute(this[_0x74894b(_0xd0d9dd._0x4b391f)], 0x3)), this[_0x74894b(0x303)][_0x74894b(0x322)](_0x74894b(_0xd0d9dd._0x59c7a0), new Float32BufferAttribute(this[_0x74894b(_0xd0d9dd._0x134596)], 0x1)), this[_0x74894b(0x303)][_0x74894b(_0xd0d9dd._0x1dc583)](_0x74894b(0x236), new Float32BufferAttribute(this['opacities'], 0x1)), this[_0x74894b(0x303)][_0x74894b(0x322)](_0x74894b(0x3d7), new Float32BufferAttribute(this[_0x74894b(0x261)], 0x1)) } [_0x48e965(0x390)] () { const _0x1cb608 = { _0x402d2e: 0x389, _0x15da31: 0x303, _0x54cafa: 0x4c4, _0x15c85e: 0x30f, _0x3e5929: 0x33d, _0xc2ba48: 0x3b7, _0x4cc131: 0x33d, _0x4c59f8: 0x303, _0x329454: 0x176 }, _0x5cdb52 = _0x48e965; this[_0x5cdb52(_0x1cb608._0x402d2e)] = requestAnimationFrame(this['risingAnimation2'][_0x5cdb52(0x2d7)](this)); const _0x3d6e31 = this[_0x5cdb52(_0x1cb608._0x15da31)]['attributes'][_0x5cdb52(_0x1cb608._0x54cafa)][_0x5cdb52(0x30f)], _0x31aca1 = this[_0x5cdb52(0x303)][_0x5cdb52(0x176)][_0x5cdb52(0x236)][_0x5cdb52(_0x1cb608._0x15c85e)]; for (let _0xb26edc = 0x0; _0xb26edc < this[_0x5cdb52(0x33d)][_0x5cdb52(0x321)]; _0xb26edc += 0x3) { const _0x49d0d2 = _0xb26edc % 0x2 == 0x0 ? 0x1 : -0x1; _0x3d6e31[_0xb26edc] += 0.001 * this[_0x5cdb52(0x33d)][_0xb26edc] * _0x49d0d2, _0x3d6e31[_0xb26edc + 0x1] += 0.0025 * this[_0x5cdb52(_0x1cb608._0x3e5929)][_0xb26edc + 0x1], Math[_0x5cdb52(0x367)](_0x3d6e31[_0xb26edc + 0x1]) > this[_0x5cdb52(0x496)] && (_0x3d6e31[_0xb26edc] = this[_0x5cdb52(_0x1cb608._0xc2ba48)][_0xb26edc], _0x3d6e31[_0xb26edc + 0x1] = 0x0, _0x3d6e31[_0xb26edc + 0x2] = this[_0x5cdb52(0x3b7)][_0xb26edc + 0x2]), _0x3d6e31[_0xb26edc + 0x2] += 0.001 * this[_0x5cdb52(_0x1cb608._0x4cc131)][_0xb26edc + 0x2] * _0x49d0d2, _0x31aca1[_0xb26edc / 0x3] = (this['height'] - _0x3d6e31[_0xb26edc + 0x1]) / this['height'] } this[_0x5cdb52(_0x1cb608._0x4c59f8)][_0x5cdb52(0x176)][_0x5cdb52(0x4c4)][_0x5cdb52(0x4f8)] = !![], this[_0x5cdb52(0x303)][_0x5cdb52(_0x1cb608._0x329454)][_0x5cdb52(0x236)][_0x5cdb52(0x4f8)] = !![] } [_0x48e965(0x47c)] () { const _0x538d93 = _0x48e965; this[_0x538d93(0x390)]() } [_0x48e965(0x541)] () { const _0x35af7e = { _0x509df5: 0x4c4, _0x161e55: 0x303, _0x223aaf: 0x176, _0x3421c2: 0x33d, _0x4f9e45: 0x496, _0x33da87: 0x176, _0x3c28ef: 0x236, _0x856929: 0x4f8 }, _0x774aea = _0x48e965; this['animationIndex'] = requestAnimationFrame(this['risingAnimation'][_0x774aea(0x2d7)](this)); const _0x53ae03 = this[_0x774aea(0x303)][_0x774aea(0x176)][_0x774aea(_0x35af7e._0x509df5)][_0x774aea(0x30f)], _0x2419c7 = this[_0x774aea(_0x35af7e._0x161e55)][_0x774aea(_0x35af7e._0x223aaf)]['opacity'][_0x774aea(0x30f)]; for (let _0x2b11dd = 0x0; _0x2b11dd < this[_0x774aea(0x33d)][_0x774aea(0x321)]; _0x2b11dd += 0x3) { _0x53ae03[_0x2b11dd] += 0.001 * this['animationTag'][_0x2b11dd]; if (Math['abs'](_0x53ae03[_0x2b11dd]) > this['width']) this[_0x774aea(_0x35af7e._0x3421c2)][_0x2b11dd] *= -0x1; _0x53ae03[_0x2b11dd + 0x1] += 0.0025 * this[_0x774aea(0x33d)][_0x2b11dd + 0x1]; if (Math['abs'](_0x53ae03[_0x2b11dd + 0x1]) > this['height']) _0x53ae03[_0x2b11dd + 0x1] = 0x0; _0x53ae03[_0x2b11dd + 0x2] += 0.001 * this[_0x774aea(0x33d)][_0x2b11dd + 0x2]; if (Math[_0x774aea(0x367)](_0x53ae03[_0x2b11dd + 0x2]) > this[_0x774aea(0x2ae)]) this[_0x774aea(_0x35af7e._0x3421c2)][_0x2b11dd + 0x2] *= -0x1; _0x2419c7[_0x2b11dd / 0x3] = (this[_0x774aea(0x496)] - _0x53ae03[_0x2b11dd + 0x1]) / this[_0x774aea(_0x35af7e._0x4f9e45)] } this[_0x774aea(0x303)][_0x774aea(0x176)]['position']['needsUpdate'] = !![], this['geometry'][_0x774aea(_0x35af7e._0x33da87)][_0x774aea(_0x35af7e._0x3c28ef)][_0x774aea(_0x35af7e._0x856929)] = !![] } [_0x48e965(0x34e)] () { const _0x641644 = { _0x277aba: 0x541 }, _0x3557a1 = _0x48e965; this[_0x3557a1(_0x641644._0x277aba)]() } [_0x48e965(0x525)] (_0x2fd120) { const _0x45d602 = { _0x3fb47e: 0x389, _0x283043: 0x525, _0x5ce5b5: 0x2d7, _0x4fe8a6: 0x325, _0x197fdf: 0x325, _0xf33dbd: 0x303, _0x24d00c: 0x30f, _0xad3a0d: 0x33d, _0x41a3cd: 0x507, _0x4a7524: 0x3b7, _0x3ed0a7: 0x261, _0x27f4e2: 0x507, _0x686627: 0x176, _0x2c302d: 0x303, _0x5173f7: 0x236, _0x9dc5fb: 0x4f8, _0x533be7: 0x303, _0xaa468e: 0x176 }, _0x5b082f = _0x48e965; this[_0x5b082f(_0x45d602._0x3fb47e)] = requestAnimationFrame(this[_0x5b082f(_0x45d602._0x283043)][_0x5b082f(_0x45d602._0x5ce5b5)](this)); if (this[_0x5b082f(_0x45d602._0x4fe8a6)] == undefined) this[_0x5b082f(_0x45d602._0x197fdf)] = _0x2fd120; else { const _0x36f9d3 = _0x2fd120 - this[_0x5b082f(_0x45d602._0x197fdf)]; this[_0x5b082f(_0x45d602._0x4fe8a6)] = _0x2fd120; const _0x30d9f2 = this[_0x5b082f(0x303)]['attributes'][_0x5b082f(0x4c4)][_0x5b082f(0x30f)], _0x4a9084 = this[_0x5b082f(_0x45d602._0xf33dbd)][_0x5b082f(0x176)][_0x5b082f(0x236)][_0x5b082f(_0x45d602._0x24d00c)], _0x1d4d51 = this[_0x5b082f(0x303)]['attributes'][_0x5b082f(0x3d7)][_0x5b082f(_0x45d602._0x24d00c)]; for (let _0x34a524 = 0x0; _0x34a524 < this[_0x5b082f(_0x45d602._0xad3a0d)]['length']; _0x34a524 += 0x3) { _0x30d9f2[_0x34a524] += 0.001 * this['animationTag'][_0x34a524] * this[_0x5b082f(_0x45d602._0x41a3cd)]['x'], _0x30d9f2[_0x34a524 + 0x1] += 0.001 * this['animationTag'][_0x34a524 + 0x1] * this[_0x5b082f(0x507)]['y'], _0x1d4d51[_0x34a524 / 0x3] -= _0x36f9d3, _0x1d4d51[_0x34a524 / 0x3] <= 0x0 && (_0x30d9f2[_0x34a524] = this[_0x5b082f(0x3b7)][_0x34a524], _0x30d9f2[_0x34a524 + 0x1] = 0x0, _0x30d9f2[_0x34a524 + 0x2] = this[_0x5b082f(_0x45d602._0x4a7524)][_0x34a524 + 0x2], this[_0x5b082f(0x261)][_0x34a524 / 0x3] = Math['random']() * 0x4b0 + 0x64, _0x1d4d51[_0x34a524 / 0x3] = this[_0x5b082f(_0x45d602._0x3ed0a7)][_0x34a524 / 0x3]), _0x30d9f2[_0x34a524 + 0x2] += 0.001 * this[_0x5b082f(_0x45d602._0xad3a0d)][_0x34a524 + 0x2] * this[_0x5b082f(_0x45d602._0x27f4e2)]['z'], _0x4a9084[_0x34a524 / 0x3] = 0x1 - _0x1d4d51[_0x34a524 / 0x3] / this[_0x5b082f(0x261)][_0x34a524 / 0x3] } this[_0x5b082f(0x303)][_0x5b082f(_0x45d602._0x686627)][_0x5b082f(0x4c4)][_0x5b082f(0x4f8)] = !![], this[_0x5b082f(_0x45d602._0x2c302d)][_0x5b082f(0x176)][_0x5b082f(_0x45d602._0x5173f7)][_0x5b082f(_0x45d602._0x9dc5fb)] = !![], this[_0x5b082f(_0x45d602._0x533be7)][_0x5b082f(_0x45d602._0xaa468e)]['lifecycle']['needsUpdate'] = !![] } } ['startSmokeSimulation'] () { const _0x3c08e2 = _0x48e965; this[_0x3c08e2(0x525)](0x0) } [_0x48e965(0x28d)] () { const _0x923014 = { _0x45ceea: 0x389 }, _0x51b19e = _0x48e965; cancelAnimationFrame(this[_0x51b19e(_0x923014._0x45ceea)]), this['animationIndex'] = -0x1, this['updateTime'] = undefined } } const Primitives = { 'BaseLine': BaseLine, 'BaseExtrudeShape': BaseExtrudeShape, 'BaseCube': BaseCube, 'BaseCircle': BaseCircle, 'BaseTitle': BaseTitle, 'BaseShapeVic': BaseShapeVic, 'BaseSpreadCircle': BaseSpreadCircle, 'BaseFlyLine': BaseFlyLine, 'BaseParticles': BaseParticles }; class WaterGeometry extends BufferGeometry { [_0x48e965(0x38a)]; constructor(_0x32ed60, _0x40360b) { const _0x1f2ab7 = { _0x20a43c: 0x38a, _0x49d04c: 0x4da, _0x46cf73: 0x31e, _0x45e340: 0x322, _0x40340e: 0x53b }, _0x170cae = _0x48e965; super(); let _0x5161b7 = [], _0x5be4b4 = [], _0x1182bf = [], _0x3479c1 = []; this[_0x170cae(_0x1f2ab7._0x20a43c)] = _0x40360b !== undefined ? _0x40360b : [0x0, 0x0, 0x0]; for (let _0x47a3f1 = 0x0; _0x47a3f1 < _0x32ed60[_0x170cae(0x321)]; _0x47a3f1++) { const _0x4ef1ef = _0x32ed60[_0x47a3f1]; _0x5161b7 = _0x5161b7[_0x170cae(_0x1f2ab7._0x49d04c)]([_0x4ef1ef[0x0], _0x4ef1ef[0x2]]), _0x5be4b4 = _0x5be4b4['concat'](_0x4ef1ef[0x0] + this[_0x170cae(0x38a)][0x0], _0x4ef1ef[0x1] + this[_0x170cae(_0x1f2ab7._0x20a43c)][0x1], _0x4ef1ef[0x2] + this[_0x170cae(_0x1f2ab7._0x20a43c)][0x2]), _0x1182bf = _0x1182bf[_0x170cae(_0x1f2ab7._0x49d04c)](0x0, 0x0, 0x1) } _0x3479c1 = earcut_1(_0x5161b7), this[_0x170cae(_0x1f2ab7._0x46cf73)](_0x3479c1), this[_0x170cae(_0x1f2ab7._0x45e340)](_0x170cae(0x4c4), new Float32BufferAttribute(_0x5be4b4, 0x3)), this[_0x170cae(0x322)]('normal', new Float32BufferAttribute(_0x1182bf, 0x3)), this['translate'](0x0, -_0x32ed60[0x0][0x1], 0x0), this[_0x170cae(0x247)](Math['PI']), this[_0x170cae(_0x1f2ab7._0x40340e)](0x0, _0x32ed60[0x0][0x1], 0x0) } } const BaseGeometries = { 'WaterGeometry': WaterGeometry }; class BaseBuildingStripeMaterial extends ShaderMaterial { ['opts']; constructor(_0xd3fb6d) { const _0x2ef93a = { _0x493675: 0x267, _0x269c06: 0x2c9, _0x3207b6: 0x372, _0x487974: 0x47d, _0x2f2e97: 0x47d, _0x1ea382: 0x209, _0x2453e3: 0x1a3, _0x69e288: 0x38e, _0x28868e: 0x267, _0x254f69: 0x4a9, _0x26311f: 0x267, _0xa3a501: 0x4d5, _0x444fcf: 0x17d, _0x46414b: 0x3f8, _0x59f0e3: 0x234 }, _0x4d52ec = _0x48e965; super(), this[_0x4d52ec(_0x2ef93a._0x493675)] = Object[_0x4d52ec(_0x2ef93a._0x269c06)]({ 'color': _0x4d52ec(_0x2ef93a._0x3207b6), 'emissiveBase': _0x4d52ec(_0x2ef93a._0x487974), 'minHeightBase': -0x9b, 'maxHeightBase': -0x24, 'mixColorBase': _0x4d52ec(0x218), 'thresholdBase': 0x0, 'minHeightStripe': -0x9b, 'maxHeightStripe': -0x24, 'emissiveStripe': _0x4d52ec(_0x2ef93a._0x2f2e97) }, _0xd3fb6d), this[_0x4d52ec(0x3ea)] = !![], this[_0x4d52ec(0x263)] = !![], this[_0x4d52ec(0x234)] = { 'color': { 'value': new Color(this[_0x4d52ec(0x267)][_0x4d52ec(_0x2ef93a._0x1ea382)]) }, 'opacity': { 'value': 0x1 }, 'emissiveBase': { 'value': new Color(this[_0x4d52ec(_0x2ef93a._0x493675)][_0x4d52ec(_0x2ef93a._0x2453e3)]) }, 'minHeightBase': { 'value': this[_0x4d52ec(_0x2ef93a._0x493675)][_0x4d52ec(_0x2ef93a._0x69e288)] }, 'maxHeightBase': { 'value': this[_0x4d52ec(0x267)]['maxHeightBase'] }, 'mixColorBase': { 'value': new Color(this[_0x4d52ec(_0x2ef93a._0x28868e)][_0x4d52ec(_0x2ef93a._0x254f69)]) }, 'thresholdBase': { 'value': this['opts'][_0x4d52ec(0x46d)] }, 'emissiveStripe': { 'value': new Color(this[_0x4d52ec(_0x2ef93a._0x26311f)][_0x4d52ec(_0x2ef93a._0xa3a501)]) }, 'minHeightStripe': { 'value': this[_0x4d52ec(_0x2ef93a._0x28868e)][_0x4d52ec(_0x2ef93a._0x444fcf)] }, 'maxHeightStripe': { 'value': this[_0x4d52ec(0x267)]['maxHeightStripe'] } }, this[_0x4d52ec(0x42e)] = _0x4d52ec(0x374), this[_0x4d52ec(_0x2ef93a._0x46414b)] = _0x4d52ec(0x230), this[_0x4d52ec(_0x2ef93a._0x59f0e3)] = UniformsUtils[_0x4d52ec(0x42a)]([this[_0x4d52ec(_0x2ef93a._0x59f0e3)], UniformsLib[_0x4d52ec(0x3ea)]]) } } class BaseBuildingGradientMaterial extends ShaderMaterial { [_0x48e965(0x267)]; constructor(_0x44a423) { const _0x3428b9 = { _0x19020a: 0x47d, _0x35db2e: 0x3ea, _0x19010c: 0x234, _0x2cd618: 0x267, _0x112edf: 0x411, _0x2b6bc3: 0x267, _0x272ef9: 0x35f, _0x447e1b: 0x407, _0x294c9d: 0x495, _0x28bc22: 0x234 }, _0x45c46e = _0x48e965; super(), this[_0x45c46e(0x267)] = Object[_0x45c46e(0x2c9)]({ 'color': '#0000ff', 'emissive': _0x45c46e(_0x3428b9._0x19020a), 'minHeight': -0x9b, 'maxHeight': -0x24, 'mixColor': _0x45c46e(0x218), 'threshold': 0x0, 'opacity': 0x1 }, _0x44a423), this[_0x45c46e(_0x3428b9._0x35db2e)] = !![], this[_0x45c46e(0x263)] = !![], this[_0x45c46e(_0x3428b9._0x19010c)] = { 'color': { 'value': new Color(this[_0x45c46e(0x267)][_0x45c46e(0x209)]) }, 'opacity': { 'value': this[_0x45c46e(_0x3428b9._0x2cd618)]['opacity'] }, 'emissive': { 'value': new Color(this[_0x45c46e(0x267)]['emissive']) }, 'minHeight': { 'value': this['opts'][_0x45c46e(0x2c0)] }, 'maxHeight': { 'value': this[_0x45c46e(0x267)][_0x45c46e(_0x3428b9._0x112edf)] }, 'mixColor': { 'value': new Color(this[_0x45c46e(_0x3428b9._0x2b6bc3)][_0x45c46e(_0x3428b9._0x272ef9)]) }, 'threshold': { 'value': this[_0x45c46e(0x267)][_0x45c46e(_0x3428b9._0x447e1b)] } }, this[_0x45c46e(0x42e)] = _0x45c46e(0x374), this[_0x45c46e(0x3f8)] = _0x45c46e(_0x3428b9._0x294c9d), this[_0x45c46e(_0x3428b9._0x19010c)] = UniformsUtils[_0x45c46e(0x42a)]([this[_0x45c46e(_0x3428b9._0x28bc22)], UniformsLib[_0x45c46e(0x3ea)]]) } } const PrimitiveMaterial = { 'BaseLineMaterial': BaseLineMaterial, 'BaseBuildingStripeMaterial': BaseBuildingStripeMaterial, 'BaseBuildingGradientMaterial': BaseBuildingGradientMaterial }; function getNodeKeyByName (_0x658ae8) { const _0x3cd1bc = { _0x306b67: 0x2b6, _0x2494e2: 0x2b9, _0x347fea: 0x490, _0x2c53ec: 0x50e, _0x2a84c0: 0x39c, _0x12c2e1: 0x3c2, _0x3f2cfe: 0x48c, _0xe4e874: 0x1c5, _0x19ce15: 0x24c, _0x1e0f3f: 0x2a5, _0x56c029: 0x3a0, _0x2eec71: 0x4d2 }, _0x102859 = _0x48e965; let _0x1e7703 = ''; switch (_0x658ae8) { case _0x102859(0x202): _0x1e7703 = 'cameras'; break; case _0x102859(_0x3cd1bc._0x306b67): _0x1e7703 = _0x102859(_0x3cd1bc._0x2494e2); break; case 'HemisphereLight': _0x1e7703 = _0x102859(0x1c9); break; case _0x102859(0x33b): _0x1e7703 = _0x102859(_0x3cd1bc._0x347fea); break; case _0x102859(0x3ae): _0x1e7703 = _0x102859(_0x3cd1bc._0x2c53ec); break; case _0x102859(0x290): _0x1e7703 = _0x102859(_0x3cd1bc._0x2a84c0); break; case _0x102859(_0x3cd1bc._0x12c2e1): _0x1e7703 = _0x102859(0x2f5); break; case 'Shadow': _0x1e7703 = _0x102859(0x455); break; case _0x102859(0x481): _0x1e7703 = 'background'; break; case 'HDR': _0x1e7703 = _0x102859(0x154); break; case 'Fog': _0x1e7703 = _0x102859(0x223); break; case _0x102859(_0x3cd1bc._0x3f2cfe): _0x1e7703 = _0x102859(_0x3cd1bc._0xe4e874); break; case _0x102859(0x1eb): _0x1e7703 = _0x102859(_0x3cd1bc._0x19ce15); break; case 'OutlinePass': _0x1e7703 = _0x102859(_0x3cd1bc._0x1e0f3f); break; case _0x102859(0x210): _0x1e7703 = 'dof'; break; case _0x102859(_0x3cd1bc._0x56c029): _0x1e7703 = _0x102859(_0x3cd1bc._0x2eec71); break }if (_0x1e7703 == '') throw new Error(_0x102859(0x268) + _0x658ae8 + _0x102859(0x2e0)); return _0x1e7703 } const lightsType = ['ambientLight', _0x48e965(0x1c9), _0x48e965(0x50e), _0x48e965(0x39c), _0x48e965(0x490), _0x48e965(0x2f5)], passesType = [_0x48e965(0x24c), _0x48e965(0x52d), _0x48e965(0x2a5), _0x48e965(0x4d2), _0x48e965(0x1c5)]; class JSONParser { [_0x48e965(0x1f0)];[_0x48e965(0x40f)]; constructor() { const _0x121aed = { _0x513b1b: 0x356, _0x5be547: 0x40f }, _0x14fd22 = _0x48e965; this['type'] = _0x14fd22(_0x121aed._0x513b1b), this[_0x14fd22(_0x121aed._0x5be547)] = { 'template': {}, 'cameras': { 'orbitCamera': {} }, 'lights': {} } } [_0x48e965(0x45e)] (_0xb79610) { const _0x131d8b = { _0x12cf2b: 0x4ab, _0x3ac6ba: 0x40f, _0x425b66: 0x4dd, _0x8f8cf: 0x3fc, _0x325b5a: 0x2b9, _0xedad33: 0x4b6, _0x5f49e8: 0x3ea, _0x54a395: 0x3ea, _0x1c45b0: 0x4b6, _0xfd7aaf: 0x321, _0x334094: 0x1da, _0x483752: 0x2c9, _0x2b097d: 0x308, _0x3b3d26: 0x478, _0x59b1c9: 0x52d }, _0x5d96af = _0x48e965; for (const _0x1f6506 in _0xb79610) { const _0x5c1992 = _0xb79610[_0x1f6506]; if (_0x5c1992[_0x5d96af(0x39d)] === -0x1) { const _0x598c76 = getNodeKeyByName(_0x5c1992[_0x5d96af(0x31c)]); if (_0x598c76 == _0x5d96af(_0x131d8b._0x12cf2b)) this[_0x5d96af(_0x131d8b._0x3ac6ba)][_0x598c76][_0x5d96af(_0x131d8b._0x425b66)] = Object['assign']({}, _0x5c1992[_0x5d96af(0x4b6)]); else { if (lightsType[_0x5d96af(_0x131d8b._0x8f8cf)](_0x598c76)) { if (_0x598c76 == _0x5d96af(_0x131d8b._0x325b5a) || _0x598c76 == _0x5d96af(0x1c9)) this['json']['lights'][_0x598c76] = Object['assign']({}, _0x5c1992[_0x5d96af(_0x131d8b._0xedad33)]); else { if (!this[_0x5d96af(_0x131d8b._0x3ac6ba)][_0x5d96af(_0x131d8b._0x5f49e8)][_0x598c76]) this[_0x5d96af(0x40f)][_0x5d96af(_0x131d8b._0x54a395)][_0x598c76] = []; if (Object[_0x5d96af(0x22f)](_0x5c1992[_0x5d96af(_0x131d8b._0x1c45b0)])[_0x5d96af(_0x131d8b._0xfd7aaf)] > 0x0) this[_0x5d96af(0x40f)]['lights'][_0x598c76][_0x5d96af(_0x131d8b._0x334094)](Object[_0x5d96af(_0x131d8b._0x483752)]({}, _0x5c1992[_0x5d96af(0x4b6)])) } } else { if (_0x598c76 == 'shadow') this['json'][_0x5d96af(_0x131d8b._0x2b097d)] = _0x5c1992['options'][_0x5d96af(0x2b1)]; else { if (_0x598c76 == 'hdr') this[_0x5d96af(_0x131d8b._0x3ac6ba)][_0x5d96af(_0x131d8b._0x3b3d26)] = _0x5c1992[_0x5d96af(_0x131d8b._0x1c45b0)]['value'][_0x5d96af(0x432)](); else { if (passesType['includes'](_0x598c76)) { this[_0x5d96af(0x40f)][_0x598c76] = Object[_0x5d96af(0x2c9)]({}, _0x5c1992['options']); if (_0x598c76 == _0x5d96af(0x24c)) this['json'][_0x5d96af(0x2af)] = _0x5c1992[_0x5d96af(_0x131d8b._0x1c45b0)]['enabled']; else { if (_0x598c76 == 'outline') this[_0x5d96af(_0x131d8b._0x3ac6ba)][_0x5d96af(0x344)] = _0x5c1992[_0x5d96af(0x4b6)][_0x5d96af(0x2b1)]; else { if (_0x598c76 == _0x5d96af(_0x131d8b._0x59b1c9)) this[_0x5d96af(_0x131d8b._0x3ac6ba)]['dofEnabled'] = _0x5c1992[_0x5d96af(0x4b6)]['enabled']; else _0x598c76 == _0x5d96af(0x4d2) && (this[_0x5d96af(_0x131d8b._0x3ac6ba)][_0x5d96af(0x385)] = _0x5c1992[_0x5d96af(_0x131d8b._0xedad33)]['enabled']) } } } else this[_0x5d96af(0x40f)][_0x598c76] = Object[_0x5d96af(0x2c9)]({}, _0x5c1992[_0x5d96af(0x4b6)]) } } } } } else { if (_0x5c1992[_0x5d96af(0x39d)] == -0x2); else this[_0x5d96af(0x40f)][_0x5d96af(0x2f0)][_0x5c1992['uuid']] = Object['assign']({}, _0x5c1992) } } return this[_0x5d96af(_0x131d8b._0x3ac6ba)] } } class TemplateParser { [_0x48e965(0x1f0)];[_0x48e965(0x491)];[_0x48e965(0x3a1)]; constructor() { const _0x38a464 = { _0x3377f0: 0x1f0, _0x90a16: 0x491 }, _0x1cd6a9 = _0x48e965; this[_0x1cd6a9(_0x38a464._0x3377f0)] = _0x1cd6a9(0x19c), this[_0x1cd6a9(_0x38a464._0x90a16)] = [], this[_0x1cd6a9(0x3a1)] = '' } [_0x48e965(0x45e)] (_0x1d2420) { const _0x55b5ca = { _0x2805fc: 0x283, _0x1cefe2: 0x20f, _0x4212c9: 0x3a1, _0x5bd3e2: 0x51f, _0x348a06: 0x164 }, _0x94d29a = { _0x521db0: 0x491 }, _0x1e1461 = _0x48e965, _0x24f003 = _0x1d2420['attrs'] && _0x1d2420[_0x1e1461(0x20f)][_0x1e1461(_0x55b5ca._0x2805fc)] !== undefined ? _0x1d2420[_0x1e1461(_0x55b5ca._0x1cefe2)]['publicPath'] + _0x1e1461(0x39e) : '/edit'; this[_0x1e1461(_0x55b5ca._0x4212c9)] = _0x24f003; const _0x321d65 = _0x1d2420['attrs'] && _0x1d2420[_0x1e1461(0x20f)][_0x1e1461(0x51f)] !== undefined ? _0x1d2420[_0x1e1461(0x20f)][_0x1e1461(_0x55b5ca._0x5bd3e2)] : []; return _0x321d65[_0x1e1461(_0x55b5ca._0x348a06)](_0x1eba4d => { const _0x278dbe = _0x1e1461; this[_0x278dbe(_0x94d29a._0x521db0)][_0x278dbe(0x1da)](_0x1eba4d) }), { 'templateModels': this[_0x1e1461(0x491)], 'templatePublic': this[_0x1e1461(0x3a1)] } } } class CompositeIcon extends Group$1 { [_0x48e965(0x40a)]; constructor() { const _0x405ee0 = { _0x541536: 0x40a }, _0x146967 = _0x48e965; super(), this[_0x146967(_0x405ee0._0x541536)] = !![] } } class CompositeIconTitle extends CompositeIcon { [_0x48e965(0x267)];[_0x48e965(0x464)]; constructor(_0x27f88c) { const _0x3d7027 = { _0x40a05a: 0x2c9, _0x1307a6: 0x218, _0x4d1cd6: 0x47d, _0x22a975: 0x1f0, _0x129cdd: 0x44d, _0x36988d: 0x267, _0x7d87b2: 0x209, _0x26209c: 0x4df, _0x38b67c: 0x209, _0xe14d4a: 0x267, _0x280def: 0x267, _0x4d644e: 0x1f0, _0x25cf9e: 0x267, _0x451d6e: 0x267, _0x37815a: 0x4df, _0x2aea13: 0x279 }, _0x1101be = { _0x1094d0: 0x3bf }, _0x27bda5 = _0x48e965; super(), this['opts'] = Object[_0x27bda5(_0x3d7027._0x40a05a)]({ 'color': _0x27bda5(_0x3d7027._0x1307a6), 'opacity': 0x1, 'titleHeight': 0x0, 'titleSize': 0x1, 'title': '', 'type': 0x0, 'fontColor': _0x27bda5(_0x3d7027._0x4d1cd6), 'bgColor': _0x27bda5(0x218), 'strokeColor': _0x27bda5(0x47d) }, _0x27f88c); if (this[_0x27bda5(0x267)][_0x27bda5(_0x3d7027._0x22a975)] == 0x3) { const _0x130438 = new BaseSpreadCircle({ 'color': this[_0x27bda5(0x267)]['color'] }); this[_0x27bda5(_0x3d7027._0x129cdd)](_0x130438), _0x130438['start'](); const _0x3b2e3b = new BaseShapeVic({ 'color': this[_0x27bda5(_0x3d7027._0x36988d)][_0x27bda5(_0x3d7027._0x7d87b2)] }); this[_0x27bda5(0x44d)](_0x3b2e3b); const _0x30b11e = () => { const _0x1d7dd8 = _0x27bda5; _0x3b2e3b[_0x1d7dd8(_0x1101be._0x1094d0)]['y'] += 0.1 / Math['PI'], requestAnimationFrame(_0x30b11e) }; _0x30b11e(), this['baseTitle'] = new BaseTitle({ 'text': this['opts'][_0x27bda5(_0x3d7027._0x26209c)], 'bgColor': this['opts']['color'], 'strokeColor': this['opts'][_0x27bda5(_0x3d7027._0x38b67c)], 'opacity': this[_0x27bda5(0x267)][_0x27bda5(0x236)], 'height': this[_0x27bda5(_0x3d7027._0xe14d4a)][_0x27bda5(0x3b9)], 'size': this[_0x27bda5(_0x3d7027._0x280def)][_0x27bda5(0x388)], 'type': this[_0x27bda5(0x267)][_0x27bda5(_0x3d7027._0x4d644e)] }), this[_0x27bda5(_0x3d7027._0x129cdd)](this[_0x27bda5(0x464)]) } else { if (this[_0x27bda5(_0x3d7027._0x25cf9e)][_0x27bda5(0x1f0)] == 0x0 || this[_0x27bda5(_0x3d7027._0x451d6e)][_0x27bda5(0x1f0)] == 0x1 || this['opts'][_0x27bda5(0x1f0)] == 0x2) { const _0x43be34 = new BaseCircle({ 'color': this[_0x27bda5(_0x3d7027._0x36988d)][_0x27bda5(_0x3d7027._0x7d87b2)], 'type': this[_0x27bda5(0x267)][_0x27bda5(0x1f0)] }); this['add'](_0x43be34), _0x43be34['startRotateAnimation'](), this['baseTitle'] = new BaseTitle({ 'text': this[_0x27bda5(_0x3d7027._0x36988d)][_0x27bda5(_0x3d7027._0x37815a)], 'bgColor': this[_0x27bda5(0x267)]['bgColor'], 'strokeColor': this['opts'][_0x27bda5(_0x3d7027._0x2aea13)], 'fontColor': this[_0x27bda5(_0x3d7027._0xe14d4a)]['fontColor'], 'opacity': this['opts'][_0x27bda5(0x236)], 'height': this[_0x27bda5(0x267)][_0x27bda5(0x3b9)], 'size': this[_0x27bda5(_0x3d7027._0x280def)][_0x27bda5(0x388)], 'type': this['opts']['type'] }), this['add'](this['baseTitle']) } } } [_0x48e965(0x3fb)] (_0x4b24b3) { const _0x57640c = { _0x3a5ecb: 0x1c8 }, _0x37c264 = _0x48e965; this[_0x37c264(0x464)][_0x37c264(_0x57640c._0x3a5ecb)]({ 'text': _0x4b24b3 }) } [_0x48e965(0x2f8)] (_0xd7c236) { const _0x575c06 = { _0x3cbc8d: 0x1c8 }, _0x11751e = _0x48e965; this[_0x11751e(0x464)][_0x11751e(_0x575c06._0x3cbc8d)]({ 'size': _0xd7c236 }) } [_0x48e965(0x2a8)] (_0x226e1a) { const _0x280206 = { _0x10190d: 0x1c8 }, _0x58c179 = _0x48e965; this['baseTitle'][_0x58c179(_0x280206._0x10190d)]({ 'bgColor': _0x226e1a }) } } class BaseTag extends Sprite { ['opts']; constructor(_0x378b40) { const _0x4351d3 = { _0x503fd6: 0x267, _0x4a687a: 0x2c9, _0x433830: 0x2f3, _0x2e0aaa: 0x4d6, _0x4f57ef: 0x49f }, _0x22f5be = _0x48e965; super(), this[_0x22f5be(_0x4351d3._0x503fd6)] = Object[_0x22f5be(_0x4351d3._0x4a687a)]({ 'text': '', 'fontColor': _0x22f5be(0x47d), 'fontSize': 0x40, 'height': 0x0, 'size': 0x1 }, _0x378b40); const { canvas: _0x14f515, width: _0x22e64a, height: _0x323b7c } = drawTagCanvas({ 'text': this[_0x22f5be(0x267)][_0x22f5be(0x28e)], 'fontColor': this[_0x22f5be(0x267)][_0x22f5be(_0x4351d3._0x433830)], 'fontSize': this['opts'][_0x22f5be(_0x4351d3._0x2e0aaa)] }), _0x221c2d = new CanvasTexture(_0x14f515); this['material'] = new SpriteMaterial({ 'map': _0x221c2d, 'transparent': !![], 'opacity': 0x1 }), this['center'][_0x22f5be(_0x4351d3._0x4f57ef)](0.5, 0x0), this['position'][_0x22f5be(0x49f)](0x0, this['opts']['height'], 0x0), this['scale'][_0x22f5be(0x49f)](this['opts'][_0x22f5be(0x394)] * (0x1 * _0x22e64a) / 0x200, this['opts'][_0x22f5be(0x394)] * 0.25, 0x1) } } class BaseSquares extends Group$1 { [_0x48e965(0x51c)];[_0x48e965(0x267)]; constructor(_0x4f1215) { const _0x19c747 = { _0x503923: 0x267, _0x5f1637: 0x218, _0x38e7f2: 0x225, _0x7d2511: 0x2b0, _0xb69663: 0x225 }, _0x20c60d = { _0x394467: 0x51c, _0x3e1086: 0x164 }, _0x7c590d = _0x48e965; super(), this[_0x7c590d(_0x19c747._0x503923)] = Object[_0x7c590d(0x2c9)]({ 'color': _0x7c590d(_0x19c747._0x5f1637) }, _0x4f1215), this[_0x7c590d(0x51c)] = []; const _0x1bdd32 = new MeshBasicMaterial({ 'color': this[_0x7c590d(_0x19c747._0x503923)][_0x7c590d(0x209)], 'transparent': !![], 'side': 0x2 }); for (let _0x2421e1 = 0x0; _0x2421e1 < 0xa; _0x2421e1++) { const _0x39a4c9 = Math[_0x7c590d(_0x19c747._0x38e7f2)]() * 0.04 + 0.02, _0x23c883 = new PlaneGeometry(_0x39a4c9, _0x39a4c9, 0x1, 0x1), _0x42186e = new Mesh(_0x23c883, _0x1bdd32[_0x7c590d(_0x19c747._0x7d2511)]()); _0x42186e[_0x7c590d(0x4c4)][_0x7c590d(0x49f)](Math[_0x7c590d(0x225)]() * 0.7 - 0.35, Math[_0x7c590d(0x225)]() * 0.5 - 0.5, Math[_0x7c590d(_0x19c747._0xb69663)]() * 0.7 - 0.35), this[_0x7c590d(0x44d)](_0x42186e), this[_0x7c590d(0x51c)]['push'](_0x42186e) } const _0x39c63f = () => { const _0x13a47 = { _0x24a6c6: 0x2be, _0x46f09b: 0x4c4, _0x1deba3: 0x2f4 }, _0x10bc12 = _0x7c590d; requestAnimationFrame(_0x39c63f), this[_0x10bc12(_0x20c60d._0x394467)][_0x10bc12(_0x20c60d._0x3e1086)](_0x21b6ab => { const _0x4ccb00 = _0x10bc12; _0x21b6ab[_0x4ccb00(0x4c4)]['y'] > 0x0 && (_0x21b6ab[_0x4ccb00(_0x13a47._0x24a6c6)]['set'](0x1, 0x1, 0x1), _0x21b6ab[_0x4ccb00(0x399)] = !![], _0x21b6ab['material'][_0x4ccb00(0x236)] = 0x1); _0x21b6ab[_0x4ccb00(_0x13a47._0x46f09b)]['y'] += 0.005; if (_0x21b6ab[_0x4ccb00(_0x13a47._0x46f09b)]['y'] > 0.35 && _0x21b6ab[_0x4ccb00(_0x13a47._0x46f09b)]['y'] < 0.5) _0x21b6ab[_0x4ccb00(_0x13a47._0x1deba3)][_0x4ccb00(0x236)] = (0.5 - _0x21b6ab['position']['y']) / 0.5, _0x21b6ab[_0x4ccb00(_0x13a47._0x24a6c6)]['x'] = (_0x21b6ab['position']['y'] + 0.15) / (0.35 + 0.15), _0x21b6ab[_0x4ccb00(0x2be)]['y'] = (_0x21b6ab[_0x4ccb00(0x4c4)]['y'] + 0.15) / (0.35 + 0.15); else _0x21b6ab[_0x4ccb00(0x4c4)]['y'] > 0.5 && (_0x21b6ab['position']['y'] = -0.2, _0x21b6ab['visible'] = ![]) }) }; _0x39c63f() } } class BaseDiamondGeometry extends BufferGeometry { constructor() { const _0x52855d = { _0x4a5662: 0x2b0, _0x35f008: 0x1da, _0xa86dc4: 0x322, _0x3bdb51: 0x3a8 }, _0x11a8ba = _0x48e965; super(); const _0xdcfd76 = [0x0, 0x0, 0x0, -0.5, 0x1, 0.5, 0.5, 0x1, 0.5, 0x0, 0x0, 0x0, 0.5, 0x1, 0.5, 0.5, 0x1, -0.5, 0x0, 0x0, 0x0, 0.5, 0x1, -0.5, -0.5, 0x1, -0.5, 0x0, 0x0, 0x0, -0.5, 0x1, -0.5, -0.5, 0x1, 0.5, -0.5, 0x1, 0.5, 0.5, 0x1, 0.5, -0.3, 1.2, 0.3, -0.3, 1.2, 0.3, 0.5, 0x1, 0.5, 0.3, 1.2, 0.3, 0.5, 0x1, 0.5, 0.5, 0x1, -0.5, 0.3, 1.2, 0.3, 0.3, 1.2, 0.3, 0.5, 0x1, -0.5, 0.3, 1.2, -0.3, 0.5, 0x1, -0.5, -0.5, 0x1, -0.5, 0.3, 1.2, -0.3, 0.3, 1.2, -0.3, -0.5, 0x1, -0.5, -0.3, 1.2, -0.3, -0.5, 0x1, -0.5, -0.5, 0x1, 0.5, -0.3, 1.2, -0.3, -0.3, 1.2, -0.3, -0.5, 0x1, 0.5, -0.3, 1.2, 0.3, -0.3, 1.2, 0.3, 0.3, 1.2, 0.3, -0.3, 1.2, -0.3, -0.3, 1.2, -0.3, 0.3, 1.2, 0.3, 0.3, 1.2, -0.3], _0x20d590 = new Vector3(), _0x4a3fa3 = new Vector3(), _0x5c3d80 = []; for (let _0x204702 = 0x0; _0x204702 < _0xdcfd76[_0x11a8ba(0x321)]; _0x204702 += 0x9) { _0x20d590[_0x11a8ba(0x49f)](_0xdcfd76[_0x204702 + 0x3] - _0xdcfd76[_0x204702], _0xdcfd76[_0x204702 + 0x4] - _0xdcfd76[_0x204702 + 0x1], _0xdcfd76[_0x204702 + 0x5] - _0xdcfd76[_0x204702 + 0x2]), _0x4a3fa3['set'](_0xdcfd76[_0x204702 + 0x6] - _0xdcfd76[_0x204702], _0xdcfd76[_0x204702 + 0x7] - _0xdcfd76[_0x204702 + 0x1], _0xdcfd76[_0x204702 + 0x8] - _0xdcfd76[_0x204702 + 0x2]); const _0x2297ee = _0x20d590[_0x11a8ba(_0x52855d._0x4a5662)]()[_0x11a8ba(0x441)](_0x4a3fa3)['normalize'](); _0x5c3d80[_0x11a8ba(_0x52855d._0x35f008)](_0x2297ee['x'], _0x2297ee['y'], _0x2297ee['z'], _0x2297ee['x'], _0x2297ee['y'], _0x2297ee['z'], _0x2297ee['x'], _0x2297ee['y'], _0x2297ee['z']) } this['setAttribute'](_0x11a8ba(0x4c4), new BufferAttribute(new Float32Array(_0xdcfd76), 0x3)), this[_0x11a8ba(_0x52855d._0xa86dc4)](_0x11a8ba(_0x52855d._0x3bdb51), new BufferAttribute(new Float32Array(_0x5c3d80), 0x3)) } } class BaseDiamond extends Mesh { [_0x48e965(0x267)]; constructor(_0x596c1c) { const _0x4bf878 = { _0x14590d: 0x218 }, _0x3e5e3c = _0x48e965; super(), this['opts'] = Object[_0x3e5e3c(0x2c9)]({ 'color': _0x3e5e3c(_0x4bf878._0x14590d), 'opacity': 0x1 }, _0x596c1c), this[_0x3e5e3c(0x303)] = new BaseDiamondGeometry(), this['material'] = new MeshStandardMaterial({ 'color': _0x3e5e3c(_0x4bf878._0x14590d), 'side': 0x2, 'transparent': this[_0x3e5e3c(0x267)][_0x3e5e3c(0x236)] != 0x1, 'opacity': this[_0x3e5e3c(0x267)][_0x3e5e3c(0x236)] }) } } class BaseStaff extends Group$1 { [_0x48e965(0x267)]; constructor(_0x348f0d) { const _0x4c14cf = { _0x3e7e46: 0x267, _0x38489a: 0x236, _0x4d57ae: 0x267, _0x32769b: 0x236, _0x36c003: 0x44d }, _0x57f1ba = _0x48e965; super(), this[_0x57f1ba(_0x4c14cf._0x3e7e46)] = Object[_0x57f1ba(0x2c9)]({ 'color': '#ff0000', 'opacity': 0x1 }, _0x348f0d); const _0x5089ab = new SphereGeometry(0.05, 0x20, 0x10), _0x33e2e4 = new MeshStandardMaterial({ 'color': this[_0x57f1ba(0x267)]['color'], 'transparent': !![], 'roughness': 0x0, 'opacity': this['opts'][_0x57f1ba(_0x4c14cf._0x38489a)] }), _0x406948 = new Mesh(_0x5089ab, _0x33e2e4); _0x406948[_0x57f1ba(0x4c4)][_0x57f1ba(0x49f)](0x0, 0.2, 0x0), this['add'](_0x406948); const _0x33cdc6 = new SphereGeometry(0.1, 0x20, 0x10, Math['PI'] * 0x2, Math['PI'] * 0x2, Math['PI'] / 0x2, Math['PI'] / 0x2), _0x1216f5 = new MeshStandardMaterial({ 'color': this[_0x57f1ba(_0x4c14cf._0x4d57ae)][_0x57f1ba(0x209)], 'transparent': !![], 'side': 0x2, 'roughness': 0x0, 'opacity': this['opts'][_0x57f1ba(_0x4c14cf._0x32769b)] }), _0x1c0917 = new Mesh(_0x33cdc6, _0x1216f5); _0x1c0917['rotateX'](Math['PI']), _0x1c0917[_0x57f1ba(0x4c4)][_0x57f1ba(0x49f)](0x0, 0.035, 0x0), this[_0x57f1ba(_0x4c14cf._0x36c003)](_0x1c0917) } } class BaseCircularArraySquares extends Group$1 { [_0x48e965(0x267)];['squares'];['animationIndex']; constructor(_0x31c6bc) { const _0x2d7679 = { _0x2bef4a: 0x218, _0x469246: 0x267, _0x396dfe: 0x38b, _0x3cd513: 0x267, _0x42d429: 0x4c4, _0x5f26b7: 0x428, _0x2d9557: 0x267, _0x27abb8: 0x4ee, _0x33f56c: 0x44d }, _0x3cf2f9 = _0x48e965; super(), this[_0x3cf2f9(0x267)] = Object[_0x3cf2f9(0x2c9)]({ 'circleRadius': 0.5, 'squareRadius': 0.05, 'numbers': 0x14, 'rotateSpeed': 0x1, 'horseRaceAnimationSpeed': 0x1, 'color': _0x3cf2f9(_0x2d7679._0x2bef4a) }, _0x31c6bc), this[_0x3cf2f9(0x51c)] = []; for (let _0x25f497 = 0x0; _0x25f497 < this[_0x3cf2f9(0x267)][_0x3cf2f9(0x4ee)]; _0x25f497++) { const _0x332813 = new PlaneGeometry(this[_0x3cf2f9(_0x2d7679._0x469246)][_0x3cf2f9(0x38b)], this[_0x3cf2f9(0x267)][_0x3cf2f9(_0x2d7679._0x396dfe)], 0x1, 0x1), _0x40808a = new MeshBasicMaterial({ 'color': this[_0x3cf2f9(_0x2d7679._0x3cd513)]['color'], 'transparent': !![], 'side': 0x2 }), _0x537034 = new Mesh(_0x332813, _0x40808a), _0x5b1b22 = Math[_0x3cf2f9(0x386)](_0x25f497 * 0x2 * Math['PI'] / this[_0x3cf2f9(0x267)]['numbers']) * this['opts']['circleRadius'], _0x452b9c = Math['sin'](_0x25f497 * 0x2 * Math['PI'] / this[_0x3cf2f9(_0x2d7679._0x469246)][_0x3cf2f9(0x4ee)]) * this[_0x3cf2f9(_0x2d7679._0x3cd513)]['circleRadius']; _0x537034[_0x3cf2f9(_0x2d7679._0x42d429)][_0x3cf2f9(0x49f)](_0x5b1b22, 0x0, _0x452b9c), _0x537034[_0x3cf2f9(0x247)](Math['PI'] / 0x2), _0x537034[_0x3cf2f9(_0x2d7679._0x5f26b7)](_0x25f497 * 0x2 * Math['PI'] / this[_0x3cf2f9(_0x2d7679._0x2d9557)][_0x3cf2f9(_0x2d7679._0x27abb8)]), _0x537034['userData']['animationLoc'] = _0x25f497, this[_0x3cf2f9(0x51c)]['push'](_0x537034), this[_0x3cf2f9(_0x2d7679._0x33f56c)](_0x537034) } } ['rotatingAnimation'] () { const _0x24cb9a = { _0x1e2a02: 0x396, _0x361c40: 0x15f, _0x24f2aa: 0x453, _0x3fc4a6: 0x453, _0x12586d: 0x386, _0x253f31: 0x267, _0x1293e8: 0x4ee, _0x5301c4: 0x274, _0x40ebb4: 0x26e, _0x557c0e: 0x267, _0x57cb1d: 0x3bf, _0x3de342: 0x4ee, _0x58dad0: 0x4c4, _0x426ebf: 0x49f }, _0xc4cef8 = _0x48e965; this[_0xc4cef8(0x389)] = requestAnimationFrame(this[_0xc4cef8(_0x24cb9a._0x1e2a02)]['bind'](this)); for (let _0x4e2448 = 0x0; _0x4e2448 < this[_0xc4cef8(0x267)][_0xc4cef8(0x4ee)]; _0x4e2448++) { const _0x4bc6d4 = this[_0xc4cef8(0x51c)][_0x4e2448]; let _0x2f6b68 = _0x4bc6d4[_0xc4cef8(_0x24cb9a._0x361c40)][_0xc4cef8(0x42d)]; _0x2f6b68 += 0.025 * (this[_0xc4cef8(0x267)][_0xc4cef8(_0x24cb9a._0x24f2aa)] ? this[_0xc4cef8(0x267)][_0xc4cef8(_0x24cb9a._0x3fc4a6)] : 0x1); const _0x352b7a = Math[_0xc4cef8(_0x24cb9a._0x12586d)](_0x2f6b68 * 0x2 * Math['PI'] / this[_0xc4cef8(_0x24cb9a._0x253f31)][_0xc4cef8(_0x24cb9a._0x1293e8)]) * this[_0xc4cef8(_0x24cb9a._0x253f31)][_0xc4cef8(_0x24cb9a._0x5301c4)], _0x1fcd9d = Math[_0xc4cef8(_0x24cb9a._0x40ebb4)](_0x2f6b68 * 0x2 * Math['PI'] / this[_0xc4cef8(0x267)][_0xc4cef8(0x4ee)]) * this[_0xc4cef8(_0x24cb9a._0x557c0e)][_0xc4cef8(_0x24cb9a._0x5301c4)]; _0x4bc6d4[_0xc4cef8(_0x24cb9a._0x57cb1d)]['z'] = _0x2f6b68 * 0x2 * Math['PI'] / this[_0xc4cef8(0x267)][_0xc4cef8(_0x24cb9a._0x3de342)], _0x4bc6d4[_0xc4cef8(_0x24cb9a._0x361c40)][_0xc4cef8(0x42d)] = _0x2f6b68, _0x4bc6d4[_0xc4cef8(_0x24cb9a._0x58dad0)][_0xc4cef8(_0x24cb9a._0x426ebf)](_0x352b7a, 0x0, _0x1fcd9d) } } [_0x48e965(0x3af)] () { this['rotatingAnimation']() } [_0x48e965(0x19e)] () { const _0x5ba5ab = { _0x119f7b: 0x389, _0x41fa69: 0x19e, _0xc994ea: 0x2d7, _0x1a53a9: 0x267, _0x1d7591: 0x4ee, _0x261420: 0x267, _0x2f3a74: 0x453, _0x5587a0: 0x386, _0x28a886: 0x267, _0x495296: 0x274, _0x4af38a: 0x15f, _0x1829a3: 0x49f }, _0x1efbc3 = _0x48e965; this[_0x1efbc3(_0x5ba5ab._0x119f7b)] = requestAnimationFrame(this[_0x1efbc3(_0x5ba5ab._0x41fa69)][_0x1efbc3(_0x5ba5ab._0xc994ea)](this)); for (let _0x2f7d4e = 0x0; _0x2f7d4e < this[_0x1efbc3(_0x5ba5ab._0x1a53a9)][_0x1efbc3(_0x5ba5ab._0x1d7591)]; _0x2f7d4e++) { const _0x516075 = this[_0x1efbc3(0x51c)][_0x2f7d4e]; let _0x4a4061 = _0x516075['userData']['animationLoc']; _0x4a4061 += 0.025 * (this[_0x1efbc3(_0x5ba5ab._0x261420)]['rotateSpeed'] ? this[_0x1efbc3(0x267)][_0x1efbc3(_0x5ba5ab._0x2f3a74)] : 0x1); const _0xba8d3 = Math[_0x1efbc3(_0x5ba5ab._0x5587a0)](_0x4a4061 * 0x2 * Math['PI'] / this[_0x1efbc3(_0x5ba5ab._0x28a886)][_0x1efbc3(_0x5ba5ab._0x1d7591)]) * this[_0x1efbc3(0x267)]['circleRadius'], _0x596076 = Math['sin'](_0x4a4061 * 0x2 * Math['PI'] / this[_0x1efbc3(0x267)][_0x1efbc3(0x4ee)]) * this['opts'][_0x1efbc3(_0x5ba5ab._0x495296)]; _0x516075[_0x1efbc3(0x3bf)]['z'] = _0x4a4061 * 0x2 * Math['PI'] / this[_0x1efbc3(0x267)][_0x1efbc3(0x4ee)], _0x516075[_0x1efbc3(_0x5ba5ab._0x4af38a)]['animationLoc'] = _0x4a4061, _0x516075['position'][_0x1efbc3(_0x5ba5ab._0x1829a3)](_0xba8d3, 0x0, _0x596076), _0x516075[_0x1efbc3(0x2f4)]['opacity'] = Math['abs'](Math['sin'](this['squares'][0x0]['userData']['animationLoc'])) } } [_0x48e965(0x2fa)] () { const _0x191333 = { _0x108d8a: 0x19e }, _0x3ba0b8 = _0x48e965; this[_0x3ba0b8(_0x191333._0x108d8a)]() } ['horseRaceLampAnimation'] () { const _0x561443 = { _0x365ff5: 0x389, _0x5d4618: 0x39f, _0x1445a9: 0x4ee, _0x3d007e: 0x267, _0x356e9f: 0x232, _0x368e64: 0x267, _0x44b4c4: 0x4ee, _0x348727: 0x4ee }, _0x1af4f2 = _0x48e965; this[_0x1af4f2(_0x561443._0x365ff5)] = requestAnimationFrame(this[_0x1af4f2(_0x561443._0x5d4618)][_0x1af4f2(0x2d7)](this)); for (let _0x30f939 = 0x0; _0x30f939 < this['opts'][_0x1af4f2(_0x561443._0x1445a9)]; _0x30f939++) { const _0x27611d = this['squares'][_0x30f939]; let _0x4065f9 = _0x27611d['userData']['animationLoc']; _0x4065f9 += 0.25 * (this[_0x1af4f2(_0x561443._0x3d007e)][_0x1af4f2(_0x561443._0x356e9f)] ? this[_0x1af4f2(_0x561443._0x368e64)][_0x1af4f2(_0x561443._0x356e9f)] : 0x1), _0x4065f9 %= this[_0x1af4f2(0x267)][_0x1af4f2(_0x561443._0x44b4c4)], _0x27611d[_0x1af4f2(0x15f)][_0x1af4f2(0x42d)] = _0x4065f9, _0x27611d['material'][_0x1af4f2(0x236)] = _0x4065f9 / this['opts'][_0x1af4f2(_0x561443._0x348727)] } } ['startHorseRaceLampAnimation'] () { const _0x3bbe22 = { _0x2585e3: 0x39f }, _0x3a8b94 = _0x48e965; this[_0x3a8b94(_0x3bbe22._0x2585e3)]() } [_0x48e965(0x28d)] () { cancelAnimationFrame(this['animationIndex']), this['animationIndex'] = -0x1 } } class BaseTriangleGeometry extends BufferGeometry { [_0x48e965(0x267)]; constructor(_0x6a2a20) { const _0x45d8ce = { _0x2e2c85: 0x2c9, _0xd6b791: 0x267, _0x2536e2: 0x267, _0x56313a: 0x394, _0x4fc29d: 0x267, _0x49761d: 0x322 }, _0x218379 = _0x48e965; super(), this[_0x218379(0x267)] = Object[_0x218379(_0x45d8ce._0x2e2c85)]({ 'size': 0x1, 'type': 0x0 }, _0x6a2a20); let _0x4d72af = []; if (this['opts']['type'] == 0x0) _0x4d72af = [0x0, 0x0, 0x0, this[_0x218379(_0x45d8ce._0xd6b791)][_0x218379(0x394)] * 1.732 / 0x2, 0x0, this[_0x218379(_0x45d8ce._0x2536e2)][_0x218379(0x394)] * 0.5, this[_0x218379(0x267)]['size'] * 1.732 / 0x2, 0x0, this[_0x218379(0x267)][_0x218379(_0x45d8ce._0x56313a)] * -0.5]; else this[_0x218379(_0x45d8ce._0x4fc29d)][_0x218379(0x1f0)] == 0x1 && (_0x4d72af = [this[_0x218379(0x267)]['size'] * -0.5, 0x0, this[_0x218379(0x267)]['size'] / (0x2 * 1.732), this[_0x218379(0x267)][_0x218379(0x394)] * 0.5, 0x0, this[_0x218379(0x267)]['size'] / (0x2 * 1.732), 0x0, 0x0, -this['opts'][_0x218379(_0x45d8ce._0x56313a)] / 1.732]); const _0x495197 = [0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0]; this[_0x218379(_0x45d8ce._0x49761d)]('position', new BufferAttribute(new Float32Array(_0x4d72af), 0x3)), this[_0x218379(_0x45d8ce._0x49761d)](_0x218379(0x3a8), new BufferAttribute(new Float32Array(_0x495197), 0x3)) } } class BaseTriangle extends Mesh { [_0x48e965(0x267)];[_0x48e965(0x394)];[_0x48e965(0x4a2)];[_0x48e965(0x453)];[_0x48e965(0x389)]; constructor(_0x39b85c) { const _0x13c068 = { _0x4d3bd6: 0x267, _0xce4eb5: 0x394, _0x5637fd: 0x267, _0xa61ff2: 0x453, _0x57f5c0: 0x267, _0x1884db: 0x303, _0x2fba8e: 0x4a2, _0x37413c: 0x209 }, _0x20be24 = _0x48e965; super(), this[_0x20be24(_0x13c068._0x4d3bd6)] = Object['assign']({ 'color': _0x20be24(0x218), 'size': 0x1, 'type': 0x0, 'rotateSpeed': 0x1 }, _0x39b85c), this['animationIndex'] = -0x1, this['size'] = this['opts'][_0x20be24(_0x13c068._0xce4eb5)] !== undefined ? this[_0x20be24(0x267)][_0x20be24(0x394)] : 0x1, this['triangleType'] = this[_0x20be24(_0x13c068._0x5637fd)][_0x20be24(0x1f0)] !== undefined ? this[_0x20be24(0x267)][_0x20be24(0x1f0)] : 0x0, this[_0x20be24(_0x13c068._0xa61ff2)] = this[_0x20be24(_0x13c068._0x4d3bd6)]['rotateSpeed'] !== undefined ? this[_0x20be24(_0x13c068._0x57f5c0)]['rotateSpeed'] : 0x1, this[_0x20be24(_0x13c068._0x1884db)] = new BaseTriangleGeometry({ 'size': this[_0x20be24(0x394)], 'type': this[_0x20be24(_0x13c068._0x2fba8e)] }), this['material'] = new MeshStandardMaterial({ 'color': this[_0x20be24(_0x13c068._0x5637fd)][_0x20be24(_0x13c068._0x37413c)], 'transparent': !![] }) } [_0x48e965(0x28d)] () { const _0x34fed4 = { _0x24cba0: 0x389 }, _0x570353 = _0x48e965; cancelAnimationFrame(this[_0x570353(0x389)]), this[_0x570353(_0x34fed4._0x24cba0)] = -0x1 } [_0x48e965(0x1d9)] () { const _0x1699bd = { _0x5af7f6: 0x267 }, _0x4f0799 = _0x48e965; if (this[_0x4f0799(_0x1699bd._0x5af7f6)][_0x4f0799(0x1f0)] == 0x1) this['rotateAnimation']() } [_0x48e965(0x3b3)] () { const _0x42a740 = { _0x5ba524: 0x3b3 }, _0x497cab = _0x48e965; this['animationIndex'] = requestAnimationFrame(this[_0x497cab(_0x42a740._0x5ba524)][_0x497cab(0x2d7)](this)), this[_0x497cab(0x3bf)]['y'] += 0.01 * this['rotateSpeed'] } } class BaseCircularArrayArrows extends Group$1 { ['opts'];[_0x48e965(0x389)];[_0x48e965(0x487)];[_0x48e965(0x529)];[_0x48e965(0x415)]; constructor(_0x1fc187) { const _0x533c9f = { _0x8ee3d6: 0x2c9, _0x17d63d: 0x267, _0xfb493c: 0x4ee, _0x579f63: 0x209, _0x2482ab: 0x49f, _0x429c00: 0x155, _0xd8b457: 0x386, _0xfc94b2: 0x4ee, _0x4ba375: 0x26e, _0x387769: 0x4e7, _0x28c635: 0x487 }, _0x3a5930 = _0x48e965; super(), this['opts'] = Object[_0x3a5930(_0x533c9f._0x8ee3d6)]({ 'circleRadius': 0.5, 'triangleSize': 0.15, 'numbers': 0x4, 'color': _0x3a5930(0x218), 'speed': 0x1, 'indicateRadius': 1.5 }, _0x1fc187), this['animationIndex'] = -0x1, this[_0x3a5930(0x487)] = [], this['directionTag'] = !![], this[_0x3a5930(0x415)] = 0x1; for (let _0x1d7068 = 0x0; _0x1d7068 < this[_0x3a5930(_0x533c9f._0x17d63d)][_0x3a5930(_0x533c9f._0xfb493c)]; _0x1d7068++) { const _0x48840b = new BaseTriangle({ 'color': this[_0x3a5930(0x267)][_0x3a5930(_0x533c9f._0x579f63)] }); _0x48840b['scale'][_0x3a5930(_0x533c9f._0x2482ab)](this['opts'][_0x3a5930(_0x533c9f._0x429c00)], this[_0x3a5930(0x267)][_0x3a5930(0x155)], this[_0x3a5930(_0x533c9f._0x17d63d)][_0x3a5930(_0x533c9f._0x429c00)]); const _0x18a7e5 = Math[_0x3a5930(_0x533c9f._0xd8b457)](_0x1d7068 * 0x2 * Math['PI'] / this['opts'][_0x3a5930(_0x533c9f._0xfc94b2)]) * this['opts']['circleRadius'], _0x3a0b96 = Math[_0x3a5930(_0x533c9f._0x4ba375)](_0x1d7068 * 0x2 * Math['PI'] / this['opts'][_0x3a5930(0x4ee)]) * this[_0x3a5930(_0x533c9f._0x17d63d)][_0x3a5930(0x274)]; _0x48840b['position']['set'](_0x18a7e5, 0x0, _0x3a0b96), _0x48840b[_0x3a5930(_0x533c9f._0x387769)](-(_0x1d7068 * 0x2 * Math['PI']) / this[_0x3a5930(0x267)][_0x3a5930(0x4ee)]), this[_0x3a5930(0x44d)](_0x48840b), this[_0x3a5930(_0x533c9f._0x28c635)][_0x3a5930(0x1da)](_0x48840b) } } [_0x48e965(0x28d)] () { const _0x397181 = { _0x1c9e59: 0x389 }, _0x3f042b = _0x48e965; cancelAnimationFrame(this[_0x3f042b(0x389)]), this[_0x3f042b(_0x397181._0x1c9e59)] = -0x1 } [_0x48e965(0x2d1)] () { const _0x28edd2 = { _0x1ffad9: 0x389, _0x5a3576: 0x2d1, _0x26e465: 0x4ee, _0x1aca0d: 0x386, _0x2f372f: 0x3cc, _0x3cc75b: 0x415, _0x4349db: 0x267, _0x20fa0b: 0x386, _0x5c5f0a: 0x26e, _0x132fbf: 0x529 }, _0x3206ca = _0x48e965; this[_0x3206ca(_0x28edd2._0x1ffad9)] = requestAnimationFrame(this[_0x3206ca(_0x28edd2._0x5a3576)][_0x3206ca(0x2d7)](this)); for (let _0x1f2a71 = 0x0; _0x1f2a71 < this['opts'][_0x3206ca(_0x28edd2._0x26e465)]; _0x1f2a71++) { const _0x205976 = this[_0x3206ca(0x487)][_0x1f2a71]; this[_0x3206ca(0x529)] ? this[_0x3206ca(0x415)] += Math[_0x3206ca(_0x28edd2._0x1aca0d)](this[_0x3206ca(0x415)]) * 0.005 * this[_0x3206ca(0x267)][_0x3206ca(_0x28edd2._0x2f372f)] : this[_0x3206ca(0x415)] -= Math[_0x3206ca(_0x28edd2._0x1aca0d)](this[_0x3206ca(_0x28edd2._0x3cc75b)]) * 0.005 * this[_0x3206ca(_0x28edd2._0x4349db)]['speed']; const _0x333538 = Math[_0x3206ca(_0x28edd2._0x20fa0b)](_0x1f2a71 * 0x2 * Math['PI'] / this[_0x3206ca(_0x28edd2._0x4349db)][_0x3206ca(_0x28edd2._0x26e465)]) * this[_0x3206ca(0x267)][_0x3206ca(0x274)] * this[_0x3206ca(0x415)], _0x4fd9d8 = Math[_0x3206ca(_0x28edd2._0x5c5f0a)](_0x1f2a71 * 0x2 * Math['PI'] / this[_0x3206ca(_0x28edd2._0x4349db)][_0x3206ca(0x4ee)]) * this[_0x3206ca(_0x28edd2._0x4349db)][_0x3206ca(0x274)] * this[_0x3206ca(0x415)]; if (this[_0x3206ca(0x415)] >= this['opts'][_0x3206ca(0x19f)]) this[_0x3206ca(_0x28edd2._0x132fbf)] = ![]; else this[_0x3206ca(0x415)] <= 0x1 && (this[_0x3206ca(0x529)] = !![]); _0x205976[_0x3206ca(0x4c4)][_0x3206ca(0x49f)](_0x333538, 0x0, _0x4fd9d8) } } [_0x48e965(0x212)] () { const _0x3654ed = _0x48e965; this[_0x3654ed(0x2d1)]() } } class BaseCubes extends Group$1 { [_0x48e965(0x267)];[_0x48e965(0x4ee)];['positionRange'];['sizeRange'];['hasWireframe'];[_0x48e965(0x389)];[_0x48e965(0x21e)];['risingSpeed'];['risingMaxHeight']; constructor(_0xb5a186) { const _0x39c049 = { _0x3aea00: 0x2c9, _0x3fa098: 0x389, _0x247397: 0x4ee, _0x1bf3c8: 0x4ee, _0x2d8dde: 0x2ef, _0x5e602c: 0x173, _0x28e34a: 0x267, _0x3b0445: 0x3b6, _0x3c06be: 0x3b6, _0x54ebdf: 0x2c4, _0x19a199: 0x225, _0x7ea393: 0x2ef, _0x346162: 0x49f, _0x2c0d77: 0x278, _0x4b41f7: 0x278, _0xa69e42: 0x225, _0x34be6b: 0x21e, _0xbb6233: 0x47d, _0x1606ff: 0x44d }, _0x41bc35 = _0x48e965; super(), this[_0x41bc35(0x267)] = Object[_0x41bc35(_0x39c049._0x3aea00)]({ 'positionRange': [0x1, 0x1, 0x1], 'sizeRange': [0x1, 0x1, 0x1], 'color': _0x41bc35(0x218), 'numbers': 0xc, 'opacity': 0x1, 'risingSpeed': 0x1, 'risingMaxHeight': 0x1 }, _0xb5a186), this[_0x41bc35(_0x39c049._0x3fa098)] = -0x1, this[_0x41bc35(_0x39c049._0x247397)] = this['opts'][_0x41bc35(_0x39c049._0x247397)] !== undefined ? this[_0x41bc35(0x267)][_0x41bc35(_0x39c049._0x1bf3c8)] : 0xc, this['positionRange'] = this['opts'][_0x41bc35(0x278)] !== undefined ? this['opts'][_0x41bc35(0x278)] : [0x1, 0x1, 0x1], this[_0x41bc35(_0x39c049._0x2d8dde)] = this[_0x41bc35(0x267)][_0x41bc35(0x2ef)] !== undefined ? this['opts']['sizeRange'] : [0x1, 0x1, 0x1], this[_0x41bc35(0x173)] = this[_0x41bc35(0x267)][_0x41bc35(_0x39c049._0x5e602c)] !== undefined ? this[_0x41bc35(_0x39c049._0x28e34a)][_0x41bc35(_0x39c049._0x5e602c)] : !![], this[_0x41bc35(0x3b6)] = this[_0x41bc35(0x267)][_0x41bc35(_0x39c049._0x3b0445)] !== undefined ? this[_0x41bc35(0x267)][_0x41bc35(_0x39c049._0x3c06be)] : 0x1, this[_0x41bc35(_0x39c049._0x54ebdf)] = this[_0x41bc35(_0x39c049._0x28e34a)]['risingMaxHeight'] !== undefined ? this['opts'][_0x41bc35(0x2c4)] : 0x1, this[_0x41bc35(0x21e)] = []; for (let _0x553186 = 0x0; _0x553186 < this[_0x41bc35(_0x39c049._0x1bf3c8)]; _0x553186++) { const _0x1f30e = Math[_0x41bc35(_0x39c049._0x19a199)]() * this[_0x41bc35(0x2ef)][0x0] + this['sizeRange'][0x0], _0x60e46f = Math['random']() * this[_0x41bc35(0x2ef)][0x1] + this[_0x41bc35(0x2ef)][0x1], _0x305447 = Math['random']() * this[_0x41bc35(0x2ef)][0x2] + this[_0x41bc35(_0x39c049._0x7ea393)][0x2], _0x20fb7d = new BoxGeometry(_0x1f30e, _0x60e46f, _0x305447), _0x405cea = new MeshStandardMaterial({ 'color': this[_0x41bc35(0x267)][_0x41bc35(0x209)], 'transparent': !![], 'opacity': this[_0x41bc35(_0x39c049._0x28e34a)][_0x41bc35(0x236)] }), _0x2232bc = new Mesh(_0x20fb7d, _0x405cea); _0x2232bc[_0x41bc35(0x4c4)][_0x41bc35(_0x39c049._0x346162)](Math['random']() * 0x2 * this['positionRange'][0x0] - this['positionRange'][0x0], Math['random']() * this[_0x41bc35(_0x39c049._0x2c0d77)][0x1] + _0x60e46f / 0x2, Math['random']() * 0x2 * this['positionRange'][0x2] - this[_0x41bc35(_0x39c049._0x4b41f7)][0x2]), this[_0x41bc35(0x44d)](_0x2232bc), _0x2232bc['userData']['risingSpeed'] = (Math[_0x41bc35(_0x39c049._0xa69e42)]() + 0.5) * this[_0x41bc35(0x3b6)], this[_0x41bc35(_0x39c049._0x34be6b)]['push'](_0x2232bc); if (this[_0x41bc35(0x173)]) { const _0x178c09 = new EdgesGeometry(_0x20fb7d), _0x14da5e = new LineBasicMaterial({ 'color': _0x41bc35(_0x39c049._0xbb6233), 'transparent': !![] }), _0x4743d7 = new LineSegments(_0x178c09, _0x14da5e); _0x2232bc[_0x41bc35(_0x39c049._0x1606ff)](_0x4743d7) } } } [_0x48e965(0x541)] () { const _0x331e34 = { _0x1a9f75: 0x389, _0x37fedc: 0x2d7, _0x1123ef: 0x3b6, _0x2de5d3: 0x236, _0x84a2b: 0x2c4, _0x17fe96: 0x3bf, _0x156343: 0x4c4 }, _0x18c73d = _0x48e965; this[_0x18c73d(_0x331e34._0x1a9f75)] = requestAnimationFrame(this['risingAnimation'][_0x18c73d(_0x331e34._0x37fedc)](this)); for (let _0x2ab917 = 0x0; _0x2ab917 < this['cubes']['length']; _0x2ab917++) { this[_0x18c73d(0x21e)][_0x2ab917][_0x18c73d(0x4c4)]['y'] += 0.0025 * this['cubes'][_0x2ab917]['userData'][_0x18c73d(_0x331e34._0x1123ef)], this['cubes'][_0x2ab917]['material'][_0x18c73d(_0x331e34._0x2de5d3)] = (this[_0x18c73d(_0x331e34._0x84a2b)] - this['cubes'][_0x2ab917]['position']['y']) / this[_0x18c73d(0x2c4)], this[_0x18c73d(0x21e)][_0x2ab917][_0x18c73d(0x3bf)]['x'] -= 0.005 * this[_0x18c73d(0x21e)][_0x2ab917][_0x18c73d(0x15f)]['risingSpeed'], this[_0x18c73d(0x21e)][_0x2ab917][_0x18c73d(_0x331e34._0x17fe96)]['y'] -= 0.005 * this['cubes'][_0x2ab917][_0x18c73d(0x15f)]['risingSpeed'], this[_0x18c73d(0x21e)][_0x2ab917][_0x18c73d(_0x331e34._0x156343)]['y'] > this[_0x18c73d(_0x331e34._0x84a2b)] && (this[_0x18c73d(0x21e)][_0x2ab917][_0x18c73d(0x4c4)]['y'] = 0x0, this['cubes'][_0x2ab917][_0x18c73d(0x3bf)]['x'] = 0x0, this[_0x18c73d(0x21e)][_0x2ab917]['rotation']['y'] = 0x0, this['cubes'][_0x2ab917][_0x18c73d(0x2f4)]['opacity'] = 0x1) } } [_0x48e965(0x34e)] () { this['risingAnimation']() } [_0x48e965(0x28d)] () { const _0x25e96b = { _0x408cbc: 0x389 }, _0xef7707 = _0x48e965; cancelAnimationFrame(this[_0xef7707(0x389)]), this[_0xef7707(_0x25e96b._0x408cbc)] = -0x1 } } class BaseOctahedron extends Mesh { ['opts']; constructor(_0x201f2e) { const _0x152b45 = { _0x115398: 0x267, _0x4e1ac1: 0x267, _0xe80a06: 0x3da, _0x5aece5: 0x2f4, _0x50b739: 0x209, _0x249be1: 0x303 }, _0x449b69 = _0x48e965; super(), this[_0x449b69(_0x152b45._0x115398)] = Object['assign']({ 'color': _0x449b69(0x218), 'radius': 0.1 }, _0x201f2e), this[_0x449b69(0x303)] = new OctahedronGeometry(this[_0x449b69(_0x152b45._0x4e1ac1)][_0x449b69(_0x152b45._0xe80a06)]), this[_0x449b69(_0x152b45._0x5aece5)] = new MeshStandardMaterial({ 'color': this['opts'][_0x449b69(_0x152b45._0x50b739)], 'transparent': !![] }); const _0x4924d7 = new EdgesGeometry(this[_0x449b69(_0x152b45._0x249be1)]), _0x5e0fcb = new LineBasicMaterial({ 'color': _0x449b69(0x47d), 'transparent': !![] }), _0x16a6e6 = new LineSegments(_0x4924d7, _0x5e0fcb); this[_0x449b69(0x44d)](_0x16a6e6) } } class BaseTriangularPyramid extends Mesh { [_0x48e965(0x267)];['animationIndex'];['rotateSpeed'];[_0x48e965(0x173)]; constructor(_0x5bab00) { const _0x4db4fc = { _0x465c89: 0x267, _0x2d4409: 0x453, _0x4b59ed: 0x453, _0x5a2c1a: 0x173, _0x206d47: 0x173, _0x48e8f3: 0x496, _0x1194a2: 0x44d }, _0xfa2ab = _0x48e965; super(), this[_0xfa2ab(_0x4db4fc._0x465c89)] = Object[_0xfa2ab(0x2c9)]({ 'color': _0xfa2ab(0x218), 'width': 0x1, 'height': 0x1, 'rotateSpeed': 0x1, 'hasWireframe': !![] }, _0x5bab00), this['animationIndex'] = -0x1, this[_0xfa2ab(_0x4db4fc._0x2d4409)] = this[_0xfa2ab(0x267)][_0xfa2ab(_0x4db4fc._0x4b59ed)] !== undefined ? this['opts'][_0xfa2ab(0x453)] : 0x1, this[_0xfa2ab(0x173)] = this[_0xfa2ab(_0x4db4fc._0x465c89)][_0xfa2ab(_0x4db4fc._0x5a2c1a)] !== undefined ? this[_0xfa2ab(0x267)][_0xfa2ab(_0x4db4fc._0x206d47)] : !![], this[_0xfa2ab(0x303)] = new ConeGeometry(this['opts']['width'], this[_0xfa2ab(_0x4db4fc._0x465c89)][_0xfa2ab(_0x4db4fc._0x48e8f3)], 0x3), this['geometry']['rotateX'](Math['PI']), this['material'] = new MeshStandardMaterial({ 'color': this[_0xfa2ab(0x267)][_0xfa2ab(0x209)], 'transparent': !![] }); if (this[_0xfa2ab(_0x4db4fc._0x5a2c1a)]) { const _0x25fc13 = new WireframeGeometry(this[_0xfa2ab(0x303)]), _0x17daf6 = new MeshBasicMaterial({ 'color': '#ffffff', 'transparent': !![], 'wireframe': !![] }), _0x24cb17 = new Mesh(_0x25fc13, _0x17daf6); this[_0xfa2ab(_0x4db4fc._0x1194a2)](_0x24cb17) } } [_0x48e965(0x28d)] () { const _0x383578 = _0x48e965; cancelAnimationFrame(this[_0x383578(0x389)]), this['animationIndex'] = -0x1 } ['startRotateAnimation'] () { this['rotateAnimation']() } ['rotateAnimation'] () { const _0x8c6f8e = { _0x37e9fa: 0x389, _0x1f5f6b: 0x3b3, _0x1dac50: 0x2d7, _0x5a6469: 0x3bf, _0xa38a1: 0x453 }, _0x572cd0 = _0x48e965; this[_0x572cd0(_0x8c6f8e._0x37e9fa)] = requestAnimationFrame(this[_0x572cd0(_0x8c6f8e._0x1f5f6b)][_0x572cd0(_0x8c6f8e._0x1dac50)](this)), this[_0x572cd0(_0x8c6f8e._0x5a6469)]['y'] += 0.01 * this[_0x572cd0(_0x8c6f8e._0xa38a1)] } } class BaseRectangularPyramid extends Mesh { [_0x48e965(0x267)];[_0x48e965(0x389)];['rotateSpeed']; constructor(_0x168262) { const _0x2ba31f = { _0x4979a3: 0x267, _0x2e3ec6: 0x453, _0x114ead: 0x303, _0x4adec7: 0x267, _0x19ca3b: 0x267, _0x4aa443: 0x303, _0x4a9431: 0x44d }, _0x31e792 = _0x48e965; super(), this[_0x31e792(_0x2ba31f._0x4979a3)] = Object['assign']({ 'color': _0x31e792(0x218), 'width': 0x1, 'height': 0x1, 'rotateSpeed': 0x1 }, _0x168262), this['animationIndex'] = -0x1, this[_0x31e792(_0x2ba31f._0x2e3ec6)] = this[_0x31e792(_0x2ba31f._0x4979a3)][_0x31e792(0x453)] !== undefined ? this['opts'][_0x31e792(0x453)] : 0x1, this[_0x31e792(_0x2ba31f._0x114ead)] = new ConeGeometry(this[_0x31e792(_0x2ba31f._0x4adec7)][_0x31e792(0x15d)], this[_0x31e792(_0x2ba31f._0x19ca3b)]['height'], 0x4), this[_0x31e792(_0x2ba31f._0x4aa443)]['rotateX'](Math['PI']), this[_0x31e792(0x2f4)] = new MeshStandardMaterial({ 'color': this[_0x31e792(_0x2ba31f._0x4adec7)]['color'], 'transparent': !![] }); const _0x414b6a = new WireframeGeometry(this[_0x31e792(0x303)]), _0x5b1c50 = new MeshBasicMaterial({ 'color': '#ffffff', 'transparent': !![], 'wireframe': !![] }), _0x19dd97 = new Mesh(_0x414b6a, _0x5b1c50); this[_0x31e792(_0x2ba31f._0x4a9431)](_0x19dd97) } [_0x48e965(0x28d)] () { const _0x4ef7e5 = _0x48e965; cancelAnimationFrame(this['animationIndex']), this[_0x4ef7e5(0x389)] = -0x1 } [_0x48e965(0x1d9)] () { const _0x1a2d4e = { _0x21ba04: 0x3b3 }, _0x4b178b = _0x48e965; this[_0x4b178b(_0x1a2d4e._0x21ba04)]() } [_0x48e965(0x3b3)] () { const _0x2e8117 = { _0x34e0ef: 0x389, _0x134a3c: 0x2d7 }, _0x449107 = _0x48e965; this[_0x449107(_0x2e8117._0x34e0ef)] = requestAnimationFrame(this['rotateAnimation'][_0x449107(_0x2e8117._0x134a3c)](this)), this['rotation']['y'] += 0.01 * this[_0x449107(0x453)] } } class BaseTriangleWall extends Mesh { ['opts'];[_0x48e965(0x394)];[_0x48e965(0x209)];[_0x48e965(0x496)]; constructor(_0x5b1837) { const _0x3828df = { _0x4ab30f: 0x218, _0x539b50: 0x394, _0x463065: 0x267, _0x4b0b6b: 0x267, _0x113ca4: 0x496, _0x40cb67: 0x394, _0x41131d: 0x394, _0x34892d: 0x321, _0x20fff7: 0x1da, _0x14b2e1: 0x303, _0x3a57a3: 0x322, _0x3f54d2: 0x420, _0x38f854: 0x514 }, _0x48614f = _0x48e965; super(), this[_0x48614f(0x267)] = Object['assign']({ 'color': _0x48614f(_0x3828df._0x4ab30f), 'size': 0.25, 'height': 0.5 }, _0x5b1837), this[_0x48614f(0x394)] = this[_0x48614f(0x267)][_0x48614f(_0x3828df._0x539b50)] !== undefined ? this['opts'][_0x48614f(_0x3828df._0x539b50)] : 0x1, this[_0x48614f(0x209)] = this[_0x48614f(_0x3828df._0x463065)]['color'] !== undefined ? this[_0x48614f(_0x3828df._0x463065)]['color'] : '#ff0000', this[_0x48614f(0x496)] = this[_0x48614f(_0x3828df._0x4b0b6b)]['height'] !== undefined ? this[_0x48614f(_0x3828df._0x463065)][_0x48614f(_0x3828df._0x113ca4)] : 0x1; const _0x1b8660 = [this[_0x48614f(_0x3828df._0x40cb67)] * -0.5, 0x0, this['size'] / (0x2 * 1.732), this[_0x48614f(_0x3828df._0x41131d)] * 0.5, 0x0, this[_0x48614f(_0x3828df._0x539b50)] / (0x2 * 1.732), 0x0, 0x0, -this[_0x48614f(0x394)] / 1.732], _0x1738fd = []; for (let _0x47ad51 = 0x0; _0x47ad51 < _0x1b8660[_0x48614f(0x321)] / 0x3; _0x47ad51++) { _0x47ad51 == _0x1b8660[_0x48614f(_0x3828df._0x34892d)] / 0x3 - 0x1 ? (_0x1738fd[_0x48614f(0x1da)](_0x1b8660[_0x47ad51 * 0x3], _0x1b8660[_0x47ad51 * 0x3 + 0x1], _0x1b8660[_0x47ad51 * 0x3 + 0x2], _0x1b8660[0x0], _0x1b8660[0x1], _0x1b8660[0x2], _0x1b8660[_0x47ad51 * 0x3], _0x1b8660[_0x47ad51 * 0x3 + 0x1] + this[_0x48614f(0x496)], _0x1b8660[_0x47ad51 * 0x3 + 0x2]), _0x1738fd[_0x48614f(_0x3828df._0x20fff7)](_0x1b8660[_0x47ad51 * 0x3], _0x1b8660[_0x47ad51 * 0x3 + 0x1] + this[_0x48614f(0x496)], _0x1b8660[_0x47ad51 * 0x3 + 0x2], _0x1b8660[0x0], _0x1b8660[0x1], _0x1b8660[0x2], _0x1b8660[0x0], _0x1b8660[0x1] + this[_0x48614f(0x496)], _0x1b8660[0x2])) : (_0x1738fd['push'](_0x1b8660[_0x47ad51 * 0x3], _0x1b8660[_0x47ad51 * 0x3 + 0x1], _0x1b8660[_0x47ad51 * 0x3 + 0x2], _0x1b8660[_0x47ad51 * 0x3 + 0x3], _0x1b8660[_0x47ad51 * 0x3 + 0x4], _0x1b8660[_0x47ad51 * 0x3 + 0x5], _0x1b8660[_0x47ad51 * 0x3], _0x1b8660[_0x47ad51 * 0x3 + 0x1] + this['height'], _0x1b8660[_0x47ad51 * 0x3 + 0x2]), _0x1738fd[_0x48614f(0x1da)](_0x1b8660[_0x47ad51 * 0x3], _0x1b8660[_0x47ad51 * 0x3 + 0x1] + this[_0x48614f(0x496)], _0x1b8660[_0x47ad51 * 0x3 + 0x2], _0x1b8660[_0x47ad51 * 0x3 + 0x3], _0x1b8660[_0x47ad51 * 0x3 + 0x4], _0x1b8660[_0x47ad51 * 0x3 + 0x5], _0x1b8660[_0x47ad51 * 0x3 + 0x3], _0x1b8660[_0x47ad51 * 0x3 + 0x4] + this[_0x48614f(0x496)], _0x1b8660[_0x47ad51 * 0x3 + 0x5])) } const _0x1ea309 = _0x1738fd; this[_0x48614f(_0x3828df._0x14b2e1)][_0x48614f(_0x3828df._0x3a57a3)]('position', new Float32BufferAttribute(_0x1ea309, 0x3)), this[_0x48614f(0x2f4)] = new ShaderMaterial({ 'transparent': !![], 'side': 0x2, 'uniforms': { 'color': { 'value': new Color(this['color']) }, 'height': { 'value': this['height'] }, 'uOpacity': { 'value': 0.35 } }, 'vertexShader': _0x48614f(_0x3828df._0x3f54d2), 'fragmentShader': _0x48614f(_0x3828df._0x38f854) }) } } class BaseTriangleWallParticles extends Group$1 { [_0x48e965(0x267)];[_0x48e965(0x22d)];[_0x48e965(0x389)];['rotateSpeed']; constructor(_0x51b443) { const _0x5c3b2e = { _0xf2b169: 0x267, _0x1403fb: 0x2c9, _0xbaea7: 0x218, _0x22977e: 0x453, _0x253ec1: 0x267, _0x14fb70: 0x401, _0x39b823: 0x49f, _0x1d485d: 0x44d, _0x1e83d5: 0x267, _0x29d50c: 0x1a9, _0x5b7de0: 0x267, _0x33e5b4: 0x437, _0x5ee362: 0x267, _0x57b626: 0x27f, _0x97ec9: 0x22d, _0x438da1: 0x393 }, _0x4efd49 = _0x48e965; super(), this[_0x4efd49(_0x5c3b2e._0xf2b169)] = Object[_0x4efd49(_0x5c3b2e._0x1403fb)]({ 'wallColor': _0x4efd49(0x218), 'wallSize': 0.25, 'wallHeight': 0.5, 'particlesColor': _0x4efd49(_0x5c3b2e._0xbaea7), 'particlesSize': 0.1, 'particlesWidth': 0.1, 'particlesHeight': 0.5, 'particlesDepth': 0.1, 'particlesNumbers': 0x14, 'pyramidColor': '#ff0000', 'pyramidWidth': 0.1, 'pyramidHeight': 0.25, 'rotateSpeed': 0x1 }, _0x51b443), this[_0x4efd49(0x22d)] = this['opts'][_0x4efd49(0x22d)] !== undefined ? this[_0x4efd49(0x267)]['pyramidHeight'] : 0.25, this['animationIndex'] = -0x1, this['rotateSpeed'] = this[_0x4efd49(0x267)][_0x4efd49(_0x5c3b2e._0x22977e)] !== undefined ? this[_0x4efd49(0x267)]['rotateSpeed'] : 0x1; const _0x2ef17b = new BaseTriangleWall({ 'color': this[_0x4efd49(_0x5c3b2e._0x253ec1)][_0x4efd49(_0x5c3b2e._0x14fb70)], 'size': this['opts'][_0x4efd49(0x310)], 'height': this[_0x4efd49(0x267)][_0x4efd49(0x3dc)] }); _0x2ef17b['position'][_0x4efd49(_0x5c3b2e._0x39b823)](0x0, this[_0x4efd49(0x22d)], 0x0), this[_0x4efd49(_0x5c3b2e._0x1d485d)](_0x2ef17b); const _0x26e707 = new BaseParticles({ 'color': this[_0x4efd49(_0x5c3b2e._0x1e83d5)][_0x4efd49(_0x5c3b2e._0x29d50c)], 'numbers': this['opts'][_0x4efd49(0x358)], 'width': this[_0x4efd49(_0x5c3b2e._0x5b7de0)][_0x4efd49(_0x5c3b2e._0x33e5b4)], 'height': this[_0x4efd49(_0x5c3b2e._0x5ee362)]['particlesHeight'], 'depth': this[_0x4efd49(_0x5c3b2e._0x1e83d5)]['particlesDepth'] }); this['add'](_0x26e707), _0x26e707[_0x4efd49(0x4c4)][_0x4efd49(0x49f)](0x0, this['pyramidHeight'], 0x0), _0x26e707[_0x4efd49(0x34e)](); const _0x3d07fc = new BaseTriangularPyramid({ 'width': this[_0x4efd49(_0x5c3b2e._0x253ec1)][_0x4efd49(_0x5c3b2e._0x57b626)], 'height': this[_0x4efd49(_0x5c3b2e._0x97ec9)], 'color': this['opts'][_0x4efd49(_0x5c3b2e._0x438da1)] }); _0x3d07fc['position']['set'](0x0, this['pyramidHeight'] / 0x2, 0x0), this[_0x4efd49(_0x5c3b2e._0x1d485d)](_0x3d07fc) } ['stopAnimation'] () { const _0x159c51 = { _0xa3a1cf: 0x389 }, _0x4bdaf5 = _0x48e965; cancelAnimationFrame(this[_0x4bdaf5(_0x159c51._0xa3a1cf)]), this['animationIndex'] = -0x1 } [_0x48e965(0x1d9)] () { const _0x2cec43 = _0x48e965; this[_0x2cec43(0x3b3)]() } ['rotateAnimation'] () { const _0x2fdd8e = { _0x12b3f4: 0x3b3, _0x5918f1: 0x3bf, _0x4b031f: 0x453 }, _0x302ab5 = _0x48e965; this['animationIndex'] = requestAnimationFrame(this[_0x302ab5(_0x2fdd8e._0x12b3f4)][_0x302ab5(0x2d7)](this)), this[_0x302ab5(_0x2fdd8e._0x5918f1)]['y'] += 0.01 * this[_0x302ab5(_0x2fdd8e._0x4b031f)] } } class BaseBubble extends Mesh { [_0x48e965(0x267)]; constructor(_0x5158fd) { const _0x4fc08d = { _0x15bddc: 0x303, _0x53a4bd: 0x303, _0x500ecf: 0x322, _0x3aa049: 0x2f4, _0x361d8e: 0x209, _0x443ec0: 0x47d }, _0x5c8ff5 = { _0x3d6216: 0x2f4, _0x454eb4: 0x234 }, _0x2431bd = _0x48e965; super(), this[_0x2431bd(0x267)] = Object['assign']({ 'color': _0x2431bd(0x218) }, _0x5158fd); const _0x2f4945 = new Float32Array([-0.5, -0.5, 0x0, 0x0, 0x0, 0.5, -0.5, 0x0, 0x1, 0x0, 0.5, 0.5, 0x0, 0x1, 0x1, -0.5, 0.5, 0x0, 0x0, 0x1]), _0x53ce94 = new InterleavedBuffer(_0x2f4945, 0x5); this[_0x2431bd(_0x4fc08d._0x15bddc)]['setIndex']([0x0, 0x1, 0x2, 0x0, 0x2, 0x3]), this[_0x2431bd(_0x4fc08d._0x53a4bd)][_0x2431bd(_0x4fc08d._0x500ecf)](_0x2431bd(0x4c4), new InterleavedBufferAttribute(_0x53ce94, 0x3, 0x0, ![])), this[_0x2431bd(_0x4fc08d._0x53a4bd)][_0x2431bd(0x322)]('uv', new InterleavedBufferAttribute(_0x53ce94, 0x2, 0x3, ![])), this[_0x2431bd(_0x4fc08d._0x3aa049)] = new ShaderMaterial({ 'transparent': !![], 'uniforms': { 'color': { 'value': new Color(this[_0x2431bd(0x267)][_0x2431bd(_0x4fc08d._0x361d8e)]) }, 'emissive': { 'value': new Color(_0x2431bd(_0x4fc08d._0x443ec0)) }, 'opacity': { 'value': 0x1 }, 'center': { 'value': new Vector2(0.5, 0.5) }, 'uTime': { 'value': 0x0 } }, 'vertexShader': _0x2431bd(0x3de), 'fragmentShader': _0x2431bd(0x366) }); let _0x1b2bd0 = 0x1; const _0x3e96b2 = () => { const _0x28ee4b = _0x2431bd; requestAnimationFrame(_0x3e96b2); if (this[_0x28ee4b(_0x5c8ff5._0x3d6216)][_0x28ee4b(0x234)][_0x28ee4b(0x4ea)][_0x28ee4b(0x27b)] > 0.08) _0x1b2bd0 = -0x1; else this[_0x28ee4b(_0x5c8ff5._0x3d6216)][_0x28ee4b(0x234)][_0x28ee4b(0x4ea)][_0x28ee4b(0x27b)] < 0x0 && (_0x1b2bd0 = 0x1); this[_0x28ee4b(0x2f4)][_0x28ee4b(_0x5c8ff5._0x454eb4)][_0x28ee4b(0x4ea)][_0x28ee4b(0x27b)] += 0.0025 * _0x1b2bd0 }; _0x3e96b2() } } class BaseCubicGuide extends Mesh { [_0x48e965(0x267)]; constructor(_0x49091e) { const _0x89c83b = { _0x103d5d: 0x303, _0x33ff9b: 0x267, _0x5c0c04: 0x267 }, _0x4ad4c2 = _0x48e965; super(), this['opts'] = Object['assign']({ 'width': 0.015, 'height': 0.5, 'depth': 0.015, 'color': '#ff0000', 'type': 0x0 }, _0x49091e), this[_0x4ad4c2(_0x89c83b._0x103d5d)] = new BoxGeometry(this[_0x4ad4c2(0x267)][_0x4ad4c2(0x15d)], this[_0x4ad4c2(_0x89c83b._0x33ff9b)][_0x4ad4c2(0x496)], this['opts']['depth']), this[_0x4ad4c2(0x2f4)] = new ShaderMaterial({ 'transparent': !![], 'depthWrite': !![], 'uniforms': { 'color': { 'value': new Color(this[_0x4ad4c2(0x267)]['color']) }, 'height': { 'value': this[_0x4ad4c2(_0x89c83b._0x5c0c04)][_0x4ad4c2(0x496)] }, 'type': { 'value': this['opts']['type'] } }, 'vertexShader': '\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<common>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20varying\x20float\x20vh;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(position,\x201.0);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vh\x20=\x20position.y;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20', 'fragmentShader': _0x4ad4c2(0x2bf) }) } } class BaseCylinder extends Mesh { [_0x48e965(0x267)]; constructor(_0x57f2f0) { const _0xc06699 = { _0x28f87f: 0x267, _0x443215: 0x2c9, _0x195961: 0x303, _0xe90cbf: 0x267, _0x41b9c9: 0x46f, _0x4857ec: 0x267, _0x2b7e30: 0x209, _0x2db033: 0x267 }, _0x4b90ab = _0x48e965; super(), this[_0x4b90ab(_0xc06699._0x28f87f)] = Object[_0x4b90ab(_0xc06699._0x443215)]({ 'color': _0x4b90ab(0x218), 'topRadius': 0.5, 'bottomRadius': 0.2, 'height': 0.5, 'openEnded': ![], 'opacity': 0.75 }, _0x57f2f0), this[_0x4b90ab(_0xc06699._0x195961)] = new CylinderGeometry(this[_0x4b90ab(_0xc06699._0xe90cbf)][_0x4b90ab(0x1e5)], this['opts'][_0x4b90ab(_0xc06699._0x41b9c9)], this[_0x4b90ab(_0xc06699._0x4857ec)][_0x4b90ab(0x496)], 0x20, 0x10, !![]), this[_0x4b90ab(0x2f4)] = new ShaderMaterial({ 'transparent': !![], 'depthTest': ![], 'side': 0x2, 'uniforms': { 'color': { 'value': new Color(this[_0x4b90ab(_0xc06699._0x28f87f)][_0x4b90ab(_0xc06699._0x2b7e30)]) }, 'opacity': { 'value': this[_0x4b90ab(_0xc06699._0x4857ec)][_0x4b90ab(0x236)] }, 'height': { 'value': this[_0x4b90ab(_0xc06699._0x2db033)][_0x4b90ab(0x496)] } }, 'vertexShader': '\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<common>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20varying\x20float\x20vh;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(position,\x201.0);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vh\x20=\x20position.y;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20', 'fragmentShader': _0x4b90ab(0x43a) }) } } class BaseCircularCone extends Mesh { ['opts'];[_0x48e965(0x389)];[_0x48e965(0x453)];[_0x48e965(0x173)]; constructor(_0x1cda69) { const _0x4dae8c = { _0x1a5d1b: 0x267, _0x340366: 0x2c9, _0xd0a689: 0x267 }, _0x1abacf = _0x48e965; super(), this[_0x1abacf(_0x4dae8c._0x1a5d1b)] = Object[_0x1abacf(_0x4dae8c._0x340366)]({ 'color': _0x1abacf(0x218), 'width': 0x1, 'height': 0x1, 'rotateSpeed': 0x1, 'hasWireframe': !![] }, _0x1cda69), this[_0x1abacf(0x389)] = -0x1, this[_0x1abacf(0x453)] = this['opts']['rotateSpeed'] !== undefined ? this[_0x1abacf(0x267)]['rotateSpeed'] : 0x1, this['hasWireframe'] = this[_0x1abacf(0x267)][_0x1abacf(0x173)] !== undefined ? this[_0x1abacf(_0x4dae8c._0x1a5d1b)]['hasWireframe'] : !![], this[_0x1abacf(0x303)] = new ConeGeometry(this[_0x1abacf(_0x4dae8c._0xd0a689)][_0x1abacf(0x15d)], this['opts']['height'], 0x20), this[_0x1abacf(0x303)][_0x1abacf(0x247)](Math['PI']), this['material'] = new MeshStandardMaterial({ 'color': this[_0x1abacf(0x267)][_0x1abacf(0x209)], 'transparent': !![] }) } } class BaseSphere extends Mesh { ['opts']; constructor(_0x45ed21) { const _0x1507a0 = { _0x597cbc: 0x218, _0x392ec5: 0x3da, _0x58367e: 0x2f4, _0x18083f: 0x209, _0xbc3526: 0x267, _0x7670dc: 0x236, _0x87c422: 0x267, _0xb5f548: 0x3da, _0x246231: 0x329 }, _0x575ab7 = _0x48e965; super(), this['opts'] = Object[_0x575ab7(0x2c9)]({ 'color': _0x575ab7(_0x1507a0._0x597cbc), 'radius': 0.05, 'opacity': 0x1 }, _0x45ed21), this[_0x575ab7(0x303)] = new SphereGeometry(this['opts'][_0x575ab7(_0x1507a0._0x392ec5)], 0x20, 0x10), this[_0x575ab7(_0x1507a0._0x58367e)] = new ShaderMaterial({ 'transparent': !![], 'uniforms': { 'color': { 'value': new Color(this[_0x575ab7(0x267)][_0x575ab7(_0x1507a0._0x18083f)]) }, 'opacity': { 'value': this[_0x575ab7(_0x1507a0._0xbc3526)][_0x575ab7(_0x1507a0._0x7670dc)] }, 'radius': { 'value': this[_0x575ab7(_0x1507a0._0x87c422)][_0x575ab7(_0x1507a0._0xb5f548)] } }, 'vertexShader': _0x575ab7(0x420), 'fragmentShader': _0x575ab7(_0x1507a0._0x246231) }) } } class BaseThermometer extends Group$1 { ['opts'];['sphereRadius']; constructor(_0x3f5d6b) { const _0xd8dbeb = { _0x81ffab: 0x4c4, _0x471f3b: 0x2de, _0xa20b46: 0x2de, _0x4384a1: 0x44d, _0x4bbbcb: 0x267, _0x27c281: 0x209, _0x50e62f: 0x49f }, _0x1038e2 = _0x48e965; super(), this['opts'] = Object['assign']({ 'color': _0x1038e2(0x218), 'sphereRadius': 0.05 }, _0x3f5d6b), this[_0x1038e2(0x2de)] = this[_0x1038e2(0x267)]['sphereRadius'] !== undefined ? this['opts']['sphereRadius'] : 0.05; const _0x59be6b = new BaseCubicGuide({ 'color': this[_0x1038e2(0x267)][_0x1038e2(0x209)], 'type': 0x1 }); _0x59be6b[_0x1038e2(_0xd8dbeb._0x81ffab)]['set'](0x0, 0.5 / 0x2 + 0x2 * this[_0x1038e2(_0xd8dbeb._0x471f3b)] - this[_0x1038e2(_0xd8dbeb._0xa20b46)] / 0x2, 0x0), this[_0x1038e2(_0xd8dbeb._0x4384a1)](_0x59be6b); const _0x2c4b77 = new BaseSphere({ 'radius': this[_0x1038e2(_0xd8dbeb._0x4bbbcb)][_0x1038e2(_0xd8dbeb._0x471f3b)], 'color': this['opts'][_0x1038e2(_0xd8dbeb._0x27c281)] }); _0x2c4b77[_0x1038e2(0x4c4)][_0x1038e2(_0xd8dbeb._0x50e62f)](0x0, this[_0x1038e2(_0xd8dbeb._0xa20b46)] / 0x2, 0x0), this[_0x1038e2(0x44d)](_0x2c4b77) } } class CompositeIconTag extends CompositeIcon { [_0x48e965(0x267)];[_0x48e965(0x331)]; constructor(_0x2d11ab) { const _0x2d1243 = { _0x228bd0: 0x267, _0x53b678: 0x209, _0x1d53a3: 0x49f, _0x11f1a9: 0x4c4, _0x14ddb0: 0x44d, _0x27769f: 0x267, _0x2c90bd: 0x209, _0x3cae0c: 0x3af, _0x3f000b: 0x267, _0x4ffbe5: 0x44d, _0x4dfcf9: 0x267, _0x1f5cce: 0x209, _0x40019b: 0x212, _0x3562df: 0x267, _0x31932b: 0x44d, _0x4160f8: 0x267, _0x52f127: 0x4a6, _0x5686af: 0x4a6, _0x16055f: 0x267, _0x314102: 0x44d, _0xe1d524: 0x209, _0x578fc5: 0x44d, _0x579148: 0x44d, _0x40ad39: 0x2d0, _0xdfabf3: 0x209, _0x4bd8c8: 0x44d, _0x298265: 0x44d, _0x1356b0: 0x1f0, _0x513eab: 0x267, _0x414e7f: 0x267, _0x3dc5ac: 0x3ef, _0x4d5fdd: 0x267, _0x51f942: 0x44d, _0x20be42: 0x267, _0x2f8222: 0x1d9, _0x543171: 0x44d, _0x3b47bc: 0x1d9, _0x1c6f19: 0x3af, _0x42f779: 0x267, _0x2bd452: 0x267, _0x18859d: 0x267, _0xe1f609: 0x209, _0x7ebe1: 0x49f, _0x1c4739: 0x267, _0xc63810: 0x44d, _0x9957f5: 0x267, _0x4d9d80: 0x49f, _0x2f542c: 0x267, _0x339f48: 0x49f, _0x3d6bfd: 0x267, _0x36644f: 0x235, _0x55e3c0: 0x390, _0x1f8282: 0x267, _0x2813ae: 0x44d, _0x5dd599: 0x209, _0x1bf168: 0x44d, _0xf2b39f: 0x28a, _0x4b3158: 0x44d, _0x5b605b: 0x49f, _0x5ff8d: 0x1d9, _0x4a92df: 0x209, _0x2611e2: 0x44d, _0x52d447: 0x4a6, _0x8df4de: 0x209, _0x5363f3: 0x44d, _0x1a06e1: 0x209, _0x5044ff: 0x34e, _0x4a9300: 0x267, _0x16eadc: 0x1f0, _0x3cf141: 0x2f4, _0x49ca9e: 0x234, _0x1102e3: 0x27b, _0x3ef9fb: 0x44d, _0x4745c2: 0x4c4, _0x313149: 0x44d, _0x23aaa6: 0x47d, _0x36df12: 0x199, _0x35b19c: 0x2f3 }, _0x14d75e = _0x48e965; super(), this[_0x14d75e(0x267)] = Object['assign']({ 'color': _0x14d75e(0x218), 'opacity': 0x1, 'titleHeight': 0x0, 'titleSize': 0x1, 'title': '', 'type': 0x0, 'fontColor': '#ffffff', 'particleNumber': 0x32, 'particleSize': 0.1 }, _0x2d11ab); if (this[_0x14d75e(_0x2d1243._0x228bd0)]['type'] == 0x0) { const _0x288529 = new BaseDiamond({ 'color': this[_0x14d75e(0x267)][_0x14d75e(_0x2d1243._0x53b678)], 'opacity': this[_0x14d75e(0x267)][_0x14d75e(0x236)] }); _0x288529['scale'][_0x14d75e(_0x2d1243._0x1d53a3)](0.15, 0.15, 0.15), _0x288529[_0x14d75e(_0x2d1243._0x11f1a9)]['set'](0x0, 0.1, 0x0), this[_0x14d75e(_0x2d1243._0x14ddb0)](_0x288529); const _0x1e7415 = new BaseSpreadCircle({ 'color': this[_0x14d75e(_0x2d1243._0x27769f)][_0x14d75e(0x209)] }); this[_0x14d75e(0x44d)](_0x1e7415), _0x1e7415['start'](); const _0x4009be = new BaseSquares({ 'color': this[_0x14d75e(0x267)][_0x14d75e(0x209)] }); this['add'](_0x4009be) } else { if (this[_0x14d75e(0x267)][_0x14d75e(0x1f0)] == 0x1) { const _0x9d62de = new BaseStaff({ 'color': this[_0x14d75e(0x267)][_0x14d75e(0x209)], 'opacity': 0.8 }); this['add'](_0x9d62de); const _0x37ae82 = new BaseCircularArraySquares({ 'circleRadius': 0.5, 'squareRadius': 0.05, 'numbers': 0x18, 'color': this[_0x14d75e(_0x2d1243._0x228bd0)][_0x14d75e(_0x2d1243._0x2c90bd)] }); this[_0x14d75e(_0x2d1243._0x14ddb0)](_0x37ae82), _0x37ae82[_0x14d75e(_0x2d1243._0x3cae0c)](); const _0x7fb79e = new BaseCircularArraySquares({ 'circleRadius': 0.3, 'squareRadius': 0.03, 'numbers': 0x12, 'color': this[_0x14d75e(_0x2d1243._0x3f000b)][_0x14d75e(_0x2d1243._0x53b678)] }); this[_0x14d75e(_0x2d1243._0x4ffbe5)](_0x7fb79e), _0x7fb79e['startHorseRaceLampAnimation'](); const _0x4abf77 = new BaseCircle({ 'type': 0x3, 'color': this[_0x14d75e(0x267)][_0x14d75e(0x209)] }); this[_0x14d75e(_0x2d1243._0x14ddb0)](_0x4abf77) } else { if (this[_0x14d75e(0x267)][_0x14d75e(0x1f0)] == 0x2) { const _0x15db34 = new BaseCircle({ 'color': this[_0x14d75e(_0x2d1243._0x4dfcf9)][_0x14d75e(0x209)], 'type': 0x4 }); this['add'](_0x15db34); const _0x361783 = new BaseCircularArraySquares({ 'circleRadius': 0.3, 'squareRadius': 0.03, 'numbers': 0x14, 'color': this[_0x14d75e(_0x2d1243._0x228bd0)][_0x14d75e(_0x2d1243._0x1f5cce)] }); this[_0x14d75e(0x44d)](_0x361783), _0x361783[_0x14d75e(0x3af)](); const _0x34aec2 = new BaseCircle({ 'color': this[_0x14d75e(_0x2d1243._0x4dfcf9)][_0x14d75e(0x209)], 'type': 0x5, 'radius': 0.35 }); this[_0x14d75e(0x44d)](_0x34aec2), _0x34aec2[_0x14d75e(_0x2d1243._0x11f1a9)][_0x14d75e(_0x2d1243._0x1d53a3)](0x0, 0.05, 0x0); const _0xc62118 = new BaseCircularArrayArrows({ 'circleRadius': 0.175, 'color': this[_0x14d75e(_0x2d1243._0x228bd0)]['color'], 'numbers': 0x4, 'triangleSize': 0.065, 'speed': 0x1, 'indicateRadius': 1.5 }); this[_0x14d75e(0x44d)](_0xc62118), _0xc62118['position']['set'](0x0, 0.05, 0x0), _0xc62118[_0x14d75e(_0x2d1243._0x40019b)](); const _0x3ba602 = new BaseShapeVic({ 'color': this[_0x14d75e(_0x2d1243._0x3562df)]['color'] }); _0x3ba602['scale'][_0x14d75e(0x49f)](0.5, 0.5, 0.5), _0x3ba602[_0x14d75e(0x4c4)]['set'](0x0, 0.1, 0x0), this[_0x14d75e(_0x2d1243._0x31932b)](_0x3ba602) } else { if (this[_0x14d75e(_0x2d1243._0x228bd0)]['type'] == 0x3) { const _0x557601 = new BaseCircle({ 'color': this[_0x14d75e(_0x2d1243._0x4160f8)]['color'], 'type': 0x6, 'radius': 0x1, 'spreadEndRadius': 0.3, 'spreadSpeed': 0x2 }); this[_0x14d75e(_0x2d1243._0x4ffbe5)](_0x557601), _0x557601[_0x14d75e(_0x2d1243._0x52f127)](); const _0x2739f3 = new BaseCircle({ 'color': this[_0x14d75e(_0x2d1243._0x27769f)][_0x14d75e(0x209)], 'type': 0x6, 'radius': 0x1, 'spreadStartRadius': 0.15, 'spreadEndRadius': 0.3, 'spreadSpeed': 0x2 }); this[_0x14d75e(0x44d)](_0x2739f3), _0x2739f3[_0x14d75e(_0x2d1243._0x5686af)](); const _0xf792e0 = new BaseCircle({ 'color': this[_0x14d75e(_0x2d1243._0x16055f)][_0x14d75e(0x209)], 'type': 0x7, 'radius': 0x1 }); this[_0x14d75e(_0x2d1243._0x314102)](_0xf792e0); const _0x5b0098 = new BaseCubes({ 'color': this[_0x14d75e(0x267)][_0x14d75e(_0x2d1243._0xe1d524)], 'sizeRange': [0.05, 0.02, 0.05], 'positionRange': [0.2, 0.2, 0.2], 'numbers': 0xc }); this[_0x14d75e(_0x2d1243._0x578fc5)](_0x5b0098), _0x5b0098[_0x14d75e(0x4c4)]['set'](0x0, 0.1, 0x0) } else { if (this[_0x14d75e(_0x2d1243._0x4160f8)][_0x14d75e(0x1f0)] == 0x4) { const _0x4863af = new BaseCircle({ 'color': this[_0x14d75e(0x267)][_0x14d75e(0x209)], 'type': 0x6, 'radius': 0x1, 'spreadStartRadius': 0.15, 'spreadEndRadius': 0.2, 'spreadSpeed': 0x2 }); this[_0x14d75e(_0x2d1243._0x579148)](_0x4863af), _0x4863af[_0x14d75e(_0x2d1243._0x52f127)](); const _0x314f12 = new BaseCircle({ 'color': this[_0x14d75e(_0x2d1243._0x3562df)]['color'], 'type': 0x8, 'radius': 0.6 }); _0x314f12[_0x14d75e(_0x2d1243._0x40ad39)](), this['add'](_0x314f12); const _0x4a19b4 = new BaseCircle({ 'color': this[_0x14d75e(0x267)][_0x14d75e(_0x2d1243._0xdfabf3)], 'type': 0x8, 'radius': 0x1, 'clockwise': 0x1 }); _0x4a19b4['startRotateAnimation8'](), this[_0x14d75e(_0x2d1243._0x4bd8c8)](_0x4a19b4); const _0x4eb414 = new BaseOctahedron({ 'color': this[_0x14d75e(_0x2d1243._0x3562df)][_0x14d75e(_0x2d1243._0x53b678)], 'radius': 0.1 }); _0x4eb414[_0x14d75e(0x4c4)][_0x14d75e(0x49f)](0x0, 0.1 + 0.1, 0x0), this[_0x14d75e(_0x2d1243._0x298265)](_0x4eb414) } else { if (this[_0x14d75e(_0x2d1243._0x4dfcf9)][_0x14d75e(_0x2d1243._0x1356b0)] == 0x5) { const _0x4e543c = new BaseCircularArraySquares({ 'circleRadius': 0.5, 'squareRadius': 0.05, 'numbers': 0x18, 'color': this[_0x14d75e(_0x2d1243._0x513eab)]['color'], 'rotateSpeed': 0x2 }); _0x4e543c[_0x14d75e(0x2fa)](), this[_0x14d75e(_0x2d1243._0x298265)](_0x4e543c); const _0x47d8aa = new BaseCubes({ 'positionRange': [0.2, 0x0, 0.2], 'sizeRange': [0.025, 0.135, 0.025], 'color': this[_0x14d75e(_0x2d1243._0x414e7f)]['color'], 'numbers': 0xc, 'opacity': 0.5 }); this['add'](_0x47d8aa); const _0x5a3b44 = new BaseCircle({ 'color': this[_0x14d75e(_0x2d1243._0x513eab)][_0x14d75e(0x209)], 'radius': 0x1, 'type': 0x9, 'spreadStartHeight': 0.35, 'spreadSpeed': 0x2, 'ringWidth': 0.02 }); _0x5a3b44[_0x14d75e(_0x2d1243._0x3dc5ac)](), this[_0x14d75e(0x44d)](_0x5a3b44) } else { if (this[_0x14d75e(0x267)][_0x14d75e(0x1f0)] == 0x6) { const _0x4f82d4 = new BaseCircularArraySquares({ 'circleRadius': 0.5, 'squareRadius': 0.05, 'numbers': 0x18, 'color': this[_0x14d75e(_0x2d1243._0x4d5fdd)]['color'] }); this['add'](_0x4f82d4), _0x4f82d4[_0x14d75e(_0x2d1243._0x3cae0c)](); const _0x4234ef = new BaseCircle({ 'color': this[_0x14d75e(_0x2d1243._0x4dfcf9)]['color'], 'type': 0xa, 'radius': 0.85 }); this[_0x14d75e(_0x2d1243._0x51f942)](_0x4234ef); const _0x169e62 = new BaseTriangle({ 'color': this['opts']['color'], 'size': 0.1, 'type': 0x1, 'rotateSpeed': 0x2 }); this['add'](_0x169e62), _0x169e62[_0x14d75e(0x1d9)](); const _0x244094 = new BaseTriangularPyramid({ 'width': 0.1, 'height': 0.2, 'color': this[_0x14d75e(_0x2d1243._0x20be42)][_0x14d75e(0x209)], 'rotateSpeed': 0x2 }); _0x244094[_0x14d75e(_0x2d1243._0x11f1a9)][_0x14d75e(_0x2d1243._0x1d53a3)](0x0, 0.2 / 0x2 + 0.05, 0x0), this['add'](_0x244094), _0x244094[_0x14d75e(0x1d9)]() } else { if (this['opts'][_0x14d75e(_0x2d1243._0x1356b0)] == 0x7) { const _0x360208 = new BaseCircle({ 'type': 0x1, 'color': this['opts'][_0x14d75e(0x209)], 'clockwise': 0x1 }); this['add'](_0x360208), _0x360208[_0x14d75e(_0x2d1243._0x2f8222)](); const _0x5c776e = new BaseCircle({ 'type': 0x1, 'color': this[_0x14d75e(_0x2d1243._0x4160f8)][_0x14d75e(_0x2d1243._0x1f5cce)], 'radius': 0.3 }); this[_0x14d75e(_0x2d1243._0x543171)](_0x5c776e), _0x5c776e[_0x14d75e(_0x2d1243._0x3b47bc)](); const _0x2c39a8 = new BaseRectangularPyramid({ 'width': 0.1, 'height': 0.2, 'color': this[_0x14d75e(_0x2d1243._0x20be42)][_0x14d75e(0x209)], 'rotateSpeed': 0x2 }); _0x2c39a8[_0x14d75e(_0x2d1243._0x11f1a9)]['set'](0x0, 0.2 / 0x2 + 0.05, 0x0), this['add'](_0x2c39a8), _0x2c39a8['startRotateAnimation']() } else { if (this[_0x14d75e(_0x2d1243._0x16055f)]['type'] == 0x8) { const _0x2a3075 = new BaseCircularArraySquares({ 'circleRadius': 0.15, 'squareRadius': 0.02, 'numbers': 0x18, 'color': this['opts'][_0x14d75e(0x209)] }); this[_0x14d75e(0x44d)](_0x2a3075), _0x2a3075[_0x14d75e(_0x2d1243._0x1c6f19)](); const _0x32d603 = new BaseTriangleWallParticles({ 'wallColor': this[_0x14d75e(_0x2d1243._0x42f779)][_0x14d75e(_0x2d1243._0xdfabf3)], 'wallSize': 0.25, 'wallHeight': 0.5, 'particlesColor': this[_0x14d75e(_0x2d1243._0x2bd452)][_0x14d75e(_0x2d1243._0x1f5cce)], 'pyramidColor': this[_0x14d75e(0x267)]['color'], 'pyramidHeight': 0.2, 'pyramidWidth': 0.15, 'rotateSpeed': -1.5 }); _0x32d603[_0x14d75e(_0x2d1243._0x3b47bc)](), this[_0x14d75e(0x44d)](_0x32d603) } else { if (this[_0x14d75e(_0x2d1243._0x228bd0)][_0x14d75e(0x1f0)] == 0x9) { const _0x3bdc69 = new BaseCircle({ 'type': 0x1, 'color': this[_0x14d75e(_0x2d1243._0x42f779)][_0x14d75e(0x209)], 'ringWidth': 0.025 }); this[_0x14d75e(_0x2d1243._0x314102)](_0x3bdc69), _0x3bdc69['startRotateAnimation'](); const _0x366fb6 = new BaseCircle({ 'type': 0x1, 'color': this[_0x14d75e(_0x2d1243._0x18859d)][_0x14d75e(0x209)], 'radius': 0.3, 'ringWidth': 0.025 }); this['add'](_0x366fb6), _0x366fb6[_0x14d75e(_0x2d1243._0x3b47bc)](); const _0x12fc18 = new BaseCubicGuide({ 'color': this[_0x14d75e(0x267)][_0x14d75e(_0x2d1243._0xe1f609)] }); this['add'](_0x12fc18), _0x12fc18['position'][_0x14d75e(_0x2d1243._0x7ebe1)](0x0, 0.25, 0x0); const _0x553e61 = new BaseBubble({ 'color': this[_0x14d75e(_0x2d1243._0x1c4739)][_0x14d75e(_0x2d1243._0xe1f609)] }); this[_0x14d75e(0x44d)](_0x553e61), _0x553e61[_0x14d75e(0x2be)][_0x14d75e(0x49f)](0.15, 0.15, 0x1), _0x553e61[_0x14d75e(_0x2d1243._0x11f1a9)]['set'](0x0, 0.5 + 0.075, 0x0) } else { if (this[_0x14d75e(_0x2d1243._0x3562df)][_0x14d75e(_0x2d1243._0x1356b0)] == 0xa) { const _0x59247b = new BaseCircularArraySquares({ 'circleRadius': 0.18, 'squareRadius': 0.02, 'numbers': 0x10, 'color': this['opts'][_0x14d75e(0x209)] }); this['add'](_0x59247b), _0x59247b['startHorseRaceLampAnimation'](); const _0x18071a = new BaseCircle({ 'color': this['opts'][_0x14d75e(0x209)], 'type': 0x6, 'radius': 0x1, 'spreadReset': ![], 'spreadStartRadius': 0.2, 'spreadEndRadius': 0.4, 'spreadSpeed': 0x2 }); this[_0x14d75e(_0x2d1243._0xc63810)](_0x18071a), _0x18071a['startSpreadAnimation'](); const _0x125bd8 = new BaseCylinder({ 'height': 0.55, 'color': this[_0x14d75e(_0x2d1243._0x9957f5)]['color'], 'topRadius': 0.35, 'bottomRadius': 0.2 }); this[_0x14d75e(_0x2d1243._0xc63810)](_0x125bd8), _0x125bd8[_0x14d75e(0x4c4)][_0x14d75e(_0x2d1243._0x4d9d80)](0x0, 0.55 / 0x2, 0x0); const _0xb4310e = new BaseCylinder({ 'height': 0.35, 'color': this[_0x14d75e(_0x2d1243._0x2f542c)][_0x14d75e(0x209)], 'topRadius': 0.5, 'bottomRadius': 0.2 }); this['add'](_0xb4310e), _0xb4310e['position'][_0x14d75e(_0x2d1243._0x339f48)](0x0, 0.35 / 0x2, 0x0); const _0xaa637b = new BaseParticles({ 'color': this['opts'][_0x14d75e(0x209)], 'numbers': this[_0x14d75e(_0x2d1243._0x3d6bfd)][_0x14d75e(_0x2d1243._0x36644f)], 'size': this['opts'][_0x14d75e(0x153)] }); this[_0x14d75e(0x44d)](_0xaa637b), _0xaa637b[_0x14d75e(_0x2d1243._0x55e3c0)]() } else { if (this[_0x14d75e(_0x2d1243._0x1f8282)]['type'] == 0xb) { const _0x1ecf1e = new BaseCircle({ 'color': this[_0x14d75e(0x267)][_0x14d75e(_0x2d1243._0xe1f609)], 'type': 0xb, 'spreadStartRadius': 0.1, 'spreadSpeed': 0x2, 'ringWidth': 0.005 }); this[_0x14d75e(0x44d)](_0x1ecf1e), _0x1ecf1e[_0x14d75e(0x4a6)](); const _0x31e91e = new BaseCircle({ 'color': this[_0x14d75e(_0x2d1243._0x9957f5)][_0x14d75e(0x209)], 'type': 0xb, 'spreadStartRadius': 0.3, 'spreadSpeed': 0x2, 'ringWidth': 0.005 }); this[_0x14d75e(_0x2d1243._0x2813ae)](_0x31e91e), _0x31e91e['startSpreadAnimation'](); const _0x1d8efb = new BaseCircle({ 'color': this[_0x14d75e(0x267)][_0x14d75e(_0x2d1243._0xe1d524)], 'type': 0xc, 'spreadStartRadius': 0x0, 'spreadEndRadius': 0.15, 'spreadStartHeight': 0x0, 'spreadEndHeight': 0.3, 'spreadSpeed': 0x1, 'ringWidth': 0.005 }); this['add'](_0x1d8efb), _0x1d8efb[_0x14d75e(0x28a)](); const _0xe86557 = new BaseCircle({ 'color': this[_0x14d75e(_0x2d1243._0x9957f5)][_0x14d75e(_0x2d1243._0x5dd599)], 'type': 0xc, 'spreadStartRadius': 0.05, 'spreadEndRadius': 0.15, 'spreadStartHeight': 0.1, 'spreadEndHeight': 0.3, 'spreadSpeed': 0x1, 'ringWidth': 0.005 }); this[_0x14d75e(_0x2d1243._0x1bf168)](_0xe86557), _0xe86557[_0x14d75e(_0x2d1243._0xf2b39f)](); const _0x38f51f = new BaseCircle({ 'color': this[_0x14d75e(_0x2d1243._0x1c4739)]['color'], 'type': 0xc, 'spreadStartRadius': 0.1, 'spreadEndRadius': 0.15, 'spreadStartHeight': 0.2, 'spreadEndHeight': 0.3, 'spreadSpeed': 0x1, 'ringWidth': 0.005 }); this[_0x14d75e(_0x2d1243._0x4b3158)](_0x38f51f), _0x38f51f[_0x14d75e(_0x2d1243._0xf2b39f)](); const _0x2ed718 = new BaseTriangularPyramid({ 'width': 0.12, 'height': 0.24, 'hasWireframe': ![] }); _0x2ed718[_0x14d75e(0x2f4)]['wireframe'] = !![], _0x2ed718[_0x14d75e(0x2f4)]['emissive'][_0x14d75e(_0x2d1243._0x5b605b)](_0x14d75e(0x47d)), _0x2ed718[_0x14d75e(_0x2d1243._0x5ff8d)](), _0x2ed718['position']['set'](0x0, 0.24 / 0x2 + 0.15, 0x0), this['add'](_0x2ed718); const _0x53ff55 = new BaseCircularCone({ 'color': this[_0x14d75e(0x267)][_0x14d75e(_0x2d1243._0x4a92df)], 'width': 0.05, 'height': 0.15 }); _0x53ff55[_0x14d75e(0x4c4)]['set'](0x0, 0.15 / 0x2 + 0.15 + (0.24 - 0.15) / 0x2, 0x0), this[_0x14d75e(_0x2d1243._0x2611e2)](_0x53ff55) } else { if (this[_0x14d75e(_0x2d1243._0x4160f8)][_0x14d75e(0x1f0)] == 0xc) { const _0x69e403 = new BaseCircle({ 'color': this[_0x14d75e(_0x2d1243._0x16055f)][_0x14d75e(_0x2d1243._0x1f5cce)], 'type': 0x6, 'radius': 1.5, 'spreadReset': ![], 'spreadStartRadius': 0.15, 'spreadEndRadius': 0.4, 'spreadSpeed': 0x2 }); this['add'](_0x69e403), _0x69e403[_0x14d75e(_0x2d1243._0x52d447)](); const _0xaf652e = new BaseCircularArraySquares({ 'circleRadius': 0.18, 'squareRadius': 0.02, 'numbers': 0x10, 'color': this[_0x14d75e(0x267)][_0x14d75e(_0x2d1243._0x8df4de)] }); this[_0x14d75e(0x44d)](_0xaf652e), _0xaf652e[_0x14d75e(0x3af)](); const _0x24704a = new BaseThermometer({ 'color': this['opts'][_0x14d75e(0x209)] }); this[_0x14d75e(_0x2d1243._0x5363f3)](_0x24704a); const _0x4f1fa8 = new BaseCubes({ 'color': this[_0x14d75e(0x267)][_0x14d75e(_0x2d1243._0x1a06e1)], 'sizeRange': [0.01, 0.01, 0.01], 'positionRange': [0.2, 0.2, 0.2], 'hasWireframe': ![], 'risingMaxHeight': 0.5 }); this[_0x14d75e(0x44d)](_0x4f1fa8), _0x4f1fa8[_0x14d75e(_0x2d1243._0x5044ff)]() } else { if (this[_0x14d75e(_0x2d1243._0x4a9300)][_0x14d75e(_0x2d1243._0x16eadc)] == 0xd) { const _0x576afd = new BaseCircle({ 'color': this[_0x14d75e(0x267)][_0x14d75e(0x209)], 'type': 0x6, 'radius': 0x1, 'ringWidth': 0.075 }); _0x576afd[_0x14d75e(_0x2d1243._0x3cf141)][_0x14d75e(_0x2d1243._0x49ca9e)][_0x14d75e(0x4ea)][_0x14d75e(_0x2d1243._0x1102e3)] = 0.28, this[_0x14d75e(_0x2d1243._0x3ef9fb)](_0x576afd); const _0x5a3852 = new BaseCircle({ 'color': this[_0x14d75e(0x267)][_0x14d75e(0x209)], 'type': 0x1, 'ringWidth': 0.025 }); this[_0x14d75e(0x44d)](_0x5a3852), _0x5a3852['startRotateAnimation'](); const _0x4360fb = new BaseCylinder({ 'color': this[_0x14d75e(_0x2d1243._0x2bd452)][_0x14d75e(0x209)], 'topRadius': 0.25, 'bottomRadius': 0.25, 'height': 0.5 }); _0x4360fb[_0x14d75e(_0x2d1243._0x4745c2)]['set'](0x0, 0.5 / 0x2, 0x0), this[_0x14d75e(_0x2d1243._0x313149)](_0x4360fb); const _0x347016 = new BaseCylinder({ 'color': this[_0x14d75e(0x267)]['color'], 'topRadius': 0.4, 'bottomRadius': 0.32, 'height': 0.3 }); _0x347016[_0x14d75e(0x4c4)][_0x14d75e(0x49f)](0x0, 0.3 / 0x2, 0x0), this[_0x14d75e(_0x2d1243._0x5363f3)](_0x347016); const _0x210ecb = new BaseCircle({ 'color': _0x14d75e(_0x2d1243._0x23aaa6), 'type': 0x9, 'spreadStartHeight': 0.4, 'spreadEndHeight': 0.5, 'spreadStartRadius': 0.075, 'ringWidth': 0.01 }); _0x210ecb['startRisingAnimationBounce'](), this[_0x14d75e(_0x2d1243._0x3ef9fb)](_0x210ecb); const _0x4312ea = new BaseCircle({ 'color': _0x14d75e(_0x2d1243._0x23aaa6), 'type': 0xd, 'ringWidth': 0.015 }); _0x4312ea['position']['set'](0x0, 0.5, 0x0), this[_0x14d75e(0x44d)](_0x4312ea), _0x4312ea[_0x14d75e(_0x2d1243._0x36df12)]() } } } } } } } } } } } } } } this[_0x14d75e(0x331)] = new BaseTag({ 'text': this[_0x14d75e(_0x2d1243._0x4a9300)]['title'], 'opacity': this[_0x14d75e(_0x2d1243._0x42f779)]['opacity'], 'height': this[_0x14d75e(0x267)][_0x14d75e(0x3b9)], 'size': this[_0x14d75e(0x267)]['titleSize'], 'fontColor': this[_0x14d75e(0x267)][_0x14d75e(_0x2d1243._0x35b19c)] }), this[_0x14d75e(_0x2d1243._0x51f942)](this['baseTag']) } [_0x48e965(0x3fb)] (_0x4e1004) { } } const drawTextWithImg = [drawTextCanvasWithImg], updateTextWithImg = [updateTextCanvasWithImg]; class BaseImageTitle extends Sprite { [_0x48e965(0x2ee)];[_0x48e965(0x4e8)];[_0x48e965(0x50a)];['opts'];[_0x48e965(0x3e8)];[_0x48e965(0x236)];[_0x48e965(0x3cf)];[_0x48e965(0x4bf)];['fontColor3'];[_0x48e965(0x279)];['fontSize1'];[_0x48e965(0x2d3)];['fontSize3'];[_0x48e965(0x496)];[_0x48e965(0x23e)];[_0x48e965(0x38c)];[_0x48e965(0x1ed)];[_0x48e965(0x23a)];[_0x48e965(0x1fd)];['anchor'];[_0x48e965(0x1db)]; constructor(_0x2be22f) { const _0x18d1c2 = { _0x45bbdf: 0x459, _0x1b83e1: 0x236, _0x3fd756: 0x47d, _0x121dc2: 0x4bf, _0x2a7acc: 0x4db, _0xf3581d: 0x218, _0xabe11d: 0x4e4, _0x1b1e86: 0x50a, _0x30d90b: 0x1f7, _0x24ce26: 0x1ad, _0x3f055d: 0x1ad, _0x3054fa: 0x496, _0x26329d: 0x496, _0x24fe5a: 0x1f0, _0x31d3de: 0x38c, _0x2de447: 0x394, _0x16c990: 0x394, _0x436fe8: 0x410, _0x139280: 0x267, _0x30574b: 0x2c9, _0x2462f7: 0x3cf, _0x3fe4db: 0x279, _0x5dda34: 0x1ad, _0x47198d: 0x1a4, _0x59eaa6: 0x496, _0xb17ed5: 0x410, _0x377707: 0x2ee, _0x532457: 0x4e8, _0x332bf5: 0x50a, _0x8710ec: 0x2d3, _0x21b5f9: 0x1a4, _0x3dd0fc: 0x38c, _0x79c43a: 0x530, _0x4ef69f: 0x49f, _0x5602c2: 0x49f, _0x138362: 0x2be, _0x1e277c: 0x530 }, _0x2666dd = _0x48e965; super(), this[_0x2666dd(0x3e8)] = new Color(_0x2be22f?.['bgColor'] !== undefined ? _0x2be22f?.[_0x2666dd(_0x18d1c2._0x45bbdf)] : _0x2666dd(0x218)), this[_0x2666dd(0x236)] = _0x2be22f?.[_0x2666dd(_0x18d1c2._0x1b83e1)] !== undefined ? _0x2be22f[_0x2666dd(0x236)] : 0x1, this['fontColor1'] = _0x2be22f?.[_0x2666dd(0x3cf)] !== undefined ? _0x2be22f?.[_0x2666dd(0x3cf)] : _0x2666dd(_0x18d1c2._0x3fd756), this[_0x2666dd(_0x18d1c2._0x121dc2)] = _0x2be22f?.[_0x2666dd(0x4bf)] !== undefined ? _0x2be22f?.[_0x2666dd(0x4bf)] : _0x2666dd(0x47d), this[_0x2666dd(0x4db)] = _0x2be22f?.[_0x2666dd(_0x18d1c2._0x2a7acc)] !== undefined ? _0x2be22f?.['fontColor3'] : _0x2666dd(0x47d), this[_0x2666dd(0x279)] = _0x2be22f?.[_0x2666dd(0x279)] !== undefined ? _0x2be22f?.['strokeColor'] : _0x2666dd(_0x18d1c2._0xf3581d), this[_0x2666dd(0x2ee)] = _0x2be22f?.[_0x2666dd(0x2ee)] !== undefined ? _0x2be22f?.[_0x2666dd(0x2ee)] : '', this[_0x2666dd(0x4e8)] = _0x2be22f?.[_0x2666dd(0x4e8)] !== undefined ? _0x2be22f?.['title2'] : _0x2666dd(_0x18d1c2._0xabe11d), this['title3'] = _0x2be22f?.[_0x2666dd(_0x18d1c2._0x1b1e86)] !== undefined ? _0x2be22f?.[_0x2666dd(_0x18d1c2._0x1b1e86)] : _0x2666dd(_0x18d1c2._0x30d90b), this[_0x2666dd(_0x18d1c2._0x24ce26)] = _0x2be22f?.[_0x2666dd(_0x18d1c2._0x3f055d)] !== undefined ? _0x2be22f?.['fontSize1'] : 0x64, this['fontSize2'] = _0x2be22f?.['fontSize2'] !== undefined ? _0x2be22f?.[_0x2666dd(0x2d3)] : 0x50, this[_0x2666dd(0x1a4)] = _0x2be22f?.[_0x2666dd(0x1a4)] !== undefined ? _0x2be22f['fontSize3'] : 0x3c, this[_0x2666dd(_0x18d1c2._0x3054fa)] = _0x2be22f?.[_0x2666dd(0x496)] !== undefined ? _0x2be22f?.[_0x2666dd(_0x18d1c2._0x26329d)] : 0x0, this[_0x2666dd(0x23e)] = _0x2be22f?.[_0x2666dd(_0x18d1c2._0x24fe5a)] !== undefined ? _0x2be22f?.[_0x2666dd(0x1f0)] : 0x0, this[_0x2666dd(_0x18d1c2._0x31d3de)] = _0x2be22f?.['img'] !== undefined ? _0x2be22f[_0x2666dd(_0x18d1c2._0x31d3de)] : null, this[_0x2666dd(0x1ed)] = _0x2be22f?.[_0x2666dd(_0x18d1c2._0x2de447)] !== undefined ? _0x2be22f?.[_0x2666dd(_0x18d1c2._0x16c990)] : 0x1, this[_0x2666dd(0x410)] = _0x2be22f?.['anchor'] !== undefined ? _0x2be22f[_0x2666dd(_0x18d1c2._0x436fe8)] : [0.5, 0x0], this[_0x2666dd(_0x18d1c2._0x139280)] = Object[_0x2666dd(_0x18d1c2._0x30574b)]({ 'title1': this[_0x2666dd(0x2ee)], 'title2': this[_0x2666dd(0x4e8)], 'title3': this['title3'], 'fontColor1': this[_0x2666dd(_0x18d1c2._0x2462f7)], 'fontColor2': this[_0x2666dd(0x4bf)], 'fontColor3': this[_0x2666dd(0x4db)], 'bgColor': this[_0x2666dd(0x459)], 'strokeColor': this[_0x2666dd(_0x18d1c2._0x3fe4db)], 'fontSize1': this[_0x2666dd(_0x18d1c2._0x5dda34)], 'fontSize2': this['fontSize2'], 'fontSize3': this[_0x2666dd(_0x18d1c2._0x47198d)], 'height': this[_0x2666dd(_0x18d1c2._0x59eaa6)], 'size': this['canvasSize'], 'type': this[_0x2666dd(0x23e)], 'img': this['img'], 'center': this[_0x2666dd(_0x18d1c2._0xb17ed5)] }, _0x2be22f); const { canvas: _0x5f1631, width: _0x3b01fd, height: _0x2e8692 } = drawTextWithImg[this[_0x2666dd(0x267)][_0x2666dd(0x1f0)]]({ 'title1': this[_0x2666dd(_0x18d1c2._0x377707)], 'title2': this[_0x2666dd(_0x18d1c2._0x532457)], 'title3': this[_0x2666dd(_0x18d1c2._0x332bf5)], 'fontColor1': this['fontColor1'], 'fontColor2': this[_0x2666dd(0x4db)], 'fontColor3': this['fontColor2'], 'bgColor': this[_0x2666dd(_0x18d1c2._0x45bbdf)], 'strokeColor': this[_0x2666dd(_0x18d1c2._0x3fe4db)], 'fontSize1': this['fontSize1'], 'fontSize2': this[_0x2666dd(_0x18d1c2._0x8710ec)], 'fontSize3': this[_0x2666dd(_0x18d1c2._0x21b5f9)], 'img': this[_0x2666dd(_0x18d1c2._0x3dd0fc)] }); this['canvasElement'] = _0x5f1631; const _0x4217e2 = new CanvasTexture(_0x5f1631); this['material'] = new SpriteMaterial({ 'map': _0x4217e2, 'transparent': !![], 'opacity': 0x1 }), this[_0x2666dd(_0x18d1c2._0x79c43a)] = _0x3b01fd, this['canvasHeight'] = _0x2e8692, this[_0x2666dd(0x1c1)][_0x2666dd(_0x18d1c2._0x4ef69f)](this[_0x2666dd(0x410)][0x0], this[_0x2666dd(_0x18d1c2._0xb17ed5)][0x1]), this[_0x2666dd(0x4c4)][_0x2666dd(_0x18d1c2._0x5602c2)](0x0, this['height'], 0x0), this[_0x2666dd(_0x18d1c2._0x138362)][_0x2666dd(0x49f)](this[_0x2666dd(0x188)] * this[_0x2666dd(_0x18d1c2._0x1e277c)] / this['canvasHeight'], this['canvasSize'], 0x1) } get [_0x48e965(0x459)] () { const _0x5129c3 = { _0x1cefaf: 0x3e8 }, _0x20b763 = _0x48e965; return _0x20b763(0x180) + this[_0x20b763(_0x5129c3._0x1cefaf)]['r'] * 0xff + ',' + this[_0x20b763(0x3e8)]['g'] * 0xff + ',' + this['_bgColor']['b'] * 0xff + ',' + this[_0x20b763(0x236)] + ')' } set [_0x48e965(0x459)] (_0x3af10d) { const _0x17b85d = { _0x508700: 0x49f }, _0x8b7e40 = _0x48e965; this['_bgColor'][_0x8b7e40(_0x17b85d._0x508700)](_0x3af10d) } get ['canvasSize'] () { const _0x2799fe = _0x48e965; return this[_0x2799fe(0x1ed)] } set [_0x48e965(0x188)] (_0xb1bc40) { const _0x5a1735 = _0x48e965; this[_0x5a1735(0x1ed)] = _0xb1bc40 } get ['canvasWidth'] () { const _0x703282 = _0x48e965; return this[_0x703282(0x23a)] } set [_0x48e965(0x530)] (_0xc7d193) { const _0x195abb = _0x48e965; this[_0x195abb(0x23a)] = _0xc7d193 } get [_0x48e965(0x489)] () { const _0x125a53 = { _0x4e2039: 0x1fd }, _0x1a7e74 = _0x48e965; return this[_0x1a7e74(_0x125a53._0x4e2039)] } set ['canvasHeight'] (_0x4efba5) { const _0x4f3edd = _0x48e965; this[_0x4f3edd(0x1fd)] = _0x4efba5 } [_0x48e965(0x1c8)] ({ type: _0x1ca779, title1: _0x33a2c7, title2: _0x13aa42, title3: _0x525bb5, fontColor1: _0x43fed9, fontColor2: _0x286810, fontColor3: _0x20e272, bgColor: _0x343510, strokeColor: _0x106a2c, fontSize1: _0x55ad16, fontSize2: _0xef8ba5, fontSize3: _0x292591, size: _0x3e5499 }) { const _0x500a4d = { _0xfbbd6: 0x3cf, _0x120fc2: 0x4bf, _0x40e858: 0x4db, _0x472e87: 0x4db, _0x2ba534: 0x279, _0xb9110b: 0x50a, _0x1f0050: 0x1ad, _0x4c6bfb: 0x1a4, _0x13b05c: 0x23e, _0x794ba8: 0x2c9, _0x2e1702: 0x2ee, _0x5c2089: 0x4db, _0x149322: 0x4bf, _0x38b88c: 0x188, _0x7bdbc5: 0x2f4, _0x3b40e0: 0x2f4 }, _0x58466b = _0x48e965; if (!this['canvasElement']) throw new Error(_0x58466b(0x1f6)); if (_0x343510 !== undefined) this[_0x58466b(0x459)] = _0x343510; this['fontColor1'] = _0x43fed9 !== undefined ? _0x43fed9 : this[_0x58466b(_0x500a4d._0xfbbd6)], this[_0x58466b(_0x500a4d._0x120fc2)] = _0x286810 !== undefined ? _0x286810 : this['fontColor2'], this[_0x58466b(_0x500a4d._0x40e858)] = _0x20e272 !== undefined ? _0x20e272 : this[_0x58466b(_0x500a4d._0x472e87)], this[_0x58466b(_0x500a4d._0x2ba534)] = _0x106a2c !== undefined ? _0x106a2c : this[_0x58466b(0x279)], this[_0x58466b(0x2ee)] = _0x33a2c7 !== undefined ? _0x33a2c7 : this[_0x58466b(0x2ee)], this[_0x58466b(0x4e8)] = _0x13aa42 !== undefined ? _0x13aa42 : this[_0x58466b(0x4e8)], this[_0x58466b(_0x500a4d._0xb9110b)] = _0x525bb5 !== undefined ? _0x525bb5 : this[_0x58466b(0x50a)], this[_0x58466b(0x1ad)] = _0x55ad16 !== undefined ? _0x55ad16 : this[_0x58466b(_0x500a4d._0x1f0050)], this['fontSize2'] = _0xef8ba5 !== undefined ? _0xef8ba5 : this[_0x58466b(0x2d3)], this['fontSize3'] = _0x292591 !== undefined ? _0x292591 : this[_0x58466b(_0x500a4d._0x4c6bfb)], this['textType'] = _0x1ca779 !== undefined ? _0x1ca779 : this[_0x58466b(_0x500a4d._0x13b05c)], this[_0x58466b(0x188)] = _0x3e5499 !== undefined ? _0x3e5499 : this[_0x58466b(0x188)]; const _0x51cb45 = Object[_0x58466b(_0x500a4d._0x794ba8)]({ 'title1': this[_0x58466b(_0x500a4d._0x2e1702)], 'title2': this[_0x58466b(0x4e8)], 'title3': this['title3'], 'fontColor1': this['fontColor1'], 'fontColor2': this[_0x58466b(_0x500a4d._0x5c2089)], 'fontColor3': this[_0x58466b(_0x500a4d._0x149322)], 'bgColor': this[_0x58466b(0x459)], 'strokeColor': this[_0x58466b(0x279)], 'fontSize1': this[_0x58466b(_0x500a4d._0x1f0050)], 'fontSize2': this[_0x58466b(0x2d3)], 'fontSize3': this['fontSize3'], 'img': this[_0x58466b(0x38c)], 'canvas': this['canvasElement'] }), { width: _0x9a7644, height: _0x20da94 } = updateTextWithImg[this[_0x58466b(0x23e)]](_0x51cb45); this[_0x58466b(0x530)] = _0x9a7644, this['canvasHeight'] = _0x20da94, this['scale'][_0x58466b(0x49f)](this[_0x58466b(_0x500a4d._0x38b88c)] * this['canvasWidth'] / this['canvasHeight'], this[_0x58466b(0x188)], 0x1); if (this[_0x58466b(_0x500a4d._0x7bdbc5)][_0x58466b(0x1ac)]) this['material']['map'][_0x58466b(0x4f8)] = !![]; this[_0x58466b(_0x500a4d._0x3b40e0)][_0x58466b(0x4f8)] = !![] } } class CompositeIconPopup extends CompositeIcon { [_0x48e965(0x267)];[_0x48e965(0x3e1)];[_0x48e965(0x196)];['t1'];['t2']; constructor(_0x23200d) { const _0x10adc3 = { _0x597cc2: 0x218, _0x57ae37: 0x209, _0x3e50bc: 0x267, _0x4102cc: 0x53f, _0x498d5d: 0x267, _0x38991d: 0x267, _0x54fdd5: 0x44d, _0x3417a8: 0x267, _0xdc20e1: 0x50a, _0x319ca8: 0x267, _0x26d85b: 0x1a4, _0x91834c: 0x3cf, _0x6eaf82: 0x267, _0x45f326: 0x279, _0x44d2dc: 0x267 }, _0x5f10f7 = _0x48e965; super(), this[_0x5f10f7(0x267)] = Object['assign']({ 'color': _0x5f10f7(0x218), 'guideHeight': 0x2, 'title1': _0x5f10f7(0x23c), 'title2': 'icon-sprite-title-2', 'title3': _0x5f10f7(0x172), 'fontSize1': 0x64, 'fontSize2': 0x50, 'fontSize3': 0x3c, 'fontColor1': '#ffffff', 'fontColor2': '#ffffff', 'fontColor3': _0x5f10f7(0x47d), 'bgColor': _0x5f10f7(_0x10adc3._0x597cc2), 'strokeColor': _0x5f10f7(0x218), 'opacity': 0x1, 'titleHeight': 0x1, 'titleSize': 0x1, 'type': 0x0, 'img': null, 'titleAnchor': [0.5, 0x0] }, _0x23200d), this[_0x5f10f7(0x196)] = new BaseCube({ 'color': this['opts'][_0x5f10f7(_0x10adc3._0x57ae37)], 'type': 0x0, 'width': 0.015, 'height': this[_0x5f10f7(_0x10adc3._0x3e50bc)][_0x5f10f7(_0x10adc3._0x4102cc)], 'depth': 0.015, 'mixColor': _0x5f10f7(0x372), 'mixColor2': '#000000' }), this['add'](this[_0x5f10f7(0x196)]); const _0x95f318 = new BaseCircle({ 'color': this[_0x5f10f7(_0x10adc3._0x498d5d)][_0x5f10f7(_0x10adc3._0x57ae37)], 'type': 0x6, 'radius': 0x2, 'spreadStartRadius': 0.2, 'spreadEndRadius': 0.4, 'spreadSpeed': 1.2 }); this[_0x5f10f7(0x44d)](_0x95f318), _0x95f318[_0x5f10f7(0x4a6)](); const _0x17f4cd = new BaseCircle({ 'color': this[_0x5f10f7(_0x10adc3._0x38991d)]['color'], 'type': 0x6, 'radius': 0x2, 'spreadStartRadius': 0.1, 'spreadEndRadius': 0.4, 'spreadSpeed': 1.2 }); this[_0x5f10f7(_0x10adc3._0x54fdd5)](_0x17f4cd), _0x17f4cd['startSpreadAnimation'](), this[_0x5f10f7(0x3e1)] = new BaseImageTitle({ 'title1': this['opts'][_0x5f10f7(0x2ee)], 'title2': this['opts'][_0x5f10f7(0x4e8)], 'title3': this[_0x5f10f7(_0x10adc3._0x3417a8)][_0x5f10f7(_0x10adc3._0xdc20e1)], 'fontSize1': this['opts'][_0x5f10f7(0x1ad)], 'fontSize2': this[_0x5f10f7(_0x10adc3._0x319ca8)][_0x5f10f7(0x2d3)], 'fontSize3': this['opts'][_0x5f10f7(_0x10adc3._0x26d85b)], 'fontColor1': this[_0x5f10f7(0x267)][_0x5f10f7(_0x10adc3._0x91834c)], 'fontColor2': this[_0x5f10f7(0x267)][_0x5f10f7(0x4bf)], 'fontColor3': this[_0x5f10f7(_0x10adc3._0x6eaf82)][_0x5f10f7(0x4db)], 'img': this['opts'][_0x5f10f7(0x38c)], 'bgColor': this[_0x5f10f7(0x267)][_0x5f10f7(0x459)], 'strokeColor': this[_0x5f10f7(_0x10adc3._0x38991d)][_0x5f10f7(_0x10adc3._0x45f326)], 'opacity': this[_0x5f10f7(0x267)]['opacity'], 'height': this[_0x5f10f7(_0x10adc3._0x44d2dc)][_0x5f10f7(0x3b9)], 'size': this[_0x5f10f7(0x267)][_0x5f10f7(0x388)], 'type': this[_0x5f10f7(0x267)][_0x5f10f7(0x1f0)], 'anchor': this['opts']['titleAnchor'] }), this['add'](this[_0x5f10f7(0x3e1)]) } ['show'] (_0x97c139) { const _0x25534d = _0x48e965; let _0x3bc81c = 0x0; this[_0x25534d(0x52c)](() => { _0x3bc81c++; if (_0x3bc81c == 0x2) _0x97c139 && _0x97c139() }), this['showGuideCube'](() => { _0x3bc81c++; if (_0x3bc81c == 0x2) _0x97c139 && _0x97c139() }) } [_0x48e965(0x3dd)] (_0x115cd7) { const _0x16bb62 = _0x48e965; let _0x9de0dd = 0x0; this[_0x16bb62(0x547)](() => { _0x9de0dd++; if (_0x9de0dd == 0x2) _0x115cd7 && _0x115cd7() }), this[_0x16bb62(0x201)](() => { _0x9de0dd++; if (_0x9de0dd == 0x2) _0x115cd7 && _0x115cd7() }) } [_0x48e965(0x52c)] (_0x179f93) { const _0x1f0f07 = { _0x30bd7e: 0x2ea, _0x22a787: 0x2be, _0x19073d: 0x3e1, _0x1ee0fa: 0x188, _0x8b742: 0x3e1, _0x4b3812: 0x489, _0x2f04d2: 0x188 }, _0x363fd9 = _0x48e965; this['t1'] && this['t1'][_0x363fd9(_0x1f0f07._0x30bd7e)](), this[_0x363fd9(0x3e1)][_0x363fd9(_0x1f0f07._0x22a787)]['x'] = 0x0, this[_0x363fd9(_0x1f0f07._0x19073d)][_0x363fd9(0x2be)]['y'] = 0x0, this['t1'] = new Tween(this[_0x363fd9(0x3e1)][_0x363fd9(_0x1f0f07._0x22a787)])['to']({ 'x': this[_0x363fd9(0x3e1)][_0x363fd9(_0x1f0f07._0x1ee0fa)] * this[_0x363fd9(0x3e1)][_0x363fd9(0x530)] / this[_0x363fd9(_0x1f0f07._0x8b742)][_0x363fd9(_0x1f0f07._0x4b3812)], 'y': this[_0x363fd9(0x3e1)][_0x363fd9(_0x1f0f07._0x2f04d2)] }, 0x320)[_0x363fd9(0x1ef)]()['onComplete'](() => { this['t1'] = null, _0x179f93 && _0x179f93() }) } ['showGuideCube'] (_0x1b8832) { const _0x4cabc4 = { _0x4ff1f6: 0x2ea, _0x4b7fc7: 0x2be, _0x2829fa: 0x196 }, _0xf7cb36 = _0x48e965; this['t2'] && this['t2'][_0xf7cb36(_0x4cabc4._0x4ff1f6)](), this[_0xf7cb36(0x196)][_0xf7cb36(_0x4cabc4._0x4b7fc7)]['y'] = 0x0, this['t2'] = new Tween(this[_0xf7cb36(_0x4cabc4._0x2829fa)][_0xf7cb36(_0x4cabc4._0x4b7fc7)])['to']({ 'y': 0x1 }, 0x320)['start']()[_0xf7cb36(0x3f5)](() => { this['t2'] = null, _0x1b8832 && _0x1b8832() }) } [_0x48e965(0x547)] (_0x37f06e) { const _0x8fda66 = { _0x4862ca: 0x2ea, _0xb6c32e: 0x2be, _0x5ae747: 0x1ef }, _0x318932 = _0x48e965; this['t1'] && this['t1'][_0x318932(_0x8fda66._0x4862ca)](), this['t1'] = new Tween(this[_0x318932(0x3e1)][_0x318932(_0x8fda66._0xb6c32e)])['to']({ 'x': 0x0, 'y': 0x0 }, 0x320)[_0x318932(_0x8fda66._0x5ae747)]()[_0x318932(0x3f5)](() => { this['t1'] = null, _0x37f06e && _0x37f06e() }) } [_0x48e965(0x201)] (_0x1420b8) { const _0x2dc742 = { _0xebbd58: 0x1ef, _0x16e19f: 0x3f5 }, _0x3b2ff6 = _0x48e965; this['t2'] && this['t2']['stop'](), this['t2'] = new Tween(this[_0x3b2ff6(0x196)][_0x3b2ff6(0x2be)])['to']({ 'y': 0x0 }, 0x320)[_0x3b2ff6(_0x2dc742._0xebbd58)]()[_0x3b2ff6(_0x2dc742._0x16e19f)](() => { this['t2'] = null, _0x1420b8 && _0x1420b8() }) } [_0x48e965(0x518)] (_0x29c521) { const _0x3d4c9c = _0x48e965; this[_0x3d4c9c(0x3e1)]['update']({ 'title1': _0x29c521 }) } ['setTitle2'] (_0x40faf2) { const _0x3bee34 = _0x48e965; this['baseImageTitle'][_0x3bee34(0x1c8)]({ 'title2': _0x40faf2 }) } [_0x48e965(0x258)] (_0x35d125) { const _0x2ab2a6 = { _0x515440: 0x3e1 }, _0x3b3a92 = _0x48e965; this[_0x3b3a92(_0x2ab2a6._0x515440)][_0x3b3a92(0x1c8)]({ 'title3': _0x35d125 }) } } class CompositeIconHTML extends CompositeIcon { [_0x48e965(0x267)];[_0x48e965(0x3e8)];['opacity'];['htmlEle']; constructor(_0x29b81d) { const _0x3ac34e = { _0x1016e1: 0x267, _0x548d0b: 0x218, _0x4186ad: 0x218, _0x243a2a: 0x459, _0x39016f: 0x267, _0x1c206a: 0x44d, _0x4f77f8: 0x4c4, _0x5cdd01: 0x212, _0x275fbc: 0x2be, _0x1820e6: 0x49f, _0x31ccbe: 0x267, _0x539dd9: 0x3e7, _0x30b03c: 0x399, _0x74f135: 0x459, _0x351cdc: 0x423, _0x465864: 0x4aa, _0x29fb15: 0x4df, _0x3b8787: 0x3c6 }, _0x2a8425 = _0x48e965; super(), this[_0x2a8425(_0x3ac34e._0x1016e1)] = Object[_0x2a8425(0x2c9)]({ 'color': _0x2a8425(_0x3ac34e._0x548d0b), 'bgColor': _0x2a8425(_0x3ac34e._0x4186ad), 'opacity': 0x1, 'title': 'icon-html', 'titleHeight': 0x1, 'titleSize': 0xe, 'titleColor': _0x2a8425(0x47d), 'closed': !![] }, _0x29b81d), this['_bgColor'] = new Color(this[_0x2a8425(_0x3ac34e._0x1016e1)][_0x2a8425(_0x3ac34e._0x243a2a)]), this[_0x2a8425(0x236)] = this[_0x2a8425(_0x3ac34e._0x39016f)][_0x2a8425(0x236)]; const _0x15cfe1 = new BaseCircle({ 'color': this['opts']['color'], 'type': 0x4 }); this[_0x2a8425(_0x3ac34e._0x1c206a)](_0x15cfe1); const _0x434fdf = new BaseCircularArraySquares({ 'circleRadius': 0.3, 'squareRadius': 0.03, 'numbers': 0x14, 'color': this[_0x2a8425(0x267)]['color'] }); this['add'](_0x434fdf), _0x434fdf[_0x2a8425(0x3af)](); const _0x2dff05 = new BaseCircle({ 'color': this['opts'][_0x2a8425(0x209)], 'type': 0x5, 'radius': 0.35 }); this[_0x2a8425(_0x3ac34e._0x1c206a)](_0x2dff05), _0x2dff05[_0x2a8425(0x4c4)][_0x2a8425(0x49f)](0x0, 0.05, 0x0); const _0x49b985 = new BaseCircularArrayArrows({ 'circleRadius': 0.175, 'color': this[_0x2a8425(_0x3ac34e._0x1016e1)][_0x2a8425(0x209)], 'numbers': 0x4, 'triangleSize': 0.065, 'speed': 0x1, 'indicateRadius': 1.5 }); this[_0x2a8425(0x44d)](_0x49b985), _0x49b985[_0x2a8425(_0x3ac34e._0x4f77f8)][_0x2a8425(0x49f)](0x0, 0.05, 0x0), _0x49b985[_0x2a8425(_0x3ac34e._0x5cdd01)](); const _0x100888 = new BaseShapeVic({ 'color': this[_0x2a8425(0x267)]['color'] }); _0x100888[_0x2a8425(_0x3ac34e._0x275fbc)][_0x2a8425(_0x3ac34e._0x1820e6)](0.5, 0.5, 0.5), _0x100888[_0x2a8425(0x4c4)][_0x2a8425(_0x3ac34e._0x1820e6)](0x0, 0.1, 0x0), this[_0x2a8425(0x44d)](_0x100888), this['htmlEle'] = new Popup({ 'closeVisible': this[_0x2a8425(_0x3ac34e._0x31ccbe)][_0x2a8425(_0x3ac34e._0x539dd9)] ? _0x2a8425(_0x3ac34e._0x30b03c) : _0x2a8425(0x392), 'value': _0x2a8425(0x1e2) + this[_0x2a8425(_0x3ac34e._0x74f135)] + _0x2a8425(_0x3ac34e._0x351cdc) + this[_0x2a8425(_0x3ac34e._0x39016f)][_0x2a8425(0x18b)] + _0x2a8425(_0x3ac34e._0x465864) + this[_0x2a8425(0x267)][_0x2a8425(0x388)] + 'px;font-weight:bold;align-items:center;\x27>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20<p\x20style=\x27width:100%;text-align:center;white-space:nowrap;\x27>' + this[_0x2a8425(_0x3ac34e._0x1016e1)][_0x2a8425(_0x3ac34e._0x29fb15)] + _0x2a8425(0x502), 'center': [-0.5, 0x0], 'position': [0x0, this['opts'][_0x2a8425(0x3b9)], 0x0], 'closeSize': 0.8 }), this['add'](this[_0x2a8425(_0x3ac34e._0x3b8787)]) } get ['bgColor'] () { const _0x130bc7 = { _0x293993: 0x3e8, _0x5bfbc3: 0x236 }, _0x382caf = _0x48e965; return 'rgba(' + this[_0x382caf(0x3e8)]['r'] * 0xff + ',' + this[_0x382caf(_0x130bc7._0x293993)]['g'] * 0xff + ',' + this['_bgColor']['b'] * 0xff + ',' + this[_0x382caf(_0x130bc7._0x5bfbc3)] + ')' } set [_0x48e965(0x459)] (_0x2ea546) { const _0x52e964 = _0x48e965; this[_0x52e964(0x3e8)]['set'](_0x2ea546) } [_0x48e965(0x35e)] () { const _0x57ccb7 = { _0x465e0a: 0x399 }, _0xf49bc5 = _0x48e965; this['htmlEle'][_0xf49bc5(_0x57ccb7._0x465e0a)] = !![] } [_0x48e965(0x3a5)] () { const _0x232c19 = { _0x131811: 0x399 }, _0x13d619 = _0x48e965; this[_0x13d619(0x3c6)][_0x13d619(_0x232c19._0x131811)] = ![] } } class CompositeIconSimple extends CompositeIcon { ['opts'];[_0x48e965(0x196)];[_0x48e965(0x246)];['t1'];['t1Tag'];['t2'];['t3']; constructor(_0x552dea) { const _0x317453 = { _0x15a9c3: 0x267, _0x36bd4a: 0x2c9, _0x17be88: 0x218, _0x59209a: 0x2a3, _0x51259a: 0x196, _0x1a2afb: 0x246, _0x2cedca: 0x1c1, _0x48490a: 0x49f, _0x16af46: 0x410, _0x2152b2: 0x2f4, _0x144159: 0x1ba }, _0x44369a = _0x48e965; super(), this[_0x44369a(_0x317453._0x15a9c3)] = Object[_0x44369a(_0x317453._0x36bd4a)]({ 'guideColor': _0x44369a(_0x317453._0x17be88), 'guideHeight': 0x2, 'opacity': 0x1, 'texture': null, 'anchor': [0.5, 0.5], 'iconSpeed': 0x1 }, _0x552dea), this[_0x44369a(_0x317453._0x59209a)] = 0x1, this[_0x44369a(_0x317453._0x51259a)] = new BaseCube({ 'color': this[_0x44369a(0x267)]['guideColor'], 'type': 0x0, 'width': 0.015, 'height': this[_0x44369a(_0x317453._0x15a9c3)][_0x44369a(0x53f)], 'depth': 0.015, 'mixColor': '#00ffff', 'mixColor2': _0x44369a(0x1b4) }), this['add'](this[_0x44369a(_0x317453._0x51259a)]), this[_0x44369a(_0x317453._0x1a2afb)] = new Sprite(), this[_0x44369a(_0x317453._0x1a2afb)][_0x44369a(_0x317453._0x2cedca)][_0x44369a(_0x317453._0x48490a)](this[_0x44369a(0x267)]['anchor'][0x0], this[_0x44369a(0x267)][_0x44369a(_0x317453._0x16af46)][0x1]), this[_0x44369a(_0x317453._0x1a2afb)][_0x44369a(_0x317453._0x2152b2)] = new SpriteMaterial({ 'map': this[_0x44369a(0x267)][_0x44369a(_0x317453._0x144159)], 'transparent': !![], 'opacity': 0x1 }), this[_0x44369a(_0x317453._0x1a2afb)][_0x44369a(0x4c4)][_0x44369a(_0x317453._0x48490a)](0x0, this[_0x44369a(_0x317453._0x15a9c3)][_0x44369a(0x53f)], 0x0), this[_0x44369a(0x44d)](this[_0x44369a(0x246)]) } [_0x48e965(0x3bd)] () { const _0x1a7e1a = { _0x46efb0: 0x267, _0x4475d8: 0x246, _0x34159a: 0x267 }, _0x1e4cbd = _0x48e965; this['t1'] = requestAnimationFrame(this[_0x1e4cbd(0x3bd)][_0x1e4cbd(0x2d7)](this)), this['icon'][_0x1e4cbd(0x4c4)]['y'] += 0.005 * this[_0x1e4cbd(_0x1a7e1a._0x46efb0)][_0x1e4cbd(0x168)] * this['t1Tag'], (this[_0x1e4cbd(0x246)][_0x1e4cbd(0x4c4)]['y'] >= this[_0x1e4cbd(0x267)][_0x1e4cbd(0x53f)] + 0.25 || this[_0x1e4cbd(_0x1a7e1a._0x4475d8)]['position']['y'] <= this[_0x1e4cbd(_0x1a7e1a._0x34159a)][_0x1e4cbd(0x53f)] - 0.25) && (this['t1Tag'] *= -0x1) } ['startIconAnimation'] () { const _0x40c994 = { _0x2089d0: 0x3bd }, _0x54be7e = _0x48e965; this[_0x54be7e(_0x40c994._0x2089d0)]() } [_0x48e965(0x1f1)] () { cancelAnimationFrame(this['t1']), this['t1'] = null } ['showGuideCube'] (_0x399da4) { const _0x14b5bb = { _0x529da2: 0x2be, _0x3da9b4: 0x1ef, _0x95428c: 0x3f5 }, _0x542ad0 = _0x48e965; this['t2'] && this['t2'][_0x542ad0(0x2ea)](), this['cubicGuide'][_0x542ad0(_0x14b5bb._0x529da2)]['y'] = 0x0, this['t2'] = new Tween(this[_0x542ad0(0x196)][_0x542ad0(0x2be)])['to']({ 'y': 0x1 }, 0x320)[_0x542ad0(_0x14b5bb._0x3da9b4)]()[_0x542ad0(_0x14b5bb._0x95428c)](() => { this['t2'] = null, _0x399da4 && _0x399da4() }) } [_0x48e965(0x201)] (_0x749771) { const _0x360735 = { _0x3ebc09: 0x2ea, _0x15a93e: 0x2be, _0x357fc8: 0x1ef }, _0x56f03a = _0x48e965; this['t2'] && this['t2'][_0x56f03a(_0x360735._0x3ebc09)](), this['t2'] = new Tween(this[_0x56f03a(0x196)][_0x56f03a(_0x360735._0x15a93e)])['to']({ 'y': 0x0 }, 0x320)[_0x56f03a(_0x360735._0x357fc8)]()[_0x56f03a(0x3f5)](() => { this['t2'] = null, _0x749771 && _0x749771() }) } [_0x48e965(0x52c)] (_0x4f84bf) { const _0x1176bc = { _0x2648d7: 0x246, _0x408f35: 0x2be, _0x20df1a: 0x3f5 }, _0x2e0be5 = _0x48e965; this['t3'] && this['t3']['stop'](), this[_0x2e0be5(_0x1176bc._0x2648d7)]['scale']['x'] = 0x0, this['icon'][_0x2e0be5(0x2be)]['y'] = 0x0, this['t3'] = new Tween(this['icon'][_0x2e0be5(_0x1176bc._0x408f35)])['to']({ 'x': 0x1, 'y': 0x1 }, 0x320)[_0x2e0be5(0x1ef)]()[_0x2e0be5(_0x1176bc._0x20df1a)](() => { this['t3'] = null, _0x4f84bf && _0x4f84bf() }) } [_0x48e965(0x547)] (_0x5dce75) { const _0x22e192 = { _0x45c603: 0x246, _0x43c046: 0x1ef, _0x33073f: 0x3f5 }, _0x2320f4 = _0x48e965; this['t3'] && this['t3']['stop'](), this['t3'] = new Tween(this[_0x2320f4(_0x22e192._0x45c603)]['scale'])['to']({ 'x': 0x0, 'y': 0x0 }, 0x320)[_0x2320f4(_0x22e192._0x43c046)]()[_0x2320f4(_0x22e192._0x33073f)](() => { this['t3'] = null, _0x5dce75 && _0x5dce75() }) } [_0x48e965(0x40b)] (_0x23113d) { const _0x51d6d6 = { _0x36c631: 0x52c }, _0x20664c = _0x48e965; let _0x360bf8 = 0x0; this[_0x20664c(_0x51d6d6._0x36c631)](() => { _0x360bf8++; if (_0x360bf8 == 0x2) _0x23113d && _0x23113d() }), this['showGuideCube'](() => { _0x360bf8++; if (_0x360bf8 == 0x2) _0x23113d && _0x23113d() }) } [_0x48e965(0x3dd)] (_0x456e93) { const _0x889f51 = { _0x2f1238: 0x201 }, _0x41705d = _0x48e965; let _0x37cdc8 = 0x0; this[_0x41705d(0x547)](() => { _0x37cdc8++; if (_0x37cdc8 == 0x2) _0x456e93 && _0x456e93() }), this[_0x41705d(_0x889f51._0x2f1238)](() => { _0x37cdc8++; if (_0x37cdc8 == 0x2) _0x456e93 && _0x456e93() }) } } class TagBase extends Group$1 { [_0x48e965(0x257)]; constructor() { const _0x3d087a = { _0x438158: 0x257 }, _0x27f232 = _0x48e965; super(), this[_0x27f232(_0x3d087a._0x438158)] = !![] } } class Box extends Mesh { [_0x48e965(0x1ae)]; constructor(_0x90d875) { const _0x97966a = { _0x2ace6d: 0x2f4, _0x3f666a: 0x209 }, _0x197244 = _0x48e965; super(); let _0x386ae3 = { 'size': [0.5, 0xa, 0.5], 'color': _0x197244(0x4ec) }; Object[_0x197244(0x2c9)](_0x386ae3, _0x90d875), this[_0x197244(0x1ae)] = !![], this[_0x197244(0x303)] = new BoxGeometry(..._0x386ae3[_0x197244(0x394)]), this[_0x197244(_0x97966a._0x2ace6d)] = new MeshStandardMaterial({ 'side': 0x2, 'transparent': ![], 'color': _0x386ae3[_0x197244(_0x97966a._0x3f666a)] }), this[_0x197244(0x4c4)]['y'] = _0x386ae3[_0x197244(0x394)][0x1] / 1.5 } } class LightWall extends Mesh { ['options'];[_0x48e965(0x4bb)]; constructor(_0x1eec9b) { const _0x5afcca = { _0x14ab9f: 0x4bb, _0x49263b: 0x394, _0x563176: 0x303, _0x562595: 0x527, _0x2a1bb2: 0x236, _0x25f1db: 0x1c2 }, _0x1dbc62 = _0x48e965; super(); let _0x37ec13 = { 'size': [0x3, 0x3, 0x5], 'color': _0x1dbc62(0x4ec), 'opacity': 0.8 }; Object['assign'](_0x37ec13, _0x1eec9b), this['options'] = _0x37ec13, this[_0x1dbc62(_0x5afcca._0x14ab9f)] = !![]; const _0x1a2109 = new Color(_0x37ec13[_0x1dbc62(0x209)]); Object['defineProperties'](this, { 'color': { 'configurable': !![], 'enumerable': !![], 'value': _0x1a2109 } }), this[_0x1dbc62(0x303)] = new CylinderGeometry(_0x37ec13['size'][0x0], _0x37ec13[_0x1dbc62(_0x5afcca._0x49263b)][0x1], _0x37ec13['size'][0x2], 0x40, 0x40), this[_0x1dbc62(_0x5afcca._0x563176)][_0x1dbc62(_0x5afcca._0x562595)](); const _0x3443ec = this[_0x1dbc62(0x303)][_0x1dbc62(0x1cb)], { min: _0x66e2d7, max: _0x3afbc6 } = _0x3443ec; this[_0x1dbc62(0x2f4)] = new ShaderMaterial({ 'transparent': !![], 'side': DoubleSide, 'uniforms': { 'uopacity': { 'value': _0x37ec13[_0x1dbc62(_0x5afcca._0x2a1bb2)] }, 'color': { 'value': _0x1a2109 }, 'height': { 'value': _0x37ec13['size'][0x2] }, 'uradius': { 'value': _0x37ec13[_0x1dbc62(_0x5afcca._0x49263b)][0x0] }, 'uMin': { 'value': _0x66e2d7 } }, 'vertexShader': '\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<common>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<color_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<fog_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<clipping_planes_pars_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20varying\x20float\x20v_opacity;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20height;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20uradius;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20uMin;\x0a\x20\x20\x20\x20\x20\x20\x20\x20void\x20main()\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20minCenter\x20=\x20vec3(0.,uMin.y,0.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20v_opacity\x20=\x20(1.\x20-\x20(position.y\x20+\x20height\x20/\x202.0\x20)\x20/\x20height);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(position.y\x20<\x20minCenter.y\x20+\x200.0001){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20v_opacity\x20*=\x20length(position\x20-\x20minCenter\x20)/\x20uradius\x20*\x200.1;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(position,\x201.0);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<clipping_planes_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<fog_vertex>\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20', 'fragmentShader': '\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_pars_fragment>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20color;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20uopacity;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20varying\x20float\x20v_opacity;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20void\x20main()\x20{\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(color,\x20v_opacity\x20*\x20uopacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<logdepthbuf_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20' }), this['position']['y'] = _0x37ec13['size'][0x2] / 0x2, this[_0x1dbc62(_0x5afcca._0x25f1db)] = 0x2 } } class CircleLightEfficiency extends Mesh { [_0x48e965(0x267)];[_0x48e965(0x3cc)];[_0x48e965(0x357)]; constructor(_0x1c4f8f) { const _0x43fd82 = { _0x443988: 0x3cc, _0x2a5d21: 0x357, _0x4375b7: 0x209, _0x12c41f: 0x2a2, _0x54a1bf: 0x303, _0x437d37: 0x3da, _0x231211: 0x4c1, _0x2ee941: 0x17e }, _0x4df674 = { _0x3fefbe: 0x2f4, _0x33c800: 0x3cc }, _0x2a9ec2 = _0x48e965; super(); let _0x2bd670 = { 'radius': 0x5, 'color': '#0954ed', 'speed': 0.1, 'isCirclSpread': ![] }; Object[_0x2a9ec2(0x2c9)](_0x2bd670, _0x1c4f8f), this['opts'] = _0x2bd670, this[_0x2a9ec2(0x3cc)] = _0x2bd670[_0x2a9ec2(_0x43fd82._0x443988)], this[_0x2a9ec2(_0x43fd82._0x2a5d21)] = !![]; let _0x518df0 = new Color(_0x2bd670[_0x2a9ec2(_0x43fd82._0x4375b7)]), _0x2064ab = new Vector2(0.19, 0.24); Object[_0x2a9ec2(_0x43fd82._0x12c41f)](this, { 'uColor': { 'configurable': !![], 'enumerable': !![], 'value': _0x518df0 }, 'scanRange': { 'configurable': !![], 'enumerable': !![], 'value': _0x2064ab } }), this[_0x2a9ec2(_0x43fd82._0x54a1bf)] = new CircleGeometry(_0x2bd670[_0x2a9ec2(_0x43fd82._0x437d37)], 0x80), this['rotateX'](-Math['PI'] / 0x2), this['renderOrder'] = 0x2, this[_0x2a9ec2(0x2f4)] = new ShaderMaterial({ 'side': 0x2, 'transparent': !![], 'uniforms': { 'uColor': { 'value': _0x518df0 }, 'startColor': { 'value': new Color(_0x2a9ec2(0x4ec)) }, 'uTime': { 'value': 0x0 }, 'startTime': { 'value': 0x0 }, 'vOpacity': { 'value': 0x1 }, 'uSpeed': { 'value': _0x2bd670[_0x2a9ec2(0x3cc)] }, 'uSge': { 'value': 0x4 }, 'scanningRange': { 'value': _0x2064ab }, 'isCirclSpread': { 'value': _0x2bd670['isCirclSpread'] } }, 'vertexShader': _0x2a9ec2(_0x43fd82._0x231211), 'fragmentShader': _0x2a9ec2(_0x43fd82._0x2ee941) }); const _0x20b669 = () => { const _0x2151ba = _0x2a9ec2; this[_0x2151ba(_0x4df674._0x3fefbe)][_0x2151ba(0x234)]['uTime']['value'] += this[_0x2151ba(_0x4df674._0x33c800)] / 0x5; const _0x4ff44d = this[_0x2151ba(_0x4df674._0x3fefbe)]; if (_0x4ff44d['uniforms']['startTime']['value'] < 0.45) _0x4ff44d['uniforms']['startTime']['value'] += 0.01; requestAnimationFrame(_0x20b669) }; _0x20b669() } } const drawText = [drawTextCanvas5, drawTextCanvas6]; class BaseTagPopup extends Sprite { [_0x48e965(0x267)];[_0x48e965(0x459)];['size']; constructor(_0x5da497) { const _0x1aa88e = { _0x47fc88: 0x459, _0x3aa9ff: 0x218, _0x43bdad: 0x267, _0x214348: 0x2c9, _0x54e640: 0x1f0, _0x26943a: 0x267, _0x3615a1: 0x279, _0x3528f8: 0x2f4, _0x1550c1: 0x267, _0x12bd1b: 0x2be, _0x59ac57: 0x267 }, _0x37683c = _0x48e965; super(), this['bgColor'] = new Color(_0x5da497?.[_0x37683c(0x459)] ? _0x5da497[_0x37683c(_0x1aa88e._0x47fc88)] : _0x37683c(_0x1aa88e._0x3aa9ff)), this[_0x37683c(_0x1aa88e._0x43bdad)] = Object[_0x37683c(_0x1aa88e._0x214348)]({ 'text': '', 'fontColor': _0x37683c(0x47d), 'bgColor': 'rgba(' + this[_0x37683c(_0x1aa88e._0x47fc88)]['r'] * 0xff + ',' + this[_0x37683c(_0x1aa88e._0x47fc88)]['g'] * 0xff + ',' + this[_0x37683c(_0x1aa88e._0x47fc88)]['b'] * 0xff + ',' + (_0x5da497?.[_0x37683c(0x236)] ? _0x5da497[_0x37683c(0x236)] : 0x1) + ')', 'strokeColor': _0x37683c(0x218), 'fontSize': 0x40, 'height': 0x0, 'size': 0x1, 'type': 0x0 }, _0x5da497); const { canvas: _0x1afd3e, width: _0x58d87d, height: _0x75af } = drawText[this[_0x37683c(_0x1aa88e._0x43bdad)][_0x37683c(_0x1aa88e._0x54e640)]]({ 'text': this['opts'][_0x37683c(0x28e)], 'fontColor': this[_0x37683c(0x267)]['fontColor'], 'bgColor': this[_0x37683c(0x267)][_0x37683c(_0x1aa88e._0x47fc88)], 'strokeColor': this[_0x37683c(_0x1aa88e._0x26943a)][_0x37683c(_0x1aa88e._0x3615a1)], 'fontSize': this[_0x37683c(_0x1aa88e._0x43bdad)]['fontSize'] }), _0x20da52 = new CanvasTexture(_0x1afd3e); this[_0x37683c(_0x1aa88e._0x3528f8)] = new SpriteMaterial({ 'map': _0x20da52, 'transparent': !![], 'opacity': 0x1 }), this['size'] = [_0x58d87d, _0x75af], this['center'][_0x37683c(0x49f)](0.5, 0x0), this['position']['set'](0x0, this[_0x37683c(_0x1aa88e._0x1550c1)][_0x37683c(0x496)], 0x0), this[_0x37683c(_0x1aa88e._0x12bd1b)][_0x37683c(0x49f)](this[_0x37683c(0x267)]['size'] * (0x1 * _0x58d87d) / 0x200, this[_0x37683c(_0x1aa88e._0x59ac57)]['size'] * _0x75af / 0x200, 0x1) } } class ColumnarTag extends TagBase { [_0x48e965(0x4b9)];['popupBaseSize'];[_0x48e965(0x4b3)];[_0x48e965(0x34f)];[_0x48e965(0x515)]; constructor(_0x344aff) { const _0x4c3dc8 = { _0x4f703b: 0x4ec, _0x41b54b: 0x4ec, _0x20e600: 0x44d, _0x4ad29b: 0x527, _0x2d7325: 0x2bb, _0x1fb072: 0x318, _0x5e3906: 0x44d, _0x4db959: 0x15f, _0x4df287: 0x1f0, _0xd5c08a: 0x4b9, _0x2324c5: 0x1c4, _0x33893f: 0x259, _0x1c9e93: 0x318, _0x365917: 0x382, _0x2962a1: 0x500 }, _0xd90496 = _0x48e965; super(); let _0x37d9bc = { 'cubeOpts': { 'size': [0.5, 0xa, 0.5], 'color': _0xd90496(_0x4c3dc8._0x4f703b) }, 'lightWallOpts': { 'size': [0x3, 0x3, 0x5], 'color': _0xd90496(0x4ec), 'opacity': 0.8 }, 'circleEfficiencyOpts': { 'radius': 0x5, 'color': _0xd90496(_0x4c3dc8._0x41b54b), 'speed': 0.1, 'isCirclSpread': ![] }, 'popupOpts': { 'text': _0xd90496(0x545), 'fontColor': _0xd90496(0x47d), 'bgColor': _0xd90496(_0x4c3dc8._0x4f703b), 'strokeColor': _0xd90496(0x4ec), 'fontSize': 0x50, 'height': 0x0, 'size': 0x5, 'type': 0x0 } }; Object['assign'](_0x37d9bc, _0x344aff), this['spritPopupAttrs'] = _0x37d9bc['popupOpts'], this['popupType'] = this[_0xd90496(0x34f)][_0xd90496(0x1f0)]; const _0x5742a6 = new Box(_0x37d9bc[_0xd90496(0x2b5)]); this[_0xd90496(_0x4c3dc8._0x20e600)](_0x5742a6), _0x5742a6[_0xd90496(0x526)](), _0x5742a6['geometry'][_0xd90496(_0x4c3dc8._0x4ad29b)](); const { min: _0x27c34b, max: _0x585b73 } = _0x5742a6[_0xd90496(0x303)][_0xd90496(0x1cb)]; _0x585b73[_0xd90496(0x24a)](_0x5742a6[_0xd90496(_0x4c3dc8._0x2d7325)]), this[_0xd90496(0x4b9)] = _0x585b73['y']; const _0x5b84cf = new LightWall(_0x37d9bc['lightWallOpts']); this[_0xd90496(_0x4c3dc8._0x20e600)](_0x5b84cf); const _0x55d7cd = new CircleLightEfficiency(_0x37d9bc[_0xd90496(_0x4c3dc8._0x1fb072)]); this[_0xd90496(0x44d)](_0x55d7cd); const _0x4f965e = new BaseTagPopup(_0x37d9bc[_0xd90496(0x391)]); this[_0xd90496(_0x4c3dc8._0x5e3906)](_0x4f965e), _0x4f965e[_0xd90496(_0x4c3dc8._0x4db959)][_0xd90496(_0x4c3dc8._0x4df287)] = _0xd90496(0x48a), _0x4f965e[_0xd90496(0x4c4)]['y'] = this[_0xd90496(_0x4c3dc8._0xd5c08a)] + 0x1, this[_0xd90496(_0x4c3dc8._0x2324c5)] = [_0x4f965e[_0xd90496(0x2be)]['x'], _0x4f965e[_0xd90496(0x2be)]['y']], this['popupBaseScale'] = 0x1, this[_0xd90496(_0x4c3dc8._0x33893f)](_0x37d9bc[_0xd90496(_0x4c3dc8._0x1c9e93)][_0xd90496(0x484)]), this[_0xd90496(_0x4c3dc8._0x365917)](_0x37d9bc[_0xd90496(_0x4c3dc8._0x2962a1)][_0xd90496(0x394)][0x0], _0x37d9bc[_0xd90496(0x318)]['radius'], [0.35, 0.45]) } [_0x48e965(0x382)] (_0x47f219, _0x3257aa, _0x8fcab6) { const _0x54b3ac = { _0x4b105d: 0x452 }, _0x28fc22 = _0x48e965, _0x191ca0 = _0x47f219 / _0x3257aa; this[_0x28fc22(0x4a5)](_0xb17d04 => { const _0x26d84e = _0x28fc22; _0xb17d04['isCirclEfficiency'] && _0xb17d04[_0x26d84e(_0x54b3ac._0x4b105d)]['set'](_0x191ca0 * _0x8fcab6[0x0], _0x191ca0 * _0x8fcab6[0x1]) }) } [_0x48e965(0x2cf)] (_0x142a8d) { const _0x447900 = { _0x256403: 0x1ae, _0x6cae09: 0x2f4, _0x226b13: 0x48a }; this['traverse'](_0x592f74 => { const _0x327395 = _0x3544; if (_0x592f74[_0x327395(_0x447900._0x256403)]) _0x592f74[_0x327395(_0x447900._0x6cae09)]['color'] = new Color(_0x142a8d); else { if (_0x592f74[_0x327395(0x357)]) _0x592f74['uColor'][_0x327395(0x49f)](_0x142a8d); else _0x592f74[_0x327395(0x15f)]?.['type'] == _0x327395(_0x447900._0x226b13) && this[_0x327395(0x349)](_0x142a8d) } }) } ['circleSwitch'] (_0x30824e, _0x37796c) { const _0x1ca1e8 = { _0x4cad62: 0x515, _0x3de470: 0x349, _0x2b0b59: 0x459, _0x185fa3: 0x445, _0x549afb: 0x34f, _0x309b07: 0x28e }, _0x3697c6 = { _0xdd707: 0x357, _0x88bdc3: 0x27b }, _0x3e9432 = _0x48e965; this[_0x3e9432(0x4a5)](_0x276dc1 => { const _0x500a2f = _0x3e9432; _0x276dc1[_0x500a2f(_0x3697c6._0xdd707)] && (_0x276dc1[_0x500a2f(0x2f4)]['uniforms'][_0x500a2f(0x484)][_0x500a2f(_0x3697c6._0x88bdc3)] = _0x30824e, _0x276dc1['material']['uniforms']['startTime'][_0x500a2f(0x27b)] = 0x0, _0x276dc1[_0x500a2f(0x2f4)]['uniforms']['uTime']['value'] = 0x0) }), this[_0x3e9432(_0x1ca1e8._0x4cad62)] = _0x30824e ? 0x1 : 0x0; if (_0x37796c) this[_0x3e9432(_0x1ca1e8._0x4cad62)] = _0x37796c; this[_0x3e9432(_0x1ca1e8._0x3de470)](this['spritPopupAttrs'][_0x3e9432(_0x1ca1e8._0x2b0b59)]), this[_0x3e9432(_0x1ca1e8._0x185fa3)](this[_0x3e9432(_0x1ca1e8._0x549afb)][_0x3e9432(_0x1ca1e8._0x309b07)]), this[_0x3e9432(0x259)](_0x30824e) } ['setSize'] (_0x203c1c) { const _0x4afcb6 = { _0x411f2e: 0x4b3 }, _0x5395b7 = { _0x528801: 0x1f0, _0x12343a: 0x48a, _0x37971d: 0x2be, _0x57f212: 0x49f, _0xbdff45: 0x1c4 }, _0x558f0f = _0x48e965, _0x5a99fa = Math[_0x558f0f(0x305)](Math[_0x558f0f(0x25b)](_0x203c1c, 0x64), 0x0); this[_0x558f0f(_0x4afcb6._0x411f2e)] = _0x5a99fa, this['traverse'](_0x4ee420 => { const _0x4b58d5 = _0x558f0f; if (_0x4ee420[_0x4b58d5(0x15f)]?.[_0x4b58d5(_0x5395b7._0x528801)] == _0x4b58d5(_0x5395b7._0x12343a)) _0x4ee420[_0x4b58d5(_0x5395b7._0x37971d)][_0x4b58d5(_0x5395b7._0x57f212)](this[_0x4b58d5(_0x5395b7._0xbdff45)][0x0] * _0x5a99fa, this[_0x4b58d5(0x1c4)][0x1] * _0x5a99fa) }) } [_0x48e965(0x17b)] (_0x41ea6c) { const _0x2642f2 = { _0x244caa: 0x25b }, _0x447f7e = { _0x2d9624: 0x1f0, _0x494d46: 0x4c4 }, _0x2abec1 = _0x48e965, _0x46e223 = Math['max'](Math[_0x2abec1(_0x2642f2._0x244caa)](_0x41ea6c, 0x64), 0x0); this[_0x2abec1(0x4a5)](_0x3f00c5 => { const _0x553b02 = _0x2abec1; if (_0x3f00c5[_0x553b02(0x15f)]?.[_0x553b02(_0x447f7e._0x2d9624)] == _0x553b02(0x48a)) _0x3f00c5[_0x553b02(_0x447f7e._0x494d46)]['y'] = this['popupBaseHeight'] + _0x46e223 }) } [_0x48e965(0x349)] (_0x9ff79f) { const _0x468305 = { _0x5f0097: 0x459, _0x25c0e9: 0x279, _0x5424fd: 0x34f, _0x4f3ddd: 0x2f4, _0x554e69: 0x2b0 }, _0x4d2bdd = { _0x33a2bb: 0x48a, _0x54c339: 0x1ac }, _0x58773c = _0x48e965; this['spritPopupAttrs'][_0x58773c(_0x468305._0x5f0097)] = _0x9ff79f, this[_0x58773c(0x34f)][_0x58773c(_0x468305._0x25c0e9)] = _0x9ff79f, this[_0x58773c(_0x468305._0x5424fd)][_0x58773c(0x1f0)] = this[_0x58773c(0x515)]; const _0x3b9df7 = new BaseTagPopup(this[_0x58773c(0x34f)]), _0x517c42 = _0x3b9df7[_0x58773c(_0x468305._0x4f3ddd)][_0x58773c(0x1ac)][_0x58773c(_0x468305._0x554e69)](); this[_0x58773c(0x4a5)](_0x1b95fe => { const _0x4fb759 = _0x58773c; if (_0x1b95fe[_0x4fb759(0x15f)]?.[_0x4fb759(0x1f0)] == _0x4fb759(_0x4d2bdd._0x33a2bb)) _0x1b95fe[_0x4fb759(0x2f4)][_0x4fb759(_0x4d2bdd._0x54c339)] = _0x517c42 }) } [_0x48e965(0x2f9)] (_0x283fab) { const _0x31b2bc = { _0x1aa4a9: 0x4a5 }, _0x4f30ef = _0x48e965; this[_0x4f30ef(_0x31b2bc._0x1aa4a9)](_0x356553 => { const _0x36b71e = _0x4f30ef; if (_0x356553['isWall']) _0x356553['color'][_0x36b71e(0x49f)](_0x283fab) }) } [_0x48e965(0x259)] (_0x84c43) { const _0x21fe52 = { _0xf6d0d2: 0x15f }, _0x4bd341 = _0x48e965; this[_0x4bd341(0x4a5)](_0x4288da => { const _0x16678c = _0x4bd341; if (_0x4288da[_0x16678c(_0x21fe52._0xf6d0d2)]?.[_0x16678c(0x1f0)] == _0x16678c(0x48a)) _0x4288da['center']['x'] = _0x84c43 ? 0x0 : 0.5 }) } [_0x48e965(0x445)] (_0xfef206) { const _0x4e1b22 = { _0x559c14: 0x181, _0x4345ad: 0x321, _0x478259: 0x2b0, _0x393bd5: 0x4a5 }, _0x28be37 = { _0x33a911: 0x1c4 }, _0x2425d4 = _0x48e965, _0x4d456e = _0xfef206[_0x2425d4(_0x4e1b22._0x559c14)](); if (_0x4d456e && _0x4d456e[_0x2425d4(0x321)] < 0x1) return; this['spritPopupAttrs']['text'] = _0x4d456e[_0x2425d4(0x29b)](0x0, Math[_0x2425d4(0x25b)](0x12, _0x4d456e[_0x2425d4(_0x4e1b22._0x4345ad)])); const _0xbad7ac = new BaseTagPopup(this['spritPopupAttrs']), _0x4dc108 = _0xbad7ac['material']['map'][_0x2425d4(_0x4e1b22._0x478259)](); this[_0x2425d4(_0x4e1b22._0x393bd5)](_0x1b3e8d => { const _0x4bd665 = _0x2425d4; _0x1b3e8d[_0x4bd665(0x15f)]?.[_0x4bd665(0x1f0)] == _0x4bd665(0x48a) && (_0x1b3e8d['material'][_0x4bd665(0x1ac)] = _0x4dc108, this[_0x4bd665(_0x28be37._0x33a911)] = [_0xbad7ac['scale']['x'], _0xbad7ac[_0x4bd665(0x2be)]['y']]) }) } } class ScanningCirle extends Mesh { [_0x48e965(0x267)];[_0x48e965(0x3cc)];['isScanningCirle']; constructor(_0x259e28) { const _0x3c3b03 = { _0x23fa54: 0x4ec, _0x5c449f: 0x303, _0x42ef2c: 0x3da, _0x52b539: 0x1c2, _0x47182f: 0x2f4, _0x4b69dd: 0x3cc }, _0x503c2c = { _0x24d128: 0x2f4, _0x6d14c4: 0x4ea, _0x498403: 0x3cc, _0x4b8289: 0x3db, _0x4238e6: 0x27b, _0x4ba20a: 0x27b }, _0x25d22b = _0x48e965; super(); let _0x4f5d4a = { 'radius': 0x5, 'color': _0x25d22b(_0x3c3b03._0x23fa54), 'speed': 0.1 }; Object[_0x25d22b(0x2c9)](_0x4f5d4a, _0x259e28), this['opts'] = _0x4f5d4a, this['speed'] = _0x4f5d4a[_0x25d22b(0x3cc)], this['isScanningCirle'] = !![]; let _0x3ce417 = new Color(_0x4f5d4a[_0x25d22b(0x209)]), _0x3b8c58 = new Vector2(0.19, 0.24); Object['defineProperties'](this, { 'uColor': { 'configurable': !![], 'enumerable': !![], 'value': _0x3ce417 }, 'scanRange': { 'configurable': !![], 'enumerable': !![], 'value': _0x3b8c58 } }), this[_0x25d22b(_0x3c3b03._0x5c449f)] = new CircleGeometry(_0x4f5d4a[_0x25d22b(_0x3c3b03._0x42ef2c)], 0x80), this['rotateX'](-Math['PI'] / 0x2), this[_0x25d22b(_0x3c3b03._0x52b539)] = 0x2, this[_0x25d22b(_0x3c3b03._0x47182f)] = new ShaderMaterial({ 'side': 0x2, 'transparent': !![], 'uniforms': { 'uColor': { 'value': _0x3ce417 }, 'uTime': { 'value': 0x0 }, 'startTime': { 'value': 0x0 }, 'vOpacity': { 'value': 0x1 }, 'uSpeed': { 'value': _0x4f5d4a[_0x25d22b(_0x3c3b03._0x4b69dd)] }, 'scanningRange': { 'value': _0x3b8c58 } }, 'vertexShader': '\x0a\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec2\x20uvu;\x0a\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(position,1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uvu\x20=\x20uv;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20', 'fragmentShader': '\x0a\x20\x20\x20\x20\x20\x20\x20\x20#define\x20EPSILON\x201e-6\x0a\x20\x20\x20\x20\x20\x20\x20\x20#define\x20PI\x203.14159265\x0a\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec2\x20uvu;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec3\x20uColor;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20uTime;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20startTime;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20vOpacity;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20vec2\x20scanningRange;\x0a\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20uSpeed;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20atan2(in\x20float\x20y,in\x20float\x20x){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20ax\x20=\x20abs(x);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20ay\x20=\x20abs(y);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20a\x20=\x20min(ax,\x20ay)\x20/\x20(max(ax,\x20ay)\x20+\x20EPSILON);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20s\x20=\x20a*a;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20r\x20=\x20((-.0464964749\x20*\x20s\x20+\x20.15931422)\x20*\x20s\x20-\x20.327622764)\x20*\x20s\x20*\x20a\x20+\x20a;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(ay\x20>\x20ax)\x20r\x20=\x20PI\x20/\x202.\x20-\x20r;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(x\x20<\x200.\x20)\x20r\x20=\x20PI\x20-\x20r;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(y\x20<\x200.\x20)\x20r\x20=\x202.\x20*\x20PI\x20-\x20r;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20r;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20difColor\x20=vec3(0.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20uopacity\x20=\x201.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20pct\x20=\x20distance(uvu,\x20vec2(.5));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20time1\x20=\x20cos(uTime);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(startTime\x20<\x200.45){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(pct\x20>\x20startTime\x20-\x200.05\x20&&\x20pct\x20<\x20startTime\x20+\x200.05){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20difColor\x20=\x20uColor;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uopacity\x20=(1.-\x20smoothstep(startTime\x20-\x200.05,startTime\x20+\x200.04,pct));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(uopacity>0.97)difColor\x20+=\x20vec3(1.)*0.1;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(uopacity\x20<0.98)uopacity\x20*=1.-\x20startTime;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uopacity\x20=\x200.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20end\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(pct\x20>\x20scanningRange.x\x20&&\x20pct\x20<\x20scanningRange.y){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20dir\x20=\x20uvu\x20-\x20vec2(.5);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20dir\x20=\x20vec2(dir.x\x20*\x20cos(uTime)\x20-\x20dir.y\x20*\x20sin(uTime),\x20dir.x\x20*\x20sin(uTime)\x20+\x20dir.y\x20*\x20cos(uTime));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20theta\x20=\x20atan2(dir.y\x20,dir.x);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20difColor\x20=\x20uColor\x20*\x20(2.4\x20+\x20sin(2.2\x20*\x20uTime));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uopacity\x20=\x20theta\x20/\x20(2.\x20*\x20PI);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x20else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20difColor\x20=\x20vec3(0.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uopacity\x20=\x200.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(time1\x20>0.\x20)uopacity\x20*=\x20time1;\x20//\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(difColor,uopacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20' }); const _0x7d50cc = () => { const _0x36de30 = _0x25d22b; this[_0x36de30(_0x503c2c._0x24d128)]['uniforms'][_0x36de30(_0x503c2c._0x6d14c4)]['value'] += this[_0x36de30(_0x503c2c._0x498403)] / 0x5; const _0x4876ff = this[_0x36de30(0x2f4)]; if (_0x4876ff['uniforms'][_0x36de30(_0x503c2c._0x4b8289)][_0x36de30(_0x503c2c._0x4238e6)] < 0.45) _0x4876ff[_0x36de30(0x234)][_0x36de30(_0x503c2c._0x4b8289)][_0x36de30(_0x503c2c._0x4ba20a)] += 0.01; requestAnimationFrame(_0x7d50cc) }; _0x7d50cc() } } class RealtimeCavans { ['opts'];[_0x48e965(0x459)];[_0x48e965(0x264)];[_0x48e965(0x15d)];[_0x48e965(0x496)];[_0x48e965(0x330)];[_0x48e965(0x1aa)];[_0x48e965(0x503)];[_0x48e965(0x1a6)];['titleWidth'];[_0x48e965(0x4d0)];[_0x48e965(0x354)]; constructor(_0x4d0fdc) { const _0x50e2ef = { _0x535b2a: 0x459, _0x465254: 0x459, _0x6b705: 0x264, _0xd0b636: 0x15d, _0x53506d: 0x20b, _0x34de40: 0x15d, _0x5ca57f: 0x496, _0x2cad43: 0x496, _0x2e272b: 0x1a6 }, _0x2ad306 = { _0x3e72aa: 0x1aa, _0x2c56b4: 0x3cc, _0x43e1bf: 0x503, _0x11d06a: 0x3cc, _0x31fd83: 0x503, _0xef5bc6: 0x330, _0x22629a: 0x1aa, _0x5c6e1b: 0x267, _0xc11643: 0x1aa, _0x4b03bc: 0x270, _0x3e8ea3: 0x1aa, _0x581aec: 0x267, _0x582646: 0x503, _0x2ef1d2: 0x354 }, _0x15bef7 = _0x48e965; this['bgColor'] = new Color(_0x4d0fdc?.[_0x15bef7(0x459)] ? _0x4d0fdc[_0x15bef7(_0x50e2ef._0x535b2a)] : _0x15bef7(0x218)), this[_0x15bef7(0x267)] = Object[_0x15bef7(0x2c9)]({ 'title': '', 'text': _0x15bef7(0x400), 'fontColor': _0x15bef7(0x47d), 'bgColor': _0x15bef7(0x180) + this[_0x15bef7(0x459)]['r'] * 0xff + ',' + this[_0x15bef7(_0x50e2ef._0x465254)]['g'] * 0xff + ',' + this['bgColor']['b'] * 0xff + ',' + (_0x4d0fdc?.[_0x15bef7(0x236)] ? _0x4d0fdc[_0x15bef7(0x236)] : 0x1) + ')', 'strokeColor': _0x15bef7(0x218), 'fontSize': 0x40, 'speed': 0x5, 'opacity': 0x1 }, _0x4d0fdc); let _0x30828e = document[_0x15bef7(0x519)](_0x15bef7(_0x50e2ef._0x6b705)); this[_0x15bef7(_0x50e2ef._0xd0b636)] = 0x400, this[_0x15bef7(0x496)] = 0x200, this[_0x15bef7(_0x50e2ef._0x53506d)] = 0x0, this[_0x15bef7(0x4d0)] = 0x0, _0x30828e[_0x15bef7(_0x50e2ef._0xd0b636)] = this[_0x15bef7(_0x50e2ef._0x34de40)], _0x30828e[_0x15bef7(0x496)] = this[_0x15bef7(_0x50e2ef._0x5ca57f)], _0x30828e['style']['width'] = this[_0x15bef7(_0x50e2ef._0xd0b636)] / 0x2 + 'px', _0x30828e['style'][_0x15bef7(_0x50e2ef._0x2cad43)] = this[_0x15bef7(0x496)] / 0x2 + 'px'; const _0x396466 = _0x30828e[_0x15bef7(0x44a)]('2d'); this[_0x15bef7(_0x50e2ef._0x2e272b)] = _0x396466, this['canvas'] = _0x30828e, this[_0x15bef7(0x330)] = 0x0, this['time1'] = 0x200, this[_0x15bef7(0x503)] = 0xa; const _0x4d6d18 = () => { const _0x508ccd = _0x15bef7; requestAnimationFrame(_0x4d6d18); if (this[_0x508ccd(0x330)] == 0x0) { if (this['time1'] < 0x401) this['drawTitle'](this[_0x508ccd(_0x2ad306._0x3e72aa)]); this[_0x508ccd(0x1aa)] += this['opts'][_0x508ccd(_0x2ad306._0x2c56b4)], this['time1'] > 0x400 && (this[_0x508ccd(0x22b)](this[_0x508ccd(_0x2ad306._0x43e1bf)]), this[_0x508ccd(_0x2ad306._0x43e1bf)] += this['opts'][_0x508ccd(_0x2ad306._0x11d06a)], this[_0x508ccd(_0x2ad306._0x31fd83)] > 0x18e && (this[_0x508ccd(_0x2ad306._0xef5bc6)] = 0x2, this[_0x508ccd(_0x2ad306._0x22629a)] = 0x200, this[_0x508ccd(_0x2ad306._0x43e1bf)] = 0xa)) } else { if (this['status'] == 0x1) { if (this[_0x508ccd(0x503)] < 0x18f && this[_0x508ccd(0x503)] > 0x9) this['drawText'](this[_0x508ccd(0x503)]); this['time2'] -= this[_0x508ccd(_0x2ad306._0x5c6e1b)]['speed']; if (this[_0x508ccd(0x503)] < 0xa) { if (this[_0x508ccd(_0x2ad306._0xc11643)] < 0x401) this[_0x508ccd(_0x2ad306._0x4b03bc)](this[_0x508ccd(_0x2ad306._0xc11643)]); this[_0x508ccd(_0x2ad306._0x3e8ea3)] -= this[_0x508ccd(_0x2ad306._0x581aec)]['speed'], this['time1'] < 0x200 && (this[_0x508ccd(0x330)] = 0x2, this['time1'] = 0x200, this[_0x508ccd(_0x2ad306._0x582646)] = 0xa, this[_0x508ccd(_0x2ad306._0x2ef1d2)] && this['clickCallback']()) } } } }; _0x4d6d18() } [_0x48e965(0x270)] (_0x56b710) { const _0x78f4f1 = { _0x38f728: 0x20b, _0x1d1f11: 0x1a6, _0x5eddbf: 0x51a, _0x4642f2: 0x267, _0x431cd6: 0x267, _0x5a2e8c: 0x30b, _0x405529: 0x4df, _0x3a1a33: 0x15d, _0x4b6e73: 0x1fc, _0xbb6cb3: 0x2d4, _0x155c10: 0x475, _0x2042dd: 0x214, _0x42fafb: 0x214, _0x221621: 0x36b, _0x5edba0: 0x4b4, _0x4259df: 0x1a6, _0x50bb63: 0x1a6, _0x47d52a: 0x1a6, _0x109452: 0x1a6, _0x988bec: 0x1a6, _0x539d24: 0x1a6, _0x40ae04: 0x520, _0x1ac89a: 0x1a6, _0x26d456: 0x4b4, _0x2e2b1f: 0x37a, _0x3a6994: 0x1e6, _0x2e004c: 0x395, _0x11e92d: 0x30b }, _0x593149 = _0x48e965; if (_0x56b710 > 0x400) return; this[_0x593149(_0x78f4f1._0x38f728)] = _0x56b710, this[_0x593149(_0x78f4f1._0x1d1f11)][_0x593149(_0x78f4f1._0x5eddbf)] = _0x593149(0x1e6) + this[_0x593149(0x267)][_0x593149(0x4d6)] + 'px\x20Microsoft\x20YaHei'; const _0x1c333a = ColorRGBA['parse'](this[_0x593149(_0x78f4f1._0x4642f2)]['strokeColor']), _0x337868 = ColorRGBA[_0x593149(0x45e)](this[_0x593149(_0x78f4f1._0x431cd6)][_0x593149(0x459)]); let _0x112e9d = this[_0x593149(0x1a6)][_0x593149(_0x78f4f1._0x5a2e8c)](this[_0x593149(0x267)][_0x593149(_0x78f4f1._0x405529)])[_0x593149(_0x78f4f1._0x3a1a33)]; _0x112e9d = Math[_0x593149(0x305)](0x40, Math[_0x593149(0x25b)](_0x112e9d, 0x400 - 0x80)); const _0xfad4a8 = this['width'] / 0x2, _0x355c6e = 'rgb(' + (_0x1c333a['r'] + 0.2) * 0xff + ',' + (_0x1c333a['g'] + 0.2) * 0xff + ',' + (_0x1c333a['b'] + 0.2) * 0xff + ')'; this['canvasContext'][_0x593149(_0x78f4f1._0x4b6e73)](0x0, 0x0, this[_0x593149(0x15d)], 0x80), this[_0x593149(_0x78f4f1._0x1d1f11)][_0x593149(0x475)] = this[_0x593149(0x267)][_0x593149(0x459)], this[_0x593149(_0x78f4f1._0x1d1f11)][_0x593149(_0x78f4f1._0xbb6cb3)](this['width'] / 0x2 - _0x56b710 / 0x2, 0x40, _0x56b710, 0x32), this['canvasContext'][_0x593149(0x1e8)](), this[_0x593149(0x1a6)][_0x593149(_0x78f4f1._0x155c10)] = _0x593149(0x498) + (_0x337868['r'] - 0.1) * 0xff + ',' + (_0x337868['g'] - 0.1) * 0xff + ',' + (_0x337868['b'] - 0.1) * 0xff + ')', this['canvasContext']['moveTo'](_0xfad4a8 - _0x112e9d * 0.6, 0x0), this[_0x593149(0x1a6)][_0x593149(_0x78f4f1._0x2042dd)](_0xfad4a8 - _0x112e9d * 0.6, 0x80 / 0x2), this['canvasContext'][_0x593149(_0x78f4f1._0x42fafb)](_0xfad4a8 - _0x112e9d * 0.6 - 0x80 / 0x2, 0x80 / 0x2), this[_0x593149(0x1a6)][_0x593149(_0x78f4f1._0x221621)] = _0x355c6e, this[_0x593149(_0x78f4f1._0x1d1f11)]['lineWidth'] = 0x1, this[_0x593149(_0x78f4f1._0x1d1f11)][_0x593149(_0x78f4f1._0x5edba0)](), this[_0x593149(_0x78f4f1._0x4259df)]['fill'](), this[_0x593149(0x1a6)]['stroke'](), this[_0x593149(0x1a6)][_0x593149(0x1e8)](), this[_0x593149(_0x78f4f1._0x4259df)][_0x593149(0x534)](_0xfad4a8 + _0x112e9d * 0.6 + 0.1, 0x0), this[_0x593149(_0x78f4f1._0x50bb63)][_0x593149(0x214)](_0xfad4a8 + _0x112e9d * 0.6 + 0.1, 0x80 / 0x2), this[_0x593149(_0x78f4f1._0x47d52a)][_0x593149(_0x78f4f1._0x42fafb)](_0xfad4a8 + _0x112e9d * 0.6 + 0x80 / 0x2 + 0.1, 0x80 / 0x2), this[_0x593149(0x1a6)]['strokeStyle'] = _0x355c6e, this['canvasContext']['lineWidth'] = 0x1, this[_0x593149(_0x78f4f1._0x109452)][_0x593149(_0x78f4f1._0x5edba0)](), this[_0x593149(_0x78f4f1._0x47d52a)][_0x593149(0x2bc)](), this[_0x593149(_0x78f4f1._0x50bb63)]['stroke'](), this[_0x593149(_0x78f4f1._0x988bec)]['beginPath'](), this[_0x593149(0x1a6)][_0x593149(0x475)] = _0x593149(0x498) + (_0x337868['r'] + 0.2) * 0xff + ',' + (_0x337868['g'] + 0.2) * 0xff + ',' + (_0x337868['b'] + 0.2) * 0xff + ')', this[_0x593149(0x1a6)][_0x593149(0x534)](_0xfad4a8 - _0x112e9d * 0.6, 0x0), this[_0x593149(_0x78f4f1._0x539d24)][_0x593149(0x214)](_0xfad4a8 + _0x112e9d * 0.6, 0x0), this[_0x593149(0x1a6)][_0x593149(_0x78f4f1._0x42fafb)](_0xfad4a8 + _0x112e9d * 0.6, 0x80 / 0x3 * 0x2), this['canvasContext'][_0x593149(_0x78f4f1._0x40ae04)](_0xfad4a8 + _0x112e9d * 0.6 - 0x14, 0x80 / 0x3 * 0x2, 0x14, 0x0, Math['PI'] / 0x2), this[_0x593149(_0x78f4f1._0x1ac89a)][_0x593149(0x214)](_0xfad4a8 - _0x112e9d * 0.6 + 0x14, 0x80 / 0x3 * 0x2 + 0x14), this['canvasContext'][_0x593149(_0x78f4f1._0x40ae04)](_0xfad4a8 - _0x112e9d * 0.6 + 0x14, 0x80 / 0x3 * 0x2, 0x14, Math['PI'] / 0x2, Math['PI']), this[_0x593149(_0x78f4f1._0x47d52a)][_0x593149(0x214)](_0xfad4a8 - _0x112e9d * 0.6, 0x0), this['canvasContext']['strokeStyle'] = _0x355c6e, this[_0x593149(0x1a6)][_0x593149(0x2dc)] = 0x1, this[_0x593149(0x1a6)][_0x593149(_0x78f4f1._0x26d456)](), this[_0x593149(0x1a6)]['fill'](), this[_0x593149(0x1a6)][_0x593149(_0x78f4f1._0x2e2b1f)](), this['canvasContext'][_0x593149(_0x78f4f1._0x5eddbf)] = _0x593149(_0x78f4f1._0x3a6994) + this[_0x593149(0x267)][_0x593149(0x4d6)] / 0x2 + 'px\x20Microsoft\x20YaHei', this['canvasContext']['textBaseline'] = _0x593149(0x2eb), this['canvasContext']['fillStyle'] = this[_0x593149(0x267)][_0x593149(0x2f3)], this[_0x593149(_0x78f4f1._0x47d52a)][_0x593149(_0x78f4f1._0x2e004c)](this['opts'][_0x593149(_0x78f4f1._0x405529)], (this[_0x593149(0x15d)] - this['canvasContext'][_0x593149(_0x78f4f1._0x11e92d)](this[_0x593149(0x267)][_0x593149(0x4df)])['width']) / 0x2, 1.2 * (0x80 - this[_0x593149(0x267)]['fontSize']) / 0x2) } [_0x48e965(0x22b)] (_0x436073) { const _0x31cea2 = { _0x4e6550: 0x496, _0x15d718: 0x475, _0x3cdd16: 0x267, _0x5943e4: 0x1a6, _0x2abf07: 0x475, _0x205ded: 0x1a6, _0x549e9d: 0x1a6, _0x4ce8a6: 0x1fc, _0x59fb7e: 0x15d, _0x428fe4: 0x1e6, _0x3709f9: 0x4d6, _0x483f25: 0x488, _0x1974f8: 0x2eb, _0x5806b9: 0x475, _0x1348b9: 0x32a, _0x41b26e: 0x28e, _0x13449c: 0x267 }, _0x212953 = _0x48e965; if (_0x436073 > 0x18e || _0x436073 < 0xa) return; this['contextBoxHeight'] = _0x436073; const _0x1474b6 = ColorRGBA['parse'](this['opts']['bgColor']); this[_0x212953(0x270)](0x400), this[_0x212953(0x1a6)][_0x212953(0x1fc)](0x0, 0x40 + 0x32, this['width'], this[_0x212953(_0x31cea2._0x4e6550)] - 0x40 - 0x32), this[_0x212953(0x1a6)][_0x212953(_0x31cea2._0x15d718)] = this[_0x212953(_0x31cea2._0x3cdd16)][_0x212953(0x459)], this[_0x212953(_0x31cea2._0x5943e4)][_0x212953(0x2d4)](0x0, 0x40 + 0x32, this['width'], _0x436073); const _0x1b1251 = 'rgb(' + _0x1474b6['r'] * 0.1 * 0xff + ',' + _0x1474b6['g'] * 0.1 * 0xff + ',' + _0x1474b6['b'] * 0.1 * 0xff + ')', _0x633ac9 = _0x436073 - 0xa; _0x633ac9 > 0xa ? (this[_0x212953(_0x31cea2._0x5943e4)][_0x212953(_0x31cea2._0x2abf07)] = _0x1b1251, this[_0x212953(_0x31cea2._0x205ded)][_0x212953(0x2d4)](0xa, 0x40 + 0x32, this['width'] - 0x14, _0x436073 - 0xa)) : this[_0x212953(_0x31cea2._0x549e9d)][_0x212953(_0x31cea2._0x4ce8a6)](0x0, 0x40 + 0x32, this[_0x212953(_0x31cea2._0x59fb7e)], 0x64), _0x633ac9 > this[_0x212953(0x267)]['fontSize'] / 0x4 && (this[_0x212953(0x1a6)][_0x212953(0x51a)] = _0x212953(_0x31cea2._0x428fe4) + this[_0x212953(0x267)][_0x212953(_0x31cea2._0x3709f9)] / 0x4 + _0x212953(0x512), this[_0x212953(_0x31cea2._0x549e9d)][_0x212953(_0x31cea2._0x483f25)] = _0x212953(_0x31cea2._0x1974f8), this[_0x212953(0x1a6)][_0x212953(_0x31cea2._0x5806b9)] = this[_0x212953(_0x31cea2._0x3cdd16)][_0x212953(0x2f3)], this[_0x212953(_0x31cea2._0x1348b9)](this['opts'][_0x212953(_0x31cea2._0x41b26e)], 0xa + 0x2, 0x40 + 0x32 + 0x2, this[_0x212953(_0x31cea2._0x13449c)][_0x212953(_0x31cea2._0x3709f9)] / 0x4)) } [_0x48e965(0x32a)] (_0x2d412c, _0x378706, _0x2ba376, _0x38e19d) { const _0x46b8b7 = { _0xff40c6: 0x15d, _0x144134: 0x1a6, _0x2003de: 0x29b }, _0x101263 = _0x48e965; let _0x1f6a10 = 0x0, _0x5a0844 = this[_0x101263(_0x46b8b7._0xff40c6)] - 0x19, _0x3fa244 = 0x0; for (let _0xadda43 = 0x0; _0xadda43 < _0x2d412c[_0x101263(0x321)]; _0xadda43++) { _0x1f6a10 += this[_0x101263(_0x46b8b7._0x144134)]['measureText'](_0x2d412c[_0xadda43])[_0x101263(_0x46b8b7._0xff40c6)], _0x1f6a10 > _0x5a0844 - _0x378706 && (this['canvasContext'][_0x101263(0x395)](_0x2d412c[_0x101263(_0x46b8b7._0x2003de)](_0x3fa244, _0xadda43), _0x378706, _0x2ba376), _0x2ba376 += _0x38e19d + 0x2, _0x1f6a10 = 0x0, _0x3fa244 = _0xadda43), _0xadda43 == _0x2d412c[_0x101263(0x321)] - 0x1 && this['canvasContext'][_0x101263(0x395)](_0x2d412c[_0x101263(_0x46b8b7._0x2003de)](_0x3fa244, _0xadda43 + 0x1), _0x378706, _0x2ba376) } } [_0x48e965(0x316)] (_0x32da40) { const _0x33b76e = { _0x492777: 0x503, _0x403e79: 0x330 }, _0x497d01 = _0x48e965; this[_0x497d01(0x1aa)] = _0x32da40 ? 0x400 : 0x200, this[_0x497d01(_0x33b76e._0x492777)] = _0x32da40 ? 0x18e : 0xa, this[_0x497d01(_0x33b76e._0x403e79)] = _0x32da40 ? 0x1 : 0x0 } ['setTitle'] (_0x581d9c) { const _0x363765 = { _0x2c977d: 0x321, _0x52e466: 0x4df, _0x1ae9f7: 0x20b, _0x1b1d46: 0x22b }, _0x3da350 = _0x48e965; if (_0x581d9c[_0x3da350(_0x363765._0x2c977d)] < 0x1) return; this[_0x3da350(0x267)][_0x3da350(_0x363765._0x52e466)] = _0x581d9c[_0x3da350(0x181)](), this['drawTitle'](this[_0x3da350(_0x363765._0x1ae9f7)]), this[_0x3da350(_0x363765._0x1b1d46)](this[_0x3da350(0x4d0)]) } [_0x48e965(0x160)] (_0x14ad9a) { const _0x34f04a = { _0x44fbdc: 0x321, _0x59c037: 0x267, _0x45478f: 0x181, _0x1da61a: 0x4d0, _0x4a7999: 0x22b }, _0x3b6ebf = _0x48e965; if (_0x14ad9a[_0x3b6ebf(_0x34f04a._0x44fbdc)] < 0x1) return; this[_0x3b6ebf(_0x34f04a._0x59c037)][_0x3b6ebf(0x28e)] = _0x14ad9a[_0x3b6ebf(_0x34f04a._0x45478f)](); if (this[_0x3b6ebf(_0x34f04a._0x1da61a)] = 0x18e) this[_0x3b6ebf(_0x34f04a._0x4a7999)](0x18e) } [_0x48e965(0x16c)] (_0x5edbf1) { const _0x3dea87 = { _0x28e4ea: 0x267, _0x5ef88e: 0x236, _0x81f182: 0x270, _0x223f77: 0x4d0 }, _0x1f5507 = _0x48e965, _0x27e15b = new Color(_0x5edbf1); this[_0x1f5507(_0x3dea87._0x28e4ea)]['bgColor'] = _0x1f5507(0x180) + _0x27e15b['r'] * 0xff + ',' + _0x27e15b['g'] * 0xff + ',' + _0x27e15b['b'] * 0xff + ',' + this['opts'][_0x1f5507(_0x3dea87._0x5ef88e)] + ')', this[_0x1f5507(_0x3dea87._0x81f182)](this[_0x1f5507(0x20b)]), this['drawText'](this[_0x1f5507(_0x3dea87._0x223f77)]) } } class InformationPopup extends Sprite { [_0x48e965(0x44b)];[_0x48e965(0x267)];[_0x48e965(0x459)];['size'];[_0x48e965(0x345)];['baseSize']; constructor(_0x16867a) { const _0xb24dfe = { _0x48e1b4: 0x459, _0x44e814: 0x459, _0x513bd1: 0x180, _0x48ced6: 0x218, _0x2b1df9: 0x267, _0x5b16a9: 0x1c1, _0x4b3aa1: 0x49f, _0x1c30b0: 0x2be, _0x1351af: 0x49f, _0x4ea07d: 0x267, _0x476788: 0x394, _0x1cbb2a: 0x496, _0x11bfbd: 0x2be }, _0x2c4f1d = { _0x1a512e: 0x264 }, _0x3bc024 = _0x48e965; super(), this['bgColor'] = new Color(_0x16867a?.[_0x3bc024(_0xb24dfe._0x48e1b4)] ? _0x16867a[_0x3bc024(_0xb24dfe._0x44e814)] : _0x3bc024(0x218)), this[_0x3bc024(0x267)] = Object['assign']({ 'title': '', 'text': '', 'fontColor': _0x3bc024(0x47d), 'bgColor': _0x3bc024(_0xb24dfe._0x513bd1) + this[_0x3bc024(0x459)]['r'] * 0xff + ',' + this['bgColor']['g'] * 0xff + ',' + this['bgColor']['b'] * 0xff + ',' + (_0x16867a?.['opacity'] ? _0x16867a[_0x3bc024(0x236)] : 0x1) + ')', 'strokeColor': _0x3bc024(_0xb24dfe._0x48ced6), 'fontSize': 0x40, 'height': 0x0, 'size': 0x1, 'type': 0x0, 'speed': 0x5 }, _0x16867a), this['isInformationPopup'] = !![]; const _0x15fcfc = new RealtimeCavans(this[_0x3bc024(_0xb24dfe._0x2b1df9)]), _0x4766ff = new CanvasTexture(_0x15fcfc[_0x3bc024(0x264)]); this[_0x3bc024(0x2f4)] = new SpriteMaterial({ 'map': _0x4766ff, 'transparent': !![], 'opacity': 0x1 }), this[_0x3bc024(0x394)] = [_0x15fcfc[_0x3bc024(0x15d)], _0x15fcfc['height']], this[_0x3bc024(_0xb24dfe._0x5b16a9)][_0x3bc024(_0xb24dfe._0x4b3aa1)](0.5, 0x0), this[_0x3bc024(0x4c4)][_0x3bc024(0x49f)](0x0, this[_0x3bc024(0x267)][_0x3bc024(0x496)], 0x0), this[_0x3bc024(_0xb24dfe._0x1c30b0)][_0x3bc024(_0xb24dfe._0x1351af)](this[_0x3bc024(_0xb24dfe._0x4ea07d)][_0x3bc024(_0xb24dfe._0x476788)] * _0x15fcfc[_0x3bc024(0x15d)] / 0x200, this[_0x3bc024(0x267)][_0x3bc024(0x394)] * _0x15fcfc[_0x3bc024(_0xb24dfe._0x1cbb2a)] / 0x200, 0x1), this[_0x3bc024(0x36c)] = [this[_0x3bc024(_0xb24dfe._0x1c30b0)]['x'], this[_0x3bc024(_0xb24dfe._0x11bfbd)]['y']], this[_0x3bc024(0x345)] = _0x15fcfc; const _0x3e6ef4 = () => { const _0xa44281 = _0x3bc024; requestAnimationFrame(_0x3e6ef4), this['material'][_0xa44281(0x1ac)] = new CanvasTexture(_0x15fcfc[_0xa44281(_0x2c4f1d._0x1a512e)]) }; _0x3e6ef4() } [_0x48e965(0x1b1)] (_0x3bdf0f) { const _0x3ff22f = _0x48e965; this[_0x3ff22f(0x345)][_0x3ff22f(0x316)](_0x3bdf0f) } [_0x48e965(0x3fb)] (_0xd299ef) { const _0x4398e4 = _0x48e965; this[_0x4398e4(0x345)][_0x4398e4(0x3fb)](_0xd299ef) } [_0x48e965(0x160)] (_0x462447) { const _0x337b70 = { _0x4afe33: 0x345 }, _0x19ec32 = _0x48e965; this[_0x19ec32(_0x337b70._0x4afe33)][_0x19ec32(0x160)](_0x462447) } [_0x48e965(0x16c)] (_0x563800) { const _0x1bb04f = _0x48e965; this[_0x1bb04f(0x345)]['setColor'](_0x563800) } [_0x48e965(0x406)] (_0x4a0cb6) { const _0x28a7ff = _0x48e965; this[_0x28a7ff(0x345)][_0x28a7ff(0x354)] = _0x4a0cb6 } } class InformationTag extends TagBase { [_0x48e965(0x4c6)];[_0x48e965(0x1b6)]; constructor(_0x1fd24c) { const _0x5f3732 = { _0x65eb03: 0x4c6, _0x2da704: 0x4ec, _0x11db5b: 0x400, _0x411413: 0x47d, _0x31f456: 0x2c9, _0x2960a8: 0x44d, _0x5152ca: 0x391, _0x1c3bd1: 0x4c4 }, _0x3e6fe0 = _0x48e965; super(), this[_0x3e6fe0(_0x5f3732._0x65eb03)] = !![]; let _0x12f2ef = { 'lightWallOpts': { 'size': [0x3, 0x3, 0x5], 'color': _0x3e6fe0(_0x5f3732._0x2da704), 'opacity': 0.8 }, 'circleOpts': { 'radius': 0x5, 'color': _0x3e6fe0(_0x5f3732._0x2da704), 'speed': 0.1 }, 'popupOpts': { 'title': '', 'text': _0x3e6fe0(_0x5f3732._0x11db5b), 'fontColor': _0x3e6fe0(_0x5f3732._0x411413), 'bgColor': _0x3e6fe0(_0x5f3732._0x2da704), 'strokeColor': _0x3e6fe0(_0x5f3732._0x2da704), 'fontSize': 0x3c, 'height': 0x0, 'size': 0x5, 'type': 0x0, 'speed': 0x14 } }; Object[_0x3e6fe0(_0x5f3732._0x31f456)](_0x12f2ef, _0x1fd24c); const _0x390e72 = new LightWall(_0x12f2ef[_0x3e6fe0(0x500)]); this[_0x3e6fe0(_0x5f3732._0x2960a8)](_0x390e72); const _0x5cfff0 = new ScanningCirle(_0x12f2ef[_0x3e6fe0(0x2aa)]); this[_0x3e6fe0(0x44d)](_0x5cfff0); const _0x5a7c95 = new InformationPopup(_0x12f2ef[_0x3e6fe0(_0x5f3732._0x5152ca)]); this[_0x3e6fe0(_0x5f3732._0x2960a8)](_0x5a7c95), _0x5a7c95[_0x3e6fe0(_0x5f3732._0x1c3bd1)]['y'] = 0x1, this[_0x3e6fe0(0x1b6)] = 0x1 } [_0x48e965(0x535)] (_0x36c521) { const _0x5af43e = { _0x5db3f9: 0x44b, _0x9a9b0e: 0x4c4, _0xdac0d7: 0x1ef, _0x5dc4bb: 0x1b1 }; this['traverse'](_0x219ca5 => { const _0xea506c = _0x3544; _0x219ca5[_0xea506c(_0x5af43e._0x5db3f9)] && (!_0x36c521 ? new Tween(_0x219ca5[_0xea506c(_0x5af43e._0x9a9b0e)])['to']({ 'y': this[_0xea506c(0x1b6)] })[_0xea506c(_0x5af43e._0xdac0d7)]()['onComplete'](() => { const _0x1c32a5 = _0xea506c; _0x219ca5[_0x1c32a5(0x1b1)](_0x36c521) }) : (_0x219ca5[_0xea506c(_0x5af43e._0x5dc4bb)](_0x36c521), _0x219ca5['setCallBack'](() => { const _0x1a0ee1 = _0xea506c; new Tween(_0x219ca5['position'])['to']({ 'y': this['baseHeightValue'] - 0x2 })[_0x1a0ee1(0x1ef)]() }))) }) } ['changeTitle'] (_0x2b0e98) { const _0x45e4eb = { _0x1eadf9: 0x321 }, _0x2a52c1 = { _0x51d707: 0x44b }, _0x5db8de = _0x48e965; if (_0x2b0e98[_0x5db8de(0x181)]()[_0x5db8de(_0x45e4eb._0x1eadf9)] > 0xc) return; this['traverse'](_0x2971a1 => { const _0x1dc07e = _0x5db8de; if (_0x2971a1[_0x1dc07e(_0x2a52c1._0x51d707)]) _0x2971a1[_0x1dc07e(0x3fb)](_0x2b0e98[_0x1dc07e(0x181)]()) }) } [_0x48e965(0x2cb)] (_0xf6678e) { const _0x10e533 = { _0x352e6f: 0x44b }, _0x10f91e = _0x48e965; this[_0x10f91e(0x4a5)](_0x3edf48 => { const _0x101819 = _0x10f91e; if (_0x3edf48[_0x101819(_0x10e533._0x352e6f)]) _0x3edf48[_0x101819(0x160)](_0xf6678e) }) } [_0x48e965(0x2cf)] (_0x5d8b44) { const _0x1c7b87 = { _0x8a84f7: 0x4a5 }, _0x12d322 = { _0x20e76a: 0x44b, _0x1411a8: 0x443 }, _0x4a5939 = _0x48e965; this[_0x4a5939(_0x1c7b87._0x8a84f7)](_0x51b4e5 => { const _0x247bbd = _0x4a5939; if (_0x51b4e5[_0x247bbd(_0x12d322._0x20e76a)]) _0x51b4e5[_0x247bbd(0x16c)](_0x5d8b44); if (_0x51b4e5[_0x247bbd(_0x12d322._0x1411a8)]) _0x51b4e5['uColor'][_0x247bbd(0x49f)](_0x5d8b44) }) } [_0x48e965(0x17b)] (_0x4718e5) { const _0x51a6d6 = { _0x94e1f6: 0x305, _0x3f38d8: 0x25b, _0x56735d: 0x4a5 }, _0x4db42c = { _0x1f19ba: 0x1b6 }, _0x35a63e = _0x48e965, _0x3e9314 = Math[_0x35a63e(_0x51a6d6._0x94e1f6)](0x0, Math[_0x35a63e(_0x51a6d6._0x3f38d8)](_0x4718e5, 0x64)); this['baseHeightValue'] = _0x3e9314, this[_0x35a63e(_0x51a6d6._0x56735d)](_0x1d2a9e => { const _0x31a37c = _0x35a63e; if (_0x1d2a9e['isInformationPopup']) _0x1d2a9e[_0x31a37c(0x4c4)]['y'] = this[_0x31a37c(_0x4db42c._0x1f19ba)] }) } [_0x48e965(0x2f8)] (_0x4f0d7e) { const _0x5bbf19 = { _0x4f44ea: 0x44b, _0x4ae33d: 0x2be, _0xd9de31: 0x49f, _0x100a6e: 0x36c }, _0x4e9890 = _0x48e965, _0x12cbdb = Math['max'](0x0, Math[_0x4e9890(0x25b)](_0x4f0d7e, 0x64)); this[_0x4e9890(0x4a5)](_0x5d3b21 => { const _0x42b858 = _0x4e9890; if (_0x5d3b21[_0x42b858(_0x5bbf19._0x4f44ea)]) _0x5d3b21[_0x42b858(_0x5bbf19._0x4ae33d)][_0x42b858(_0x5bbf19._0xd9de31)](_0x5d3b21[_0x42b858(_0x5bbf19._0x100a6e)][0x0] * _0x12cbdb, _0x5d3b21[_0x42b858(0x36c)][0x1] * _0x12cbdb) }) } ['setColorOfWall'] (_0x5377c6) { const _0x38bd2c = { _0x3f5232: 0x4a5 }, _0x2cb344 = { _0x5ea931: 0x4bb }, _0x184798 = _0x48e965; this[_0x184798(_0x38bd2c._0x3f5232)](_0x2fd67b => { const _0x3b5ea6 = _0x184798; if (_0x2fd67b[_0x3b5ea6(_0x2cb344._0x5ea931)]) _0x2fd67b['color']['set'](_0x5377c6) }) } } class SpreadRound extends Mesh { [_0x48e965(0x267)];[_0x48e965(0x3cc)];[_0x48e965(0x1b3)]; constructor(_0x58527f) { const _0x4da359 = { _0x41c3f7: 0x4ec, _0x9681c8: 0x267, _0xb2d7d6: 0x3cc, _0x58c1b2: 0x209, _0x1b27d9: 0x2a2, _0x5503d1: 0x540 }, _0x38cb52 = { _0x1d55d9: 0x27b, _0x56f2d7: 0x234 }, _0x517a26 = _0x48e965; super(); let _0x468735 = { 'radius': 0x5, 'color': _0x517a26(_0x4da359._0x41c3f7), 'speed': 0.1 }; Object['assign'](_0x468735, _0x58527f), this[_0x517a26(_0x4da359._0x9681c8)] = _0x468735, this[_0x517a26(_0x4da359._0xb2d7d6)] = _0x468735['speed'], this['isSpreadRound'] = !![]; let _0x3b173e = new Color(_0x468735[_0x517a26(_0x4da359._0x58c1b2)]), _0x24e851 = new Vector2(0x1, 0x1); Object[_0x517a26(_0x4da359._0x1b27d9)](this, { 'uColor': { 'configurable': !![], 'enumerable': !![], 'value': _0x3b173e }, 'spreadRange': { 'configurable': !![], 'enumerable': !![], 'value': _0x24e851 } }), this[_0x517a26(0x303)] = new CircleGeometry(_0x468735[_0x517a26(0x3da)], 0x80), this[_0x517a26(0x247)](-Math['PI'] / 0x2), this[_0x517a26(0x1c2)] = 0x2, this[_0x517a26(0x2f4)] = new ShaderMaterial({ 'side': 0x2, 'transparent': !![], 'uniforms': { 'uColor': { 'value': _0x3b173e }, 'uTime': { 'value': 0x0 }, 'startTime': { 'value': 0x0 }, 'vOpacity': { 'value': 0x1 }, 'uSpeed': { 'value': _0x468735[_0x517a26(_0x4da359._0xb2d7d6)] }, 'uSge': { 'value': 0x4 }, 'spreadRange': { 'value': _0x24e851 } }, 'vertexShader': '\x0a\x20\x20\x20\x20\x20\x20\x20\x20varying\x20vec2\x20uvu;\x0a\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(position,1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uvu\x20=\x20uv;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20', 'fragmentShader': _0x517a26(_0x4da359._0x5503d1) }); const _0x15dd19 = () => { const _0x1cd5e2 = _0x517a26; this['material']['uniforms']['uTime'][_0x1cd5e2(_0x38cb52._0x1d55d9)] += this['speed'] / 0x14; const _0x200688 = this['material']; if (_0x200688[_0x1cd5e2(_0x38cb52._0x56f2d7)][_0x1cd5e2(0x3db)][_0x1cd5e2(0x27b)] < 0.45) _0x200688[_0x1cd5e2(0x234)][_0x1cd5e2(0x3db)][_0x1cd5e2(0x27b)] += 0.01; requestAnimationFrame(_0x15dd19) }; _0x15dd19() } } class PictureDropdownCanvas { [_0x48e965(0x267)];[_0x48e965(0x459)];[_0x48e965(0x264)];[_0x48e965(0x15d)];[_0x48e965(0x496)];[_0x48e965(0x330)];[_0x48e965(0x1aa)];[_0x48e965(0x503)];[_0x48e965(0x1a6)];['titleHeight'];[_0x48e965(0x189)];[_0x48e965(0x184)];['defaultPicture'];[_0x48e965(0x4f3)];[_0x48e965(0x2e4)];[_0x48e965(0x465)]; constructor(_0x278c35) { const _0x308a0c = { _0x1165be: 0x459, _0x363321: 0x180, _0x41634c: 0x519, _0xa04247: 0x264, _0x3228dd: 0x267, _0x1fec37: 0x3df, _0x107c66: 0x181, _0x13e4f3: 0x321, _0x458cf3: 0x189, _0x4f8767: 0x159, _0x84ad78: 0x3b2, _0x433453: 0x15d, _0x230503: 0x496, _0x5c3904: 0x1a6, _0x464f82: 0x264, _0x42cf77: 0x503, _0x556426: 0x4bd }, _0x4c2665 = { _0x12d1f8: 0x330, _0x668396: 0x267, _0x520787: 0x1aa, _0x55e9f1: 0x18e, _0x2c19a3: 0x503, _0xce637c: 0x267, _0x970cca: 0x1aa, _0x4e2c88: 0x503, _0x49ab1c: 0x330, _0x2139cd: 0x1aa, _0x218ed5: 0x1aa, _0x22ee0b: 0x503 }, _0x54ceeb = _0x48e965; this['bgColor'] = new Color(_0x278c35?.['bgColor'] ? _0x278c35[_0x54ceeb(_0x308a0c._0x1165be)] : _0x54ceeb(0x218)), this[_0x54ceeb(0x267)] = Object[_0x54ceeb(0x2c9)]({ 'title': '', 'resourcePath': '', 'defaultResource': '', 'fontColor': '#ffffff', 'bgColor': _0x54ceeb(_0x308a0c._0x363321) + this['bgColor']['r'] * 0xff + ',' + this['bgColor']['g'] * 0xff + ',' + this['bgColor']['b'] * 0xff + ',' + (_0x278c35?.[_0x54ceeb(0x236)] ? _0x278c35['opacity'] : 0x1) + ')', 'strokeColor': _0x54ceeb(0x218), 'fontSize': 0x40, 'speed': 0x14, 'opacity': 0x1 }, _0x278c35); let _0x4da781 = document[_0x54ceeb(_0x308a0c._0x41634c)](_0x54ceeb(_0x308a0c._0xa04247)); this[_0x54ceeb(_0x308a0c._0x3228dd)][_0x54ceeb(_0x308a0c._0x1fec37)][_0x54ceeb(_0x308a0c._0x107c66)]()[_0x54ceeb(_0x308a0c._0x13e4f3)] > 0x0 && (this[_0x54ceeb(_0x308a0c._0x458cf3)] = new Image(), this['resourcePicture'][_0x54ceeb(0x3b2)] = this[_0x54ceeb(0x267)][_0x54ceeb(0x3df)]); this[_0x54ceeb(_0x308a0c._0x3228dd)][_0x54ceeb(0x296)]['trim']()['length'] > 0x0 && (this[_0x54ceeb(0x159)] = new Image(), this[_0x54ceeb(_0x308a0c._0x4f8767)][_0x54ceeb(_0x308a0c._0x84ad78)] = this['opts'][_0x54ceeb(0x296)]); this[_0x54ceeb(_0x308a0c._0x433453)] = 0x400, this['height'] = 0x400, this[_0x54ceeb(0x3b9)] = 0x0, _0x4da781[_0x54ceeb(_0x308a0c._0x433453)] = this[_0x54ceeb(0x15d)], _0x4da781['height'] = this[_0x54ceeb(_0x308a0c._0x230503)], _0x4da781['style'][_0x54ceeb(0x15d)] = this['width'] / 0x2 + 'px', _0x4da781[_0x54ceeb(0x165)][_0x54ceeb(_0x308a0c._0x230503)] = this[_0x54ceeb(0x496)] / 0x2 + 'px'; const _0x2349d3 = _0x4da781[_0x54ceeb(0x44a)]('2d'); this[_0x54ceeb(_0x308a0c._0x5c3904)] = _0x2349d3, this[_0x54ceeb(_0x308a0c._0x464f82)] = _0x4da781, this['status'] = 0x0, this[_0x54ceeb(0x1aa)] = 0x280, this[_0x54ceeb(_0x308a0c._0x42cf77)] = 0x0, this[_0x54ceeb(0x2e4)] = 0x0, this[_0x54ceeb(_0x308a0c._0x556426)](), this['pictureHeight'] = 0x80; const _0xca94a4 = () => { const _0x5986d0 = _0x54ceeb; requestAnimationFrame(_0xca94a4); if (this[_0x5986d0(_0x4c2665._0x12d1f8)] == 0x0) { if (this[_0x5986d0(0x1aa)] >= 0x0 && this[_0x5986d0(0x1aa)] <= 0x280) this[_0x5986d0(0x22b)](this['time1']); this[_0x5986d0(0x1aa)] -= this[_0x5986d0(_0x4c2665._0x668396)]['speed'], this[_0x5986d0(_0x4c2665._0x520787)] < 0x0 && (this[_0x5986d0(_0x4c2665._0x55e9f1)](this[_0x5986d0(_0x4c2665._0x2c19a3)]), this['time2'] += this[_0x5986d0(_0x4c2665._0xce637c)]['speed'], this[_0x5986d0(0x503)] > 0x280 && (this[_0x5986d0(_0x4c2665._0x970cca)] = 0x280, this[_0x5986d0(_0x4c2665._0x4e2c88)] = 0x0, this[_0x5986d0(_0x4c2665._0x49ab1c)] = 0x2)) } else { if (this['status'] == 0x1) { if (this['time2'] > 0x0 && this[_0x5986d0(_0x4c2665._0x4e2c88)] < 0x280) this['drawPictureBackground'](this[_0x5986d0(0x503)]); this[_0x5986d0(_0x4c2665._0x4e2c88)] -= this[_0x5986d0(0x267)]['speed']; if (this['time2'] < 0x0) { if (this['time1'] >= 0x0 && this[_0x5986d0(_0x4c2665._0x2139cd)] <= 0x280) this[_0x5986d0(0x22b)](this[_0x5986d0(0x1aa)]); this[_0x5986d0(_0x4c2665._0x218ed5)] += this[_0x5986d0(_0x4c2665._0x668396)][_0x5986d0(0x3cc)], this[_0x5986d0(0x1aa)] > 0x280 && (this[_0x5986d0(_0x4c2665._0x2139cd)] = 0x280, this[_0x5986d0(_0x4c2665._0x22ee0b)] = 0x0, this[_0x5986d0(0x330)] = 0x2) } } } }; _0xca94a4() } [_0x48e965(0x22b)] (_0x444d1d) { const _0x49e70f = { _0x15d2a8: 0x1a6, _0x192ed3: 0x1e6, _0x1ceeba: 0x279, _0x5f1f77: 0x45e, _0x50e9bd: 0x267, _0x39e9e5: 0x1a6, _0x66f44d: 0x305, _0x2c3dca: 0x459, _0x4f310e: 0x2d4, _0x39a647: 0x475, _0x205a7e: 0x33a, _0x3b0801: 0x15d, _0x3dd0cd: 0x15d, _0x43b9f9: 0x2d4, _0xf34280: 0x1a6, _0x23c102: 0x1a6, _0x4c6c7e: 0x4d6, _0x48e837: 0x1a6, _0x4f6e87: 0x1a6, _0x26671e: 0x1a6, _0x4689e5: 0x395, _0x373474: 0x15d }, _0xbaf386 = _0x48e965; if (_0x444d1d < 0x0 || _0x444d1d > 0x280) return; this[_0xbaf386(0x3b9)] = _0x444d1d, this[_0xbaf386(_0x49e70f._0x15d2a8)]['font'] = _0xbaf386(_0x49e70f._0x192ed3) + this[_0xbaf386(0x267)]['fontSize'] + _0xbaf386(0x512), ColorRGBA[_0xbaf386(0x45e)](this[_0xbaf386(0x267)][_0xbaf386(_0x49e70f._0x1ceeba)]); const _0x2fdda4 = ColorRGBA[_0xbaf386(_0x49e70f._0x5f1f77)](this[_0xbaf386(_0x49e70f._0x50e9bd)][_0xbaf386(0x459)]); let _0x2c65c1 = this[_0xbaf386(_0x49e70f._0x39e9e5)][_0xbaf386(0x30b)](this[_0xbaf386(0x267)][_0xbaf386(0x4df)])[_0xbaf386(0x15d)]; _0x2c65c1 = Math[_0xbaf386(_0x49e70f._0x66f44d)](0x40, Math[_0xbaf386(0x25b)](_0x2c65c1, 0x400 - 0x80)), this[_0xbaf386(0x1a6)][_0xbaf386(0x1fc)](0x0, 0x0, this['width'], 0x80 + 0x280), this[_0xbaf386(_0x49e70f._0x39e9e5)][_0xbaf386(0x475)] = this[_0xbaf386(_0x49e70f._0x50e9bd)][_0xbaf386(_0x49e70f._0x2c3dca)], this['canvasContext'][_0xbaf386(_0x49e70f._0x4f310e)](this['width'] / 0x2 - _0x2c65c1 * 0.6, _0x444d1d, _0x2c65c1 * 1.2, 0x80); const _0x308dec = _0xbaf386(0x498) + (_0x2fdda4['r'] + 0.1) * 0xff + ',' + (_0x2fdda4['g'] + 0.1) * 0xff + ',' + (_0x2fdda4['b'] + 0.1) * 0xff + ')'; this[_0xbaf386(_0x49e70f._0x15d2a8)][_0xbaf386(_0x49e70f._0x39a647)] = _0x308dec, this[_0xbaf386(0x1a6)][_0xbaf386(_0x49e70f._0x4f310e)](this[_0xbaf386(0x15d)] / 0x2 - _0x2c65c1 * 0.6, _0x444d1d + 0x14, 0x8, 0x80 - 0x28); let _0x25bfc2 = this['canvasContext'][_0xbaf386(_0x49e70f._0x205a7e)](this[_0xbaf386(0x15d)] / 0x2 - _0x2c65c1 * 0.6, _0x444d1d, this[_0xbaf386(_0x49e70f._0x3b0801)] / 0x2 + _0x2c65c1 * 0.6, _0x444d1d); _0x25bfc2['addColorStop'](0x0, _0x308dec), _0x25bfc2['addColorStop'](0x1, this[_0xbaf386(_0x49e70f._0x50e9bd)]['bgColor']), this[_0xbaf386(0x1a6)]['fillStyle'] = _0x25bfc2, this[_0xbaf386(_0x49e70f._0x15d2a8)]['fillRect'](this[_0xbaf386(0x15d)] / 0x2 - _0x2c65c1 * 0.6, _0x444d1d, _0x2c65c1 * 1.2, 0x4), this[_0xbaf386(0x1a6)]['fillRect'](this[_0xbaf386(_0x49e70f._0x3dd0cd)] / 0x2 - _0x2c65c1 * 0.6, _0x444d1d + 0x80 - 0x5, _0x2c65c1 * 1.2, 0x4); for (let _0x5362a5 = 0x0; _0x5362a5 < 0xa; _0x5362a5++) { this[_0xbaf386(0x1a6)][_0xbaf386(_0x49e70f._0x43b9f9)](this[_0xbaf386(_0x49e70f._0x3dd0cd)] / 0x2 - _0x2c65c1 * 0.6 + _0x2c65c1 * 1.2 / 0xb * (_0x5362a5 + 0x1), _0x444d1d, 0x2, 0x80) } for (let _0x32abfb = 0x0; _0x32abfb < 0x3; _0x32abfb++) { this[_0xbaf386(_0x49e70f._0xf34280)][_0xbaf386(0x2d4)](this[_0xbaf386(_0x49e70f._0x3b0801)] / 0x2 - _0x2c65c1 * 0.6 + _0x2c65c1 * 1.2 / 0x3, _0x444d1d + 0x80 / 0x4 * (_0x32abfb + 0x1), _0x2c65c1 * 1.2 / 0x3, 0x2) } this[_0xbaf386(_0x49e70f._0x23c102)][_0xbaf386(0x51a)] = _0xbaf386(0x1e6) + this[_0xbaf386(0x267)][_0xbaf386(_0x49e70f._0x4c6c7e)] + _0xbaf386(0x512), this[_0xbaf386(_0x49e70f._0x48e837)][_0xbaf386(0x488)] = _0xbaf386(0x2eb), this[_0xbaf386(_0x49e70f._0x4f6e87)]['fillStyle'] = this[_0xbaf386(0x267)]['fontColor'], this[_0xbaf386(_0x49e70f._0x26671e)][_0xbaf386(_0x49e70f._0x4689e5)](this['opts'][_0xbaf386(0x4df)], (this[_0xbaf386(_0x49e70f._0x373474)] - this['canvasContext']['measureText'](this['opts']['title'])['width']) / 0x2, _0x444d1d + 0x40 - this[_0xbaf386(0x267)][_0xbaf386(_0x49e70f._0x4c6c7e)] / 0x2) } [_0x48e965(0x18e)] (_0x4f7409) { const _0x213cdb = { _0xc2eaab: 0x1a6, _0x357581: 0x1a6 }, _0x332851 = _0x48e965; if (_0x4f7409 < 0x0 || _0x4f7409 > 0x280) return; this[_0x332851(_0x213cdb._0xc2eaab)]['clearRect'](0x0, 0x80, this['width'], 0x280), this[_0x332851(0x1a6)][_0x332851(0x475)] = 'rgba(5,5,5,.5)', this[_0x332851(_0x213cdb._0x357581)]['fillRect'](0x0, 0x80, this['width'], _0x4f7409), this[_0x332851(0x27c)](_0x4f7409) } [_0x48e965(0x4bd)] () { const _0xaa4335 = { _0x5c49ca: 0x1a6, _0x475557: 0x1fc, _0x5a1059: 0x2d4, _0x359fcc: 0x36b, _0x50c9da: 0x280, _0x3290a9: 0x1a6, _0x5cac91: 0x1e8, _0x5d348c: 0x15d, _0x192142: 0x1a6, _0x50ca71: 0x15d, _0x12280a: 0x496, _0x7d75a0: 0x1a6, _0x1a0ba1: 0x1a6, _0x105724: 0x1e8, _0x48ab65: 0x214, _0x339026: 0x534, _0x5830c4: 0x496, _0x2ca056: 0x1a6, _0x3bb66e: 0x1a6, _0x5d424e: 0x15d, _0x27b969: 0x1a6 }, _0xe32722 = _0x48e965; this[_0xe32722(_0xaa4335._0x5c49ca)][_0xe32722(_0xaa4335._0x475557)](0x0, 0x300, this[_0xe32722(0x15d)], 0x400 - 0x300), this[_0xe32722(_0xaa4335._0x5c49ca)]['fillStyle'] = _0xe32722(0x280), this[_0xe32722(0x1a6)][_0xe32722(0x2d4)](this['width'] / 0x2 - 0xa, 0x2f6, 0x14, 0x28), this[_0xe32722(0x1a6)][_0xe32722(_0xaa4335._0x5a1059)](this[_0xe32722(0x15d)] / 0x2 - 0x4, 0x31e, 0x8, 0x400 - 0x31e - 0x32), this['canvasContext'][_0xe32722(_0xaa4335._0x359fcc)] = _0xe32722(_0xaa4335._0x50c9da), this[_0xe32722(_0xaa4335._0x3290a9)][_0xe32722(_0xaa4335._0x5cac91)](), this[_0xe32722(_0xaa4335._0x5c49ca)][_0xe32722(0x534)](this[_0xe32722(0x15d)] / 0x2 - 0x14, this[_0xe32722(0x496)] - 0x2d), this[_0xe32722(0x1a6)]['lineTo'](this[_0xe32722(_0xaa4335._0x5d348c)] / 0x2 + 0x14, this[_0xe32722(0x496)] - 0x5), this[_0xe32722(_0xaa4335._0x192142)]['moveTo'](this[_0xe32722(_0xaa4335._0x50ca71)] / 0x2 + 0x14, this[_0xe32722(0x496)] - 0x2d), this[_0xe32722(_0xaa4335._0x192142)]['lineTo'](this[_0xe32722(0x15d)] / 0x2 - 0x14, this[_0xe32722(_0xaa4335._0x12280a)] - 0x5), this[_0xe32722(_0xaa4335._0x7d75a0)][_0xe32722(0x2dc)] = 0x4, this[_0xe32722(0x1a6)]['stroke'](), this[_0xe32722(0x1a6)][_0xe32722(0x475)] = _0xe32722(0x216), this[_0xe32722(0x1a6)][_0xe32722(0x36b)] = _0xe32722(0x216), this[_0xe32722(_0xaa4335._0x1a0ba1)][_0xe32722(_0xaa4335._0x105724)](), this[_0xe32722(0x1a6)][_0xe32722(0x534)](this[_0xe32722(_0xaa4335._0x5d348c)] / 0x2, this[_0xe32722(0x496)] - 0x32), this[_0xe32722(_0xaa4335._0x192142)][_0xe32722(_0xaa4335._0x48ab65)](this['width'] / 0x2, this[_0xe32722(0x496)] - 0x28), this['canvasContext'][_0xe32722(_0xaa4335._0x339026)](this[_0xe32722(_0xaa4335._0x50ca71)] / 0x2 - 1.5, this[_0xe32722(_0xaa4335._0x5830c4)] - 0xa), this[_0xe32722(_0xaa4335._0x3290a9)][_0xe32722(0x214)](this[_0xe32722(0x15d)] / 0x2 - 1.5, this['height']), this[_0xe32722(0x1a6)][_0xe32722(0x534)](this[_0xe32722(_0xaa4335._0x5d348c)] / 0x2 - 0x28, this['height'] - 0x17), this[_0xe32722(_0xaa4335._0x2ca056)][_0xe32722(0x214)](this[_0xe32722(_0xaa4335._0x5d348c)] / 0x2 - 0xa, this[_0xe32722(0x496)] - 0x17), this[_0xe32722(_0xaa4335._0x3bb66e)][_0xe32722(_0xaa4335._0x339026)](this[_0xe32722(_0xaa4335._0x5d424e)] / 0x2 + 0x28, this[_0xe32722(0x496)] - 0x17), this[_0xe32722(0x1a6)][_0xe32722(0x214)](this[_0xe32722(0x15d)] / 0x2 + 0xa, this[_0xe32722(_0xaa4335._0x5830c4)] - 0x17), this[_0xe32722(_0xaa4335._0x27b969)][_0xe32722(0x2dc)] = 0x3, this[_0xe32722(0x1a6)]['stroke']() } [_0x48e965(0x27c)] (_0x49a511) { const _0x294127 = { _0x5a06ca: 0x267, _0x4c1b64: 0x3df, _0x1fa9f2: 0x2e4, _0x1fc801: 0x321, _0x967dff: 0x15d, _0x3cbf43: 0x25b, _0x124480: 0x465, _0x134c3c: 0x496, _0x291050: 0x1a6, _0x451865: 0x398, _0x16e8ac: 0x496, _0x145508: 0x15d, _0x145674: 0x398 }, _0x59a806 = _0x48e965; if (_0x49a511 <= 0x0) return; if (this[_0x59a806(_0x294127._0x5a06ca)][_0x59a806(_0x294127._0x4c1b64)][_0x59a806(0x181)]()[_0x59a806(0x321)] < 0x1 && this[_0x59a806(0x267)][_0x59a806(0x296)][_0x59a806(0x181)]()[_0x59a806(0x321)] < 0x1) return; const _0x29c52e = this[_0x59a806(_0x294127._0x1fa9f2)]; let _0x1363af = this['opts']['resourcePath'][_0x59a806(0x181)]()[_0x59a806(_0x294127._0x1fc801)] > 0x1 ? this['resourcePicture'] : this['defaultPicture']; const _0xea5988 = this[_0x59a806(0x15d)], _0x591122 = _0x1363af[_0x59a806(_0x294127._0x967dff)] / _0xea5988 > 0x1 ? 0x1 : _0x1363af[_0x59a806(0x15d)] / _0xea5988, _0x4d79ea = Math['max'](0xa, _0xea5988 / 0x2 - _0x591122 * _0xea5988 / 0x2); let _0x1e5aa0 = 0x8a, _0x541576 = Math[_0x59a806(_0x294127._0x3cbf43)](0x276, _0x49a511); this[_0x59a806(_0x294127._0x124480)] = _0x541576, _0x1363af[_0x59a806(_0x294127._0x134c3c)] / _0x541576 > 0x1 ? 0x1 : _0x1363af[_0x59a806(_0x294127._0x134c3c)] / _0x541576; if (_0x29c52e == 0x0) this[_0x59a806(_0x294127._0x291050)][_0x59a806(_0x294127._0x451865)](_0x1363af, _0x4d79ea, _0x1e5aa0, Math['min'](this[_0x59a806(_0x294127._0x967dff)] - 0xa, _0x591122 * _0xea5988), _0x541576); else { if (_0x29c52e == 0x1) this[_0x59a806(0x1a6)]['drawImage'](_0x1363af, _0x1363af['width'] / 0x4, _0x1363af[_0x59a806(_0x294127._0x16e8ac)] / 0x4, _0x1363af[_0x59a806(_0x294127._0x145508)] / 0x2, _0x1363af[_0x59a806(0x496)] / 0x2, 0xa, _0x1e5aa0, this[_0x59a806(_0x294127._0x145508)] - 0x14, _0x541576); else _0x29c52e == 0x2 && this[_0x59a806(0x1a6)][_0x59a806(_0x294127._0x145674)](_0x1363af, 0xa, _0x1e5aa0, this['width'] - 0x14, _0x541576) } } [_0x48e965(0x42b)] (_0x5a4ef8) { const _0x349b21 = { _0xb4116f: 0x21c, _0x5d9dc0: 0x304, _0x4d233a: 0x159, _0x3c478e: 0x320 }, _0x487250 = { _0x59427b: 0x4f3 }, _0x106118 = { _0x10398a: 0x4f3, _0x4f81d3: 0x321 }, _0x20cf99 = _0x48e965, _0x32d3b3 = _0x5a4ef8[_0x20cf99(0x181)](); if (_0x32d3b3[_0x20cf99(0x321)] < 0x1) return console[_0x20cf99(_0x349b21._0xb4116f)](_0x20cf99(_0x349b21._0x5d9dc0)); this[_0x20cf99(0x4f3)] = 0x0, this[_0x20cf99(0x159)]['src'] = _0x32d3b3, this[_0x20cf99(_0x349b21._0x4d233a)][_0x20cf99(_0x349b21._0x3c478e)] = () => { const _0x309154 = _0x20cf99; this[_0x309154(_0x106118._0x10398a)] = 0x1; if (this[_0x309154(0x189)][_0x309154(0x3b2)][_0x309154(_0x106118._0x4f81d3)] < 0x1) { if (this[_0x309154(0x465)] == 0x276) this[_0x309154(0x18e)](0x280) } }, this[_0x20cf99(_0x349b21._0x4d233a)]['onerror'] = () => { const _0x47b5d3 = _0x20cf99; this[_0x47b5d3(_0x487250._0x59427b)] = 0x2 } } [_0x48e965(0x242)] (_0x12387d) { const _0x1c748b = { _0xa6f07c: 0x21c, _0x4e125c: 0x304, _0x30f523: 0x189, _0x505fd2: 0x3b2, _0x4e06b3: 0x189, _0x538548: 0x320 }, _0x58ae77 = { _0x970dba: 0x465, _0x1901d5: 0x18e }, _0xdd2162 = _0x48e965, _0x267ddd = _0x12387d[_0xdd2162(0x181)](); if (_0x267ddd['length'] < 0x1) return console[_0xdd2162(_0x1c748b._0xa6f07c)](_0xdd2162(_0x1c748b._0x4e125c)); this['resourcePictureStatus'] = 0x0, this[_0xdd2162(_0x1c748b._0x30f523)][_0xdd2162(_0x1c748b._0x505fd2)] = _0x267ddd, this[_0xdd2162(_0x1c748b._0x4e06b3)][_0xdd2162(_0x1c748b._0x538548)] = () => { const _0x417458 = _0xdd2162; this['resourcePictureStatus'] = 0x1; if (this[_0x417458(_0x58ae77._0x970dba)] == 0x276) this[_0x417458(_0x58ae77._0x1901d5)](0x280) }, this[_0xdd2162(_0x1c748b._0x30f523)][_0xdd2162(0x4e6)] = () => { const _0x144886 = _0xdd2162; this[_0x144886(0x184)] = 0x2 } } [_0x48e965(0x4a3)] (_0x384fd0) { const _0x3af098 = { _0x55634c: 0x25c, _0x376b1f: 0x2e4, _0x8e740: 0x465 }, _0x1e00b5 = _0x48e965; if (_0x384fd0 > 0x2 || _0x384fd0 < 0x0) return console['warn'](_0x1e00b5(_0x3af098._0x55634c)); this[_0x1e00b5(_0x3af098._0x376b1f)] = _0x384fd0, this[_0x1e00b5(_0x3af098._0x8e740)] == 0x276 && this['drawPictureBackground'](0x280) } [_0x48e965(0x1ce)] (_0x339b23) { const _0x4e4de0 = { _0x34429f: 0x321, _0x10f08d: 0x267, _0x383536: 0x3b9, _0x2a6529: 0x3b9, _0x2287fb: 0x18e }, _0x47216c = _0x48e965, _0x2d69b3 = _0x339b23[_0x47216c(0x181)](); if (_0x2d69b3['length'] < 0x1 || _0x2d69b3[_0x47216c(_0x4e4de0._0x34429f)] > 0x12) return; this[_0x47216c(_0x4e4de0._0x10f08d)]['title'] = _0x2d69b3, console[_0x47216c(0x1b0)](this[_0x47216c(_0x4e4de0._0x383536)]); this[_0x47216c(_0x4e4de0._0x2a6529)] == 0xa && (this['drawText'](this[_0x47216c(_0x4e4de0._0x383536)]), this[_0x47216c(_0x4e4de0._0x2287fb)](0x280)); if (this[_0x47216c(0x3b9)] == 0x276) this[_0x47216c(0x22b)](this[_0x47216c(_0x4e4de0._0x383536)]) } [_0x48e965(0x2cf)] (_0xd3002c) { const _0x380bd1 = { _0x29c6e5: 0x459, _0x712906: 0x180, _0x10daee: 0x3b9, _0x787c85: 0x3b9 }, _0xbd7b67 = _0x48e965, _0x52c49d = new Color(_0xd3002c); this[_0xbd7b67(0x267)][_0xbd7b67(_0x380bd1._0x29c6e5)] = _0xbd7b67(_0x380bd1._0x712906) + _0x52c49d['r'] * 0xff + ',' + _0x52c49d['g'] * 0xff + ',' + _0x52c49d['b'] * 0xff + ',' + this[_0xbd7b67(0x267)][_0xbd7b67(0x236)] + ')'; this[_0xbd7b67(0x3b9)] == 0xa && (this['drawText'](this[_0xbd7b67(_0x380bd1._0x10daee)]), this['drawPictureBackground'](0x280)); if (this[_0xbd7b67(_0x380bd1._0x787c85)] == 0x276) this[_0xbd7b67(0x22b)](this[_0xbd7b67(_0x380bd1._0x10daee)]) } [_0x48e965(0x316)] (_0x586edc) { const _0x8ada9e = { _0xa7c34f: 0x503 }, _0x4a7926 = _0x48e965; this[_0x4a7926(0x1aa)] = _0x586edc ? 0x0 : 0x280, this[_0x4a7926(_0x8ada9e._0xa7c34f)] = _0x586edc ? 0x280 : 0x0, this[_0x4a7926(0x330)] = _0x586edc ? 0x1 : 0x0 } } class PicturePopup extends Sprite { ['isPicturePopup'];[_0x48e965(0x267)];['bgColor'];[_0x48e965(0x394)];[_0x48e965(0x345)];[_0x48e965(0x36c)]; constructor(_0x141c52) { const _0x2fef45 = { _0x1ec959: 0x2c9, _0x220dd2: 0x236, _0xce0487: 0x218, _0x2954c6: 0x355, _0x4171c5: 0x394, _0x44fef2: 0x15d, _0x1adb1d: 0x49f, _0x487562: 0x496, _0x1a0954: 0x49f, _0x15992d: 0x267 }, _0x50c259 = { _0x47e74a: 0x264 }, _0x11ecf0 = _0x48e965; super(), this['bgColor'] = new Color(_0x141c52?.[_0x11ecf0(0x459)] ? _0x141c52['bgColor'] : _0x11ecf0(0x218)), this['opts'] = Object[_0x11ecf0(_0x2fef45._0x1ec959)]({ 'title': '', 'resourcePath': '', 'defaultResource': '', 'fontColor': _0x11ecf0(0x47d), 'bgColor': _0x11ecf0(0x180) + this[_0x11ecf0(0x459)]['r'] * 0xff + ',' + this['bgColor']['g'] * 0xff + ',' + this[_0x11ecf0(0x459)]['b'] * 0xff + ',' + (_0x141c52?.[_0x11ecf0(0x236)] ? _0x141c52[_0x11ecf0(_0x2fef45._0x220dd2)] : 0x1) + ')', 'strokeColor': _0x11ecf0(_0x2fef45._0xce0487), 'fontSize': 0x40, 'height': 0x0, 'size': 0x1, 'type': 0x0, 'speed': 0x5 }, _0x141c52), this[_0x11ecf0(_0x2fef45._0x2954c6)] = !![]; const _0x3d63c0 = new PictureDropdownCanvas(this[_0x11ecf0(0x267)]), _0x5cfe22 = new CanvasTexture(_0x3d63c0[_0x11ecf0(0x264)]); this[_0x11ecf0(0x2f4)] = new SpriteMaterial({ 'map': _0x5cfe22, 'transparent': !![], 'opacity': 0x1 }), this[_0x11ecf0(_0x2fef45._0x4171c5)] = [_0x3d63c0[_0x11ecf0(_0x2fef45._0x44fef2)], _0x3d63c0[_0x11ecf0(0x496)]], this['center'][_0x11ecf0(_0x2fef45._0x1adb1d)](0.5, 0x0), this['position']['set'](0x0, this['opts'][_0x11ecf0(_0x2fef45._0x487562)], 0x0), this[_0x11ecf0(0x2be)][_0x11ecf0(_0x2fef45._0x1a0954)](this[_0x11ecf0(_0x2fef45._0x15992d)][_0x11ecf0(0x394)] * _0x3d63c0['width'] / 0x200, this[_0x11ecf0(0x267)][_0x11ecf0(0x394)] * _0x3d63c0[_0x11ecf0(0x496)] / 0x200, 0x1), this[_0x11ecf0(0x36c)] = [this['scale']['x'], this[_0x11ecf0(0x2be)]['y']], this[_0x11ecf0(0x345)] = _0x3d63c0; const _0x16bfc9 = () => { const _0x15d1b7 = _0x11ecf0; requestAnimationFrame(_0x16bfc9), this[_0x15d1b7(0x2f4)][_0x15d1b7(0x1ac)] = new CanvasTexture(_0x3d63c0[_0x15d1b7(_0x50c259._0x47e74a)]) }; _0x16bfc9() } ['popupAnimation'] (_0x3c620d) { const _0x26c4e4 = { _0x2aacf1: 0x345, _0x3081cf: 0x316 }, _0x1a62dc = _0x48e965; this[_0x1a62dc(_0x26c4e4._0x2aacf1)][_0x1a62dc(_0x26c4e4._0x3081cf)](_0x3c620d) } [_0x48e965(0x3fb)] (_0x5c8bac) { const _0x566e60 = { _0x1ab2c4: 0x1ce }, _0x49843b = _0x48e965; this[_0x49843b(0x345)][_0x49843b(_0x566e60._0x1ab2c4)](_0x5c8bac) } [_0x48e965(0x16c)] (_0x4cf838) { const _0x1e488c = { _0x21c648: 0x345 }, _0x2a5ac0 = _0x48e965; this[_0x2a5ac0(_0x1e488c._0x21c648)]['changeColor'](_0x4cf838) } [_0x48e965(0x262)] (_0x194fdd) { const _0x58c961 = _0x48e965; if (_0x194fdd < 0x0 || _0x194fdd > 0x2) return; this[_0x58c961(0x345)]['switchMode'](_0x194fdd) } [_0x48e965(0x463)] (_0x467d8b) { const _0x3f6243 = { _0x39c95f: 0x345, _0x335b36: 0x42b }, _0xd0057 = _0x48e965; this[_0xd0057(_0x3f6243._0x39c95f)][_0xd0057(_0x3f6243._0x335b36)](_0x467d8b) } ['changeResourcePicture'] (_0x2d4d66) { const _0x3a89e8 = _0x48e965; this[_0x3a89e8(0x345)][_0x3a89e8(0x242)](_0x2d4d66) } } class PictureDropdownTag extends TagBase { ['isPictureDropdownTag'];[_0x48e965(0x1b6)]; constructor(_0x1c035e) { const _0x5a178d = { _0x428785: 0x500, _0x384022: 0x44d, _0x5dd6f8: 0x44d, _0x1c6230: 0x394 }, _0x1b2cbe = _0x48e965; super(); let _0xe2ae5c = { 'lightWallOpts': { 'size': [0x3, 0x3, 0x5], 'color': '#0954ed', 'opacity': 0.8 }, 'spreadRoundOpts': { 'radius': 0x5, 'color': _0x1b2cbe(0x4ec), 'speed': 0.1 }, 'picturePopupOpts': { 'title': '', 'resourcePath': '', 'defaultResource': '', 'fontColor': _0x1b2cbe(0x47d), 'bgColor': '#0954ed', 'strokeColor': '#ff0000', 'fontSize': 0x40, 'height': 0x0, 'size': 0x5, 'type': 0x0, 'speed': 0x1e } }; this[_0x1b2cbe(0x255)] = !![], Object[_0x1b2cbe(0x2c9)](_0xe2ae5c, _0x1c035e); const _0x1cd119 = new LightWall(_0xe2ae5c[_0x1b2cbe(_0x5a178d._0x428785)]); this[_0x1b2cbe(_0x5a178d._0x384022)](_0x1cd119); const _0x2fbc61 = new SpreadRound(_0xe2ae5c['spreadRoundOpts']); this[_0x1b2cbe(_0x5a178d._0x5dd6f8)](_0x2fbc61); const _0x26d122 = new PicturePopup(_0xe2ae5c['picturePopupOpts']); this[_0x1b2cbe(0x44d)](_0x26d122), _0x26d122['position']['y'] = 0x4, this['baseHeightValue'] = 0x4, this['computedSpreadCircle'](_0xe2ae5c[_0x1b2cbe(_0x5a178d._0x428785)][_0x1b2cbe(_0x5a178d._0x1c6230)][0x0], _0xe2ae5c['spreadRoundOpts']['radius']) } [_0x48e965(0x2d8)] (_0x1a7254, _0x564f2b) { const _0x42526b = { _0x4e0806: 0x1b3, _0x5379b7: 0x49f }, _0x2a92bf = _0x48e965, _0x249e33 = _0x1a7254 / _0x564f2b; this[_0x2a92bf(0x4a5)](_0x5bd77c => { const _0x21c86b = _0x2a92bf; _0x5bd77c[_0x21c86b(_0x42526b._0x4e0806)] && _0x5bd77c['spreadRange'][_0x21c86b(_0x42526b._0x5379b7)](_0x249e33 * 0.5, _0x249e33 * 0.5) }) } [_0x48e965(0x535)] (_0x5a48bf) { const _0x205241 = { _0x18ef04: 0x1b1 }; this['traverse'](_0x54c0dc => { const _0xb33be2 = _0x3544; if (_0x54c0dc[_0xb33be2(0x355)]) _0x54c0dc[_0xb33be2(_0x205241._0x18ef04)](_0x5a48bf) }) } [_0x48e965(0x1ce)] (_0x169b5b) { const _0x3ddbcc = _0x48e965; this[_0x3ddbcc(0x4a5)](_0x55ba7e => { const _0x237fc2 = _0x3ddbcc; if (_0x55ba7e['isPicturePopup']) _0x55ba7e[_0x237fc2(0x3fb)](_0x169b5b) }) } [_0x48e965(0x2cf)] (_0x295e52) { const _0x54c091 = { _0x2e7f6b: 0x1b3, _0x257ac5: 0x49f }, _0x11ddc0 = _0x48e965; this[_0x11ddc0(0x4a5)](_0x50fd4d => { const _0x28866f = _0x11ddc0; if (_0x50fd4d[_0x28866f(0x355)]) _0x50fd4d[_0x28866f(0x16c)](_0x295e52); if (_0x50fd4d[_0x28866f(_0x54c091._0x2e7f6b)]) _0x50fd4d['uColor'][_0x28866f(_0x54c091._0x257ac5)](_0x295e52) }) } [_0x48e965(0x262)] (_0x50be76) { const _0x5ee807 = { _0x2cb428: 0x355, _0x2e1478: 0x262 }, _0xd6cbc9 = _0x48e965; this[_0xd6cbc9(0x4a5)](_0x5dd1a1 => { const _0x2b50a1 = _0xd6cbc9; if (_0x5dd1a1[_0x2b50a1(_0x5ee807._0x2cb428)]) _0x5dd1a1[_0x2b50a1(_0x5ee807._0x2e1478)](_0x50be76) }) } [_0x48e965(0x463)] (_0x3a773d) { const _0x3d475e = { _0x5719ca: 0x463 }; this['traverse'](_0xa4c639 => { const _0x5cb686 = _0x3544; if (_0xa4c639[_0x5cb686(0x355)]) _0xa4c639[_0x5cb686(_0x3d475e._0x5719ca)](_0x3a773d) }) } [_0x48e965(0x243)] (_0x111c8c) { this['traverse'](_0x4d1318 => { const _0xda5900 = _0x3544; if (_0x4d1318[_0xda5900(0x355)]) _0x4d1318[_0xda5900(0x243)](_0x111c8c) }) } [_0x48e965(0x2f8)] (_0x1b1a9d) { const _0x419519 = { _0x5d0572: 0x305 }, _0x4bc0b7 = { _0x30ab9e: 0x36c }, _0x9ca31c = _0x48e965, _0x3c325d = Math[_0x9ca31c(_0x419519._0x5d0572)](0x0, Math['min'](_0x1b1a9d, 0x64)); this[_0x9ca31c(0x4a5)](_0x5f09d => { const _0x1cee75 = _0x9ca31c; if (_0x5f09d['isPicturePopup']) _0x5f09d[_0x1cee75(0x2be)]['set'](_0x5f09d['baseSize'][0x0] * _0x3c325d, _0x5f09d[_0x1cee75(_0x4bc0b7._0x30ab9e)][0x1] * _0x3c325d) }) } [_0x48e965(0x17b)] (_0x50cf2f) { const _0x4405c4 = { _0x267659: 0x25b, _0x4a17d2: 0x4a5 }, _0x1bca06 = _0x48e965, _0x4afc55 = Math[_0x1bca06(0x305)](0x0, Math[_0x1bca06(_0x4405c4._0x267659)](_0x50cf2f, 0x64)); this['baseHeightValue'] = _0x4afc55, this[_0x1bca06(_0x4405c4._0x4a17d2)](_0x2e4fd7 => { const _0x102f75 = _0x1bca06; if (_0x2e4fd7['isPicturePopup']) _0x2e4fd7['position']['y'] = this[_0x102f75(0x1b6)] }) } } class Water extends Mesh { constructor(_0x5324a3, _0x2d7b86 = {}) { const _0x259dcc = { _0x4e1d4d: 0x42c, _0x1fc18c: 0x42c, _0x475f69: 0x4c5, _0x35d660: 0x183, _0x45845d: 0x281, _0x40fec2: 0x1a7, _0x41c12d: 0x52a, _0x41659b: 0x1ec, _0x50fd0f: 0x215, _0x3c1dbc: 0x49a, _0x4810b5: 0x223, _0x53222b: 0x1ba, _0x139edf: 0x3c3, _0xd63b0a: 0x223, _0x452d32: 0x3ea, _0x342047: 0x444, _0x3440c8: 0x42e, _0x2c1362: 0x234, _0x524529: 0x1ba, _0x24dfc4: 0x27b, _0x2353d7: 0x234, _0x89dcad: 0x234, _0x56c72f: 0x27b, _0x32083b: 0x52a, _0x3a56b5: 0x27b, _0x2e54a8: 0x1a7, _0x566952: 0x215, _0x337da5: 0x234, _0x1fabaa: 0x27b, _0x4927ad: 0x2f4, _0x11b4ba: 0x435 }, _0x1edc83 = { _0x49cd01: 0x2bb, _0x530367: 0x272, _0x1590d4: 0x2bb, _0x35e5a3: 0x49f, _0x249ad2: 0x317, _0x29f6d1: 0x44d, _0x439038: 0x22a, _0x70926c: 0x24a, _0xc22b09: 0x4d8, _0xc319d4: 0x4c4, _0xfa0aba: 0x24a, _0x5ab439: 0x21b, _0x30a472: 0x332, _0xcc7083: 0x332, _0x3819f5: 0x4d9, _0x3382c0: 0x4f4, _0x50786d: 0x533, _0x54a59b: 0x24a, _0x1e18b9: 0x3a8, _0x38b465: 0x3a8, _0x40a809: 0x332, _0x4ca1a0: 0x3c4, _0x4b462a: 0x3c4, _0x47ae98: 0x1d6, _0x5d61d0: 0x2d2, _0xf795de: 0x301, _0x364ad9: 0x2b1, _0xe3c18c: 0x244, _0x48a058: 0x289, _0x38a738: 0x244, _0x5e3e81: 0x301, _0x3708ab: 0x43f, _0xeefd23: 0x43f }, _0x2327cc = _0x48e965; super(_0x5324a3); const _0x367a1e = this, _0x399f40 = _0x2d7b86[_0x2327cc(_0x259dcc._0x4e1d4d)] !== undefined ? _0x2d7b86[_0x2327cc(_0x259dcc._0x1fc18c)] : 0x200, _0xe3a63f = _0x2d7b86[_0x2327cc(0x4c5)] !== undefined ? _0x2d7b86[_0x2327cc(_0x259dcc._0x475f69)] : 0x200, _0x5717a2 = _0x2d7b86[_0x2327cc(0x183)] !== undefined ? _0x2d7b86[_0x2327cc(_0x259dcc._0x35d660)] : 0x0, _0x290f53 = _0x2d7b86[_0x2327cc(0x281)] !== undefined ? _0x2d7b86[_0x2327cc(_0x259dcc._0x45845d)] : 0x1, _0x543d12 = _0x2d7b86['time'] !== undefined ? _0x2d7b86[_0x2327cc(0x383)] : 0x0, _0x5c67cf = _0x2d7b86[_0x2327cc(0x1b8)] !== undefined ? _0x2d7b86[_0x2327cc(0x1b8)] : null, _0x93316d = _0x2d7b86['sunDirection'] !== undefined ? _0x2d7b86[_0x2327cc(_0x259dcc._0x40fec2)] : new Vector3(0.70707, 0.70707, 0x0), _0x41636e = new Color(_0x2d7b86[_0x2327cc(_0x259dcc._0x41c12d)] !== undefined ? _0x2d7b86[_0x2327cc(0x52a)] : 0xffffff), _0x12acad = new Color(_0x2d7b86[_0x2327cc(0x1ec)] !== undefined ? _0x2d7b86[_0x2327cc(_0x259dcc._0x41659b)] : 0x7f7f7f), _0x3c4547 = _0x2d7b86[_0x2327cc(0x307)] !== undefined ? _0x2d7b86[_0x2327cc(0x307)] : new Vector3(0x0, 0x0, 0x0), _0x3888a6 = _0x2d7b86[_0x2327cc(0x215)] !== undefined ? _0x2d7b86[_0x2327cc(_0x259dcc._0x50fd0f)] : 0x14, _0x12170b = _0x2d7b86[_0x2327cc(_0x259dcc._0x3c1dbc)] !== undefined ? _0x2d7b86[_0x2327cc(0x49a)] : FrontSide, _0x5cf171 = _0x2d7b86[_0x2327cc(0x223)] !== undefined ? _0x2d7b86[_0x2327cc(_0x259dcc._0x4810b5)] : ![], _0x43c21c = new Plane(), _0x4eb99b = new Vector3(), _0x3658c2 = new Vector3(), _0x3b737e = new Vector3(), _0x1d8efd = new Matrix4(), _0x293f3b = new Vector3(0x0, 0x0, -0x1), _0x2e40cc = new Vector4(), _0x87f781 = new Vector3(), _0x5d89ac = new Vector3(), _0x4311a8 = new Vector4(), _0x31a37d = new Matrix4(), _0x3843ca = new PerspectiveCamera(), _0x461197 = { 'minFilter': LinearFilter, 'magFilter': LinearFilter, 'format': RGBFormat }, _0x5e4968 = new WebGLRenderTarget(_0x399f40, _0xe3a63f, _0x461197); (!MathUtils[_0x2327cc(0x49d)](_0x399f40) || !MathUtils[_0x2327cc(0x49d)](_0xe3a63f)) && (_0x5e4968[_0x2327cc(_0x259dcc._0x53222b)][_0x2327cc(_0x259dcc._0x139edf)] = ![]); const _0x223b89 = { 'uniforms': UniformsUtils$1['merge']([UniformsLib$1[_0x2327cc(_0x259dcc._0xd63b0a)], UniformsLib$1[_0x2327cc(_0x259dcc._0x452d32)], { 'normalSampler': { 'value': null }, 'mirrorSampler': { 'value': null }, 'alpha': { 'value': 0x1 }, 'time': { 'value': 0x0 }, 'size': { 'value': 0x1 }, 'distortionScale': { 'value': 0x14 }, 'textureMatrix': { 'value': new Matrix4() }, 'sunColor': { 'value': new Color(0x7f7f7f) }, 'sunDirection': { 'value': new Vector3(0.70707, 0.70707, 0x0) }, 'eye': { 'value': new Vector3() }, 'waterColor': { 'value': new Color(0x555555) } }]), 'vertexShader': _0x2327cc(0x523), 'fragmentShader': _0x2327cc(_0x259dcc._0x342047) }, _0x1edd4b = new ShaderMaterial({ 'fragmentShader': _0x223b89[_0x2327cc(0x3f8)], 'vertexShader': _0x223b89[_0x2327cc(_0x259dcc._0x3440c8)], 'uniforms': UniformsUtils$1['clone'](_0x223b89[_0x2327cc(_0x259dcc._0x2c1362)]), 'lights': !![], 'side': _0x12170b, 'fog': _0x5cf171 }); _0x1edd4b['uniforms'][_0x2327cc(0x50d)]['value'] = _0x5e4968[_0x2327cc(_0x259dcc._0x524529)], _0x1edd4b['uniforms']['textureMatrix'][_0x2327cc(0x27b)] = _0x31a37d, _0x1edd4b[_0x2327cc(0x234)][_0x2327cc(0x281)][_0x2327cc(_0x259dcc._0x24dfc4)] = _0x290f53, _0x1edd4b[_0x2327cc(_0x259dcc._0x2353d7)][_0x2327cc(0x383)][_0x2327cc(0x27b)] = _0x543d12, _0x1edd4b[_0x2327cc(_0x259dcc._0x89dcad)][_0x2327cc(0x52e)][_0x2327cc(_0x259dcc._0x56c72f)] = _0x5c67cf, _0x1edd4b['uniforms'][_0x2327cc(_0x259dcc._0x32083b)][_0x2327cc(0x27b)] = _0x41636e, _0x1edd4b['uniforms']['waterColor'][_0x2327cc(_0x259dcc._0x3a56b5)] = _0x12acad, _0x1edd4b[_0x2327cc(0x234)][_0x2327cc(_0x259dcc._0x2e54a8)][_0x2327cc(0x27b)] = _0x93316d, _0x1edd4b['uniforms'][_0x2327cc(_0x259dcc._0x566952)]['value'] = _0x3888a6, _0x1edd4b[_0x2327cc(_0x259dcc._0x337da5)]['eye'][_0x2327cc(_0x259dcc._0x1fabaa)] = _0x3c4547, _0x367a1e[_0x2327cc(_0x259dcc._0x4927ad)] = _0x1edd4b, _0x367a1e[_0x2327cc(_0x259dcc._0x11b4ba)] = function (_0x5b7f71, _0x6e6ae1, _0xc72c05) { const _0x1568c8 = _0x2327cc; _0x3658c2[_0x1568c8(0x272)](_0x367a1e[_0x1568c8(_0x1edc83._0x49cd01)]), _0x3b737e[_0x1568c8(_0x1edc83._0x530367)](_0xc72c05[_0x1568c8(_0x1edc83._0x1590d4)]), _0x1d8efd[_0x1568c8(0x22a)](_0x367a1e[_0x1568c8(0x2bb)]), _0x4eb99b[_0x1568c8(_0x1edc83._0x35e5a3)](0x0, 0x1, 0x0), _0x4eb99b[_0x1568c8(0x24a)](_0x1d8efd), _0x87f781[_0x1568c8(_0x1edc83._0x249ad2)](_0x3658c2, _0x3b737e); if (_0x87f781['dot'](_0x4eb99b) > 0x0) return; _0x87f781[_0x1568c8(0x4d8)](_0x4eb99b)[_0x1568c8(0x41e)](), _0x87f781[_0x1568c8(_0x1edc83._0x29f6d1)](_0x3658c2), _0x1d8efd[_0x1568c8(_0x1edc83._0x439038)](_0xc72c05[_0x1568c8(0x2bb)]), _0x293f3b[_0x1568c8(_0x1edc83._0x35e5a3)](0x0, 0x0, -0x1), _0x293f3b[_0x1568c8(_0x1edc83._0x70926c)](_0x1d8efd), _0x293f3b[_0x1568c8(_0x1edc83._0x29f6d1)](_0x3b737e), _0x5d89ac[_0x1568c8(0x317)](_0x3658c2, _0x293f3b), _0x5d89ac[_0x1568c8(_0x1edc83._0xc22b09)](_0x4eb99b)[_0x1568c8(0x41e)](), _0x5d89ac[_0x1568c8(0x44d)](_0x3658c2), _0x3843ca[_0x1568c8(_0x1edc83._0xc319d4)][_0x1568c8(0x371)](_0x87f781), _0x3843ca['up'][_0x1568c8(0x49f)](0x0, 0x1, 0x0), _0x3843ca['up'][_0x1568c8(_0x1edc83._0xfa0aba)](_0x1d8efd), _0x3843ca['up'][_0x1568c8(0x4d8)](_0x4eb99b), _0x3843ca['lookAt'](_0x5d89ac), _0x3843ca[_0x1568c8(_0x1edc83._0x5ab439)] = _0xc72c05[_0x1568c8(0x21b)], _0x3843ca['updateMatrixWorld'](), _0x3843ca[_0x1568c8(_0x1edc83._0x30a472)]['copy'](_0xc72c05[_0x1568c8(_0x1edc83._0xcc7083)]), _0x31a37d['set'](0.5, 0x0, 0x0, 0.5, 0x0, 0.5, 0x0, 0.5, 0x0, 0x0, 0.5, 0.5, 0x0, 0x0, 0x0, 0x1), _0x31a37d[_0x1568c8(_0x1edc83._0x3819f5)](_0x3843ca[_0x1568c8(0x332)]), _0x31a37d[_0x1568c8(0x4d9)](_0x3843ca[_0x1568c8(_0x1edc83._0x3382c0)]), _0x43c21c[_0x1568c8(_0x1edc83._0x50786d)](_0x4eb99b, _0x3658c2), _0x43c21c[_0x1568c8(_0x1edc83._0x54a59b)](_0x3843ca[_0x1568c8(0x4f4)]), _0x2e40cc['set'](_0x43c21c[_0x1568c8(_0x1edc83._0x1e18b9)]['x'], _0x43c21c[_0x1568c8(_0x1edc83._0x38b465)]['y'], _0x43c21c['normal']['z'], _0x43c21c[_0x1568c8(0x4eb)]); const _0x6ce124 = _0x3843ca[_0x1568c8(_0x1edc83._0x40a809)]; _0x4311a8['x'] = (Math[_0x1568c8(0x376)](_0x2e40cc['x']) + _0x6ce124[_0x1568c8(_0x1edc83._0x4ca1a0)][0x8]) / _0x6ce124['elements'][0x0], _0x4311a8['y'] = (Math[_0x1568c8(0x376)](_0x2e40cc['y']) + _0x6ce124[_0x1568c8(_0x1edc83._0x4b462a)][0x9]) / _0x6ce124['elements'][0x5], _0x4311a8['z'] = -0x1, _0x4311a8['w'] = (0x1 + _0x6ce124[_0x1568c8(0x3c4)][0xa]) / _0x6ce124['elements'][0xe], _0x2e40cc['multiplyScalar'](0x2 / _0x2e40cc[_0x1568c8(_0x1edc83._0x47ae98)](_0x4311a8)), _0x6ce124[_0x1568c8(_0x1edc83._0x4ca1a0)][0x2] = _0x2e40cc['x'], _0x6ce124[_0x1568c8(_0x1edc83._0x4ca1a0)][0x6] = _0x2e40cc['y'], _0x6ce124[_0x1568c8(0x3c4)][0xa] = _0x2e40cc['z'] + 0x1 - _0x5717a2, _0x6ce124[_0x1568c8(_0x1edc83._0x4b462a)][0xe] = _0x2e40cc['w'], _0x3c4547[_0x1568c8(_0x1edc83._0x530367)](_0xc72c05[_0x1568c8(0x2bb)]); const _0x4f99ac = _0x5b7f71[_0x1568c8(_0x1edc83._0x5d61d0)](), _0x501b35 = _0x5b7f71['xr'][_0x1568c8(0x2b1)], _0xc3ae04 = _0x5b7f71[_0x1568c8(0x244)][_0x1568c8(_0x1edc83._0xf795de)]; _0x367a1e[_0x1568c8(0x399)] = ![], _0x5b7f71['xr'][_0x1568c8(_0x1edc83._0x364ad9)] = ![], _0x5b7f71[_0x1568c8(_0x1edc83._0xe3c18c)]['autoUpdate'] = ![], _0x5b7f71['setRenderTarget'](_0x5e4968), _0x5b7f71['state']['buffers'][_0x1568c8(0x2ae)][_0x1568c8(0x26f)](!![]); if (_0x5b7f71[_0x1568c8(_0x1edc83._0x48a058)] === ![]) _0x5b7f71['clear'](); _0x5b7f71[_0x1568c8(0x368)](_0x6e6ae1, _0x3843ca), _0x367a1e[_0x1568c8(0x399)] = !![], _0x5b7f71['xr'][_0x1568c8(0x2b1)] = _0x501b35, _0x5b7f71[_0x1568c8(_0x1edc83._0x38a738)][_0x1568c8(_0x1edc83._0x5e3e81)] = _0xc3ae04, _0x5b7f71[_0x1568c8(0x513)](_0x4f99ac); const _0x52d55c = _0xc72c05[_0x1568c8(_0x1edc83._0x3708ab)]; _0x52d55c !== undefined && _0x5b7f71[_0x1568c8(0x29c)][_0x1568c8(_0x1edc83._0xeefd23)](_0x52d55c) } } } Water[_0x48e965(0x4c2)]['isWater'] = !![]; class Reflector$1 extends Mesh { constructor(_0x3db6e6, _0x2abbd1 = {}) { const _0x1c41e1 = { _0x2dcf94: 0x182, _0x1b3a57: 0x209, _0x67a2c4: 0x42c, _0x4ef460: 0x1ba, _0x1839fc: 0x3c3, _0x2a7444: 0x2b0, _0x46057b: 0x3f8, _0x3d5fa3: 0x42e, _0x57c33c: 0x27b, _0x47f6e5: 0x234, _0x582604: 0x2f4, _0xd7823c: 0x2d2 }, _0x31a8 = { _0x1044a0: 0x272, _0x3f57dd: 0x24a, _0x3abd61: 0x41e, _0x13a3ab: 0x317, _0x552fb8: 0x44d, _0x32550f: 0x24a, _0x2523f0: 0x195, _0x2af58a: 0x21b, _0x501044: 0x332, _0x5b809c: 0x4d9, _0x3100b6: 0x533, _0x19bbdc: 0x4f4, _0x49636b: 0x49f, _0x286432: 0x3a8, _0x4d284c: 0x4eb, _0x11b57b: 0x332, _0x338079: 0x3c4, _0x54b32c: 0x3c4, _0x46a128: 0x1d6, _0x277275: 0x399, _0x52d745: 0x2d2, _0x8b833d: 0x301, _0x26af83: 0x156, _0x143668: 0x2ae, _0x282f4f: 0x368, _0x26a2b1: 0x2b1, _0x4d02c0: 0x43f }, _0x50bb67 = _0x48e965; super(_0x3db6e6), this[_0x50bb67(0x1f0)] = _0x50bb67(_0x1c41e1._0x2dcf94); const _0x4f322b = this, _0x411810 = _0x2abbd1[_0x50bb67(_0x1c41e1._0x1b3a57)] !== undefined ? new Color(_0x2abbd1[_0x50bb67(0x209)]) : new Color(0x7f7f7f), _0x4c06e3 = _0x2abbd1[_0x50bb67(_0x1c41e1._0x67a2c4)] || 0x200, _0x521d2a = _0x2abbd1[_0x50bb67(0x4c5)] || 0x200, _0x4dec8b = _0x2abbd1['clipBias'] || 0x0, _0x408be8 = _0x2abbd1[_0x50bb67(0x3a6)] || Reflector$1[_0x50bb67(0x293)], _0x9504b1 = new Plane(), _0x534bdf = new Vector3(), _0x41e2f7 = new Vector3(), _0x53f2a2 = new Vector3(), _0x5a9e06 = new Matrix4(), _0x2ffa74 = new Vector3(0x0, 0x0, -0x1), _0xd2e95a = new Vector4(), _0x3c8489 = new Vector3(), _0x541423 = new Vector3(), _0x22ce5f = new Vector4(), _0x12fa73 = new Matrix4(), _0x596654 = new PerspectiveCamera(), _0x1f99e1 = { 'minFilter': LinearFilter, 'magFilter': LinearFilter, 'format': RGBFormat }, _0x3e1cbb = new WebGLRenderTarget(_0x4c06e3, _0x521d2a, _0x1f99e1); (!MathUtils['isPowerOfTwo'](_0x4c06e3) || !MathUtils[_0x50bb67(0x49d)](_0x521d2a)) && (_0x3e1cbb[_0x50bb67(_0x1c41e1._0x4ef460)][_0x50bb67(_0x1c41e1._0x1839fc)] = ![]); const _0x57478f = new ShaderMaterial({ 'uniforms': UniformsUtils$1[_0x50bb67(_0x1c41e1._0x2a7444)](_0x408be8[_0x50bb67(0x234)]), 'fragmentShader': _0x408be8[_0x50bb67(_0x1c41e1._0x46057b)], 'vertexShader': _0x408be8[_0x50bb67(_0x1c41e1._0x3d5fa3)] }); _0x57478f['uniforms']['tDiffuse'][_0x50bb67(_0x1c41e1._0x57c33c)] = _0x3e1cbb['texture'], _0x57478f[_0x50bb67(0x234)]['color']['value'] = _0x411810, _0x57478f[_0x50bb67(_0x1c41e1._0x47f6e5)][_0x50bb67(0x15c)][_0x50bb67(_0x1c41e1._0x57c33c)] = _0x12fa73, this[_0x50bb67(_0x1c41e1._0x582604)] = _0x57478f, this['onBeforeRender'] = function (_0x38025c, _0x4b7f81, _0xe3e294) { const _0x3f03aa = _0x50bb67; _0x41e2f7['setFromMatrixPosition'](_0x4f322b[_0x3f03aa(0x2bb)]), _0x53f2a2[_0x3f03aa(_0x31a8._0x1044a0)](_0xe3e294['matrixWorld']), _0x5a9e06['extractRotation'](_0x4f322b['matrixWorld']), _0x534bdf['set'](0x0, 0x0, 0x1), _0x534bdf[_0x3f03aa(_0x31a8._0x3f57dd)](_0x5a9e06), _0x3c8489['subVectors'](_0x41e2f7, _0x53f2a2); if (_0x3c8489['dot'](_0x534bdf) > 0x0) return; _0x3c8489[_0x3f03aa(0x4d8)](_0x534bdf)[_0x3f03aa(_0x31a8._0x3abd61)](), _0x3c8489['add'](_0x41e2f7), _0x5a9e06['extractRotation'](_0xe3e294[_0x3f03aa(0x2bb)]), _0x2ffa74[_0x3f03aa(0x49f)](0x0, 0x0, -0x1), _0x2ffa74[_0x3f03aa(_0x31a8._0x3f57dd)](_0x5a9e06), _0x2ffa74['add'](_0x53f2a2), _0x541423[_0x3f03aa(_0x31a8._0x13a3ab)](_0x41e2f7, _0x2ffa74), _0x541423['reflect'](_0x534bdf)[_0x3f03aa(0x41e)](), _0x541423[_0x3f03aa(_0x31a8._0x552fb8)](_0x41e2f7), _0x596654['position'][_0x3f03aa(0x371)](_0x3c8489), _0x596654['up']['set'](0x0, 0x1, 0x0), _0x596654['up'][_0x3f03aa(_0x31a8._0x32550f)](_0x5a9e06), _0x596654['up'][_0x3f03aa(0x4d8)](_0x534bdf), _0x596654[_0x3f03aa(_0x31a8._0x2523f0)](_0x541423), _0x596654[_0x3f03aa(_0x31a8._0x2af58a)] = _0xe3e294['far'], _0x596654[_0x3f03aa(0x526)](), _0x596654[_0x3f03aa(0x332)]['copy'](_0xe3e294[_0x3f03aa(_0x31a8._0x501044)]), _0x12fa73[_0x3f03aa(0x49f)](0.5, 0x0, 0x0, 0.5, 0x0, 0.5, 0x0, 0.5, 0x0, 0x0, 0.5, 0.5, 0x0, 0x0, 0x0, 0x1), _0x12fa73[_0x3f03aa(0x4d9)](_0x596654[_0x3f03aa(0x332)]), _0x12fa73[_0x3f03aa(_0x31a8._0x5b809c)](_0x596654[_0x3f03aa(0x4f4)]), _0x12fa73[_0x3f03aa(0x4d9)](_0x4f322b['matrixWorld']), _0x9504b1[_0x3f03aa(_0x31a8._0x3100b6)](_0x534bdf, _0x41e2f7), _0x9504b1[_0x3f03aa(0x24a)](_0x596654[_0x3f03aa(_0x31a8._0x19bbdc)]), _0xd2e95a[_0x3f03aa(_0x31a8._0x49636b)](_0x9504b1[_0x3f03aa(0x3a8)]['x'], _0x9504b1[_0x3f03aa(_0x31a8._0x286432)]['y'], _0x9504b1[_0x3f03aa(_0x31a8._0x286432)]['z'], _0x9504b1[_0x3f03aa(_0x31a8._0x4d284c)]); const _0x33fb82 = _0x596654[_0x3f03aa(_0x31a8._0x11b57b)]; _0x22ce5f['x'] = (Math[_0x3f03aa(0x376)](_0xd2e95a['x']) + _0x33fb82[_0x3f03aa(_0x31a8._0x338079)][0x8]) / _0x33fb82['elements'][0x0], _0x22ce5f['y'] = (Math['sign'](_0xd2e95a['y']) + _0x33fb82['elements'][0x9]) / _0x33fb82[_0x3f03aa(0x3c4)][0x5], _0x22ce5f['z'] = -0x1, _0x22ce5f['w'] = (0x1 + _0x33fb82[_0x3f03aa(_0x31a8._0x338079)][0xa]) / _0x33fb82[_0x3f03aa(_0x31a8._0x54b32c)][0xe], _0xd2e95a['multiplyScalar'](0x2 / _0xd2e95a[_0x3f03aa(_0x31a8._0x46a128)](_0x22ce5f)), _0x33fb82[_0x3f03aa(0x3c4)][0x2] = _0xd2e95a['x'], _0x33fb82['elements'][0x6] = _0xd2e95a['y'], _0x33fb82[_0x3f03aa(_0x31a8._0x54b32c)][0xa] = _0xd2e95a['z'] + 0x1 - _0x4dec8b, _0x33fb82[_0x3f03aa(0x3c4)][0xe] = _0xd2e95a['w'], _0x3e1cbb['texture'][_0x3f03aa(0x292)] = _0x38025c[_0x3f03aa(0x470)], _0x4f322b[_0x3f03aa(_0x31a8._0x277275)] = ![]; const _0x7606f8 = _0x38025c[_0x3f03aa(_0x31a8._0x52d745)](), _0x10a5e9 = _0x38025c['xr'][_0x3f03aa(0x2b1)], _0x22db8e = _0x38025c[_0x3f03aa(0x244)]['autoUpdate']; _0x38025c['xr']['enabled'] = ![], _0x38025c[_0x3f03aa(0x244)][_0x3f03aa(_0x31a8._0x8b833d)] = ![], _0x38025c[_0x3f03aa(0x513)](_0x3e1cbb), _0x38025c['state'][_0x3f03aa(_0x31a8._0x26af83)][_0x3f03aa(_0x31a8._0x143668)]['setMask'](!![]); if (_0x38025c['autoClear'] === ![]) _0x38025c['clear'](); _0x38025c[_0x3f03aa(_0x31a8._0x282f4f)](_0x4b7f81, _0x596654), _0x38025c['xr'][_0x3f03aa(_0x31a8._0x26a2b1)] = _0x10a5e9, _0x38025c['shadowMap']['autoUpdate'] = _0x22db8e, _0x38025c['setRenderTarget'](_0x7606f8); const _0x21b9fd = _0xe3e294[_0x3f03aa(0x43f)]; _0x21b9fd !== undefined && _0x38025c[_0x3f03aa(0x29c)][_0x3f03aa(_0x31a8._0x4d02c0)](_0x21b9fd), _0x4f322b[_0x3f03aa(0x399)] = !![] }, this[_0x50bb67(_0x1c41e1._0xd7823c)] = function () { return _0x3e1cbb } } } Reflector$1[_0x48e965(0x4c2)][_0x48e965(0x1e7)] = !![], Reflector$1[_0x48e965(0x293)] = { 'uniforms': { 'color': { 'value': null }, 'tDiffuse': { 'value': null }, 'textureMatrix': { 'value': null } }, 'vertexShader': '\x0a\x09\x09uniform\x20mat4\x20textureMatrix;\x0a\x09\x09varying\x20vec4\x20vUv;\x0a\x0a\x09\x09#include\x20<common>\x0a\x09\x09#include\x20<logdepthbuf_pars_vertex>\x0a\x0a\x09\x09void\x20main()\x20{\x0a\x0a\x09\x09\x09vUv\x20=\x20textureMatrix\x20*\x20vec4(\x20position,\x201.0\x20);\x0a\x0a\x09\x09\x09gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(\x20position,\x201.0\x20);\x0a\x0a\x09\x09\x09#include\x20<logdepthbuf_vertex>\x0a\x0a\x09\x09}', 'fragmentShader': _0x48e965(0x266) }; class ReflectorRTT extends Reflector$1 { constructor(_0x282fe0, _0x1f9519) { const _0x1552d3 = _0x48e965; super(_0x282fe0, _0x1f9519), this[_0x1552d3(0x303)][_0x1552d3(0x457)](0x0, 0x0) } } class Reflector extends Mesh { constructor(_0x3458a3, _0x3c4a41 = {}) { const _0x36d09c = { _0x13b4f9: 0x209, _0x30e9a2: 0x42c, _0x10bbfb: 0x4c5, _0x54a3be: 0x3a6, _0x4b3651: 0x49d, _0x5edaa8: 0x3c3, _0x4432f5: 0x2b0, _0x3c64df: 0x234, _0x178199: 0x15e, _0xd5b20a: 0x27b, _0x36696e: 0x1ba, _0x40b202: 0x234, _0x19345c: 0x2f4, _0x58b1ea: 0x435, _0x3421f2: 0x2d2 }, _0x1cde85 = { _0x13780a: 0x272, _0x17853f: 0x2bb, _0x14f826: 0x2bb, _0x1b7085: 0x2bb, _0x356cb0: 0x1d6, _0x2febc9: 0x22a, _0x30949f: 0x44d, _0xe37469: 0x44d, _0xd1d8bb: 0x49f, _0x1c13fe: 0x4d8, _0x30629d: 0x195, _0x29148e: 0x21b, _0x2371fd: 0x332, _0x17c3e9: 0x4d9, _0x39608e: 0x4f4, _0x172d45: 0x3a8, _0x4f884c: 0x3a8, _0x51a319: 0x3a8, _0x21346f: 0x4eb, _0x41be7a: 0x3c4, _0x113d1c: 0x376, _0x5882f8: 0x3c4, _0x9dd446: 0x3c4, _0x56f788: 0x470, _0x486d6c: 0x244, _0x19c40d: 0x2b1, _0x20e06e: 0x156, _0x310ab6: 0x2ae, _0x507af1: 0x29c, _0x2ce8d9: 0x43f, _0x1fdc38: 0x399 }, _0x34817d = _0x48e965; super(_0x3458a3), this[_0x34817d(0x1f0)] = _0x34817d(0x182); const _0x3c5708 = this, _0x201c43 = _0x3c4a41[_0x34817d(0x209)] !== undefined ? new Color(_0x3c4a41[_0x34817d(_0x36d09c._0x13b4f9)]) : new Color(0x7f7f7f), _0xb997ac = _0x3c4a41[_0x34817d(_0x36d09c._0x30e9a2)] || 0x200, _0x200afe = _0x3c4a41[_0x34817d(_0x36d09c._0x10bbfb)] || 0x200, _0x36bd9e = _0x3c4a41['clipBias'] || 0x0, _0x3cdfdb = _0x3c4a41[_0x34817d(_0x36d09c._0x54a3be)] || Reflector[_0x34817d(0x293)], _0x320527 = new Plane(), _0x12e7dd = new Vector3(), _0x3fe5c4 = new Vector3(), _0x2ff953 = new Vector3(), _0x347f58 = new Matrix4(), _0xcfebe8 = new Vector3(0x0, 0x0, -0x1), _0x2354d5 = new Vector4(), _0x3700d3 = new Vector3(), _0x19eb30 = new Vector3(), _0x348236 = new Vector4(), _0xe80dc5 = new Matrix4(), _0x53f56f = new PerspectiveCamera(), _0x2b58d5 = { 'minFilter': LinearFilter, 'magFilter': LinearFilter, 'format': RGBFormat }, _0x18090a = new WebGLRenderTarget(_0xb997ac, _0x200afe, _0x2b58d5); (!MathUtils[_0x34817d(0x49d)](_0xb997ac) || !MathUtils[_0x34817d(_0x36d09c._0x4b3651)](_0x200afe)) && (_0x18090a[_0x34817d(0x1ba)][_0x34817d(_0x36d09c._0x5edaa8)] = ![]); const _0x16ec43 = new ShaderMaterial({ 'transparent': !![], 'uniforms': UniformsUtils$1[_0x34817d(_0x36d09c._0x4432f5)](_0x3cdfdb[_0x34817d(_0x36d09c._0x3c64df)]), 'fragmentShader': _0x3cdfdb[_0x34817d(0x3f8)], 'vertexShader': _0x3cdfdb[_0x34817d(0x42e)] }); _0x16ec43[_0x34817d(_0x36d09c._0x3c64df)][_0x34817d(_0x36d09c._0x178199)][_0x34817d(_0x36d09c._0xd5b20a)] = _0x18090a[_0x34817d(_0x36d09c._0x36696e)], _0x16ec43[_0x34817d(_0x36d09c._0x40b202)][_0x34817d(0x209)][_0x34817d(0x27b)] = _0x201c43, _0x16ec43[_0x34817d(_0x36d09c._0x3c64df)]['textureMatrix']['value'] = _0xe80dc5, _0x16ec43[_0x34817d(0x234)]['opacity']['value'] = 0x1, this[_0x34817d(_0x36d09c._0x19345c)] = _0x16ec43, this[_0x34817d(_0x36d09c._0x58b1ea)] = function (_0x5542bd, _0x890f45, _0x4a57a0) { const _0x565893 = _0x34817d; _0x3fe5c4[_0x565893(_0x1cde85._0x13780a)](_0x3c5708[_0x565893(_0x1cde85._0x17853f)]), _0x2ff953[_0x565893(0x272)](_0x4a57a0[_0x565893(_0x1cde85._0x14f826)]), _0x347f58[_0x565893(0x22a)](_0x3c5708[_0x565893(_0x1cde85._0x1b7085)]), _0x12e7dd['set'](0x0, 0x1, 0x0), _0x12e7dd[_0x565893(0x24a)](_0x347f58), _0x3700d3[_0x565893(0x317)](_0x3fe5c4, _0x2ff953); if (_0x3700d3[_0x565893(_0x1cde85._0x356cb0)](_0x12e7dd) > 0x0) return; _0x3700d3[_0x565893(0x4d8)](_0x12e7dd)['negate'](), _0x3700d3[_0x565893(0x44d)](_0x3fe5c4), _0x347f58[_0x565893(_0x1cde85._0x2febc9)](_0x4a57a0[_0x565893(_0x1cde85._0x1b7085)]), _0xcfebe8[_0x565893(0x49f)](0x0, 0x0, -0x1), _0xcfebe8[_0x565893(0x24a)](_0x347f58), _0xcfebe8[_0x565893(_0x1cde85._0x30949f)](_0x2ff953), _0x19eb30[_0x565893(0x317)](_0x3fe5c4, _0xcfebe8), _0x19eb30[_0x565893(0x4d8)](_0x12e7dd)['negate'](), _0x19eb30[_0x565893(_0x1cde85._0xe37469)](_0x3fe5c4), _0x53f56f['position']['copy'](_0x3700d3), _0x53f56f['up'][_0x565893(_0x1cde85._0xd1d8bb)](0x0, 0x1, 0x0), _0x53f56f['up'][_0x565893(0x24a)](_0x347f58), _0x53f56f['up'][_0x565893(_0x1cde85._0x1c13fe)](_0x12e7dd), _0x53f56f[_0x565893(_0x1cde85._0x30629d)](_0x19eb30), _0x53f56f[_0x565893(_0x1cde85._0x29148e)] = _0x4a57a0[_0x565893(0x21b)], _0x53f56f[_0x565893(0x526)](), _0x53f56f[_0x565893(_0x1cde85._0x2371fd)]['copy'](_0x4a57a0['projectionMatrix']), _0xe80dc5[_0x565893(0x49f)](0.5, 0x0, 0x0, 0.5, 0x0, 0.5, 0x0, 0.5, 0x0, 0x0, 0.5, 0.5, 0x0, 0x0, 0x0, 0x1), _0xe80dc5['multiply'](_0x53f56f['projectionMatrix']), _0xe80dc5['multiply'](_0x53f56f['matrixWorldInverse']), _0xe80dc5[_0x565893(_0x1cde85._0x17c3e9)](_0x3c5708['matrixWorld']), _0x320527[_0x565893(0x533)](_0x12e7dd, _0x3fe5c4), _0x320527['applyMatrix4'](_0x53f56f[_0x565893(_0x1cde85._0x39608e)]), _0x2354d5[_0x565893(_0x1cde85._0xd1d8bb)](_0x320527[_0x565893(_0x1cde85._0x172d45)]['x'], _0x320527[_0x565893(_0x1cde85._0x4f884c)]['y'], _0x320527[_0x565893(_0x1cde85._0x51a319)]['z'], _0x320527[_0x565893(_0x1cde85._0x21346f)]); const _0x24accf = _0x53f56f[_0x565893(0x332)]; _0x348236['x'] = (Math[_0x565893(0x376)](_0x2354d5['x']) + _0x24accf[_0x565893(_0x1cde85._0x41be7a)][0x8]) / _0x24accf[_0x565893(0x3c4)][0x0], _0x348236['y'] = (Math[_0x565893(_0x1cde85._0x113d1c)](_0x2354d5['y']) + _0x24accf[_0x565893(0x3c4)][0x9]) / _0x24accf[_0x565893(_0x1cde85._0x41be7a)][0x5], _0x348236['z'] = -0x1, _0x348236['w'] = (0x1 + _0x24accf[_0x565893(_0x1cde85._0x5882f8)][0xa]) / _0x24accf[_0x565893(_0x1cde85._0x9dd446)][0xe], _0x2354d5['multiplyScalar'](0x2 / _0x2354d5[_0x565893(0x1d6)](_0x348236)), _0x24accf['elements'][0x2] = _0x2354d5['x'], _0x24accf['elements'][0x6] = _0x2354d5['y'], _0x24accf[_0x565893(0x3c4)][0xa] = _0x2354d5['z'] + 0x1 - _0x36bd9e, _0x24accf[_0x565893(0x3c4)][0xe] = _0x2354d5['w'], _0x18090a[_0x565893(0x1ba)][_0x565893(0x292)] = _0x5542bd[_0x565893(_0x1cde85._0x56f788)], _0x3c5708['visible'] = ![]; const _0x19eadf = _0x5542bd['getRenderTarget'](), _0x46f460 = _0x5542bd['xr']['enabled'], _0x4beb4e = _0x5542bd[_0x565893(_0x1cde85._0x486d6c)]['autoUpdate']; _0x5542bd['xr'][_0x565893(_0x1cde85._0x19c40d)] = ![], _0x5542bd[_0x565893(_0x1cde85._0x486d6c)][_0x565893(0x301)] = ![], _0x5542bd['setRenderTarget'](_0x18090a), _0x5542bd['state'][_0x565893(_0x1cde85._0x20e06e)][_0x565893(_0x1cde85._0x310ab6)][_0x565893(0x26f)](!![]); if (_0x5542bd[_0x565893(0x289)] === ![]) _0x5542bd[_0x565893(0x1d7)](); _0x5542bd[_0x565893(0x368)](_0x890f45, _0x53f56f), _0x5542bd['xr'][_0x565893(_0x1cde85._0x19c40d)] = _0x46f460, _0x5542bd[_0x565893(0x244)]['autoUpdate'] = _0x4beb4e, _0x5542bd['setRenderTarget'](_0x19eadf); const _0x8641f1 = _0x4a57a0[_0x565893(0x43f)]; _0x8641f1 !== undefined && _0x5542bd[_0x565893(_0x1cde85._0x507af1)][_0x565893(_0x1cde85._0x2ce8d9)](_0x8641f1), _0x3c5708[_0x565893(_0x1cde85._0x1fdc38)] = !![] }, this[_0x34817d(_0x36d09c._0x3421f2)] = function () { return _0x18090a } } } Reflector[_0x48e965(0x4c2)][_0x48e965(0x1e7)] = !![], Reflector[_0x48e965(0x293)] = { 'uniforms': { 'color': { 'value': null }, 'tDiffuse': { 'value': null }, 'textureMatrix': { 'value': null }, 'opacity': { 'value': 0x1 } }, 'vertexShader': _0x48e965(0x412), 'fragmentShader': _0x48e965(0x37f) }; class SkeletonUtils { static ['retarget'] (_0x43f13d, _0x12e7d, _0x6b6386 = {}) { const _0x36d1dc = { _0x4e921e: 0x397, _0x52dcdd: 0x287, _0x1301f4: 0x3ac, _0x5d986d: 0x286, _0x40e866: 0x440, _0x617e66: 0x295, _0x349d53: 0x1fa, _0x25db0a: 0x2a7, _0x42b5de: 0x2ad, _0x480291: 0x321, _0xab818b: 0x4c4, _0x3e75f8: 0x2bb, _0x4368f6: 0x29e, _0x2dd521: 0x31c, _0x3fa698: 0x39a, _0x10e896: 0x3eb, _0x56f897: 0x39a, _0x2195a6: 0x476, _0x5a1bd2: 0x419, _0x23e06b: 0x2be, _0x233739: 0x1da, _0x298298: 0x440, _0x27a8ca: 0x31c, _0x1c9994: 0x2da, _0x1bb67b: 0x526, _0x2e0956: 0x456, _0x3f4e6d: 0x413, _0x2596da: 0x36a, _0x3fe03d: 0x449, _0x5e289d: 0x3eb, _0x395c34: 0x371, _0xbae458: 0x2c2, _0x2cb0f9: 0x4d9, _0x5f2fef: 0x371, _0x1908e7: 0x1b5, _0x2c5d4a: 0x2be, _0x13f50e: 0x526, _0x481f5f: 0x440, _0x1d98ad: 0x31c, _0x42552f: 0x397 }, _0x370b94 = _0x48e965, _0x5a2494 = new Vector3(), _0x3e0a9e = new Quaternion(), _0x267e30 = new Vector3(), _0x2979f3 = new Matrix4(), _0x12578d = new Matrix4(), _0x59bffd = new Matrix4(); _0x6b6386[_0x370b94(_0x36d1dc._0x4e921e)] = _0x6b6386['preserveMatrix'] !== undefined ? _0x6b6386[_0x370b94(0x397)] : !![], _0x6b6386[_0x370b94(_0x36d1dc._0x52dcdd)] = _0x6b6386[_0x370b94(_0x36d1dc._0x52dcdd)] !== undefined ? _0x6b6386[_0x370b94(_0x36d1dc._0x52dcdd)] : !![], _0x6b6386['preserveHipPosition'] = _0x6b6386['preserveHipPosition'] !== undefined ? _0x6b6386['preserveHipPosition'] : ![], _0x6b6386[_0x370b94(0x3ac)] = _0x6b6386[_0x370b94(_0x36d1dc._0x1301f4)] !== undefined ? _0x6b6386[_0x370b94(0x3ac)] : ![], _0x6b6386[_0x370b94(_0x36d1dc._0x5d986d)] = _0x6b6386[_0x370b94(0x286)] !== undefined ? _0x6b6386[_0x370b94(0x286)] : _0x370b94(0x286), _0x6b6386[_0x370b94(0x440)] = _0x6b6386[_0x370b94(_0x36d1dc._0x40e866)] || {}; const _0x7ac95e = _0x12e7d['isObject3D'] ? _0x12e7d[_0x370b94(_0x36d1dc._0x617e66)][_0x370b94(_0x36d1dc._0x349d53)] : this[_0x370b94(_0x36d1dc._0x25db0a)](_0x12e7d), _0x39ec56 = _0x43f13d[_0x370b94(0x2ad)] ? _0x43f13d[_0x370b94(0x295)]['bones'] : this['getBones'](_0x43f13d); let _0x4b242f, _0x4a85e6, _0x232c28, _0x1c39f0, _0x4fd39f; _0x43f13d[_0x370b94(_0x36d1dc._0x42b5de)] ? _0x43f13d[_0x370b94(0x295)][_0x370b94(0x28f)]() : (_0x6b6386[_0x370b94(0x3ac)] = !![], _0x6b6386[_0x370b94(0x397)] = ![]); if (_0x6b6386['preservePosition']) { _0x4fd39f = []; for (let _0x20467e = 0x0; _0x20467e < _0x39ec56[_0x370b94(_0x36d1dc._0x480291)]; _0x20467e++) { _0x4fd39f['push'](_0x39ec56[_0x20467e][_0x370b94(_0x36d1dc._0xab818b)]['clone']()) } } if (_0x6b6386[_0x370b94(0x397)]) { _0x43f13d['updateMatrixWorld'](), _0x43f13d[_0x370b94(_0x36d1dc._0x3e75f8)][_0x370b94(0x1d3)](); for (let _0x214a0d = 0x0; _0x214a0d < _0x43f13d[_0x370b94(0x29e)][_0x370b94(0x321)]; ++_0x214a0d) { _0x43f13d[_0x370b94(_0x36d1dc._0x4368f6)][_0x214a0d]['updateMatrixWorld'](!![]) } } if (_0x6b6386[_0x370b94(0x39a)]) { _0x4b242f = []; for (let _0x56444f = 0x0; _0x56444f < _0x39ec56['length']; ++_0x56444f) { _0x4a85e6 = _0x39ec56[_0x56444f], _0x232c28 = _0x6b6386['names'][_0x4a85e6[_0x370b94(_0x36d1dc._0x2dd521)]] || _0x4a85e6['name'], _0x6b6386[_0x370b94(_0x36d1dc._0x3fa698)] && _0x6b6386[_0x370b94(_0x36d1dc._0x3fa698)][_0x232c28] && (_0x4a85e6[_0x370b94(_0x36d1dc._0x10e896)][_0x370b94(0x4d9)](_0x6b6386[_0x370b94(_0x36d1dc._0x56f897)][_0x232c28]), _0x4a85e6[_0x370b94(0x3eb)][_0x370b94(_0x36d1dc._0x2195a6)](_0x4a85e6[_0x370b94(_0x36d1dc._0xab818b)], _0x4a85e6[_0x370b94(_0x36d1dc._0x5a1bd2)], _0x4a85e6[_0x370b94(_0x36d1dc._0x23e06b)]), _0x4a85e6['updateMatrixWorld']()), _0x4b242f[_0x370b94(_0x36d1dc._0x233739)](_0x4a85e6[_0x370b94(_0x36d1dc._0x3e75f8)][_0x370b94(0x2b0)]()) } } for (let _0x219ce5 = 0x0; _0x219ce5 < _0x39ec56[_0x370b94(0x321)]; ++_0x219ce5) { _0x4a85e6 = _0x39ec56[_0x219ce5], _0x232c28 = _0x6b6386[_0x370b94(_0x36d1dc._0x298298)][_0x4a85e6[_0x370b94(0x31c)]] || _0x4a85e6[_0x370b94(_0x36d1dc._0x27a8ca)], _0x1c39f0 = this[_0x370b94(_0x36d1dc._0x1c9994)](_0x232c28, _0x7ac95e), _0x59bffd[_0x370b94(0x371)](_0x4a85e6[_0x370b94(0x2bb)]); if (_0x1c39f0) { _0x1c39f0[_0x370b94(_0x36d1dc._0x1bb67b)](); _0x6b6386['useTargetMatrix'] ? _0x12578d[_0x370b94(0x371)](_0x1c39f0[_0x370b94(0x2bb)]) : (_0x12578d[_0x370b94(0x371)](_0x43f13d[_0x370b94(0x2bb)])['invert'](), _0x12578d[_0x370b94(0x4d9)](_0x1c39f0[_0x370b94(0x2bb)])); _0x267e30[_0x370b94(0x224)](_0x12578d), _0x12578d[_0x370b94(_0x36d1dc._0x23e06b)](_0x267e30[_0x370b94(0x49f)](0x1 / _0x267e30['x'], 0x1 / _0x267e30['y'], 0x1 / _0x267e30['z'])), _0x59bffd['makeRotationFromQuaternion'](_0x3e0a9e[_0x370b94(_0x36d1dc._0x2e0956)](_0x12578d)); if (_0x43f13d[_0x370b94(0x2ad)]) { const _0xb490ca = _0x39ec56[_0x370b94(_0x36d1dc._0x3f4e6d)](_0x4a85e6), _0x4e7203 = _0x4b242f ? _0x4b242f[_0xb490ca] : _0x2979f3['copy'](_0x43f13d[_0x370b94(0x295)][_0x370b94(_0x36d1dc._0x2596da)][_0xb490ca])[_0x370b94(0x275)](); _0x59bffd[_0x370b94(0x4d9)](_0x4e7203) } _0x59bffd[_0x370b94(_0x36d1dc._0x3fe03d)](_0x12578d) } _0x4a85e6['parent'] && _0x4a85e6['parent'][_0x370b94(0x313)] ? (_0x4a85e6[_0x370b94(_0x36d1dc._0x5e289d)][_0x370b94(_0x36d1dc._0x395c34)](_0x4a85e6[_0x370b94(_0x36d1dc._0xbae458)][_0x370b94(0x2bb)])['invert'](), _0x4a85e6[_0x370b94(0x3eb)][_0x370b94(_0x36d1dc._0x2cb0f9)](_0x59bffd)) : _0x4a85e6['matrix'][_0x370b94(_0x36d1dc._0x5f2fef)](_0x59bffd), _0x6b6386[_0x370b94(_0x36d1dc._0x1908e7)] && _0x232c28 === _0x6b6386[_0x370b94(_0x36d1dc._0x5d986d)] && _0x4a85e6['matrix'][_0x370b94(0x42f)](_0x5a2494[_0x370b94(0x49f)](0x0, _0x4a85e6[_0x370b94(0x4c4)]['y'], 0x0)), _0x4a85e6[_0x370b94(_0x36d1dc._0x5e289d)][_0x370b94(_0x36d1dc._0x2195a6)](_0x4a85e6[_0x370b94(0x4c4)], _0x4a85e6[_0x370b94(_0x36d1dc._0x5a1bd2)], _0x4a85e6[_0x370b94(_0x36d1dc._0x2c5d4a)]), _0x4a85e6[_0x370b94(_0x36d1dc._0x13f50e)]() } if (_0x6b6386[_0x370b94(_0x36d1dc._0x52dcdd)]) for (let _0xfa9ae5 = 0x0; _0xfa9ae5 < _0x39ec56[_0x370b94(_0x36d1dc._0x480291)]; ++_0xfa9ae5) { _0x4a85e6 = _0x39ec56[_0xfa9ae5], _0x232c28 = _0x6b6386[_0x370b94(_0x36d1dc._0x481f5f)][_0x4a85e6[_0x370b94(_0x36d1dc._0x2dd521)]] || _0x4a85e6[_0x370b94(_0x36d1dc._0x1d98ad)], _0x232c28 !== _0x6b6386['hip'] && _0x4a85e6[_0x370b94(0x4c4)][_0x370b94(_0x36d1dc._0x5f2fef)](_0x4fd39f[_0xfa9ae5]) } _0x6b6386[_0x370b94(_0x36d1dc._0x42552f)] && _0x43f13d[_0x370b94(0x526)](!![]) } static [_0x48e965(0x205)] (_0x57a4f4, _0x200fd5, _0x503c4d, _0xa206df = {}) { const _0x1539a7 = { _0x54fe37: 0x4d1, _0x35f523: 0x4d1, _0x5657bf: 0x23b, _0x302632: 0x440, _0x4a373d: 0x454, _0x5a63e8: 0x23b, _0xede07: 0x2a7, _0x39ba1a: 0x2f2, _0x2a6f76: 0x1f8, _0x16f1a4: 0x321, _0x5b2d2d: 0x295, _0x45d82b: 0x286, _0x92c8b3: 0x4c4, _0x277598: 0x238, _0x3e495d: 0x45c, _0x5ce59d: 0x4c4, _0x3d5f41: 0x45c, _0x1c3058: 0x387, _0x11dbf4: 0x51e, _0x1b83fc: 0x419, _0x1563fe: 0x492, _0x2ed6cd: 0x387, _0xa5971b: 0x526, _0x36095f: 0x321, _0x156e25: 0x26a, _0x16c4c6: 0x446, _0x5a7a31: 0x16d, _0xefd1c7: 0x51e, _0x1464ec: 0x45c, _0x29df6d: 0x207, _0x5f245c: 0x1da, _0xb0bf1b: 0x43e, _0x34f1fb: 0x51e, _0x26e0a4: 0x31c }, _0x20340d = _0x48e965; _0xa206df[_0x20340d(_0x1539a7._0x54fe37)] = _0xa206df[_0x20340d(0x4d1)] !== undefined ? _0xa206df[_0x20340d(_0x1539a7._0x35f523)] : ![], _0xa206df['fps'] = _0xa206df[_0x20340d(_0x1539a7._0x5657bf)] !== undefined ? _0xa206df[_0x20340d(_0x1539a7._0x5657bf)] : 0x1e, _0xa206df[_0x20340d(_0x1539a7._0x302632)] = _0xa206df['names'] || []; !_0x200fd5[_0x20340d(0x2ad)] && (_0x200fd5 = this[_0x20340d(_0x1539a7._0x4a373d)](_0x200fd5)); const _0x4c0ac3 = Math['round'](_0x503c4d[_0x20340d(0x3b5)] * (_0xa206df[_0x20340d(_0x1539a7._0x5a63e8)] / 0x3e8) * 0x3e8), _0x15b2b4 = 0x1 / _0xa206df[_0x20340d(0x23b)], _0x558e2d = [], _0x34da37 = new AnimationMixer(_0x200fd5), _0x5828ec = this[_0x20340d(_0x1539a7._0xede07)](_0x57a4f4[_0x20340d(0x295)]), _0x59e745 = []; let _0x4adb34, _0x18c0e1, _0x8e3ef3, _0x333f61, _0x4f9439; _0x34da37[_0x20340d(_0x1539a7._0x39ba1a)](_0x503c4d)[_0x20340d(0x260)](), _0x34da37[_0x20340d(0x1c8)](0x0), _0x200fd5[_0x20340d(0x526)](); for (let _0x2627d8 = 0x0; _0x2627d8 < _0x4c0ac3; ++_0x2627d8) { const _0x53abc2 = _0x2627d8 * _0x15b2b4; this[_0x20340d(_0x1539a7._0x2a6f76)](_0x57a4f4, _0x200fd5, _0xa206df); for (let _0x3b221a = 0x0; _0x3b221a < _0x5828ec[_0x20340d(_0x1539a7._0x16f1a4)]; ++_0x3b221a) { _0x4f9439 = _0xa206df[_0x20340d(0x440)][_0x5828ec[_0x3b221a][_0x20340d(0x31c)]] || _0x5828ec[_0x3b221a][_0x20340d(0x31c)], _0x8e3ef3 = this[_0x20340d(0x2da)](_0x4f9439, _0x200fd5[_0x20340d(_0x1539a7._0x5b2d2d)]), _0x8e3ef3 && (_0x18c0e1 = _0x5828ec[_0x3b221a], _0x333f61 = _0x59e745[_0x3b221a] = _0x59e745[_0x3b221a] || { 'bone': _0x18c0e1 }, _0xa206df[_0x20340d(_0x1539a7._0x45d82b)] === _0x4f9439 && (!_0x333f61[_0x20340d(0x45c)] && (_0x333f61[_0x20340d(0x45c)] = { 'times': new Float32Array(_0x4c0ac3), 'values': new Float32Array(_0x4c0ac3 * 0x3) }), _0xa206df['useFirstFramePosition'] && (_0x2627d8 === 0x0 && (_0x4adb34 = _0x18c0e1[_0x20340d(_0x1539a7._0x92c8b3)][_0x20340d(0x2b0)]()), _0x18c0e1[_0x20340d(_0x1539a7._0x92c8b3)][_0x20340d(_0x1539a7._0x277598)](_0x4adb34)), _0x333f61[_0x20340d(_0x1539a7._0x3e495d)]['times'][_0x2627d8] = _0x53abc2, _0x18c0e1[_0x20340d(_0x1539a7._0x5ce59d)][_0x20340d(0x492)](_0x333f61[_0x20340d(_0x1539a7._0x3d5f41)]['values'], _0x2627d8 * 0x3)), !_0x333f61[_0x20340d(_0x1539a7._0x1c3058)] && (_0x333f61['quat'] = { 'times': new Float32Array(_0x4c0ac3), 'values': new Float32Array(_0x4c0ac3 * 0x4) }), _0x333f61[_0x20340d(0x387)][_0x20340d(_0x1539a7._0x11dbf4)][_0x2627d8] = _0x53abc2, _0x18c0e1[_0x20340d(_0x1539a7._0x1b83fc)][_0x20340d(_0x1539a7._0x1563fe)](_0x333f61[_0x20340d(_0x1539a7._0x2ed6cd)]['values'], _0x2627d8 * 0x4)) } _0x34da37[_0x20340d(0x1c8)](_0x15b2b4), _0x200fd5[_0x20340d(_0x1539a7._0xa5971b)]() } for (let _0x1d7df1 = 0x0; _0x1d7df1 < _0x59e745[_0x20340d(_0x1539a7._0x36095f)]; ++_0x1d7df1) { _0x333f61 = _0x59e745[_0x1d7df1], _0x333f61 && (_0x333f61[_0x20340d(0x45c)] && _0x558e2d[_0x20340d(0x1da)](new VectorKeyframeTrack(_0x20340d(_0x1539a7._0x156e25) + _0x333f61[_0x20340d(_0x1539a7._0x16c4c6)]['name'] + _0x20340d(_0x1539a7._0x5a7a31), _0x333f61['pos'][_0x20340d(_0x1539a7._0xefd1c7)], _0x333f61[_0x20340d(_0x1539a7._0x1464ec)][_0x20340d(_0x1539a7._0x29df6d)])), _0x558e2d[_0x20340d(_0x1539a7._0x5f245c)](new QuaternionKeyframeTrack(_0x20340d(0x26a) + _0x333f61[_0x20340d(0x446)]['name'] + _0x20340d(_0x1539a7._0xb0bf1b), _0x333f61['quat'][_0x20340d(_0x1539a7._0x34f1fb)], _0x333f61['quat']['values']))) } return _0x34da37[_0x20340d(0x1ff)](_0x503c4d), new AnimationClip(_0x503c4d[_0x20340d(_0x1539a7._0x26e0a4)], -0x1, _0x558e2d) } static [_0x48e965(0x454)] (_0x2e3371) { const _0x393998 = { _0x225043: 0x1fa }, _0x39c6ff = _0x48e965, _0xae54 = new SkeletonHelper(_0x2e3371[_0x39c6ff(_0x393998._0x225043)][0x0]); return _0xae54[_0x39c6ff(0x295)] = _0x2e3371, _0xae54 } static [_0x48e965(0x220)] (_0x118c9d, _0x3cd5df, _0x205c18 = {}) { const _0x144974 = { _0x128b91: 0x286, _0x1b5af1: 0x286, _0x1b24bb: 0x440, _0x843289: 0x440, _0x3d17da: 0x207, _0x124e66: 0x28f, _0x5ef8d5: 0x31c, _0x5a07fe: 0x190, _0x14dc1d: 0x2c2, _0x5d5a98: 0x526, _0x2df42d: 0x2bb, _0x353419: 0x317, _0x2ebd29: 0x497, _0x305cff: 0x424, _0x318432: 0x3eb, _0x548b87: 0x2be }, _0x3b85e2 = _0x48e965, _0x1c9b09 = new Vector3(), _0x2fde23 = new Vector3(), _0x45f213 = new Vector3(), _0x252c21 = new Vector3(), _0x4f5f63 = new Vector2(), _0xdd9545 = new Vector2(); _0x205c18[_0x3b85e2(0x286)] = _0x205c18['hip'] !== undefined ? _0x205c18[_0x3b85e2(_0x144974._0x128b91)] : _0x3b85e2(_0x144974._0x1b5af1), _0x205c18[_0x3b85e2(_0x144974._0x1b24bb)] = _0x205c18[_0x3b85e2(_0x144974._0x1b24bb)] || {}; !_0x3cd5df[_0x3b85e2(0x2ad)] && (_0x3cd5df = this[_0x3b85e2(0x454)](_0x3cd5df)); const _0x5594e8 = Object[_0x3b85e2(0x22f)](_0x205c18[_0x3b85e2(_0x144974._0x843289)]), _0x42312b = Object[_0x3b85e2(_0x144974._0x3d17da)](_0x205c18['names']), _0x134241 = _0x3cd5df['isObject3D'] ? _0x3cd5df[_0x3b85e2(0x295)][_0x3b85e2(0x1fa)] : this['getBones'](_0x3cd5df), _0xe544a4 = _0x118c9d[_0x3b85e2(0x2ad)] ? _0x118c9d[_0x3b85e2(0x295)][_0x3b85e2(0x1fa)] : this[_0x3b85e2(0x2a7)](_0x118c9d), _0x276b02 = []; let _0x44f3ca, _0x5628f8, _0x5ede2e, _0x4d00d1; _0x118c9d[_0x3b85e2(0x295)][_0x3b85e2(_0x144974._0x124e66)](); for (_0x4d00d1 = 0x0; _0x4d00d1 < _0xe544a4['length']; ++_0x4d00d1) { _0x44f3ca = _0xe544a4[_0x4d00d1], _0x5ede2e = _0x205c18['names'][_0x44f3ca[_0x3b85e2(0x31c)]] || _0x44f3ca[_0x3b85e2(_0x144974._0x5ef8d5)], _0x5628f8 = this[_0x3b85e2(0x2da)](_0x5ede2e, _0x134241); if (_0x5628f8 && _0x5ede2e !== _0x205c18['hip']) { const _0x4143e5 = this[_0x3b85e2(0x190)](_0x44f3ca[_0x3b85e2(0x2c2)], _0x5594e8), _0x46ef1b = this[_0x3b85e2(_0x144974._0x5a07fe)](_0x5628f8[_0x3b85e2(_0x144974._0x14dc1d)], _0x42312b); _0x4143e5[_0x3b85e2(_0x144974._0x5d5a98)](), _0x46ef1b[_0x3b85e2(0x526)](), _0x1c9b09[_0x3b85e2(0x272)](_0x4143e5['matrixWorld']), _0x2fde23[_0x3b85e2(0x272)](_0x44f3ca[_0x3b85e2(_0x144974._0x2df42d)]), _0x45f213['setFromMatrixPosition'](_0x46ef1b[_0x3b85e2(_0x144974._0x2df42d)]), _0x252c21[_0x3b85e2(0x272)](_0x5628f8[_0x3b85e2(0x2bb)]), _0x4f5f63[_0x3b85e2(_0x144974._0x353419)](new Vector2(_0x2fde23['x'], _0x2fde23['y']), new Vector2(_0x1c9b09['x'], _0x1c9b09['y']))[_0x3b85e2(0x497)](), _0xdd9545[_0x3b85e2(0x317)](new Vector2(_0x252c21['x'], _0x252c21['y']), new Vector2(_0x45f213['x'], _0x45f213['y']))[_0x3b85e2(_0x144974._0x2ebd29)](); const _0x2e994f = _0x4f5f63[_0x3b85e2(0x424)]() - _0xdd9545[_0x3b85e2(_0x144974._0x305cff)](), _0x37ac81 = new Matrix4()['makeRotationFromEuler'](new Euler(0x0, 0x0, _0x2e994f)); _0x44f3ca[_0x3b85e2(0x3eb)][_0x3b85e2(0x4d9)](_0x37ac81), _0x44f3ca[_0x3b85e2(_0x144974._0x318432)][_0x3b85e2(0x476)](_0x44f3ca[_0x3b85e2(0x4c4)], _0x44f3ca[_0x3b85e2(0x419)], _0x44f3ca[_0x3b85e2(_0x144974._0x548b87)]), _0x44f3ca[_0x3b85e2(0x526)](), _0x276b02[_0x5ede2e] = _0x37ac81 } } return _0x276b02 } static [_0x48e965(0x197)] (_0x6cb193, _0x541feb) { const _0x355a39 = { _0x273954: 0x2a7, _0x254dc2: 0x321 }, _0x31f450 = _0x48e965, _0x1e24ff = this[_0x31f450(_0x355a39._0x273954)](_0x6cb193); for (let _0x29b458 = 0x0; _0x29b458 < _0x1e24ff[_0x31f450(_0x355a39._0x254dc2)]; ++_0x29b458) { const _0x570a94 = _0x1e24ff[_0x29b458]; _0x541feb[_0x570a94['name']] && (_0x570a94[_0x31f450(0x31c)] = _0x541feb[_0x570a94[_0x31f450(0x31c)]]) } return this } static [_0x48e965(0x2a7)] (_0x1fef4e) { const _0x534c5a = { _0x4c89ad: 0x20e }, _0x48a015 = _0x48e965; return Array[_0x48a015(_0x534c5a._0x4c89ad)](_0x1fef4e) ? _0x1fef4e : _0x1fef4e[_0x48a015(0x1fa)] } static ['getBoneByName'] (_0x4a357b, _0x59580d) { const _0x3c7f6f = { _0x23e91a: 0x31c }, _0x23a44b = _0x48e965; for (let _0x1d1a6b = 0x0, _0xbc898b = this[_0x23a44b(0x2a7)](_0x59580d); _0x1d1a6b < _0xbc898b['length']; _0x1d1a6b++) { if (_0x4a357b === _0xbc898b[_0x1d1a6b][_0x23a44b(_0x3c7f6f._0x23e91a)]) return _0xbc898b[_0x1d1a6b] } } static [_0x48e965(0x190)] (_0x11afb6, _0x2506d9) { const _0x2f884e = { _0x594918: 0x2c2 }, _0x2ff086 = _0x48e965; while (_0x11afb6['isBone']) { if (_0x2506d9['indexOf'](_0x11afb6[_0x2ff086(0x31c)]) !== -0x1) return _0x11afb6; _0x11afb6 = _0x11afb6[_0x2ff086(_0x2f884e._0x594918)] } } static [_0x48e965(0x21f)] (_0x1eac04, _0x13cecd) { const _0x2e6bba = { _0x1a037e: 0x211 }, _0x6c9e69 = _0x48e965, _0xad69fc = /\[(.*)\]\.(.*)/, _0x49a18a = { 'name': _0x1eac04 }; for (let _0x38ea6b = 0x0; _0x38ea6b < _0x13cecd[_0x6c9e69(0x321)]; ++_0x38ea6b) { const _0x4784a2 = _0xad69fc[_0x6c9e69(_0x2e6bba._0x1a037e)](_0x13cecd[_0x38ea6b]['name']); _0x4784a2 && _0x1eac04 === _0x4784a2[0x1] && (_0x49a18a[_0x4784a2[0x2]] = _0x38ea6b) } return _0x49a18a } static ['getEqualsBonesNames'] (_0x23ac30, _0x2ca86c) { const _0x520ec8 = { _0x46225b: 0x2a7, _0x1f8b6e: 0x2a7, _0x2b06ea: 0x31c, _0x49f578: 0x321, _0x2cd934: 0x1da }, _0xcbe5b5 = _0x48e965, _0x358033 = this[_0xcbe5b5(_0x520ec8._0x46225b)](_0x23ac30), _0x3dfb72 = this[_0xcbe5b5(_0x520ec8._0x1f8b6e)](_0x2ca86c), _0x311808 = []; _0x3da696: for (let _0x88fb54 = 0x0; _0x88fb54 < _0x358033[_0xcbe5b5(0x321)]; _0x88fb54++) { const _0x21f7b7 = _0x358033[_0x88fb54][_0xcbe5b5(_0x520ec8._0x2b06ea)]; for (let _0x1d9d1a = 0x0; _0x1d9d1a < _0x3dfb72[_0xcbe5b5(_0x520ec8._0x49f578)]; _0x1d9d1a++) { if (_0x21f7b7 === _0x3dfb72[_0x1d9d1a][_0xcbe5b5(_0x520ec8._0x2b06ea)]) { _0x311808[_0xcbe5b5(_0x520ec8._0x2cd934)](_0x21f7b7); continue _0x3da696 } } } return _0x311808 } static [_0x48e965(0x2b0)] (_0x1da63e) { const _0x528ee2 = { _0x151ba3: 0x2b0, _0x1d17b1: 0x4a5 }, _0x468d25 = { _0x24ef1d: 0x33c, _0x345e0a: 0x295, _0x5179d8: 0x2b0, _0x195504: 0x4f5, _0x380d7b: 0x4f5, _0x5930a3: 0x295, _0x1473b1: 0x1ac, _0x22ac28: 0x2d7, _0xace247: 0x295 }, _0x31f0db = { _0x538865: 0x49f }, _0x22d66d = _0x48e965, _0x559528 = new Map(), _0x11e505 = new Map(), _0x23156c = _0x1da63e[_0x22d66d(_0x528ee2._0x151ba3)](); return parallelTraverse(_0x1da63e, _0x23156c, function (_0x1c2022, _0x1cd003) { const _0x10ca0e = _0x22d66d; _0x559528[_0x10ca0e(_0x31f0db._0x538865)](_0x1cd003, _0x1c2022), _0x11e505[_0x10ca0e(0x49f)](_0x1c2022, _0x1cd003) }), _0x23156c[_0x22d66d(_0x528ee2._0x1d17b1)](function (_0x598b8b) { const _0x52c664 = _0x22d66d; if (!_0x598b8b[_0x52c664(_0x468d25._0x24ef1d)]) return; const _0x10c84c = _0x598b8b, _0x4624ed = _0x559528['get'](_0x598b8b), _0x3beb0a = _0x4624ed[_0x52c664(_0x468d25._0x345e0a)]['bones']; _0x10c84c[_0x52c664(0x295)] = _0x4624ed[_0x52c664(_0x468d25._0x345e0a)][_0x52c664(_0x468d25._0x5179d8)](), _0x10c84c[_0x52c664(_0x468d25._0x195504)]['copy'](_0x4624ed[_0x52c664(_0x468d25._0x380d7b)]), _0x10c84c[_0x52c664(_0x468d25._0x5930a3)][_0x52c664(0x1fa)] = _0x3beb0a[_0x52c664(_0x468d25._0x1473b1)](function (_0xa8c398) { return _0x11e505['get'](_0xa8c398) }), _0x10c84c[_0x52c664(_0x468d25._0x22ac28)](_0x10c84c[_0x52c664(_0x468d25._0xace247)], _0x10c84c['bindMatrix']) }), _0x23156c } } function parallelTraverse (_0x5cf96d, _0x3d70d6, _0x1f19be) { const _0x48c254 = { _0x2fb108: 0x29e }, _0x298fba = _0x48e965; _0x1f19be(_0x5cf96d, _0x3d70d6); for (let _0x2a2a8f = 0x0; _0x2a2a8f < _0x5cf96d[_0x298fba(0x29e)][_0x298fba(0x321)]; _0x2a2a8f++) { parallelTraverse(_0x5cf96d[_0x298fba(_0x48c254._0x2fb108)][_0x2a2a8f], _0x3d70d6[_0x298fba(0x29e)][_0x2a2a8f], _0x1f19be) } }

	exports.ACESFilmicToneMapping = ACESFilmicToneMapping
	exports.AddEquation = AddEquation
	exports.AddOperation = AddOperation
	exports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode
	exports.AdditiveBlending = AdditiveBlending
	exports.AlphaFormat = AlphaFormat
	exports.AlwaysDepth = AlwaysDepth
	exports.AlwaysStencilFunc = AlwaysStencilFunc
	exports.AmbientLight = AmbientLight
	exports.AmbientLightProbe = AmbientLightProbe
	exports.AnimationClip = AnimationClip
	exports.AnimationLoader = AnimationLoader
	exports.AnimationMixer = AnimationMixer
	exports.AnimationObjectGroup = AnimationObjectGroup
	exports.AnimationUtils = AnimationUtils
	exports.ArcCurve = ArcCurve
	exports.ArrayCamera = ArrayCamera
	exports.ArrowHelper = ArrowHelper
	exports.Audio = Audio
	exports.AudioAnalyser = AudioAnalyser
	exports.AudioContext = AudioContext
	exports.AudioListener = AudioListener
	exports.AudioLoader = AudioLoader
	exports.AxesHelper = AxesHelper
	exports.AxisHelper = AxisHelper
	exports.BackSide = BackSide
	exports.BaseGeometries = BaseGeometries
	exports.BasicDepthPacking = BasicDepthPacking
	exports.BasicShadowMap = BasicShadowMap
	exports.BinaryTextureLoader = BinaryTextureLoader
	exports.Bone = Bone
	exports.BooleanKeyframeTrack = BooleanKeyframeTrack
	exports.BoundingBoxHelper = BoundingBoxHelper
	exports.Box2 = Box2
	exports.Box3 = Box3
	exports.Box3Helper = Box3Helper
	exports.BoxBufferGeometry = BoxGeometry
	exports.BoxGeometry = BoxGeometry
	exports.BoxHelper = BoxHelper
	exports.BufferAttribute = BufferAttribute
	exports.BufferGeometry = BufferGeometry
	exports.BufferGeometryLoader = BufferGeometryLoader
	exports.ByteType = ByteType
	exports.Cache = Cache
	exports.Camera = Camera
	exports.CameraHelper = CameraHelper
	exports.CanvasRenderer = CanvasRenderer
	exports.CanvasTexture = CanvasTexture
	exports.CatmullRomCurve3 = CatmullRomCurve3
	exports.CineonToneMapping = CineonToneMapping
	exports.CircleBufferGeometry = CircleGeometry
	exports.CircleGeometry = CircleGeometry
	exports.ClampToEdgeWrapping = ClampToEdgeWrapping
	exports.Clock = Clock
	exports.Color = Color
	exports.ColorKeyframeTrack = ColorKeyframeTrack
	exports.ColumnarTag = ColumnarTag
	exports.CompositeIconHTML = CompositeIconHTML
	exports.CompositeIconPopup = CompositeIconPopup
	exports.CompositeIconSimple = CompositeIconSimple
	exports.CompositeIconTag = CompositeIconTag
	exports.CompositeIconTitle = CompositeIconTitle
	exports.CompressedTexture = CompressedTexture
	exports.CompressedTextureLoader = CompressedTextureLoader
	exports.ConeBufferGeometry = ConeGeometry
	exports.ConeGeometry = ConeGeometry
	exports.Container = Container
	exports.CubeCamera = CubeCamera
	exports.CubeReflectionMapping = CubeReflectionMapping
	exports.CubeRefractionMapping = CubeRefractionMapping
	exports.CubeTexture = CubeTexture
	exports.CubeTextureLoader = CubeTextureLoader
	exports.CubeUVReflectionMapping = CubeUVReflectionMapping
	exports.CubeUVRefractionMapping = CubeUVRefractionMapping
	exports.CubicBezierCurve = CubicBezierCurve
	exports.CubicBezierCurve3 = CubicBezierCurve3
	exports.CubicInterpolant = CubicInterpolant
	exports.CullFaceBack = CullFaceBack
	exports.CullFaceFront = CullFaceFront
	exports.CullFaceFrontBack = CullFaceFrontBack
	exports.CullFaceNone = CullFaceNone
	exports.Curve = Curve
	exports.CurvePath = CurvePath
	exports.CustomBlending = CustomBlending
	exports.CustomToneMapping = CustomToneMapping
	exports.CylinderBufferGeometry = CylinderGeometry
	exports.CylinderGeometry = CylinderGeometry
	exports.Cylindrical = Cylindrical
	exports.DataTexture = DataTexture
	exports.DataTexture2DArray = DataTexture2DArray
	exports.DataTexture3D = DataTexture3D
	exports.DataTextureLoader = DataTextureLoader
	exports.DataUtils = DataUtils
	exports.DecrementStencilOp = DecrementStencilOp
	exports.DecrementWrapStencilOp = DecrementWrapStencilOp
	exports.DefaultLoadingManager = DefaultLoadingManager
	exports.DepthFormat = DepthFormat
	exports.DepthStencilFormat = DepthStencilFormat
	exports.DepthTexture = DepthTexture
	exports.DirectionalLight = DirectionalLight
	exports.DirectionalLightHelper = DirectionalLightHelper
	exports.DiscreteInterpolant = DiscreteInterpolant
	exports.DodecahedronBufferGeometry = DodecahedronGeometry
	exports.DodecahedronGeometry = DodecahedronGeometry
	exports.DoubleSide = DoubleSide
	exports.DstAlphaFactor = DstAlphaFactor
	exports.DstColorFactor = DstColorFactor
	exports.DynamicBufferAttribute = DynamicBufferAttribute
	exports.DynamicCopyUsage = DynamicCopyUsage
	exports.DynamicDrawUsage = DynamicDrawUsage
	exports.DynamicReadUsage = DynamicReadUsage
	exports.EdgesGeometry = EdgesGeometry
	exports.EdgesHelper = EdgesHelper
	exports.EllipseCurve = EllipseCurve
	exports.EqualDepth = EqualDepth
	exports.EqualStencilFunc = EqualStencilFunc
	exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping
	exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping
	exports.Euler = Euler
	exports.EventDispatcher = EventDispatcher
	exports.Events = Events
	exports.ExtrudeBufferGeometry = ExtrudeGeometry
	exports.ExtrudeGeometry = ExtrudeGeometry
	exports.FaceColors = FaceColors
	exports.FileLoader = FileLoader
	exports.FlatShading = FlatShading
	exports.Float16BufferAttribute = Float16BufferAttribute
	exports.Float32Attribute = Float32Attribute
	exports.Float32BufferAttribute = Float32BufferAttribute
	exports.Float64Attribute = Float64Attribute
	exports.Float64BufferAttribute = Float64BufferAttribute
	exports.FloatType = FloatType
	exports.Fog = Fog
	exports.FogExp2 = FogExp2
	exports.Font = Font
	exports.FontLoader = FontLoader
	exports.FrontSide = FrontSide
	exports.Frustum = Frustum
	exports.GLBufferAttribute = GLBufferAttribute
	exports.GLSL1 = GLSL1
	exports.GLSL3 = GLSL3
	exports.GammaEncoding = GammaEncoding
	exports.GreaterDepth = GreaterDepth
	exports.GreaterEqualDepth = GreaterEqualDepth
	exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc
	exports.GreaterStencilFunc = GreaterStencilFunc
	exports.GridHelper = GridHelper
	exports.Group = Group$1
	exports.HalfFloatType = HalfFloatType
	exports.HemisphereLight = HemisphereLight
	exports.HemisphereLightHelper = HemisphereLightHelper
	exports.HemisphereLightProbe = HemisphereLightProbe
	exports.IcosahedronBufferGeometry = IcosahedronGeometry
	exports.IcosahedronGeometry = IcosahedronGeometry
	exports.ImageBitmapLoader = ImageBitmapLoader
	exports.ImageLoader = ImageLoader
	exports.ImageUtils = ImageUtils
	exports.ImmediateRenderObject = ImmediateRenderObject
	exports.IncrementStencilOp = IncrementStencilOp
	exports.IncrementWrapStencilOp = IncrementWrapStencilOp
	exports.InformationTag = InformationTag
	exports.InstancedBufferAttribute = InstancedBufferAttribute
	exports.InstancedBufferGeometry = InstancedBufferGeometry
	exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer
	exports.InstancedMesh = InstancedMesh
	exports.Int16Attribute = Int16Attribute
	exports.Int16BufferAttribute = Int16BufferAttribute
	exports.Int32Attribute = Int32Attribute
	exports.Int32BufferAttribute = Int32BufferAttribute
	exports.Int8Attribute = Int8Attribute
	exports.Int8BufferAttribute = Int8BufferAttribute
	exports.IntType = IntType
	exports.InterleavedBuffer = InterleavedBuffer
	exports.InterleavedBufferAttribute = InterleavedBufferAttribute
	exports.Interpolant = Interpolant
	exports.InterpolateDiscrete = InterpolateDiscrete
	exports.InterpolateLinear = InterpolateLinear
	exports.InterpolateSmooth = InterpolateSmooth
	exports.InvertStencilOp = InvertStencilOp
	exports.JSONLoader = JSONLoader
	exports.JSONParser = JSONParser
	exports.KeepStencilOp = KeepStencilOp
	exports.KeyframeTrack = KeyframeTrack
	exports.LOD = LOD
	exports.LatheBufferGeometry = LatheGeometry
	exports.LatheGeometry = LatheGeometry
	exports.Layers = Layers
	exports.LensFlare = LensFlare
	exports.LessDepth = LessDepth
	exports.LessEqualDepth = LessEqualDepth
	exports.LessEqualStencilFunc = LessEqualStencilFunc
	exports.LessStencilFunc = LessStencilFunc
	exports.Light = Light
	exports.LightProbe = LightProbe
	exports.Line = Line
	exports.Line3 = Line3
	exports.LineBasicMaterial = LineBasicMaterial
	exports.LineCurve = LineCurve
	exports.LineCurve3 = LineCurve3
	exports.LineDashedMaterial = LineDashedMaterial
	exports.LineGeometry = LineGeometry
	exports.LineLoop = LineLoop
	exports.LinePieces = LinePieces
	exports.LineSegments = LineSegments
	exports.LineStrip = LineStrip
	exports.LinearEncoding = LinearEncoding
	exports.LinearFilter = LinearFilter
	exports.LinearInterpolant = LinearInterpolant
	exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter
	exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter
	exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter
	exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter
	exports.LinearToneMapping = LinearToneMapping
	exports.Loader = Loader
	exports.LoaderUtils = LoaderUtils
	exports.LoadingManager = LoadingManager
	exports.LogLuvEncoding = LogLuvEncoding
	exports.LoopOnce = LoopOnce
	exports.LoopPingPong = LoopPingPong
	exports.LoopRepeat = LoopRepeat
	exports.LuminanceAlphaFormat = LuminanceAlphaFormat
	exports.LuminanceFormat = LuminanceFormat
	exports.MOUSE = MOUSE
	exports.Material = Material
	exports.MaterialLoader = MaterialLoader
	exports.Math = MathUtils
	exports.MathUtils = MathUtils
	exports.Matrix3 = Matrix3
	exports.Matrix4 = Matrix4
	exports.MaxEquation = MaxEquation
	exports.Mesh = Mesh
	exports.MeshBasicMaterial = MeshBasicMaterial
	exports.MeshDepthMaterial = MeshDepthMaterial
	exports.MeshDistanceMaterial = MeshDistanceMaterial
	exports.MeshFaceMaterial = MeshFaceMaterial
	exports.MeshLambertMaterial = MeshLambertMaterial
	exports.MeshMatcapMaterial = MeshMatcapMaterial
	exports.MeshNormalMaterial = MeshNormalMaterial
	exports.MeshPhongMaterial = MeshPhongMaterial
	exports.MeshPhysicalMaterial = MeshPhysicalMaterial
	exports.MeshStandardMaterial = MeshStandardMaterial
	exports.MeshToonMaterial = MeshToonMaterial
	exports.MinEquation = MinEquation
	exports.MirroredRepeatWrapping = MirroredRepeatWrapping
	exports.MixOperation = MixOperation
	exports.MultiMaterial = MultiMaterial
	exports.MultiplyBlending = MultiplyBlending
	exports.MultiplyOperation = MultiplyOperation
	exports.NearestFilter = NearestFilter
	exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter
	exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter
	exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter
	exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter
	exports.NeverDepth = NeverDepth
	exports.NeverStencilFunc = NeverStencilFunc
	exports.NoBlending = NoBlending
	exports.NoColors = NoColors
	exports.NoToneMapping = NoToneMapping
	exports.NormalAnimationBlendMode = NormalAnimationBlendMode
	exports.NormalBlending = NormalBlending
	exports.NotEqualDepth = NotEqualDepth
	exports.NotEqualStencilFunc = NotEqualStencilFunc
	exports.NumberKeyframeTrack = NumberKeyframeTrack
	exports.Object3D = Object3D
	exports.ObjectLoader = ObjectLoader
	exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap
	exports.OctahedronBufferGeometry = OctahedronGeometry
	exports.OctahedronGeometry = OctahedronGeometry
	exports.OneFactor = OneFactor
	exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor
	exports.OneMinusDstColorFactor = OneMinusDstColorFactor
	exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor
	exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor
	exports.OrthographicCamera = OrthographicCamera
	exports.PCFShadowMap = PCFShadowMap
	exports.PCFSoftShadowMap = PCFSoftShadowMap
	exports.PMREMGenerator = PMREMGenerator
	exports.POI = POI
	exports.ParametricBufferGeometry = ParametricGeometry
	exports.ParametricGeometry = ParametricGeometry
	exports.Particle = Particle
	exports.ParticleBasicMaterial = ParticleBasicMaterial
	exports.ParticleSystem = ParticleSystem
	exports.ParticleSystemMaterial = ParticleSystemMaterial
	exports.Path = Path
	exports.PerspectiveCamera = PerspectiveCamera
	exports.PictureDropdownTag = PictureDropdownTag
	exports.Plane = Plane
	exports.PlaneBufferGeometry = PlaneGeometry
	exports.PlaneGeometry = PlaneGeometry
	exports.PlaneHelper = PlaneHelper
	exports.PointCloud = PointCloud
	exports.PointCloudMaterial = PointCloudMaterial
	exports.PointLight = PointLight
	exports.PointLightHelper = PointLightHelper
	exports.Points = Points
	exports.PointsMaterial = PointsMaterial
	exports.PolarGridHelper = PolarGridHelper
	exports.PolyhedronBufferGeometry = PolyhedronGeometry
	exports.PolyhedronGeometry = PolyhedronGeometry
	exports.PositionalAudio = PositionalAudio
	exports.PrimitiveMaterial = PrimitiveMaterial
	exports.Primitives = Primitives
	exports.PropertyBinding = PropertyBinding
	exports.PropertyMixer = PropertyMixer
	exports.QuadraticBezierCurve = QuadraticBezierCurve
	exports.QuadraticBezierCurve3 = QuadraticBezierCurve3
	exports.Quaternion = Quaternion
	exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack
	exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant
	exports.REVISION = REVISION
	exports.RGBADepthPacking = RGBADepthPacking
	exports.RGBAFormat = RGBAFormat
	exports.RGBAIntegerFormat = RGBAIntegerFormat
	exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format
	exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format
	exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format
	exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format
	exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format
	exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format
	exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format
	exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format
	exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format
	exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format
	exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format
	exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format
	exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format
	exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format
	exports.RGBA_BPTC_Format = RGBA_BPTC_Format
	exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format
	exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format
	exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format
	exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format
	exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format
	exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format
	exports.RGBDEncoding = RGBDEncoding
	exports.RGBEEncoding = RGBEEncoding
	exports.RGBEFormat = RGBEFormat
	exports.RGBFormat = RGBFormat
	exports.RGBIntegerFormat = RGBIntegerFormat
	exports.RGBM16Encoding = RGBM16Encoding
	exports.RGBM7Encoding = RGBM7Encoding
	exports.RGB_ETC1_Format = RGB_ETC1_Format
	exports.RGB_ETC2_Format = RGB_ETC2_Format
	exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format
	exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format
	exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format
	exports.RGFormat = RGFormat
	exports.RGIntegerFormat = RGIntegerFormat
	exports.RawShaderMaterial = RawShaderMaterial
	exports.Ray = Ray
	exports.Raycaster = Raycaster
	exports.RectAreaLight = RectAreaLight
	exports.RedFormat = RedFormat
	exports.RedIntegerFormat = RedIntegerFormat
	exports.Reflector = Reflector
	exports.ReflectorRTT = ReflectorRTT
	exports.ReinhardToneMapping = ReinhardToneMapping
	exports.RepeatWrapping = RepeatWrapping
	exports.ReplaceStencilOp = ReplaceStencilOp
	exports.ReverseSubtractEquation = ReverseSubtractEquation
	exports.RingBufferGeometry = RingGeometry
	exports.RingGeometry = RingGeometry
	exports.SRGB8_ALPHA8_ASTC_10x10_Format = SRGB8_ALPHA8_ASTC_10x10_Format
	exports.SRGB8_ALPHA8_ASTC_10x5_Format = SRGB8_ALPHA8_ASTC_10x5_Format
	exports.SRGB8_ALPHA8_ASTC_10x6_Format = SRGB8_ALPHA8_ASTC_10x6_Format
	exports.SRGB8_ALPHA8_ASTC_10x8_Format = SRGB8_ALPHA8_ASTC_10x8_Format
	exports.SRGB8_ALPHA8_ASTC_12x10_Format = SRGB8_ALPHA8_ASTC_12x10_Format
	exports.SRGB8_ALPHA8_ASTC_12x12_Format = SRGB8_ALPHA8_ASTC_12x12_Format
	exports.SRGB8_ALPHA8_ASTC_4x4_Format = SRGB8_ALPHA8_ASTC_4x4_Format
	exports.SRGB8_ALPHA8_ASTC_5x4_Format = SRGB8_ALPHA8_ASTC_5x4_Format
	exports.SRGB8_ALPHA8_ASTC_5x5_Format = SRGB8_ALPHA8_ASTC_5x5_Format
	exports.SRGB8_ALPHA8_ASTC_6x5_Format = SRGB8_ALPHA8_ASTC_6x5_Format
	exports.SRGB8_ALPHA8_ASTC_6x6_Format = SRGB8_ALPHA8_ASTC_6x6_Format
	exports.SRGB8_ALPHA8_ASTC_8x5_Format = SRGB8_ALPHA8_ASTC_8x5_Format
	exports.SRGB8_ALPHA8_ASTC_8x6_Format = SRGB8_ALPHA8_ASTC_8x6_Format
	exports.SRGB8_ALPHA8_ASTC_8x8_Format = SRGB8_ALPHA8_ASTC_8x8_Format
	exports.Scene = Scene
	exports.SceneUtils = SceneUtils
	exports.ShaderChunk = ShaderChunk$1
	exports.ShaderLib = ShaderLib$1
	exports.ShaderMaterial = ShaderMaterial
	exports.ShadowMaterial = ShadowMaterial
	exports.Shape = Shape
	exports.ShapeBufferGeometry = ShapeGeometry
	exports.ShapeGeometry = ShapeGeometry
	exports.ShapePath = ShapePath
	exports.ShapeUtils = ShapeUtils
	exports.ShortType = ShortType
	exports.Skeleton = Skeleton
	exports.SkeletonHelper = SkeletonHelper
	exports.SkeletonUtils = SkeletonUtils
	exports.SkinnedMesh = SkinnedMesh
	exports.SmoothShading = SmoothShading
	exports.Sphere = Sphere
	exports.SphereBufferGeometry = SphereGeometry
	exports.SphereGeometry = SphereGeometry
	exports.Spherical = Spherical
	exports.SphericalHarmonics3 = SphericalHarmonics3
	exports.SplineCurve = SplineCurve
	exports.SpotLight = SpotLight
	exports.SpotLightHelper = SpotLightHelper
	exports.Sprite = Sprite
	exports.SpriteMaterial = SpriteMaterial
	exports.SrcAlphaFactor = SrcAlphaFactor
	exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor
	exports.SrcColorFactor = SrcColorFactor
	exports.StaticCopyUsage = StaticCopyUsage
	exports.StaticDrawUsage = StaticDrawUsage
	exports.StaticReadUsage = StaticReadUsage
	exports.StereoCamera = StereoCamera
	exports.StreamCopyUsage = StreamCopyUsage
	exports.StreamDrawUsage = StreamDrawUsage
	exports.StreamReadUsage = StreamReadUsage
	exports.StringKeyframeTrack = StringKeyframeTrack
	exports.SubtractEquation = SubtractEquation
	exports.SubtractiveBlending = SubtractiveBlending
	exports.TOUCH = TOUCH
	exports.TWEEN = tween_esm
	exports.TangentSpaceNormalMap = TangentSpaceNormalMap
	exports.TemplateParser = TemplateParser
	exports.TetrahedronBufferGeometry = TetrahedronGeometry
	exports.TetrahedronGeometry = TetrahedronGeometry
	exports.TextBufferGeometry = TextGeometry
	exports.TextGeometry = TextGeometry
	exports.Texture = Texture
	exports.TextureLoader = TextureLoader
	exports.TorusBufferGeometry = TorusGeometry
	exports.TorusGeometry = TorusGeometry
	exports.TorusKnotBufferGeometry = TorusKnotGeometry
	exports.TorusKnotGeometry = TorusKnotGeometry
	exports.Triangle = Triangle
	exports.TriangleFanDrawMode = TriangleFanDrawMode
	exports.TriangleStripDrawMode = TriangleStripDrawMode
	exports.TrianglesDrawMode = TrianglesDrawMode
	exports.TubeBufferGeometry = TubeGeometry
	exports.TubeGeometry = TubeGeometry
	exports.UVMapping = UVMapping
	exports.Uint16Attribute = Uint16Attribute
	exports.Uint16BufferAttribute = Uint16BufferAttribute
	exports.Uint32Attribute = Uint32Attribute
	exports.Uint32BufferAttribute = Uint32BufferAttribute
	exports.Uint8Attribute = Uint8Attribute
	exports.Uint8BufferAttribute = Uint8BufferAttribute
	exports.Uint8ClampedAttribute = Uint8ClampedAttribute
	exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute
	exports.Uniform = Uniform
	exports.UniformsLib = UniformsLib
	exports.UniformsUtils = UniformsUtils
	exports.UnsignedByteType = UnsignedByteType
	exports.UnsignedInt248Type = UnsignedInt248Type
	exports.UnsignedIntType = UnsignedIntType
	exports.UnsignedShort4444Type = UnsignedShort4444Type
	exports.UnsignedShort5551Type = UnsignedShort5551Type
	exports.UnsignedShort565Type = UnsignedShort565Type
	exports.UnsignedShortType = UnsignedShortType
	exports.VSMShadowMap = VSMShadowMap
	exports.Vector2 = Vector2
	exports.Vector3 = Vector3
	exports.Vector4 = Vector4
	exports.VectorKeyframeTrack = VectorKeyframeTrack
	exports.Vertex = Vertex
	exports.VertexColors = VertexColors
	exports.VideoTexture = VideoTexture
	exports.Water = Water
	exports.WebGL1Renderer = WebGL1Renderer
	exports.WebGLCubeRenderTarget = WebGLCubeRenderTarget
	exports.WebGLMultipleRenderTargets = WebGLMultipleRenderTargets
	exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget
	exports.WebGLRenderTarget = WebGLRenderTarget
	exports.WebGLRenderTargetCube = WebGLRenderTargetCube
	exports.WebGLRenderer = WebGLRenderer$1
	exports.WebGLUtils = WebGLUtils$1
	exports.WireframeGeometry = WireframeGeometry
	exports.WireframeHelper = WireframeHelper
	exports.WrapAroundEnding = WrapAroundEnding
	exports.XHRLoader = XHRLoader
	exports.ZeroCurvatureEnding = ZeroCurvatureEnding
	exports.ZeroFactor = ZeroFactor
	exports.ZeroSlopeEnding = ZeroSlopeEnding
	exports.ZeroStencilOp = ZeroStencilOp
	exports.lnglat2mercator = lnglat2mercator
	exports.mercator2lnglat = mercator2lnglat
	exports.sRGBEncoding = sRGBEncoding
	exports.CSS3DSprite = CSS3DSprite

	Object.defineProperty(exports, '__esModule', { value: true })

}))
